<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/include/replication/walreceiver.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/include/replication</a> - walreceiver.h<span style="font-size: 80%;"> (source / <a href="walreceiver.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * walreceiver.h
<span class="lineNum">       4 </span>            :  *    Exports from replication/walreceiverfuncs.c.
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Portions Copyright (c) 2010-2019, PostgreSQL Global Development Group
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * src/include/replication/walreceiver.h
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      11 </span>            :  */
<span class="lineNum">      12 </span>            : #ifndef _WALRECEIVER_H
<span class="lineNum">      13 </span>            : #define _WALRECEIVER_H
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &quot;access/xlog.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;access/xlogdefs.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;getaddrinfo.h&quot;      /* for NI_MAXHOST */
<span class="lineNum">      18 </span>            : #include &quot;replication/logicalproto.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;replication/walsender.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;storage/latch.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;storage/spin.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;pgtime.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;utils/tuplestore.h&quot;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : /* user-settable parameters */
<span class="lineNum">      26 </span>            : extern int  wal_receiver_status_interval;
<span class="lineNum">      27 </span>            : extern int  wal_receiver_timeout;
<span class="lineNum">      28 </span>            : extern bool hot_standby_feedback;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : /*
<span class="lineNum">      31 </span>            :  * MAXCONNINFO: maximum size of a connection string.
<span class="lineNum">      32 </span>            :  *
<span class="lineNum">      33 </span>            :  * XXX: Should this move to pg_config_manual.h?
<span class="lineNum">      34 </span>            :  */
<span class="lineNum">      35 </span>            : #define MAXCONNINFO     1024
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : /* Can we allow the standby to accept replication connection from another standby? */
<span class="lineNum">      38 </span>            : #define AllowCascadeReplication() (EnableHotStandby &amp;&amp; max_wal_senders &gt; 0)
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : /*
<span class="lineNum">      41 </span>            :  * Values for WalRcv-&gt;walRcvState.
<span class="lineNum">      42 </span>            :  */
<span class="lineNum">      43 </span>            : typedef enum
<span class="lineNum">      44 </span>            : {
<span class="lineNum">      45 </span>            :     WALRCV_STOPPED,             /* stopped and mustn't start up again */
<span class="lineNum">      46 </span>            :     WALRCV_STARTING,            /* launched, but the process hasn't
<span class="lineNum">      47 </span>            :                                  * initialized yet */
<span class="lineNum">      48 </span>            :     WALRCV_STREAMING,           /* walreceiver is streaming */
<span class="lineNum">      49 </span>            :     WALRCV_WAITING,             /* stopped streaming, waiting for orders */
<span class="lineNum">      50 </span>            :     WALRCV_RESTARTING,          /* asked to restart streaming */
<span class="lineNum">      51 </span>            :     WALRCV_STOPPING             /* requested to stop, but still running */
<span class="lineNum">      52 </span>            : } WalRcvState;
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : /* Shared memory area for management of walreceiver process */
<span class="lineNum">      55 </span>            : typedef struct
<span class="lineNum">      56 </span>            : {
<span class="lineNum">      57 </span>            :     /*
<span class="lineNum">      58 </span>            :      * PID of currently active walreceiver process, its current state and
<span class="lineNum">      59 </span>            :      * start time (actually, the time at which it was requested to be
<span class="lineNum">      60 </span>            :      * started).
<span class="lineNum">      61 </span>            :      */
<span class="lineNum">      62 </span>            :     pid_t       pid;
<span class="lineNum">      63 </span>            :     WalRcvState walRcvState;
<span class="lineNum">      64 </span>            :     pg_time_t   startTime;
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            :     /*
<span class="lineNum">      67 </span>            :      * receiveStart and receiveStartTLI indicate the first byte position and
<span class="lineNum">      68 </span>            :      * timeline that will be received. When startup process starts the
<span class="lineNum">      69 </span>            :      * walreceiver, it sets these to the point where it wants the streaming to
<span class="lineNum">      70 </span>            :      * begin.
<span class="lineNum">      71 </span>            :      */
<span class="lineNum">      72 </span>            :     XLogRecPtr  receiveStart;
<span class="lineNum">      73 </span>            :     TimeLineID  receiveStartTLI;
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            :     /*
<span class="lineNum">      76 </span>            :      * receivedUpto-1 is the last byte position that has already been
<span class="lineNum">      77 </span>            :      * received, and receivedTLI is the timeline it came from.  At the first
<span class="lineNum">      78 </span>            :      * startup of walreceiver, these are set to receiveStart and
<span class="lineNum">      79 </span>            :      * receiveStartTLI. After that, walreceiver updates these whenever it
<span class="lineNum">      80 </span>            :      * flushes the received WAL to disk.
<span class="lineNum">      81 </span>            :      */
<span class="lineNum">      82 </span>            :     XLogRecPtr  receivedUpto;
<span class="lineNum">      83 </span>            :     TimeLineID  receivedTLI;
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            :     /*
<span class="lineNum">      86 </span>            :      * latestChunkStart is the starting byte position of the current &quot;batch&quot;
<span class="lineNum">      87 </span>            :      * of received WAL.  It's actually the same as the previous value of
<span class="lineNum">      88 </span>            :      * receivedUpto before the last flush to disk.  Startup process can use
<span class="lineNum">      89 </span>            :      * this to detect whether it's keeping up or not.
<span class="lineNum">      90 </span>            :      */
<span class="lineNum">      91 </span>            :     XLogRecPtr  latestChunkStart;
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :     /*
<span class="lineNum">      94 </span>            :      * Time of send and receive of any message received.
<span class="lineNum">      95 </span>            :      */
<span class="lineNum">      96 </span>            :     TimestampTz lastMsgSendTime;
<span class="lineNum">      97 </span>            :     TimestampTz lastMsgReceiptTime;
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            :     /*
<span class="lineNum">     100 </span>            :      * Latest reported end of WAL on the sender
<span class="lineNum">     101 </span>            :      */
<span class="lineNum">     102 </span>            :     XLogRecPtr  latestWalEnd;
<span class="lineNum">     103 </span>            :     TimestampTz latestWalEndTime;
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            :     /*
<span class="lineNum">     106 </span>            :      * connection string; initially set to connect to the primary, and later
<span class="lineNum">     107 </span>            :      * clobbered to hide security-sensitive fields.
<span class="lineNum">     108 </span>            :      */
<span class="lineNum">     109 </span>            :     char        conninfo[MAXCONNINFO];
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :     /*
<span class="lineNum">     112 </span>            :      * Host name (this can be a host name, an IP address, or a directory path)
<span class="lineNum">     113 </span>            :      * and port number of the active replication connection.
<span class="lineNum">     114 </span>            :      */
<span class="lineNum">     115 </span>            :     char        sender_host[NI_MAXHOST];
<span class="lineNum">     116 </span>            :     int         sender_port;
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            :     /*
<span class="lineNum">     119 </span>            :      * replication slot name; is also used for walreceiver to connect with the
<span class="lineNum">     120 </span>            :      * primary
<span class="lineNum">     121 </span>            :      */
<span class="lineNum">     122 </span>            :     char        slotname[NAMEDATALEN];
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            :     /* set true once conninfo is ready to display (obfuscated pwds etc) */
<span class="lineNum">     125 </span>            :     bool        ready_to_display;
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            :     /*
<span class="lineNum">     128 </span>            :      * Latch used by startup process to wake up walreceiver after telling it
<span class="lineNum">     129 </span>            :      * where to start streaming (after setting receiveStart and
<span class="lineNum">     130 </span>            :      * receiveStartTLI), and also to tell it to send apply feedback to the
<span class="lineNum">     131 </span>            :      * primary whenever specially marked commit records are applied. This is
<span class="lineNum">     132 </span>            :      * normally mapped to procLatch when walreceiver is running.
<span class="lineNum">     133 </span>            :      */
<span class="lineNum">     134 </span>            :     Latch      *latch;
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            :     slock_t     mutex;          /* locks shared variables shown above */
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            :     /*
<span class="lineNum">     139 </span>            :      * force walreceiver reply?  This doesn't need to be locked; memory
<span class="lineNum">     140 </span>            :      * barriers for ordering are sufficient.  But we do need atomic fetch and
<span class="lineNum">     141 </span>            :      * store semantics, so use sig_atomic_t.
<span class="lineNum">     142 </span>            :      */
<span class="lineNum">     143 </span>            :     sig_atomic_t force_reply;   /* used as a bool */
<span class="lineNum">     144 </span>            : } WalRcvData;
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : extern WalRcvData *WalRcv;
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : typedef struct
<span class="lineNum">     149 </span>            : {
<span class="lineNum">     150 </span>            :     bool        logical;        /* True if this is logical replication stream,
<span class="lineNum">     151 </span>            :                                  * false if physical stream.  */
<span class="lineNum">     152 </span>            :     char       *slotname;       /* Name of the replication slot or NULL. */
<span class="lineNum">     153 </span>            :     XLogRecPtr  startpoint;     /* LSN of starting point. */
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            :     union
<span class="lineNum">     156 </span>            :     {
<span class="lineNum">     157 </span>            :         struct
<span class="lineNum">     158 </span>            :         {
<span class="lineNum">     159 </span>            :             TimeLineID  startpointTLI;  /* Starting timeline */
<span class="lineNum">     160 </span>            :         }           physical;
<span class="lineNum">     161 </span>            :         struct
<span class="lineNum">     162 </span>            :         {
<span class="lineNum">     163 </span>            :             uint32      proto_version;  /* Logical protocol version */
<span class="lineNum">     164 </span>            :             List       *publication_names;  /* String list of publications */
<span class="lineNum">     165 </span>            :         }           logical;
<span class="lineNum">     166 </span>            :     }           proto;
<span class="lineNum">     167 </span>            : } WalRcvStreamOptions;
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            : struct WalReceiverConn;
<span class="lineNum">     170 </span>            : typedef struct WalReceiverConn WalReceiverConn;
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : /*
<span class="lineNum">     173 </span>            :  * Status of walreceiver query execution.
<span class="lineNum">     174 </span>            :  *
<span class="lineNum">     175 </span>            :  * We only define statuses that are currently used.
<span class="lineNum">     176 </span>            :  */
<span class="lineNum">     177 </span>            : typedef enum
<span class="lineNum">     178 </span>            : {
<span class="lineNum">     179 </span>            :     WALRCV_ERROR,               /* There was error when executing the query. */
<span class="lineNum">     180 </span>            :     WALRCV_OK_COMMAND,          /* Query executed utility or replication
<span class="lineNum">     181 </span>            :                                  * command. */
<span class="lineNum">     182 </span>            :     WALRCV_OK_TUPLES,           /* Query returned tuples. */
<span class="lineNum">     183 </span>            :     WALRCV_OK_COPY_IN,          /* Query started COPY FROM. */
<span class="lineNum">     184 </span>            :     WALRCV_OK_COPY_OUT,         /* Query started COPY TO. */
<span class="lineNum">     185 </span>            :     WALRCV_OK_COPY_BOTH         /* Query started COPY BOTH replication
<span class="lineNum">     186 </span>            :                                  * protocol. */
<span class="lineNum">     187 </span>            : } WalRcvExecStatus;
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : /*
<span class="lineNum">     190 </span>            :  * Return value for walrcv_exec, returns the status of the execution and
<span class="lineNum">     191 </span>            :  * tuples if any.
<span class="lineNum">     192 </span>            :  */
<span class="lineNum">     193 </span>            : typedef struct WalRcvExecResult
<span class="lineNum">     194 </span>            : {
<span class="lineNum">     195 </span>            :     WalRcvExecStatus status;
<span class="lineNum">     196 </span>            :     char       *err;
<span class="lineNum">     197 </span>            :     Tuplestorestate *tuplestore;
<span class="lineNum">     198 </span>            :     TupleDesc   tupledesc;
<span class="lineNum">     199 </span>            : } WalRcvExecResult;
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : /* libpqwalreceiver hooks */
<span class="lineNum">     202 </span>            : typedef WalReceiverConn *(*walrcv_connect_fn) (const char *conninfo, bool logical,
<span class="lineNum">     203 </span>            :                                                const char *appname,
<span class="lineNum">     204 </span>            :                                                char **err);
<span class="lineNum">     205 </span>            : typedef void (*walrcv_check_conninfo_fn) (const char *conninfo);
<span class="lineNum">     206 </span>            : typedef char *(*walrcv_get_conninfo_fn) (WalReceiverConn *conn);
<span class="lineNum">     207 </span>            : typedef void (*walrcv_get_senderinfo_fn) (WalReceiverConn *conn,
<span class="lineNum">     208 </span>            :                                           char **sender_host,
<span class="lineNum">     209 </span>            :                                           int *sender_port);
<span class="lineNum">     210 </span>            : typedef char *(*walrcv_identify_system_fn) (WalReceiverConn *conn,
<span class="lineNum">     211 </span>            :                                             TimeLineID *primary_tli);
<span class="lineNum">     212 </span>            : typedef int (*walrcv_server_version_fn) (WalReceiverConn *conn);
<span class="lineNum">     213 </span>            : typedef void (*walrcv_readtimelinehistoryfile_fn) (WalReceiverConn *conn,
<span class="lineNum">     214 </span>            :                                                    TimeLineID tli,
<span class="lineNum">     215 </span>            :                                                    char **filename,
<span class="lineNum">     216 </span>            :                                                    char **content, int *size);
<span class="lineNum">     217 </span>            : typedef bool (*walrcv_startstreaming_fn) (WalReceiverConn *conn,
<span class="lineNum">     218 </span>            :                                           const WalRcvStreamOptions *options);
<span class="lineNum">     219 </span>            : typedef void (*walrcv_endstreaming_fn) (WalReceiverConn *conn,
<span class="lineNum">     220 </span>            :                                         TimeLineID *next_tli);
<span class="lineNum">     221 </span>            : typedef int (*walrcv_receive_fn) (WalReceiverConn *conn, char **buffer,
<span class="lineNum">     222 </span>            :                                   pgsocket *wait_fd);
<span class="lineNum">     223 </span>            : typedef void (*walrcv_send_fn) (WalReceiverConn *conn, const char *buffer,
<span class="lineNum">     224 </span>            :                                 int nbytes);
<span class="lineNum">     225 </span>            : typedef char *(*walrcv_create_slot_fn) (WalReceiverConn *conn,
<span class="lineNum">     226 </span>            :                                         const char *slotname, bool temporary,
<span class="lineNum">     227 </span>            :                                         CRSSnapshotAction snapshot_action,
<span class="lineNum">     228 </span>            :                                         XLogRecPtr *lsn);
<span class="lineNum">     229 </span>            : typedef WalRcvExecResult *(*walrcv_exec_fn) (WalReceiverConn *conn,
<span class="lineNum">     230 </span>            :                                              const char *query,
<span class="lineNum">     231 </span>            :                                              const int nRetTypes,
<span class="lineNum">     232 </span>            :                                              const Oid *retTypes);
<span class="lineNum">     233 </span>            : typedef void (*walrcv_disconnect_fn) (WalReceiverConn *conn);
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            : typedef struct WalReceiverFunctionsType
<span class="lineNum">     236 </span>            : {
<span class="lineNum">     237 </span>            :     walrcv_connect_fn walrcv_connect;
<span class="lineNum">     238 </span>            :     walrcv_check_conninfo_fn walrcv_check_conninfo;
<span class="lineNum">     239 </span>            :     walrcv_get_conninfo_fn walrcv_get_conninfo;
<span class="lineNum">     240 </span>            :     walrcv_get_senderinfo_fn walrcv_get_senderinfo;
<span class="lineNum">     241 </span>            :     walrcv_identify_system_fn walrcv_identify_system;
<span class="lineNum">     242 </span>            :     walrcv_server_version_fn walrcv_server_version;
<span class="lineNum">     243 </span>            :     walrcv_readtimelinehistoryfile_fn walrcv_readtimelinehistoryfile;
<span class="lineNum">     244 </span>            :     walrcv_startstreaming_fn walrcv_startstreaming;
<span class="lineNum">     245 </span>            :     walrcv_endstreaming_fn walrcv_endstreaming;
<span class="lineNum">     246 </span>            :     walrcv_receive_fn walrcv_receive;
<span class="lineNum">     247 </span>            :     walrcv_send_fn walrcv_send;
<span class="lineNum">     248 </span>            :     walrcv_create_slot_fn walrcv_create_slot;
<span class="lineNum">     249 </span>            :     walrcv_exec_fn walrcv_exec;
<span class="lineNum">     250 </span>            :     walrcv_disconnect_fn walrcv_disconnect;
<span class="lineNum">     251 </span>            : } WalReceiverFunctionsType;
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : extern PGDLLIMPORT WalReceiverFunctionsType *WalReceiverFunctions;
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : #define walrcv_connect(conninfo, logical, appname, err) \
<span class="lineNum">     256 </span>            :     WalReceiverFunctions-&gt;walrcv_connect(conninfo, logical, appname, err)
<span class="lineNum">     257 </span>            : #define walrcv_check_conninfo(conninfo) \
<span class="lineNum">     258 </span>            :     WalReceiverFunctions-&gt;walrcv_check_conninfo(conninfo)
<span class="lineNum">     259 </span>            : #define walrcv_get_conninfo(conn) \
<span class="lineNum">     260 </span>            :     WalReceiverFunctions-&gt;walrcv_get_conninfo(conn)
<span class="lineNum">     261 </span>            : #define walrcv_get_senderinfo(conn, sender_host, sender_port) \
<span class="lineNum">     262 </span>            :     WalReceiverFunctions-&gt;walrcv_get_senderinfo(conn, sender_host, sender_port)
<span class="lineNum">     263 </span>            : #define walrcv_identify_system(conn, primary_tli) \
<span class="lineNum">     264 </span>            :     WalReceiverFunctions-&gt;walrcv_identify_system(conn, primary_tli)
<span class="lineNum">     265 </span>            : #define walrcv_server_version(conn) \
<span class="lineNum">     266 </span>            :     WalReceiverFunctions-&gt;walrcv_server_version(conn)
<span class="lineNum">     267 </span>            : #define walrcv_readtimelinehistoryfile(conn, tli, filename, content, size) \
<span class="lineNum">     268 </span>            :     WalReceiverFunctions-&gt;walrcv_readtimelinehistoryfile(conn, tli, filename, content, size)
<span class="lineNum">     269 </span>            : #define walrcv_startstreaming(conn, options) \
<span class="lineNum">     270 </span>            :     WalReceiverFunctions-&gt;walrcv_startstreaming(conn, options)
<span class="lineNum">     271 </span>            : #define walrcv_endstreaming(conn, next_tli) \
<span class="lineNum">     272 </span>            :     WalReceiverFunctions-&gt;walrcv_endstreaming(conn, next_tli)
<span class="lineNum">     273 </span>            : #define walrcv_receive(conn, buffer, wait_fd) \
<span class="lineNum">     274 </span>            :     WalReceiverFunctions-&gt;walrcv_receive(conn, buffer, wait_fd)
<span class="lineNum">     275 </span>            : #define walrcv_send(conn, buffer, nbytes) \
<span class="lineNum">     276 </span>            :     WalReceiverFunctions-&gt;walrcv_send(conn, buffer, nbytes)
<span class="lineNum">     277 </span>            : #define walrcv_create_slot(conn, slotname, temporary, snapshot_action, lsn) \
<span class="lineNum">     278 </span>            :     WalReceiverFunctions-&gt;walrcv_create_slot(conn, slotname, temporary, snapshot_action, lsn)
<span class="lineNum">     279 </span>            : #define walrcv_exec(conn, exec, nRetTypes, retTypes) \
<span class="lineNum">     280 </span>            :     WalReceiverFunctions-&gt;walrcv_exec(conn, exec, nRetTypes, retTypes)
<span class="lineNum">     281 </span>            : #define walrcv_disconnect(conn) \
<span class="lineNum">     282 </span>            :     WalReceiverFunctions-&gt;walrcv_disconnect(conn)
<a name="283"><span class="lineNum">     283 </span>            : </a>
<span class="lineNum">     284 </span>            : static inline void
<span class="lineNum">     285 </span><span class="lineNoCov">          0 : walrcv_clear_result(WalRcvExecResult *walres)</span>
<span class="lineNum">     286 </span>            : {
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     if (!walres)</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :     if (walres-&gt;err)</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :         pfree(walres-&gt;err);</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     if (walres-&gt;tuplestore)</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :         tuplestore_end(walres-&gt;tuplestore);</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     if (walres-&gt;tupledesc)</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         FreeTupleDesc(walres-&gt;tupledesc);</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     pfree(walres);</span>
<span class="lineNum">     300 </span>            : }
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            : /* prototypes for functions in walreceiver.c */
<span class="lineNum">     303 </span>            : extern void WalReceiverMain(void) pg_attribute_noreturn();
<span class="lineNum">     304 </span>            : extern void ProcessWalRcvInterrupts(void);
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            : /* prototypes for functions in walreceiverfuncs.c */
<span class="lineNum">     307 </span>            : extern Size WalRcvShmemSize(void);
<span class="lineNum">     308 </span>            : extern void WalRcvShmemInit(void);
<span class="lineNum">     309 </span>            : extern void ShutdownWalRcv(void);
<span class="lineNum">     310 </span>            : extern bool WalRcvStreaming(void);
<span class="lineNum">     311 </span>            : extern bool WalRcvRunning(void);
<span class="lineNum">     312 </span>            : extern void RequestXLogStreaming(TimeLineID tli, XLogRecPtr recptr,
<span class="lineNum">     313 </span>            :                                  const char *conninfo, const char *slotname);
<span class="lineNum">     314 </span>            : extern XLogRecPtr GetWalRcvWriteRecPtr(XLogRecPtr *latestChunkStart, TimeLineID *receiveTLI);
<span class="lineNum">     315 </span>            : extern int  GetReplicationApplyDelay(void);
<span class="lineNum">     316 </span>            : extern int  GetReplicationTransferLatency(void);
<span class="lineNum">     317 </span>            : extern void WalRcvForceReply(void);
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            : #endif                          /* _WALRECEIVER_H */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
