<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/include/utils/expandedrecord.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/include/utils</a> - expandedrecord.h<span style="font-size: 80%;"> (source / <a href="expandedrecord.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntryHi">90.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * expandedrecord.h
<span class="lineNum">       4 </span>            :  *    Declarations for composite expanded objects.
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  * src/include/utils/expandedrecord.h
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      12 </span>            :  */
<span class="lineNum">      13 </span>            : #ifndef EXPANDEDRECORD_H
<span class="lineNum">      14 </span>            : #define EXPANDEDRECORD_H
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &quot;access/htup.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;access/tupdesc.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;fmgr.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;utils/expandeddatum.h&quot;
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : /*
<span class="lineNum">      23 </span>            :  * An expanded record is contained within a private memory context (as
<span class="lineNum">      24 </span>            :  * all expanded objects must be) and has a control structure as below.
<span class="lineNum">      25 </span>            :  *
<span class="lineNum">      26 </span>            :  * The expanded record might contain a regular &quot;flat&quot; tuple if that was the
<span class="lineNum">      27 </span>            :  * original input and we've not modified it.  Otherwise, the contents are
<span class="lineNum">      28 </span>            :  * represented by Datum/isnull arrays plus type information.  We could also
<span class="lineNum">      29 </span>            :  * have both forms, if we've deconstructed the original tuple for access
<span class="lineNum">      30 </span>            :  * purposes but not yet changed it.  For pass-by-reference field types, the
<span class="lineNum">      31 </span>            :  * Datums would point into the flat tuple in this situation.  Once we start
<span class="lineNum">      32 </span>            :  * modifying tuple fields, new pass-by-ref fields are separately palloc'd
<span class="lineNum">      33 </span>            :  * within the memory context.
<span class="lineNum">      34 </span>            :  *
<span class="lineNum">      35 </span>            :  * It's possible to build an expanded record that references a &quot;flat&quot; tuple
<span class="lineNum">      36 </span>            :  * stored externally, if the caller can guarantee that that tuple will not
<span class="lineNum">      37 </span>            :  * change for the lifetime of the expanded record.  (This frammish is mainly
<span class="lineNum">      38 </span>            :  * meant to avoid unnecessary data copying in trigger functions.)
<span class="lineNum">      39 </span>            :  */
<span class="lineNum">      40 </span>            : #define ER_MAGIC 1384727874     /* ID for debugging crosschecks */
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : typedef struct ExpandedRecordHeader
<span class="lineNum">      43 </span>            : {
<span class="lineNum">      44 </span>            :     /* Standard header for expanded objects */
<span class="lineNum">      45 </span>            :     ExpandedObjectHeader hdr;
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            :     /* Magic value identifying an expanded record (for debugging only) */
<span class="lineNum">      48 </span>            :     int         er_magic;
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            :     /* Assorted flag bits */
<span class="lineNum">      51 </span>            :     int         flags;
<span class="lineNum">      52 </span>            : #define ER_FLAG_FVALUE_VALID    0x0001  /* fvalue is up to date? */
<span class="lineNum">      53 </span>            : #define ER_FLAG_FVALUE_ALLOCED  0x0002  /* fvalue is local storage? */
<span class="lineNum">      54 </span>            : #define ER_FLAG_DVALUES_VALID   0x0004  /* dvalues/dnulls are up to date? */
<span class="lineNum">      55 </span>            : #define ER_FLAG_DVALUES_ALLOCED 0x0008  /* any field values local storage? */
<span class="lineNum">      56 </span>            : #define ER_FLAG_HAVE_EXTERNAL   0x0010  /* any field values are external? */
<span class="lineNum">      57 </span>            : #define ER_FLAG_TUPDESC_ALLOCED 0x0020  /* tupdesc is local storage? */
<span class="lineNum">      58 </span>            : #define ER_FLAG_IS_DOMAIN       0x0040  /* er_decltypeid is domain? */
<span class="lineNum">      59 </span>            : #define ER_FLAG_IS_DUMMY        0x0080  /* this header is dummy (see below) */
<span class="lineNum">      60 </span>            : /* flag bits that are not to be cleared when replacing tuple data: */
<span class="lineNum">      61 </span>            : #define ER_FLAGS_NON_DATA \
<span class="lineNum">      62 </span>            :     (ER_FLAG_TUPDESC_ALLOCED | ER_FLAG_IS_DOMAIN | ER_FLAG_IS_DUMMY)
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            :     /* Declared type of the record variable (could be a domain type) */
<span class="lineNum">      65 </span>            :     Oid         er_decltypeid;
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            :     /*
<span class="lineNum">      68 </span>            :      * Actual composite type/typmod; never a domain (if ER_FLAG_IS_DOMAIN,
<span class="lineNum">      69 </span>            :      * these identify the composite base type).  These will match
<span class="lineNum">      70 </span>            :      * er_tupdesc-&gt;tdtypeid/tdtypmod, as well as the header fields of
<span class="lineNum">      71 </span>            :      * composite datums made from or stored in this expanded record.
<span class="lineNum">      72 </span>            :      */
<span class="lineNum">      73 </span>            :     Oid         er_typeid;      /* type OID of the composite type */
<span class="lineNum">      74 </span>            :     int32       er_typmod;      /* typmod of the composite type */
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            :     /*
<span class="lineNum">      77 </span>            :      * Tuple descriptor, if we have one, else NULL.  This may point to a
<span class="lineNum">      78 </span>            :      * reference-counted tupdesc originally belonging to the typcache, in
<span class="lineNum">      79 </span>            :      * which case we use a memory context reset callback to release the
<span class="lineNum">      80 </span>            :      * refcount.  It can also be locally allocated in this object's private
<span class="lineNum">      81 </span>            :      * context (in which case ER_FLAG_TUPDESC_ALLOCED is set).
<span class="lineNum">      82 </span>            :      */
<span class="lineNum">      83 </span>            :     TupleDesc   er_tupdesc;
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            :     /*
<span class="lineNum">      86 </span>            :      * Unique-within-process identifier for the tupdesc (see typcache.h). This
<span class="lineNum">      87 </span>            :      * field will never be equal to INVALID_TUPLEDESC_IDENTIFIER.
<span class="lineNum">      88 </span>            :      */
<span class="lineNum">      89 </span>            :     uint64      er_tupdesc_id;
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :     /*
<span class="lineNum">      92 </span>            :      * If we have a Datum-array representation of the record, it's kept here;
<span class="lineNum">      93 </span>            :      * else ER_FLAG_DVALUES_VALID is not set, and dvalues/dnulls may be NULL
<span class="lineNum">      94 </span>            :      * if they've not yet been allocated.  If allocated, the dvalues and
<span class="lineNum">      95 </span>            :      * dnulls arrays are palloc'd within the object private context, and are
<span class="lineNum">      96 </span>            :      * of length matching er_tupdesc-&gt;natts.  For pass-by-ref field types,
<span class="lineNum">      97 </span>            :      * dvalues entries might point either into the fstartptr..fendptr area, or
<span class="lineNum">      98 </span>            :      * to separately palloc'd chunks.
<span class="lineNum">      99 </span>            :      */
<span class="lineNum">     100 </span>            :     Datum      *dvalues;        /* array of Datums */
<span class="lineNum">     101 </span>            :     bool       *dnulls;         /* array of is-null flags for Datums */
<span class="lineNum">     102 </span>            :     int         nfields;        /* length of above arrays */
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :     /*
<span class="lineNum">     105 </span>            :      * flat_size is the current space requirement for the flat equivalent of
<span class="lineNum">     106 </span>            :      * the expanded record, if known; otherwise it's 0.  We store this to make
<span class="lineNum">     107 </span>            :      * consecutive calls of get_flat_size cheap.  If flat_size is not 0, the
<span class="lineNum">     108 </span>            :      * component values data_len, hoff, and hasnull must be valid too.
<span class="lineNum">     109 </span>            :      */
<span class="lineNum">     110 </span>            :     Size        flat_size;
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            :     Size        data_len;       /* data len within flat_size */
<span class="lineNum">     113 </span>            :     int         hoff;           /* header offset */
<span class="lineNum">     114 </span>            :     bool        hasnull;        /* null bitmap needed? */
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            :     /*
<span class="lineNum">     117 </span>            :      * fvalue points to the flat representation if we have one, else it is
<span class="lineNum">     118 </span>            :      * NULL.  If the flat representation is valid (up to date) then
<span class="lineNum">     119 </span>            :      * ER_FLAG_FVALUE_VALID is set.  Even if we've outdated the flat
<span class="lineNum">     120 </span>            :      * representation due to changes of user fields, it can still be used to
<span class="lineNum">     121 </span>            :      * fetch system column values.  If we have a flat representation then
<span class="lineNum">     122 </span>            :      * fstartptr/fendptr point to the start and end+1 of its data area; this
<span class="lineNum">     123 </span>            :      * is so that we can tell which Datum pointers point into the flat
<span class="lineNum">     124 </span>            :      * representation rather than being pointers to separately palloc'd data.
<span class="lineNum">     125 </span>            :      */
<span class="lineNum">     126 </span>            :     HeapTuple   fvalue;         /* might or might not be private storage */
<span class="lineNum">     127 </span>            :     char       *fstartptr;      /* start of its data area */
<span class="lineNum">     128 </span>            :     char       *fendptr;        /* end+1 of its data area */
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            :     /* Some operations on the expanded record need a short-lived context */
<span class="lineNum">     131 </span>            :     MemoryContext er_short_term_cxt;    /* short-term memory context */
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :     /* Working state for domain checking, used if ER_FLAG_IS_DOMAIN is set */
<span class="lineNum">     134 </span>            :     struct ExpandedRecordHeader *er_dummy_header;   /* dummy record header */
<span class="lineNum">     135 </span>            :     void       *er_domaininfo;  /* cache space for domain_check() */
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            :     /* Callback info (it's active if er_mcb.arg is not NULL) */
<span class="lineNum">     138 </span>            :     MemoryContextCallback er_mcb;
<span class="lineNum">     139 </span>            : } ExpandedRecordHeader;
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : /* fmgr macros for expanded record objects */
<span class="lineNum">     142 </span>            : #define PG_GETARG_EXPANDED_RECORD(n)  DatumGetExpandedRecord(PG_GETARG_DATUM(n))
<span class="lineNum">     143 </span>            : #define ExpandedRecordGetDatum(erh)   EOHPGetRWDatum(&amp;(erh)-&gt;hdr)
<span class="lineNum">     144 </span>            : #define ExpandedRecordGetRODatum(erh) EOHPGetRODatum(&amp;(erh)-&gt;hdr)
<span class="lineNum">     145 </span>            : #define PG_RETURN_EXPANDED_RECORD(x)  PG_RETURN_DATUM(ExpandedRecordGetDatum(x))
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            : /* assorted other macros */
<span class="lineNum">     148 </span>            : #define ExpandedRecordIsEmpty(erh) \
<span class="lineNum">     149 </span>            :     (((erh)-&gt;flags &amp; (ER_FLAG_DVALUES_VALID | ER_FLAG_FVALUE_VALID)) == 0)
<span class="lineNum">     150 </span>            : #define ExpandedRecordIsDomain(erh) \
<span class="lineNum">     151 </span>            :     (((erh)-&gt;flags &amp; ER_FLAG_IS_DOMAIN) != 0)
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            : /* this can substitute for TransferExpandedObject() when we already have erh */
<span class="lineNum">     154 </span>            : #define TransferExpandedRecord(erh, cxt) \
<span class="lineNum">     155 </span>            :     MemoryContextSetParent((erh)-&gt;hdr.eoh_context, cxt)
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : /* information returned by expanded_record_lookup_field() */
<span class="lineNum">     158 </span>            : typedef struct ExpandedRecordFieldInfo
<span class="lineNum">     159 </span>            : {
<span class="lineNum">     160 </span>            :     int         fnumber;        /* field's attr number in record */
<span class="lineNum">     161 </span>            :     Oid         ftypeid;        /* field's type/typmod info */
<span class="lineNum">     162 </span>            :     int32       ftypmod;
<span class="lineNum">     163 </span>            :     Oid         fcollation;     /* field's collation if any */
<span class="lineNum">     164 </span>            : } ExpandedRecordFieldInfo;
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : /*
<span class="lineNum">     167 </span>            :  * prototypes for functions defined in expandedrecord.c
<span class="lineNum">     168 </span>            :  */
<span class="lineNum">     169 </span>            : extern ExpandedRecordHeader *make_expanded_record_from_typeid(Oid type_id, int32 typmod,
<span class="lineNum">     170 </span>            :                                                               MemoryContext parentcontext);
<span class="lineNum">     171 </span>            : extern ExpandedRecordHeader *make_expanded_record_from_tupdesc(TupleDesc tupdesc,
<span class="lineNum">     172 </span>            :                                                                MemoryContext parentcontext);
<span class="lineNum">     173 </span>            : extern ExpandedRecordHeader *make_expanded_record_from_exprecord(ExpandedRecordHeader *olderh,
<span class="lineNum">     174 </span>            :                                                                  MemoryContext parentcontext);
<span class="lineNum">     175 </span>            : extern void expanded_record_set_tuple(ExpandedRecordHeader *erh,
<span class="lineNum">     176 </span>            :                                       HeapTuple tuple, bool copy, bool expand_external);
<span class="lineNum">     177 </span>            : extern Datum make_expanded_record_from_datum(Datum recorddatum,
<span class="lineNum">     178 </span>            :                                              MemoryContext parentcontext);
<span class="lineNum">     179 </span>            : extern TupleDesc expanded_record_fetch_tupdesc(ExpandedRecordHeader *erh);
<span class="lineNum">     180 </span>            : extern HeapTuple expanded_record_get_tuple(ExpandedRecordHeader *erh);
<span class="lineNum">     181 </span>            : extern ExpandedRecordHeader *DatumGetExpandedRecord(Datum d);
<span class="lineNum">     182 </span>            : extern void deconstruct_expanded_record(ExpandedRecordHeader *erh);
<span class="lineNum">     183 </span>            : extern bool expanded_record_lookup_field(ExpandedRecordHeader *erh,
<span class="lineNum">     184 </span>            :                                          const char *fieldname,
<span class="lineNum">     185 </span>            :                                          ExpandedRecordFieldInfo *finfo);
<span class="lineNum">     186 </span>            : extern Datum expanded_record_fetch_field(ExpandedRecordHeader *erh, int fnumber,
<span class="lineNum">     187 </span>            :                                          bool *isnull);
<span class="lineNum">     188 </span>            : extern void expanded_record_set_field_internal(ExpandedRecordHeader *erh,
<span class="lineNum">     189 </span>            :                                                int fnumber,
<span class="lineNum">     190 </span>            :                                                Datum newValue, bool isnull,
<span class="lineNum">     191 </span>            :                                                bool expand_external,
<span class="lineNum">     192 </span>            :                                                bool check_constraints);
<span class="lineNum">     193 </span>            : extern void expanded_record_set_fields(ExpandedRecordHeader *erh,
<span class="lineNum">     194 </span>            :                                        const Datum *newValues, const bool *isnulls,
<span class="lineNum">     195 </span>            :                                        bool expand_external);
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            : /* outside code should never call expanded_record_set_field_internal as such */
<span class="lineNum">     198 </span>            : #define expanded_record_set_field(erh, fnumber, newValue, isnull, expand_external) \
<span class="lineNum">     199 </span>            :     expanded_record_set_field_internal(erh, fnumber, newValue, isnull, expand_external, true)
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : /*
<span class="lineNum">     202 </span>            :  * Inline-able fast cases.  The expanded_record_fetch_xxx functions above
<span class="lineNum">     203 </span>            :  * handle the general cases.
<span class="lineNum">     204 </span>            :  */
<span class="lineNum">     205 </span>            : 
<a name="206"><span class="lineNum">     206 </span>            : /* Get the tupdesc for the expanded record's actual type */</a>
<span class="lineNum">     207 </span>            : static inline TupleDesc
<span class="lineNum">     208 </span><span class="lineCov">      14842 : expanded_record_get_tupdesc(ExpandedRecordHeader *erh)</span>
<span class="lineNum">     209 </span>            : {
<span class="lineNum">     210 </span><span class="lineCov">      14842 :     if (likely(erh-&gt;er_tupdesc != NULL))</span>
<span class="lineNum">     211 </span><span class="lineCov">      14842 :         return erh-&gt;er_tupdesc;</span>
<span class="lineNum">     212 </span>            :     else
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :         return expanded_record_fetch_tupdesc(erh);</span>
<span class="lineNum">     214 </span>            : }
<span class="lineNum">     215 </span>            : 
<a name="216"><span class="lineNum">     216 </span>            : /* Get value of record field */</a>
<span class="lineNum">     217 </span>            : static inline Datum
<span class="lineNum">     218 </span><span class="lineCov">      11556 : expanded_record_get_field(ExpandedRecordHeader *erh, int fnumber,</span>
<span class="lineNum">     219 </span>            :                           bool *isnull)
<span class="lineNum">     220 </span>            : {
<span class="lineNum">     221 </span><span class="lineCov">      17576 :     if ((erh-&gt;flags &amp; ER_FLAG_DVALUES_VALID) &amp;&amp;</span>
<span class="lineNum">     222 </span><span class="lineCov">       6020 :         likely(fnumber &gt; 0 &amp;&amp; fnumber &lt;= erh-&gt;nfields))</span>
<span class="lineNum">     223 </span>            :     {
<span class="lineNum">     224 </span><span class="lineCov">       6020 :         *isnull = erh-&gt;dnulls[fnumber - 1];</span>
<span class="lineNum">     225 </span><span class="lineCov">       6020 :         return erh-&gt;dvalues[fnumber - 1];</span>
<span class="lineNum">     226 </span>            :     }
<span class="lineNum">     227 </span>            :     else
<span class="lineNum">     228 </span><span class="lineCov">       5536 :         return expanded_record_fetch_field(erh, fnumber, isnull);</span>
<span class="lineNum">     229 </span>            : }
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            : #endif                          /* EXPANDEDRECORD_H */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
