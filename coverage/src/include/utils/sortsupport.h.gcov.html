<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/include/utils/sortsupport.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/include/utils</a> - sortsupport.h<span style="font-size: 80%;"> (source / <a href="sortsupport.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">24</td>
            <td class="headerCovTableEntry">30</td>
            <td class="headerCovTableEntryMed">80.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * sortsupport.h
<span class="lineNum">       4 </span>            :  *    Framework for accelerated sorting.
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Traditionally, PostgreSQL has implemented sorting by repeatedly invoking
<span class="lineNum">       7 </span>            :  * an SQL-callable comparison function &quot;cmp(x, y) returns int&quot; on pairs of
<span class="lineNum">       8 </span>            :  * values to be compared, where the comparison function is the BTORDER_PROC
<span class="lineNum">       9 </span>            :  * pg_amproc support function of the appropriate btree index opclass.
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  * This file defines alternative APIs that allow sorting to be performed with
<span class="lineNum">      12 </span>            :  * reduced overhead.  To support lower-overhead sorting, a btree opclass may
<span class="lineNum">      13 </span>            :  * provide a BTSORTSUPPORT_PROC pg_amproc entry, which must take a single
<span class="lineNum">      14 </span>            :  * argument of type internal and return void.  The argument is actually a
<span class="lineNum">      15 </span>            :  * pointer to a SortSupportData struct, which is defined below.
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  * If provided, the BTSORTSUPPORT function will be called during sort setup,
<span class="lineNum">      18 </span>            :  * and it must initialize the provided struct with pointers to function(s)
<span class="lineNum">      19 </span>            :  * that can be called to perform sorting.  This API is defined to allow
<span class="lineNum">      20 </span>            :  * multiple acceleration mechanisms to be supported, but no opclass is
<span class="lineNum">      21 </span>            :  * required to provide all of them.  The BTSORTSUPPORT function should
<span class="lineNum">      22 </span>            :  * simply not set any function pointers for mechanisms it doesn't support.
<span class="lineNum">      23 </span>            :  * Opclasses that provide BTSORTSUPPORT and don't provide a comparator
<span class="lineNum">      24 </span>            :  * function will have a shim set up by sort support automatically.  However,
<span class="lineNum">      25 </span>            :  * opclasses that support the optional additional abbreviated key capability
<span class="lineNum">      26 </span>            :  * must always provide an authoritative comparator used to tie-break
<span class="lineNum">      27 </span>            :  * inconclusive abbreviated comparisons and also used  when aborting
<span class="lineNum">      28 </span>            :  * abbreviation.  Furthermore, a converter and abort/costing function must be
<span class="lineNum">      29 </span>            :  * provided.
<span class="lineNum">      30 </span>            :  *
<span class="lineNum">      31 </span>            :  * All sort support functions will be passed the address of the
<span class="lineNum">      32 </span>            :  * SortSupportData struct when called, so they can use it to store
<span class="lineNum">      33 </span>            :  * additional private data as needed.  In particular, for collation-aware
<span class="lineNum">      34 </span>            :  * datatypes, the ssup_collation field is set before calling BTSORTSUPPORT
<span class="lineNum">      35 </span>            :  * and is available to all support functions.  Additional opclass-dependent
<span class="lineNum">      36 </span>            :  * data can be stored using the ssup_extra field.  Any such data
<span class="lineNum">      37 </span>            :  * should be allocated in the ssup_cxt memory context.
<span class="lineNum">      38 </span>            :  *
<span class="lineNum">      39 </span>            :  * Note: since pg_amproc functions are indexed by (lefttype, righttype)
<span class="lineNum">      40 </span>            :  * it is possible to associate a BTSORTSUPPORT function with a cross-type
<span class="lineNum">      41 </span>            :  * comparison.  This could sensibly be used to provide a fast comparator
<span class="lineNum">      42 </span>            :  * function for such cases, but probably not any other acceleration method.
<span class="lineNum">      43 </span>            :  *
<span class="lineNum">      44 </span>            :  *
<span class="lineNum">      45 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">      46 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">      47 </span>            :  *
<span class="lineNum">      48 </span>            :  * src/include/utils/sortsupport.h
<span class="lineNum">      49 </span>            :  *
<span class="lineNum">      50 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      51 </span>            :  */
<span class="lineNum">      52 </span>            : #ifndef SORTSUPPORT_H
<span class="lineNum">      53 </span>            : #define SORTSUPPORT_H
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : #include &quot;access/attnum.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;utils/relcache.h&quot;
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : typedef struct SortSupportData *SortSupport;
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : typedef struct SortSupportData
<span class="lineNum">      61 </span>            : {
<span class="lineNum">      62 </span>            :     /*
<span class="lineNum">      63 </span>            :      * These fields are initialized before calling the BTSORTSUPPORT function
<span class="lineNum">      64 </span>            :      * and should not be changed later.
<span class="lineNum">      65 </span>            :      */
<span class="lineNum">      66 </span>            :     MemoryContext ssup_cxt;     /* Context containing sort info */
<span class="lineNum">      67 </span>            :     Oid         ssup_collation; /* Collation to use, or InvalidOid */
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            :     /*
<span class="lineNum">      70 </span>            :      * Additional sorting parameters; but unlike ssup_collation, these can be
<span class="lineNum">      71 </span>            :      * changed after BTSORTSUPPORT is called, so don't use them in selecting
<span class="lineNum">      72 </span>            :      * sort support functions.
<span class="lineNum">      73 </span>            :      */
<span class="lineNum">      74 </span>            :     bool        ssup_reverse;   /* descending-order sort? */
<span class="lineNum">      75 </span>            :     bool        ssup_nulls_first;   /* sort nulls first? */
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            :     /*
<span class="lineNum">      78 </span>            :      * These fields are workspace for callers, and should not be touched by
<span class="lineNum">      79 </span>            :      * opclass-specific functions.
<span class="lineNum">      80 </span>            :      */
<span class="lineNum">      81 </span>            :     AttrNumber  ssup_attno;     /* column number to sort */
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            :     /*
<span class="lineNum">      84 </span>            :      * ssup_extra is zeroed before calling the BTSORTSUPPORT function, and is
<span class="lineNum">      85 </span>            :      * not touched subsequently by callers.
<span class="lineNum">      86 </span>            :      */
<span class="lineNum">      87 </span>            :     void       *ssup_extra;     /* Workspace for opclass functions */
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            :     /*
<span class="lineNum">      90 </span>            :      * Function pointers are zeroed before calling the BTSORTSUPPORT function,
<span class="lineNum">      91 </span>            :      * and must be set by it for any acceleration methods it wants to supply.
<span class="lineNum">      92 </span>            :      * The comparator pointer must be set, others are optional.
<span class="lineNum">      93 </span>            :      */
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            :     /*
<span class="lineNum">      96 </span>            :      * Comparator function has the same API as the traditional btree
<span class="lineNum">      97 </span>            :      * comparison function, ie, return &lt;0, 0, or &gt;0 according as x is less
<span class="lineNum">      98 </span>            :      * than, equal to, or greater than y.  Note that x and y are guaranteed
<span class="lineNum">      99 </span>            :      * not null, and there is no way to return null either.
<span class="lineNum">     100 </span>            :      *
<span class="lineNum">     101 </span>            :      * This may be either the authoritative comparator, or the abbreviated
<span class="lineNum">     102 </span>            :      * comparator.  Core code may switch this over the initial preference of
<span class="lineNum">     103 </span>            :      * an opclass support function despite originally indicating abbreviation
<span class="lineNum">     104 </span>            :      * was applicable, by assigning the authoritative comparator back.
<span class="lineNum">     105 </span>            :      */
<span class="lineNum">     106 </span>            :     int         (*comparator) (Datum x, Datum y, SortSupport ssup);
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            :     /*
<span class="lineNum">     109 </span>            :      * &quot;Abbreviated key&quot; infrastructure follows.
<span class="lineNum">     110 </span>            :      *
<span class="lineNum">     111 </span>            :      * All callbacks must be set by sortsupport opclasses that make use of
<span class="lineNum">     112 </span>            :      * this optional additional infrastructure (unless for whatever reasons
<span class="lineNum">     113 </span>            :      * the opclass doesn't proceed with abbreviation, in which case
<span class="lineNum">     114 </span>            :      * abbrev_converter must not be set).
<span class="lineNum">     115 </span>            :      *
<span class="lineNum">     116 </span>            :      * This allows opclass authors to supply a conversion routine, used to
<span class="lineNum">     117 </span>            :      * create an alternative representation of the underlying type (an
<span class="lineNum">     118 </span>            :      * &quot;abbreviated key&quot;).  This representation must be pass-by-value and
<span class="lineNum">     119 </span>            :      * typically will use some ad-hoc format that only the opclass has
<span class="lineNum">     120 </span>            :      * knowledge of.  An alternative comparator, used only with this
<span class="lineNum">     121 </span>            :      * alternative representation must also be provided (which is assigned to
<span class="lineNum">     122 </span>            :      * &quot;comparator&quot;).  This representation is a simple approximation of the
<span class="lineNum">     123 </span>            :      * original Datum.  It must be possible to compare datums of this
<span class="lineNum">     124 </span>            :      * representation with each other using the supplied alternative
<span class="lineNum">     125 </span>            :      * comparator, and have any non-zero return value be a reliable proxy for
<span class="lineNum">     126 </span>            :      * what a proper comparison would indicate. Returning zero from the
<span class="lineNum">     127 </span>            :      * alternative comparator does not indicate equality, as with a
<span class="lineNum">     128 </span>            :      * conventional support routine 1, though -- it indicates that it wasn't
<span class="lineNum">     129 </span>            :      * possible to determine how the two abbreviated values compared.  A
<span class="lineNum">     130 </span>            :      * proper comparison, using &quot;abbrev_full_comparator&quot;/
<span class="lineNum">     131 </span>            :      * ApplySortAbbrevFullComparator() is therefore required.  In many cases
<span class="lineNum">     132 </span>            :      * this results in most or all comparisons only using the cheap
<span class="lineNum">     133 </span>            :      * alternative comparison func, which is typically implemented as code
<span class="lineNum">     134 </span>            :      * that compiles to just a few CPU instructions.  CPU cache miss penalties
<span class="lineNum">     135 </span>            :      * are expensive; to get good overall performance, sort infrastructure
<span class="lineNum">     136 </span>            :      * must heavily weigh cache performance.
<span class="lineNum">     137 </span>            :      *
<span class="lineNum">     138 </span>            :      * Opclass authors must consider the final cardinality of abbreviated keys
<span class="lineNum">     139 </span>            :      * when devising an encoding scheme.  It's possible for a strategy to work
<span class="lineNum">     140 </span>            :      * better than an alternative strategy with one usage pattern, while the
<span class="lineNum">     141 </span>            :      * reverse might be true for another usage pattern.  All of these factors
<span class="lineNum">     142 </span>            :      * must be considered.
<span class="lineNum">     143 </span>            :      */
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :     /*
<span class="lineNum">     146 </span>            :      * &quot;abbreviate&quot; concerns whether or not the abbreviated key optimization
<span class="lineNum">     147 </span>            :      * is applicable in principle (that is, the sortsupport routine needs to
<span class="lineNum">     148 </span>            :      * know if its dealing with a key where an abbreviated representation can
<span class="lineNum">     149 </span>            :      * usefully be packed together.  Conventionally, this is the leading
<span class="lineNum">     150 </span>            :      * attribute key).  Note, however, that in order to determine that
<span class="lineNum">     151 </span>            :      * abbreviation is not in play, the core code always checks whether or not
<span class="lineNum">     152 </span>            :      * the opclass has set abbrev_converter.  This is a one way, one time
<span class="lineNum">     153 </span>            :      * message to the opclass.
<span class="lineNum">     154 </span>            :      */
<span class="lineNum">     155 </span>            :     bool        abbreviate;
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            :     /*
<span class="lineNum">     158 </span>            :      * Converter to abbreviated format, from original representation.  Core
<span class="lineNum">     159 </span>            :      * code uses this callback to convert from a pass-by-reference &quot;original&quot;
<span class="lineNum">     160 </span>            :      * Datum to a pass-by-value abbreviated key Datum.  Note that original is
<span class="lineNum">     161 </span>            :      * guaranteed NOT NULL, because it doesn't make sense to factor NULLness
<span class="lineNum">     162 </span>            :      * into ad-hoc cost model.
<span class="lineNum">     163 </span>            :      *
<span class="lineNum">     164 </span>            :      * abbrev_converter is tested to see if abbreviation is in play.  Core
<span class="lineNum">     165 </span>            :      * code may set it to NULL to indicate abbreviation should not be used
<span class="lineNum">     166 </span>            :      * (which is something sortsupport routines need not concern themselves
<span class="lineNum">     167 </span>            :      * with). However, sortsupport routines must not set it when it is
<span class="lineNum">     168 </span>            :      * immediately established that abbreviation should not proceed (e.g., for
<span class="lineNum">     169 </span>            :      * !abbreviate calls, or due to platform-specific impediments to using
<span class="lineNum">     170 </span>            :      * abbreviation).
<span class="lineNum">     171 </span>            :      */
<span class="lineNum">     172 </span>            :     Datum       (*abbrev_converter) (Datum original, SortSupport ssup);
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            :     /*
<span class="lineNum">     175 </span>            :      * abbrev_abort callback allows clients to verify that the current
<span class="lineNum">     176 </span>            :      * strategy is working out, using a sortsupport routine defined ad-hoc
<span class="lineNum">     177 </span>            :      * cost model. If there is a lot of duplicate abbreviated keys in
<span class="lineNum">     178 </span>            :      * practice, it's useful to be able to abandon the strategy before paying
<span class="lineNum">     179 </span>            :      * too high a cost in conversion (perhaps certain opclass-specific
<span class="lineNum">     180 </span>            :      * adaptations are useful too).
<span class="lineNum">     181 </span>            :      */
<span class="lineNum">     182 </span>            :     bool        (*abbrev_abort) (int memtupcount, SortSupport ssup);
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :     /*
<span class="lineNum">     185 </span>            :      * Full, authoritative comparator for key that an abbreviated
<span class="lineNum">     186 </span>            :      * representation was generated for, used when an abbreviated comparison
<span class="lineNum">     187 </span>            :      * was inconclusive (by calling ApplySortAbbrevFullComparator()), or used
<span class="lineNum">     188 </span>            :      * to replace &quot;comparator&quot; when core system ultimately decides against
<span class="lineNum">     189 </span>            :      * abbreviation.
<span class="lineNum">     190 </span>            :      */
<span class="lineNum">     191 </span>            :     int         (*abbrev_full_comparator) (Datum x, Datum y, SortSupport ssup);
<span class="lineNum">     192 </span>            : } SortSupportData;
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : /*
<span class="lineNum">     196 </span>            :  * Apply a sort comparator function and return a 3-way comparison result.
<span class="lineNum">     197 </span>            :  * This takes care of handling reverse-sort and NULLs-ordering properly.
<a name="198"><span class="lineNum">     198 </span>            :  */</a>
<span class="lineNum">     199 </span>            : static inline int
<span class="lineNum">     200 </span><span class="lineCov">  123294116 : ApplySortComparator(Datum datum1, bool isNull1,</span>
<span class="lineNum">     201 </span>            :                     Datum datum2, bool isNull2,
<span class="lineNum">     202 </span>            :                     SortSupport ssup)
<span class="lineNum">     203 </span>            : {
<span class="lineNum">     204 </span>            :     int         compare;
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineCov">  123294116 :     if (isNull1)</span>
<span class="lineNum">     207 </span>            :     {
<span class="lineNum">     208 </span><span class="lineCov">     124794 :         if (isNull2)</span>
<span class="lineNum">     209 </span><span class="lineCov">     116332 :             compare = 0;        /* NULL &quot;=&quot; NULL */</span>
<span class="lineNum">     210 </span><span class="lineCov">       8462 :         else if (ssup-&gt;ssup_nulls_first)</span>
<span class="lineNum">     211 </span><span class="lineCov">       1558 :             compare = -1;       /* NULL &quot;&lt;&quot; NOT_NULL */</span>
<span class="lineNum">     212 </span>            :         else
<span class="lineNum">     213 </span><span class="lineCov">       6904 :             compare = 1;        /* NULL &quot;&gt;&quot; NOT_NULL */</span>
<span class="lineNum">     214 </span>            :     }
<span class="lineNum">     215 </span><span class="lineCov">  123169322 :     else if (isNull2)</span>
<span class="lineNum">     216 </span>            :     {
<span class="lineNum">     217 </span><span class="lineCov">      13420 :         if (ssup-&gt;ssup_nulls_first)</span>
<span class="lineNum">     218 </span><span class="lineCov">        240 :             compare = 1;        /* NOT_NULL &quot;&gt;&quot; NULL */</span>
<span class="lineNum">     219 </span>            :         else
<span class="lineNum">     220 </span><span class="lineCov">      13180 :             compare = -1;       /* NOT_NULL &quot;&lt;&quot; NULL */</span>
<span class="lineNum">     221 </span>            :     }
<span class="lineNum">     222 </span>            :     else
<span class="lineNum">     223 </span>            :     {
<span class="lineNum">     224 </span><span class="lineCov">  123155902 :         compare = ssup-&gt;comparator(datum1, datum2, ssup);</span>
<span class="lineNum">     225 </span><span class="lineCov">  123155902 :         if (ssup-&gt;ssup_reverse)</span>
<span class="lineNum">     226 </span><span class="lineCov">    5098002 :             INVERT_COMPARE_RESULT(compare);</span>
<span class="lineNum">     227 </span>            :     }
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span><span class="lineCov">  123294116 :     return compare;</span>
<span class="lineNum">     230 </span>            : }
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            : /*
<span class="lineNum">     233 </span>            :  * Apply a sort comparator function and return a 3-way comparison using full,
<span class="lineNum">     234 </span>            :  * authoritative comparator.  This takes care of handling reverse-sort and
<span class="lineNum">     235 </span>            :  * NULLs-ordering properly.
<a name="236"><span class="lineNum">     236 </span>            :  */</a>
<span class="lineNum">     237 </span>            : static inline int
<span class="lineNum">     238 </span><span class="lineCov">    1104296 : ApplySortAbbrevFullComparator(Datum datum1, bool isNull1,</span>
<span class="lineNum">     239 </span>            :                               Datum datum2, bool isNull2,
<span class="lineNum">     240 </span>            :                               SortSupport ssup)
<span class="lineNum">     241 </span>            : {
<span class="lineNum">     242 </span>            :     int         compare;
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span><span class="lineCov">    1104296 :     if (isNull1)</span>
<span class="lineNum">     245 </span>            :     {
<span class="lineNum">     246 </span><span class="lineCov">        110 :         if (isNull2)</span>
<span class="lineNum">     247 </span><span class="lineCov">        110 :             compare = 0;        /* NULL &quot;=&quot; NULL */</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         else if (ssup-&gt;ssup_nulls_first)</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :             compare = -1;       /* NULL &quot;&lt;&quot; NOT_NULL */</span>
<span class="lineNum">     250 </span>            :         else
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :             compare = 1;        /* NULL &quot;&gt;&quot; NOT_NULL */</span>
<span class="lineNum">     252 </span>            :     }
<span class="lineNum">     253 </span><span class="lineCov">    1104186 :     else if (isNull2)</span>
<span class="lineNum">     254 </span>            :     {
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :         if (ssup-&gt;ssup_nulls_first)</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :             compare = 1;        /* NOT_NULL &quot;&gt;&quot; NULL */</span>
<span class="lineNum">     257 </span>            :         else
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :             compare = -1;       /* NOT_NULL &quot;&lt;&quot; NULL */</span>
<span class="lineNum">     259 </span>            :     }
<span class="lineNum">     260 </span>            :     else
<span class="lineNum">     261 </span>            :     {
<span class="lineNum">     262 </span><span class="lineCov">    1104186 :         compare = ssup-&gt;abbrev_full_comparator(datum1, datum2, ssup);</span>
<span class="lineNum">     263 </span><span class="lineCov">    1104186 :         if (ssup-&gt;ssup_reverse)</span>
<span class="lineNum">     264 </span><span class="lineCov">     484654 :             INVERT_COMPARE_RESULT(compare);</span>
<span class="lineNum">     265 </span>            :     }
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span><span class="lineCov">    1104296 :     return compare;</span>
<span class="lineNum">     268 </span>            : }
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            : /* Other functions in utils/sort/sortsupport.c */
<span class="lineNum">     271 </span>            : extern void PrepareSortSupportComparisonShim(Oid cmpFunc, SortSupport ssup);
<span class="lineNum">     272 </span>            : extern void PrepareSortSupportFromOrderingOp(Oid orderingOp, SortSupport ssup);
<span class="lineNum">     273 </span>            : extern void PrepareSortSupportFromIndexRel(Relation indexRel, int16 strategy,
<span class="lineNum">     274 </span>            :                                            SortSupport ssup);
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            : #endif                          /* SORTSUPPORT_H */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
