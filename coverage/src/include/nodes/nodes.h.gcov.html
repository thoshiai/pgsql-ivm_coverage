<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/include/nodes/nodes.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/include/nodes</a> - nodes.h<span style="font-size: 80%;"> (source / <a href="nodes.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * nodes.h
<span class="lineNum">       4 </span>            :  *    Definitions for tagged nodes.
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       8 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * src/include/nodes/nodes.h
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      13 </span>            :  */
<span class="lineNum">      14 </span>            : #ifndef NODES_H
<span class="lineNum">      15 </span>            : #define NODES_H
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : /*
<span class="lineNum">      18 </span>            :  * The first field of every node is NodeTag. Each node created (with makeNode)
<span class="lineNum">      19 </span>            :  * will have one of the following tags as the value of its first field.
<span class="lineNum">      20 </span>            :  *
<span class="lineNum">      21 </span>            :  * Note that inserting or deleting node types changes the numbers of other
<span class="lineNum">      22 </span>            :  * node types later in the list.  This is no problem during development, since
<span class="lineNum">      23 </span>            :  * the node numbers are never stored on disk.  But don't do it in a released
<span class="lineNum">      24 </span>            :  * branch, because that would represent an ABI break for extensions.
<span class="lineNum">      25 </span>            :  */
<span class="lineNum">      26 </span>            : typedef enum NodeTag
<span class="lineNum">      27 </span>            : {
<span class="lineNum">      28 </span>            :     T_Invalid = 0,
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            :     /*
<span class="lineNum">      31 </span>            :      * TAGS FOR EXECUTOR NODES (execnodes.h)
<span class="lineNum">      32 </span>            :      */
<span class="lineNum">      33 </span>            :     T_IndexInfo,
<span class="lineNum">      34 </span>            :     T_ExprContext,
<span class="lineNum">      35 </span>            :     T_ProjectionInfo,
<span class="lineNum">      36 </span>            :     T_JunkFilter,
<span class="lineNum">      37 </span>            :     T_OnConflictSetState,
<span class="lineNum">      38 </span>            :     T_ResultRelInfo,
<span class="lineNum">      39 </span>            :     T_EState,
<span class="lineNum">      40 </span>            :     T_TupleTableSlot,
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            :     /*
<span class="lineNum">      43 </span>            :      * TAGS FOR PLAN NODES (plannodes.h)
<span class="lineNum">      44 </span>            :      */
<span class="lineNum">      45 </span>            :     T_Plan,
<span class="lineNum">      46 </span>            :     T_Result,
<span class="lineNum">      47 </span>            :     T_ProjectSet,
<span class="lineNum">      48 </span>            :     T_ModifyTable,
<span class="lineNum">      49 </span>            :     T_Append,
<span class="lineNum">      50 </span>            :     T_MergeAppend,
<span class="lineNum">      51 </span>            :     T_RecursiveUnion,
<span class="lineNum">      52 </span>            :     T_BitmapAnd,
<span class="lineNum">      53 </span>            :     T_BitmapOr,
<span class="lineNum">      54 </span>            :     T_Scan,
<span class="lineNum">      55 </span>            :     T_SeqScan,
<span class="lineNum">      56 </span>            :     T_SampleScan,
<span class="lineNum">      57 </span>            :     T_IndexScan,
<span class="lineNum">      58 </span>            :     T_IndexOnlyScan,
<span class="lineNum">      59 </span>            :     T_BitmapIndexScan,
<span class="lineNum">      60 </span>            :     T_BitmapHeapScan,
<span class="lineNum">      61 </span>            :     T_TidScan,
<span class="lineNum">      62 </span>            :     T_SubqueryScan,
<span class="lineNum">      63 </span>            :     T_FunctionScan,
<span class="lineNum">      64 </span>            :     T_ValuesScan,
<span class="lineNum">      65 </span>            :     T_TableFuncScan,
<span class="lineNum">      66 </span>            :     T_CteScan,
<span class="lineNum">      67 </span>            :     T_NamedTuplestoreScan,
<span class="lineNum">      68 </span>            :     T_WorkTableScan,
<span class="lineNum">      69 </span>            :     T_ForeignScan,
<span class="lineNum">      70 </span>            :     T_CustomScan,
<span class="lineNum">      71 </span>            :     T_Join,
<span class="lineNum">      72 </span>            :     T_NestLoop,
<span class="lineNum">      73 </span>            :     T_MergeJoin,
<span class="lineNum">      74 </span>            :     T_HashJoin,
<span class="lineNum">      75 </span>            :     T_Material,
<span class="lineNum">      76 </span>            :     T_Sort,
<span class="lineNum">      77 </span>            :     T_Group,
<span class="lineNum">      78 </span>            :     T_Agg,
<span class="lineNum">      79 </span>            :     T_WindowAgg,
<span class="lineNum">      80 </span>            :     T_Unique,
<span class="lineNum">      81 </span>            :     T_Gather,
<span class="lineNum">      82 </span>            :     T_GatherMerge,
<span class="lineNum">      83 </span>            :     T_Hash,
<span class="lineNum">      84 </span>            :     T_SetOp,
<span class="lineNum">      85 </span>            :     T_LockRows,
<span class="lineNum">      86 </span>            :     T_Limit,
<span class="lineNum">      87 </span>            :     /* these aren't subclasses of Plan: */
<span class="lineNum">      88 </span>            :     T_NestLoopParam,
<span class="lineNum">      89 </span>            :     T_PlanRowMark,
<span class="lineNum">      90 </span>            :     T_PartitionPruneInfo,
<span class="lineNum">      91 </span>            :     T_PartitionedRelPruneInfo,
<span class="lineNum">      92 </span>            :     T_PartitionPruneStepOp,
<span class="lineNum">      93 </span>            :     T_PartitionPruneStepCombine,
<span class="lineNum">      94 </span>            :     T_PlanInvalItem,
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            :     /*
<span class="lineNum">      97 </span>            :      * TAGS FOR PLAN STATE NODES (execnodes.h)
<span class="lineNum">      98 </span>            :      *
<span class="lineNum">      99 </span>            :      * These should correspond one-to-one with Plan node types.
<span class="lineNum">     100 </span>            :      */
<span class="lineNum">     101 </span>            :     T_PlanState,
<span class="lineNum">     102 </span>            :     T_ResultState,
<span class="lineNum">     103 </span>            :     T_ProjectSetState,
<span class="lineNum">     104 </span>            :     T_ModifyTableState,
<span class="lineNum">     105 </span>            :     T_AppendState,
<span class="lineNum">     106 </span>            :     T_MergeAppendState,
<span class="lineNum">     107 </span>            :     T_RecursiveUnionState,
<span class="lineNum">     108 </span>            :     T_BitmapAndState,
<span class="lineNum">     109 </span>            :     T_BitmapOrState,
<span class="lineNum">     110 </span>            :     T_ScanState,
<span class="lineNum">     111 </span>            :     T_SeqScanState,
<span class="lineNum">     112 </span>            :     T_SampleScanState,
<span class="lineNum">     113 </span>            :     T_IndexScanState,
<span class="lineNum">     114 </span>            :     T_IndexOnlyScanState,
<span class="lineNum">     115 </span>            :     T_BitmapIndexScanState,
<span class="lineNum">     116 </span>            :     T_BitmapHeapScanState,
<span class="lineNum">     117 </span>            :     T_TidScanState,
<span class="lineNum">     118 </span>            :     T_SubqueryScanState,
<span class="lineNum">     119 </span>            :     T_FunctionScanState,
<span class="lineNum">     120 </span>            :     T_TableFuncScanState,
<span class="lineNum">     121 </span>            :     T_ValuesScanState,
<span class="lineNum">     122 </span>            :     T_CteScanState,
<span class="lineNum">     123 </span>            :     T_NamedTuplestoreScanState,
<span class="lineNum">     124 </span>            :     T_WorkTableScanState,
<span class="lineNum">     125 </span>            :     T_ForeignScanState,
<span class="lineNum">     126 </span>            :     T_CustomScanState,
<span class="lineNum">     127 </span>            :     T_JoinState,
<span class="lineNum">     128 </span>            :     T_NestLoopState,
<span class="lineNum">     129 </span>            :     T_MergeJoinState,
<span class="lineNum">     130 </span>            :     T_HashJoinState,
<span class="lineNum">     131 </span>            :     T_MaterialState,
<span class="lineNum">     132 </span>            :     T_SortState,
<span class="lineNum">     133 </span>            :     T_GroupState,
<span class="lineNum">     134 </span>            :     T_AggState,
<span class="lineNum">     135 </span>            :     T_WindowAggState,
<span class="lineNum">     136 </span>            :     T_UniqueState,
<span class="lineNum">     137 </span>            :     T_GatherState,
<span class="lineNum">     138 </span>            :     T_GatherMergeState,
<span class="lineNum">     139 </span>            :     T_HashState,
<span class="lineNum">     140 </span>            :     T_SetOpState,
<span class="lineNum">     141 </span>            :     T_LockRowsState,
<span class="lineNum">     142 </span>            :     T_LimitState,
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            :     /*
<span class="lineNum">     145 </span>            :      * TAGS FOR PRIMITIVE NODES (primnodes.h)
<span class="lineNum">     146 </span>            :      */
<span class="lineNum">     147 </span>            :     T_Alias,
<span class="lineNum">     148 </span>            :     T_RangeVar,
<span class="lineNum">     149 </span>            :     T_TableFunc,
<span class="lineNum">     150 </span>            :     T_Expr,
<span class="lineNum">     151 </span>            :     T_Var,
<span class="lineNum">     152 </span>            :     T_Const,
<span class="lineNum">     153 </span>            :     T_Param,
<span class="lineNum">     154 </span>            :     T_Aggref,
<span class="lineNum">     155 </span>            :     T_GroupingFunc,
<span class="lineNum">     156 </span>            :     T_WindowFunc,
<span class="lineNum">     157 </span>            :     T_SubscriptingRef,
<span class="lineNum">     158 </span>            :     T_FuncExpr,
<span class="lineNum">     159 </span>            :     T_NamedArgExpr,
<span class="lineNum">     160 </span>            :     T_OpExpr,
<span class="lineNum">     161 </span>            :     T_DistinctExpr,
<span class="lineNum">     162 </span>            :     T_NullIfExpr,
<span class="lineNum">     163 </span>            :     T_ScalarArrayOpExpr,
<span class="lineNum">     164 </span>            :     T_BoolExpr,
<span class="lineNum">     165 </span>            :     T_SubLink,
<span class="lineNum">     166 </span>            :     T_SubPlan,
<span class="lineNum">     167 </span>            :     T_AlternativeSubPlan,
<span class="lineNum">     168 </span>            :     T_FieldSelect,
<span class="lineNum">     169 </span>            :     T_FieldStore,
<span class="lineNum">     170 </span>            :     T_RelabelType,
<span class="lineNum">     171 </span>            :     T_CoerceViaIO,
<span class="lineNum">     172 </span>            :     T_ArrayCoerceExpr,
<span class="lineNum">     173 </span>            :     T_ConvertRowtypeExpr,
<span class="lineNum">     174 </span>            :     T_CollateExpr,
<span class="lineNum">     175 </span>            :     T_CaseExpr,
<span class="lineNum">     176 </span>            :     T_CaseWhen,
<span class="lineNum">     177 </span>            :     T_CaseTestExpr,
<span class="lineNum">     178 </span>            :     T_ArrayExpr,
<span class="lineNum">     179 </span>            :     T_RowExpr,
<span class="lineNum">     180 </span>            :     T_RowCompareExpr,
<span class="lineNum">     181 </span>            :     T_CoalesceExpr,
<span class="lineNum">     182 </span>            :     T_MinMaxExpr,
<span class="lineNum">     183 </span>            :     T_SQLValueFunction,
<span class="lineNum">     184 </span>            :     T_XmlExpr,
<span class="lineNum">     185 </span>            :     T_NullTest,
<span class="lineNum">     186 </span>            :     T_BooleanTest,
<span class="lineNum">     187 </span>            :     T_CoerceToDomain,
<span class="lineNum">     188 </span>            :     T_CoerceToDomainValue,
<span class="lineNum">     189 </span>            :     T_SetToDefault,
<span class="lineNum">     190 </span>            :     T_CurrentOfExpr,
<span class="lineNum">     191 </span>            :     T_NextValueExpr,
<span class="lineNum">     192 </span>            :     T_InferenceElem,
<span class="lineNum">     193 </span>            :     T_TargetEntry,
<span class="lineNum">     194 </span>            :     T_RangeTblRef,
<span class="lineNum">     195 </span>            :     T_JoinExpr,
<span class="lineNum">     196 </span>            :     T_FromExpr,
<span class="lineNum">     197 </span>            :     T_OnConflictExpr,
<span class="lineNum">     198 </span>            :     T_IntoClause,
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :     /*
<span class="lineNum">     201 </span>            :      * TAGS FOR EXPRESSION STATE NODES (execnodes.h)
<span class="lineNum">     202 </span>            :      *
<span class="lineNum">     203 </span>            :      * ExprState represents the evaluation state for a whole expression tree.
<span class="lineNum">     204 </span>            :      * Most Expr-based plan nodes do not have a corresponding expression state
<span class="lineNum">     205 </span>            :      * node, they're fully handled within execExpr* - but sometimes the state
<span class="lineNum">     206 </span>            :      * needs to be shared with other parts of the executor, as for example
<span class="lineNum">     207 </span>            :      * with AggrefExprState, which nodeAgg.c has to modify.
<span class="lineNum">     208 </span>            :      */
<span class="lineNum">     209 </span>            :     T_ExprState,
<span class="lineNum">     210 </span>            :     T_AggrefExprState,
<span class="lineNum">     211 </span>            :     T_WindowFuncExprState,
<span class="lineNum">     212 </span>            :     T_SetExprState,
<span class="lineNum">     213 </span>            :     T_SubPlanState,
<span class="lineNum">     214 </span>            :     T_AlternativeSubPlanState,
<span class="lineNum">     215 </span>            :     T_DomainConstraintState,
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            :     /*
<span class="lineNum">     218 </span>            :      * TAGS FOR PLANNER NODES (pathnodes.h)
<span class="lineNum">     219 </span>            :      */
<span class="lineNum">     220 </span>            :     T_PlannerInfo,
<span class="lineNum">     221 </span>            :     T_PlannerGlobal,
<span class="lineNum">     222 </span>            :     T_RelOptInfo,
<span class="lineNum">     223 </span>            :     T_IndexOptInfo,
<span class="lineNum">     224 </span>            :     T_ForeignKeyOptInfo,
<span class="lineNum">     225 </span>            :     T_ParamPathInfo,
<span class="lineNum">     226 </span>            :     T_Path,
<span class="lineNum">     227 </span>            :     T_IndexPath,
<span class="lineNum">     228 </span>            :     T_BitmapHeapPath,
<span class="lineNum">     229 </span>            :     T_BitmapAndPath,
<span class="lineNum">     230 </span>            :     T_BitmapOrPath,
<span class="lineNum">     231 </span>            :     T_TidPath,
<span class="lineNum">     232 </span>            :     T_SubqueryScanPath,
<span class="lineNum">     233 </span>            :     T_ForeignPath,
<span class="lineNum">     234 </span>            :     T_CustomPath,
<span class="lineNum">     235 </span>            :     T_NestPath,
<span class="lineNum">     236 </span>            :     T_MergePath,
<span class="lineNum">     237 </span>            :     T_HashPath,
<span class="lineNum">     238 </span>            :     T_AppendPath,
<span class="lineNum">     239 </span>            :     T_MergeAppendPath,
<span class="lineNum">     240 </span>            :     T_GroupResultPath,
<span class="lineNum">     241 </span>            :     T_MaterialPath,
<span class="lineNum">     242 </span>            :     T_UniquePath,
<span class="lineNum">     243 </span>            :     T_GatherPath,
<span class="lineNum">     244 </span>            :     T_GatherMergePath,
<span class="lineNum">     245 </span>            :     T_ProjectionPath,
<span class="lineNum">     246 </span>            :     T_ProjectSetPath,
<span class="lineNum">     247 </span>            :     T_SortPath,
<span class="lineNum">     248 </span>            :     T_GroupPath,
<span class="lineNum">     249 </span>            :     T_UpperUniquePath,
<span class="lineNum">     250 </span>            :     T_AggPath,
<span class="lineNum">     251 </span>            :     T_GroupingSetsPath,
<span class="lineNum">     252 </span>            :     T_MinMaxAggPath,
<span class="lineNum">     253 </span>            :     T_WindowAggPath,
<span class="lineNum">     254 </span>            :     T_SetOpPath,
<span class="lineNum">     255 </span>            :     T_RecursiveUnionPath,
<span class="lineNum">     256 </span>            :     T_LockRowsPath,
<span class="lineNum">     257 </span>            :     T_ModifyTablePath,
<span class="lineNum">     258 </span>            :     T_LimitPath,
<span class="lineNum">     259 </span>            :     /* these aren't subclasses of Path: */
<span class="lineNum">     260 </span>            :     T_EquivalenceClass,
<span class="lineNum">     261 </span>            :     T_EquivalenceMember,
<span class="lineNum">     262 </span>            :     T_PathKey,
<span class="lineNum">     263 </span>            :     T_PathTarget,
<span class="lineNum">     264 </span>            :     T_RestrictInfo,
<span class="lineNum">     265 </span>            :     T_IndexClause,
<span class="lineNum">     266 </span>            :     T_PlaceHolderVar,
<span class="lineNum">     267 </span>            :     T_SpecialJoinInfo,
<span class="lineNum">     268 </span>            :     T_AppendRelInfo,
<span class="lineNum">     269 </span>            :     T_PlaceHolderInfo,
<span class="lineNum">     270 </span>            :     T_MinMaxAggInfo,
<span class="lineNum">     271 </span>            :     T_PlannerParamItem,
<span class="lineNum">     272 </span>            :     T_RollupData,
<span class="lineNum">     273 </span>            :     T_GroupingSetData,
<span class="lineNum">     274 </span>            :     T_StatisticExtInfo,
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :     /*
<span class="lineNum">     277 </span>            :      * TAGS FOR MEMORY NODES (memnodes.h)
<span class="lineNum">     278 </span>            :      */
<span class="lineNum">     279 </span>            :     T_MemoryContext,
<span class="lineNum">     280 </span>            :     T_AllocSetContext,
<span class="lineNum">     281 </span>            :     T_SlabContext,
<span class="lineNum">     282 </span>            :     T_GenerationContext,
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            :     /*
<span class="lineNum">     285 </span>            :      * TAGS FOR VALUE NODES (value.h)
<span class="lineNum">     286 </span>            :      */
<span class="lineNum">     287 </span>            :     T_Value,
<span class="lineNum">     288 </span>            :     T_Integer,
<span class="lineNum">     289 </span>            :     T_Float,
<span class="lineNum">     290 </span>            :     T_String,
<span class="lineNum">     291 </span>            :     T_BitString,
<span class="lineNum">     292 </span>            :     T_Null,
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :     /*
<span class="lineNum">     295 </span>            :      * TAGS FOR LIST NODES (pg_list.h)
<span class="lineNum">     296 </span>            :      */
<span class="lineNum">     297 </span>            :     T_List,
<span class="lineNum">     298 </span>            :     T_IntList,
<span class="lineNum">     299 </span>            :     T_OidList,
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :     /*
<span class="lineNum">     302 </span>            :      * TAGS FOR EXTENSIBLE NODES (extensible.h)
<span class="lineNum">     303 </span>            :      */
<span class="lineNum">     304 </span>            :     T_ExtensibleNode,
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :     /*
<span class="lineNum">     307 </span>            :      * TAGS FOR STATEMENT NODES (mostly in parsenodes.h)
<span class="lineNum">     308 </span>            :      */
<span class="lineNum">     309 </span>            :     T_RawStmt,
<span class="lineNum">     310 </span>            :     T_Query,
<span class="lineNum">     311 </span>            :     T_PlannedStmt,
<span class="lineNum">     312 </span>            :     T_InsertStmt,
<span class="lineNum">     313 </span>            :     T_DeleteStmt,
<span class="lineNum">     314 </span>            :     T_UpdateStmt,
<span class="lineNum">     315 </span>            :     T_SelectStmt,
<span class="lineNum">     316 </span>            :     T_AlterTableStmt,
<span class="lineNum">     317 </span>            :     T_AlterTableCmd,
<span class="lineNum">     318 </span>            :     T_AlterDomainStmt,
<span class="lineNum">     319 </span>            :     T_SetOperationStmt,
<span class="lineNum">     320 </span>            :     T_GrantStmt,
<span class="lineNum">     321 </span>            :     T_GrantRoleStmt,
<span class="lineNum">     322 </span>            :     T_AlterDefaultPrivilegesStmt,
<span class="lineNum">     323 </span>            :     T_ClosePortalStmt,
<span class="lineNum">     324 </span>            :     T_ClusterStmt,
<span class="lineNum">     325 </span>            :     T_CopyStmt,
<span class="lineNum">     326 </span>            :     T_CreateStmt,
<span class="lineNum">     327 </span>            :     T_DefineStmt,
<span class="lineNum">     328 </span>            :     T_DropStmt,
<span class="lineNum">     329 </span>            :     T_TruncateStmt,
<span class="lineNum">     330 </span>            :     T_CommentStmt,
<span class="lineNum">     331 </span>            :     T_FetchStmt,
<span class="lineNum">     332 </span>            :     T_IndexStmt,
<span class="lineNum">     333 </span>            :     T_CreateFunctionStmt,
<span class="lineNum">     334 </span>            :     T_AlterFunctionStmt,
<span class="lineNum">     335 </span>            :     T_DoStmt,
<span class="lineNum">     336 </span>            :     T_RenameStmt,
<span class="lineNum">     337 </span>            :     T_RuleStmt,
<span class="lineNum">     338 </span>            :     T_NotifyStmt,
<span class="lineNum">     339 </span>            :     T_ListenStmt,
<span class="lineNum">     340 </span>            :     T_UnlistenStmt,
<span class="lineNum">     341 </span>            :     T_TransactionStmt,
<span class="lineNum">     342 </span>            :     T_ViewStmt,
<span class="lineNum">     343 </span>            :     T_LoadStmt,
<span class="lineNum">     344 </span>            :     T_CreateDomainStmt,
<span class="lineNum">     345 </span>            :     T_CreatedbStmt,
<span class="lineNum">     346 </span>            :     T_DropdbStmt,
<span class="lineNum">     347 </span>            :     T_VacuumStmt,
<span class="lineNum">     348 </span>            :     T_ExplainStmt,
<span class="lineNum">     349 </span>            :     T_CreateTableAsStmt,
<span class="lineNum">     350 </span>            :     T_CreateSeqStmt,
<span class="lineNum">     351 </span>            :     T_AlterSeqStmt,
<span class="lineNum">     352 </span>            :     T_VariableSetStmt,
<span class="lineNum">     353 </span>            :     T_VariableShowStmt,
<span class="lineNum">     354 </span>            :     T_DiscardStmt,
<span class="lineNum">     355 </span>            :     T_CreateTrigStmt,
<span class="lineNum">     356 </span>            :     T_CreatePLangStmt,
<span class="lineNum">     357 </span>            :     T_CreateRoleStmt,
<span class="lineNum">     358 </span>            :     T_AlterRoleStmt,
<span class="lineNum">     359 </span>            :     T_DropRoleStmt,
<span class="lineNum">     360 </span>            :     T_LockStmt,
<span class="lineNum">     361 </span>            :     T_ConstraintsSetStmt,
<span class="lineNum">     362 </span>            :     T_ReindexStmt,
<span class="lineNum">     363 </span>            :     T_CheckPointStmt,
<span class="lineNum">     364 </span>            :     T_CreateSchemaStmt,
<span class="lineNum">     365 </span>            :     T_AlterDatabaseStmt,
<span class="lineNum">     366 </span>            :     T_AlterDatabaseSetStmt,
<span class="lineNum">     367 </span>            :     T_AlterRoleSetStmt,
<span class="lineNum">     368 </span>            :     T_CreateConversionStmt,
<span class="lineNum">     369 </span>            :     T_CreateCastStmt,
<span class="lineNum">     370 </span>            :     T_CreateOpClassStmt,
<span class="lineNum">     371 </span>            :     T_CreateOpFamilyStmt,
<span class="lineNum">     372 </span>            :     T_AlterOpFamilyStmt,
<span class="lineNum">     373 </span>            :     T_PrepareStmt,
<span class="lineNum">     374 </span>            :     T_ExecuteStmt,
<span class="lineNum">     375 </span>            :     T_DeallocateStmt,
<span class="lineNum">     376 </span>            :     T_DeclareCursorStmt,
<span class="lineNum">     377 </span>            :     T_CreateTableSpaceStmt,
<span class="lineNum">     378 </span>            :     T_DropTableSpaceStmt,
<span class="lineNum">     379 </span>            :     T_AlterObjectDependsStmt,
<span class="lineNum">     380 </span>            :     T_AlterObjectSchemaStmt,
<span class="lineNum">     381 </span>            :     T_AlterOwnerStmt,
<span class="lineNum">     382 </span>            :     T_AlterOperatorStmt,
<span class="lineNum">     383 </span>            :     T_DropOwnedStmt,
<span class="lineNum">     384 </span>            :     T_ReassignOwnedStmt,
<span class="lineNum">     385 </span>            :     T_CompositeTypeStmt,
<span class="lineNum">     386 </span>            :     T_CreateEnumStmt,
<span class="lineNum">     387 </span>            :     T_CreateRangeStmt,
<span class="lineNum">     388 </span>            :     T_AlterEnumStmt,
<span class="lineNum">     389 </span>            :     T_AlterTSDictionaryStmt,
<span class="lineNum">     390 </span>            :     T_AlterTSConfigurationStmt,
<span class="lineNum">     391 </span>            :     T_CreateFdwStmt,
<span class="lineNum">     392 </span>            :     T_AlterFdwStmt,
<span class="lineNum">     393 </span>            :     T_CreateForeignServerStmt,
<span class="lineNum">     394 </span>            :     T_AlterForeignServerStmt,
<span class="lineNum">     395 </span>            :     T_CreateUserMappingStmt,
<span class="lineNum">     396 </span>            :     T_AlterUserMappingStmt,
<span class="lineNum">     397 </span>            :     T_DropUserMappingStmt,
<span class="lineNum">     398 </span>            :     T_AlterTableSpaceOptionsStmt,
<span class="lineNum">     399 </span>            :     T_AlterTableMoveAllStmt,
<span class="lineNum">     400 </span>            :     T_SecLabelStmt,
<span class="lineNum">     401 </span>            :     T_CreateForeignTableStmt,
<span class="lineNum">     402 </span>            :     T_ImportForeignSchemaStmt,
<span class="lineNum">     403 </span>            :     T_CreateExtensionStmt,
<span class="lineNum">     404 </span>            :     T_AlterExtensionStmt,
<span class="lineNum">     405 </span>            :     T_AlterExtensionContentsStmt,
<span class="lineNum">     406 </span>            :     T_CreateEventTrigStmt,
<span class="lineNum">     407 </span>            :     T_AlterEventTrigStmt,
<span class="lineNum">     408 </span>            :     T_RefreshMatViewStmt,
<span class="lineNum">     409 </span>            :     T_ReplicaIdentityStmt,
<span class="lineNum">     410 </span>            :     T_AlterSystemStmt,
<span class="lineNum">     411 </span>            :     T_CreatePolicyStmt,
<span class="lineNum">     412 </span>            :     T_AlterPolicyStmt,
<span class="lineNum">     413 </span>            :     T_CreateTransformStmt,
<span class="lineNum">     414 </span>            :     T_CreateAmStmt,
<span class="lineNum">     415 </span>            :     T_CreatePublicationStmt,
<span class="lineNum">     416 </span>            :     T_AlterPublicationStmt,
<span class="lineNum">     417 </span>            :     T_CreateSubscriptionStmt,
<span class="lineNum">     418 </span>            :     T_AlterSubscriptionStmt,
<span class="lineNum">     419 </span>            :     T_DropSubscriptionStmt,
<span class="lineNum">     420 </span>            :     T_CreateStatsStmt,
<span class="lineNum">     421 </span>            :     T_AlterCollationStmt,
<span class="lineNum">     422 </span>            :     T_CallStmt,
<span class="lineNum">     423 </span>            :     T_AlterStatsStmt,
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :     /*
<span class="lineNum">     426 </span>            :      * TAGS FOR PARSE TREE NODES (parsenodes.h)
<span class="lineNum">     427 </span>            :      */
<span class="lineNum">     428 </span>            :     T_A_Expr,
<span class="lineNum">     429 </span>            :     T_ColumnRef,
<span class="lineNum">     430 </span>            :     T_ParamRef,
<span class="lineNum">     431 </span>            :     T_A_Const,
<span class="lineNum">     432 </span>            :     T_FuncCall,
<span class="lineNum">     433 </span>            :     T_A_Star,
<span class="lineNum">     434 </span>            :     T_A_Indices,
<span class="lineNum">     435 </span>            :     T_A_Indirection,
<span class="lineNum">     436 </span>            :     T_A_ArrayExpr,
<span class="lineNum">     437 </span>            :     T_ResTarget,
<span class="lineNum">     438 </span>            :     T_MultiAssignRef,
<span class="lineNum">     439 </span>            :     T_TypeCast,
<span class="lineNum">     440 </span>            :     T_CollateClause,
<span class="lineNum">     441 </span>            :     T_SortBy,
<span class="lineNum">     442 </span>            :     T_WindowDef,
<span class="lineNum">     443 </span>            :     T_RangeSubselect,
<span class="lineNum">     444 </span>            :     T_RangeFunction,
<span class="lineNum">     445 </span>            :     T_RangeTableSample,
<span class="lineNum">     446 </span>            :     T_RangeTableFunc,
<span class="lineNum">     447 </span>            :     T_RangeTableFuncCol,
<span class="lineNum">     448 </span>            :     T_TypeName,
<span class="lineNum">     449 </span>            :     T_ColumnDef,
<span class="lineNum">     450 </span>            :     T_IndexElem,
<span class="lineNum">     451 </span>            :     T_Constraint,
<span class="lineNum">     452 </span>            :     T_DefElem,
<span class="lineNum">     453 </span>            :     T_RangeTblEntry,
<span class="lineNum">     454 </span>            :     T_RangeTblFunction,
<span class="lineNum">     455 </span>            :     T_TableSampleClause,
<span class="lineNum">     456 </span>            :     T_WithCheckOption,
<span class="lineNum">     457 </span>            :     T_SortGroupClause,
<span class="lineNum">     458 </span>            :     T_GroupingSet,
<span class="lineNum">     459 </span>            :     T_WindowClause,
<span class="lineNum">     460 </span>            :     T_ObjectWithArgs,
<span class="lineNum">     461 </span>            :     T_AccessPriv,
<span class="lineNum">     462 </span>            :     T_CreateOpClassItem,
<span class="lineNum">     463 </span>            :     T_TableLikeClause,
<span class="lineNum">     464 </span>            :     T_FunctionParameter,
<span class="lineNum">     465 </span>            :     T_LockingClause,
<span class="lineNum">     466 </span>            :     T_RowMarkClause,
<span class="lineNum">     467 </span>            :     T_XmlSerialize,
<span class="lineNum">     468 </span>            :     T_WithClause,
<span class="lineNum">     469 </span>            :     T_InferClause,
<span class="lineNum">     470 </span>            :     T_OnConflictClause,
<span class="lineNum">     471 </span>            :     T_CommonTableExpr,
<span class="lineNum">     472 </span>            :     T_RoleSpec,
<span class="lineNum">     473 </span>            :     T_TriggerTransition,
<span class="lineNum">     474 </span>            :     T_PartitionElem,
<span class="lineNum">     475 </span>            :     T_PartitionSpec,
<span class="lineNum">     476 </span>            :     T_PartitionBoundSpec,
<span class="lineNum">     477 </span>            :     T_PartitionRangeDatum,
<span class="lineNum">     478 </span>            :     T_PartitionCmd,
<span class="lineNum">     479 </span>            :     T_VacuumRelation,
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            :     /*
<span class="lineNum">     482 </span>            :      * TAGS FOR REPLICATION GRAMMAR PARSE NODES (replnodes.h)
<span class="lineNum">     483 </span>            :      */
<span class="lineNum">     484 </span>            :     T_IdentifySystemCmd,
<span class="lineNum">     485 </span>            :     T_BaseBackupCmd,
<span class="lineNum">     486 </span>            :     T_CreateReplicationSlotCmd,
<span class="lineNum">     487 </span>            :     T_DropReplicationSlotCmd,
<span class="lineNum">     488 </span>            :     T_StartReplicationCmd,
<span class="lineNum">     489 </span>            :     T_TimeLineHistoryCmd,
<span class="lineNum">     490 </span>            :     T_SQLCmd,
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            :     /*
<span class="lineNum">     493 </span>            :      * TAGS FOR RANDOM OTHER STUFF
<span class="lineNum">     494 </span>            :      *
<span class="lineNum">     495 </span>            :      * These are objects that aren't part of parse/plan/execute node tree
<span class="lineNum">     496 </span>            :      * structures, but we give them NodeTags anyway for identification
<span class="lineNum">     497 </span>            :      * purposes (usually because they are involved in APIs where we want to
<span class="lineNum">     498 </span>            :      * pass multiple object types through the same pointer).
<span class="lineNum">     499 </span>            :      */
<span class="lineNum">     500 </span>            :     T_TriggerData,              /* in commands/trigger.h */
<span class="lineNum">     501 </span>            :     T_EventTriggerData,         /* in commands/event_trigger.h */
<span class="lineNum">     502 </span>            :     T_ReturnSetInfo,            /* in nodes/execnodes.h */
<span class="lineNum">     503 </span>            :     T_WindowObjectData,         /* private in nodeWindowAgg.c */
<span class="lineNum">     504 </span>            :     T_TIDBitmap,                /* in nodes/tidbitmap.h */
<span class="lineNum">     505 </span>            :     T_InlineCodeBlock,          /* in nodes/parsenodes.h */
<span class="lineNum">     506 </span>            :     T_FdwRoutine,               /* in foreign/fdwapi.h */
<span class="lineNum">     507 </span>            :     T_IndexAmRoutine,           /* in access/amapi.h */
<span class="lineNum">     508 </span>            :     T_TableAmRoutine,           /* in access/tableam.h */
<span class="lineNum">     509 </span>            :     T_TsmRoutine,               /* in access/tsmapi.h */
<span class="lineNum">     510 </span>            :     T_ForeignKeyCacheInfo,      /* in utils/rel.h */
<span class="lineNum">     511 </span>            :     T_CallContext,              /* in nodes/parsenodes.h */
<span class="lineNum">     512 </span>            :     T_SupportRequestSimplify,   /* in nodes/supportnodes.h */
<span class="lineNum">     513 </span>            :     T_SupportRequestSelectivity,    /* in nodes/supportnodes.h */
<span class="lineNum">     514 </span>            :     T_SupportRequestCost,       /* in nodes/supportnodes.h */
<span class="lineNum">     515 </span>            :     T_SupportRequestRows,       /* in nodes/supportnodes.h */
<span class="lineNum">     516 </span>            :     T_SupportRequestIndexCondition  /* in nodes/supportnodes.h */
<span class="lineNum">     517 </span>            : } NodeTag;
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            : /*
<span class="lineNum">     520 </span>            :  * The first field of a node of any type is guaranteed to be the NodeTag.
<span class="lineNum">     521 </span>            :  * Hence the type of any node can be gotten by casting it to Node. Declaring
<span class="lineNum">     522 </span>            :  * a variable to be of Node * (instead of void *) can also facilitate
<span class="lineNum">     523 </span>            :  * debugging.
<span class="lineNum">     524 </span>            :  */
<span class="lineNum">     525 </span>            : typedef struct Node
<span class="lineNum">     526 </span>            : {
<span class="lineNum">     527 </span>            :     NodeTag     type;
<span class="lineNum">     528 </span>            : } Node;
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            : #define nodeTag(nodeptr)        (((const Node*)(nodeptr))-&gt;type)
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            : /*
<span class="lineNum">     533 </span>            :  * newNode -
<span class="lineNum">     534 </span>            :  *    create a new node of the specified size and tag the node with the
<span class="lineNum">     535 </span>            :  *    specified tag.
<span class="lineNum">     536 </span>            :  *
<span class="lineNum">     537 </span>            :  * !WARNING!: Avoid using newNode directly. You should be using the
<span class="lineNum">     538 </span>            :  *    macro makeNode.  eg. to create a Query node, use makeNode(Query)
<span class="lineNum">     539 </span>            :  *
<span class="lineNum">     540 </span>            :  * Note: the size argument should always be a compile-time constant, so the
<span class="lineNum">     541 </span>            :  * apparent risk of multiple evaluation doesn't matter in practice.
<span class="lineNum">     542 </span>            :  */
<span class="lineNum">     543 </span>            : #ifdef __GNUC__
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            : /* With GCC, we can use a compound statement within an expression */
<span class="lineNum">     546 </span>            : #define newNode(size, tag) \
<span class="lineNum">     547 </span>            : ({  Node   *_result; \
<span class="lineNum">     548 </span>            :     AssertMacro((size) &gt;= sizeof(Node));     /* need the tag, at least */ \
<span class="lineNum">     549 </span>            :     _result = (Node *) palloc0fast(size); \
<span class="lineNum">     550 </span>            :     _result-&gt;type = (tag); \
<span class="lineNum">     551 </span>            :     _result; \
<span class="lineNum">     552 </span>            : })
<span class="lineNum">     553 </span>            : #else
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span>            : /*
<span class="lineNum">     556 </span>            :  *  There is no way to dereference the palloc'ed pointer to assign the
<span class="lineNum">     557 </span>            :  *  tag, and also return the pointer itself, so we need a holder variable.
<span class="lineNum">     558 </span>            :  *  Fortunately, this macro isn't recursive so we just define
<span class="lineNum">     559 </span>            :  *  a global variable for this purpose.
<span class="lineNum">     560 </span>            :  */
<span class="lineNum">     561 </span>            : extern PGDLLIMPORT Node *newNodeMacroHolder;
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span>            : #define newNode(size, tag) \
<span class="lineNum">     564 </span>            : ( \
<span class="lineNum">     565 </span>            :     AssertMacro((size) &gt;= sizeof(Node)),     /* need the tag, at least */ \
<span class="lineNum">     566 </span>            :     newNodeMacroHolder = (Node *) palloc0fast(size), \
<span class="lineNum">     567 </span>            :     newNodeMacroHolder-&gt;type = (tag), \
<span class="lineNum">     568 </span>            :     newNodeMacroHolder \
<span class="lineNum">     569 </span>            : )
<span class="lineNum">     570 </span>            : #endif                          /* __GNUC__ */
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            : #define makeNode(_type_)        ((_type_ *) newNode(sizeof(_type_),T_##_type_))
<span class="lineNum">     574 </span>            : #define NodeSetTag(nodeptr,t)   (((Node*)(nodeptr))-&gt;type = (t))
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            : #define IsA(nodeptr,_type_)     (nodeTag(nodeptr) == T_##_type_)
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            : /*
<span class="lineNum">     579 </span>            :  * castNode(type, ptr) casts ptr to &quot;type *&quot;, and if assertions are enabled,
<span class="lineNum">     580 </span>            :  * verifies that the node has the appropriate type (using its nodeTag()).
<span class="lineNum">     581 </span>            :  *
<span class="lineNum">     582 </span>            :  * Use an inline function when assertions are enabled, to avoid multiple
<span class="lineNum">     583 </span>            :  * evaluations of the ptr argument (which could e.g. be a function call).
<span class="lineNum">     584 </span>            :  */
<a name="585"><span class="lineNum">     585 </span>            : #ifdef USE_ASSERT_CHECKING</a>
<span class="lineNum">     586 </span>            : static inline Node *
<span class="lineNum">     587 </span><span class="lineCov">   30896048 : castNodeImpl(NodeTag type, void *ptr)</span>
<span class="lineNum">     588 </span>            : {
<span class="lineNum">     589 </span><span class="lineCov">   30896048 :     Assert(ptr == NULL || nodeTag(ptr) == type);</span>
<span class="lineNum">     590 </span><span class="lineCov">   30896048 :     return (Node *) ptr;</span>
<span class="lineNum">     591 </span>            : }
<span class="lineNum">     592 </span>            : #define castNode(_type_, nodeptr) ((_type_ *) castNodeImpl(T_##_type_, nodeptr))
<span class="lineNum">     593 </span>            : #else
<span class="lineNum">     594 </span>            : #define castNode(_type_, nodeptr) ((_type_ *) (nodeptr))
<span class="lineNum">     595 </span>            : #endif                          /* USE_ASSERT_CHECKING */
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            : /* ----------------------------------------------------------------
<span class="lineNum">     599 </span>            :  *                    extern declarations follow
<span class="lineNum">     600 </span>            :  * ----------------------------------------------------------------
<span class="lineNum">     601 </span>            :  */
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            : /*
<span class="lineNum">     604 </span>            :  * nodes/{outfuncs.c,print.c}
<span class="lineNum">     605 </span>            :  */
<span class="lineNum">     606 </span>            : struct Bitmapset;               /* not to include bitmapset.h here */
<span class="lineNum">     607 </span>            : struct StringInfoData;          /* not to include stringinfo.h here */
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            : extern void outNode(struct StringInfoData *str, const void *obj);
<span class="lineNum">     610 </span>            : extern void outToken(struct StringInfoData *str, const char *s);
<span class="lineNum">     611 </span>            : extern void outBitmapset(struct StringInfoData *str,
<span class="lineNum">     612 </span>            :                          const struct Bitmapset *bms);
<span class="lineNum">     613 </span>            : extern void outDatum(struct StringInfoData *str, uintptr_t value,
<span class="lineNum">     614 </span>            :                      int typlen, bool typbyval);
<span class="lineNum">     615 </span>            : extern char *nodeToString(const void *obj);
<span class="lineNum">     616 </span>            : extern char *bmsToString(const struct Bitmapset *bms);
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span>            : /*
<span class="lineNum">     619 </span>            :  * nodes/{readfuncs.c,read.c}
<span class="lineNum">     620 </span>            :  */
<span class="lineNum">     621 </span>            : extern void *stringToNode(const char *str);
<span class="lineNum">     622 </span>            : #ifdef WRITE_READ_PARSE_PLAN_TREES
<span class="lineNum">     623 </span>            : extern void *stringToNodeWithLocations(const char *str);
<span class="lineNum">     624 </span>            : #endif
<span class="lineNum">     625 </span>            : extern struct Bitmapset *readBitmapset(void);
<span class="lineNum">     626 </span>            : extern uintptr_t readDatum(bool typbyval);
<span class="lineNum">     627 </span>            : extern bool *readBoolCols(int numCols);
<span class="lineNum">     628 </span>            : extern int *readIntCols(int numCols);
<span class="lineNum">     629 </span>            : extern Oid *readOidCols(int numCols);
<span class="lineNum">     630 </span>            : extern int16 *readAttrNumberCols(int numCols);
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            : /*
<span class="lineNum">     633 </span>            :  * nodes/copyfuncs.c
<span class="lineNum">     634 </span>            :  */
<span class="lineNum">     635 </span>            : extern void *copyObjectImpl(const void *obj);
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            : /* cast result back to argument type, if supported by compiler */
<span class="lineNum">     638 </span>            : #ifdef HAVE_TYPEOF
<span class="lineNum">     639 </span>            : #define copyObject(obj) ((typeof(obj)) copyObjectImpl(obj))
<span class="lineNum">     640 </span>            : #else
<span class="lineNum">     641 </span>            : #define copyObject(obj) copyObjectImpl(obj)
<span class="lineNum">     642 </span>            : #endif
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            : /*
<span class="lineNum">     645 </span>            :  * nodes/equalfuncs.c
<span class="lineNum">     646 </span>            :  */
<span class="lineNum">     647 </span>            : extern bool equal(const void *a, const void *b);
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            : /*
<span class="lineNum">     651 </span>            :  * Typedefs for identifying qualifier selectivities and plan costs as such.
<span class="lineNum">     652 </span>            :  * These are just plain &quot;double&quot;s, but declaring a variable as Selectivity
<span class="lineNum">     653 </span>            :  * or Cost makes the intent more obvious.
<span class="lineNum">     654 </span>            :  *
<span class="lineNum">     655 </span>            :  * These could have gone into plannodes.h or some such, but many files
<span class="lineNum">     656 </span>            :  * depend on them...
<span class="lineNum">     657 </span>            :  */
<span class="lineNum">     658 </span>            : typedef double Selectivity;     /* fraction of tuples a qualifier will pass */
<span class="lineNum">     659 </span>            : typedef double Cost;            /* execution cost (in page-access units) */
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            : /*
<span class="lineNum">     663 </span>            :  * CmdType -
<span class="lineNum">     664 </span>            :  *    enums for type of operation represented by a Query or PlannedStmt
<span class="lineNum">     665 </span>            :  *
<span class="lineNum">     666 </span>            :  * This is needed in both parsenodes.h and plannodes.h, so put it here...
<span class="lineNum">     667 </span>            :  */
<span class="lineNum">     668 </span>            : typedef enum CmdType
<span class="lineNum">     669 </span>            : {
<span class="lineNum">     670 </span>            :     CMD_UNKNOWN,
<span class="lineNum">     671 </span>            :     CMD_SELECT,                 /* select stmt */
<span class="lineNum">     672 </span>            :     CMD_UPDATE,                 /* update stmt */
<span class="lineNum">     673 </span>            :     CMD_INSERT,                 /* insert stmt */
<span class="lineNum">     674 </span>            :     CMD_DELETE,
<span class="lineNum">     675 </span>            :     CMD_UTILITY,                /* cmds like create, destroy, copy, vacuum,
<span class="lineNum">     676 </span>            :                                  * etc. */
<span class="lineNum">     677 </span>            :     CMD_NOTHING                 /* dummy command for instead nothing rules
<span class="lineNum">     678 </span>            :                                  * with qual */
<span class="lineNum">     679 </span>            : } CmdType;
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span>            : /*
<span class="lineNum">     683 </span>            :  * JoinType -
<span class="lineNum">     684 </span>            :  *    enums for types of relation joins
<span class="lineNum">     685 </span>            :  *
<span class="lineNum">     686 </span>            :  * JoinType determines the exact semantics of joining two relations using
<span class="lineNum">     687 </span>            :  * a matching qualification.  For example, it tells what to do with a tuple
<span class="lineNum">     688 </span>            :  * that has no match in the other relation.
<span class="lineNum">     689 </span>            :  *
<span class="lineNum">     690 </span>            :  * This is needed in both parsenodes.h and plannodes.h, so put it here...
<span class="lineNum">     691 </span>            :  */
<span class="lineNum">     692 </span>            : typedef enum JoinType
<span class="lineNum">     693 </span>            : {
<span class="lineNum">     694 </span>            :     /*
<span class="lineNum">     695 </span>            :      * The canonical kinds of joins according to the SQL JOIN syntax. Only
<span class="lineNum">     696 </span>            :      * these codes can appear in parser output (e.g., JoinExpr nodes).
<span class="lineNum">     697 </span>            :      */
<span class="lineNum">     698 </span>            :     JOIN_INNER,                 /* matching tuple pairs only */
<span class="lineNum">     699 </span>            :     JOIN_LEFT,                  /* pairs + unmatched LHS tuples */
<span class="lineNum">     700 </span>            :     JOIN_FULL,                  /* pairs + unmatched LHS + unmatched RHS */
<span class="lineNum">     701 </span>            :     JOIN_RIGHT,                 /* pairs + unmatched RHS tuples */
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            :     /*
<span class="lineNum">     704 </span>            :      * Semijoins and anti-semijoins (as defined in relational theory) do not
<span class="lineNum">     705 </span>            :      * appear in the SQL JOIN syntax, but there are standard idioms for
<span class="lineNum">     706 </span>            :      * representing them (e.g., using EXISTS).  The planner recognizes these
<span class="lineNum">     707 </span>            :      * cases and converts them to joins.  So the planner and executor must
<span class="lineNum">     708 </span>            :      * support these codes.  NOTE: in JOIN_SEMI output, it is unspecified
<span class="lineNum">     709 </span>            :      * which matching RHS row is joined to.  In JOIN_ANTI output, the row is
<span class="lineNum">     710 </span>            :      * guaranteed to be null-extended.
<span class="lineNum">     711 </span>            :      */
<span class="lineNum">     712 </span>            :     JOIN_SEMI,                  /* 1 copy of each LHS row that has match(es) */
<span class="lineNum">     713 </span>            :     JOIN_ANTI,                  /* 1 copy of each LHS row that has no match */
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            :     /*
<span class="lineNum">     716 </span>            :      * These codes are used internally in the planner, but are not supported
<span class="lineNum">     717 </span>            :      * by the executor (nor, indeed, by most of the planner).
<span class="lineNum">     718 </span>            :      */
<span class="lineNum">     719 </span>            :     JOIN_UNIQUE_OUTER,          /* LHS path must be made unique */
<span class="lineNum">     720 </span>            :     JOIN_UNIQUE_INNER           /* RHS path must be made unique */
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :     /*
<span class="lineNum">     723 </span>            :      * We might need additional join types someday.
<span class="lineNum">     724 </span>            :      */
<span class="lineNum">     725 </span>            : } JoinType;
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            : /*
<span class="lineNum">     728 </span>            :  * OUTER joins are those for which pushed-down quals must behave differently
<span class="lineNum">     729 </span>            :  * from the join's own quals.  This is in fact everything except INNER and
<span class="lineNum">     730 </span>            :  * SEMI joins.  However, this macro must also exclude the JOIN_UNIQUE symbols
<span class="lineNum">     731 </span>            :  * since those are temporary proxies for what will eventually be an INNER
<span class="lineNum">     732 </span>            :  * join.
<span class="lineNum">     733 </span>            :  *
<span class="lineNum">     734 </span>            :  * Note: semijoins are a hybrid case, but we choose to treat them as not
<span class="lineNum">     735 </span>            :  * being outer joins.  This is okay principally because the SQL syntax makes
<span class="lineNum">     736 </span>            :  * it impossible to have a pushed-down qual that refers to the inner relation
<span class="lineNum">     737 </span>            :  * of a semijoin; so there is no strong need to distinguish join quals from
<span class="lineNum">     738 </span>            :  * pushed-down quals.  This is convenient because for almost all purposes,
<span class="lineNum">     739 </span>            :  * quals attached to a semijoin can be treated the same as innerjoin quals.
<span class="lineNum">     740 </span>            :  */
<span class="lineNum">     741 </span>            : #define IS_OUTER_JOIN(jointype) \
<span class="lineNum">     742 </span>            :     (((1 &lt;&lt; (jointype)) &amp; \
<span class="lineNum">     743 </span>            :       ((1 &lt;&lt; JOIN_LEFT) | \
<span class="lineNum">     744 </span>            :        (1 &lt;&lt; JOIN_FULL) | \
<span class="lineNum">     745 </span>            :        (1 &lt;&lt; JOIN_RIGHT) | \
<span class="lineNum">     746 </span>            :        (1 &lt;&lt; JOIN_ANTI))) != 0)
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            : /*
<span class="lineNum">     749 </span>            :  * AggStrategy -
<span class="lineNum">     750 </span>            :  *    overall execution strategies for Agg plan nodes
<span class="lineNum">     751 </span>            :  *
<span class="lineNum">     752 </span>            :  * This is needed in both pathnodes.h and plannodes.h, so put it here...
<span class="lineNum">     753 </span>            :  */
<span class="lineNum">     754 </span>            : typedef enum AggStrategy
<span class="lineNum">     755 </span>            : {
<span class="lineNum">     756 </span>            :     AGG_PLAIN,                  /* simple agg across all input rows */
<span class="lineNum">     757 </span>            :     AGG_SORTED,                 /* grouped agg, input must be sorted */
<span class="lineNum">     758 </span>            :     AGG_HASHED,                 /* grouped agg, use internal hashtable */
<span class="lineNum">     759 </span>            :     AGG_MIXED                   /* grouped agg, hash and sort both used */
<span class="lineNum">     760 </span>            : } AggStrategy;
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span>            : /*
<span class="lineNum">     763 </span>            :  * AggSplit -
<span class="lineNum">     764 </span>            :  *    splitting (partial aggregation) modes for Agg plan nodes
<span class="lineNum">     765 </span>            :  *
<span class="lineNum">     766 </span>            :  * This is needed in both pathnodes.h and plannodes.h, so put it here...
<span class="lineNum">     767 </span>            :  */
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            : /* Primitive options supported by nodeAgg.c: */
<span class="lineNum">     770 </span>            : #define AGGSPLITOP_COMBINE      0x01    /* substitute combinefn for transfn */
<span class="lineNum">     771 </span>            : #define AGGSPLITOP_SKIPFINAL    0x02    /* skip finalfn, return state as-is */
<span class="lineNum">     772 </span>            : #define AGGSPLITOP_SERIALIZE    0x04    /* apply serialfn to output */
<span class="lineNum">     773 </span>            : #define AGGSPLITOP_DESERIALIZE  0x08    /* apply deserialfn to input */
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            : /* Supported operating modes (i.e., useful combinations of these options): */
<span class="lineNum">     776 </span>            : typedef enum AggSplit
<span class="lineNum">     777 </span>            : {
<span class="lineNum">     778 </span>            :     /* Basic, non-split aggregation: */
<span class="lineNum">     779 </span>            :     AGGSPLIT_SIMPLE = 0,
<span class="lineNum">     780 </span>            :     /* Initial phase of partial aggregation, with serialization: */
<span class="lineNum">     781 </span>            :     AGGSPLIT_INITIAL_SERIAL = AGGSPLITOP_SKIPFINAL | AGGSPLITOP_SERIALIZE,
<span class="lineNum">     782 </span>            :     /* Final phase of partial aggregation, with deserialization: */
<span class="lineNum">     783 </span>            :     AGGSPLIT_FINAL_DESERIAL = AGGSPLITOP_COMBINE | AGGSPLITOP_DESERIALIZE
<span class="lineNum">     784 </span>            : } AggSplit;
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            : /* Test whether an AggSplit value selects each primitive option: */
<span class="lineNum">     787 </span>            : #define DO_AGGSPLIT_COMBINE(as)     (((as) &amp; AGGSPLITOP_COMBINE) != 0)
<span class="lineNum">     788 </span>            : #define DO_AGGSPLIT_SKIPFINAL(as)   (((as) &amp; AGGSPLITOP_SKIPFINAL) != 0)
<span class="lineNum">     789 </span>            : #define DO_AGGSPLIT_SERIALIZE(as)   (((as) &amp; AGGSPLITOP_SERIALIZE) != 0)
<span class="lineNum">     790 </span>            : #define DO_AGGSPLIT_DESERIALIZE(as) (((as) &amp; AGGSPLITOP_DESERIALIZE) != 0)
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            : /*
<span class="lineNum">     793 </span>            :  * SetOpCmd and SetOpStrategy -
<span class="lineNum">     794 </span>            :  *    overall semantics and execution strategies for SetOp plan nodes
<span class="lineNum">     795 </span>            :  *
<span class="lineNum">     796 </span>            :  * This is needed in both pathnodes.h and plannodes.h, so put it here...
<span class="lineNum">     797 </span>            :  */
<span class="lineNum">     798 </span>            : typedef enum SetOpCmd
<span class="lineNum">     799 </span>            : {
<span class="lineNum">     800 </span>            :     SETOPCMD_INTERSECT,
<span class="lineNum">     801 </span>            :     SETOPCMD_INTERSECT_ALL,
<span class="lineNum">     802 </span>            :     SETOPCMD_EXCEPT,
<span class="lineNum">     803 </span>            :     SETOPCMD_EXCEPT_ALL
<span class="lineNum">     804 </span>            : } SetOpCmd;
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span>            : typedef enum SetOpStrategy
<span class="lineNum">     807 </span>            : {
<span class="lineNum">     808 </span>            :     SETOP_SORTED,               /* input must be sorted */
<span class="lineNum">     809 </span>            :     SETOP_HASHED                /* use internal hashtable */
<span class="lineNum">     810 </span>            : } SetOpStrategy;
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            : /*
<span class="lineNum">     813 </span>            :  * OnConflictAction -
<span class="lineNum">     814 </span>            :  *    &quot;ON CONFLICT&quot; clause type of query
<span class="lineNum">     815 </span>            :  *
<span class="lineNum">     816 </span>            :  * This is needed in both parsenodes.h and plannodes.h, so put it here...
<span class="lineNum">     817 </span>            :  */
<span class="lineNum">     818 </span>            : typedef enum OnConflictAction
<span class="lineNum">     819 </span>            : {
<span class="lineNum">     820 </span>            :     ONCONFLICT_NONE,            /* No &quot;ON CONFLICT&quot; clause */
<span class="lineNum">     821 </span>            :     ONCONFLICT_NOTHING,         /* ON CONFLICT ... DO NOTHING */
<span class="lineNum">     822 </span>            :     ONCONFLICT_UPDATE           /* ON CONFLICT ... DO UPDATE */
<span class="lineNum">     823 </span>            : } OnConflictAction;
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            : #endif                          /* NODES_H */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
