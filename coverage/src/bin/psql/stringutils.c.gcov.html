<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/bin/psql/stringutils.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/bin/psql</a> - stringutils.c<span style="font-size: 80%;"> (source / <a href="stringutils.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">57</td>
            <td class="headerCovTableEntry">111</td>
            <td class="headerCovTableEntryLo">51.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntryLo">33.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * psql - the PostgreSQL interactive terminal
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Copyright (c) 2000-2019, PostgreSQL Global Development Group
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * src/bin/psql/stringutils.c
<span class="lineNum">       7 </span>            :  */
<span class="lineNum">       8 </span>            : #include &quot;postgres_fe.h&quot;
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &lt;ctype.h&gt;
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : #include &quot;common.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;stringutils.h&quot;
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : /*
<span class="lineNum">      17 </span>            :  * Replacement for strtok() (a.k.a. poor man's flex)
<span class="lineNum">      18 </span>            :  *
<span class="lineNum">      19 </span>            :  * Splits a string into tokens, returning one token per call, then NULL
<span class="lineNum">      20 </span>            :  * when no more tokens exist in the given string.
<span class="lineNum">      21 </span>            :  *
<span class="lineNum">      22 </span>            :  * The calling convention is similar to that of strtok, but with more
<span class="lineNum">      23 </span>            :  * frammishes.
<span class="lineNum">      24 </span>            :  *
<span class="lineNum">      25 </span>            :  * s -          string to parse, if NULL continue parsing the last string
<span class="lineNum">      26 </span>            :  * whitespace - set of whitespace characters that separate tokens
<span class="lineNum">      27 </span>            :  * delim -      set of non-whitespace separator characters (or NULL)
<span class="lineNum">      28 </span>            :  * quote -      set of characters that can quote a token (NULL if none)
<span class="lineNum">      29 </span>            :  * escape -     character that can quote quotes (0 if none)
<span class="lineNum">      30 </span>            :  * e_strings -  if true, treat E'...' syntax as a valid token
<span class="lineNum">      31 </span>            :  * del_quotes - if true, strip quotes from the returned token, else return
<span class="lineNum">      32 </span>            :  *              it exactly as found in the string
<span class="lineNum">      33 </span>            :  * encoding -   the active character-set encoding
<span class="lineNum">      34 </span>            :  *
<span class="lineNum">      35 </span>            :  * Characters in 'delim', if any, will be returned as single-character
<span class="lineNum">      36 </span>            :  * tokens unless part of a quoted token.
<span class="lineNum">      37 </span>            :  *
<span class="lineNum">      38 </span>            :  * Double occurrences of the quoting character are always taken to represent
<span class="lineNum">      39 </span>            :  * a single quote character in the data.  If escape isn't 0, then escape
<span class="lineNum">      40 </span>            :  * followed by anything (except \0) is a data character too.
<span class="lineNum">      41 </span>            :  *
<span class="lineNum">      42 </span>            :  * The combination of e_strings and del_quotes both true is not currently
<span class="lineNum">      43 </span>            :  * handled.  This could be fixed but it's not needed anywhere at the moment.
<span class="lineNum">      44 </span>            :  *
<span class="lineNum">      45 </span>            :  * Note that the string s is _not_ overwritten in this implementation.
<span class="lineNum">      46 </span>            :  *
<span class="lineNum">      47 </span>            :  * NB: it's okay to vary delim, quote, and escape from one call to the
<span class="lineNum">      48 </span>            :  * next on a single source string, but changing whitespace is a bad idea
<span class="lineNum">      49 </span>            :  * since you might lose data.
<a name="50"><span class="lineNum">      50 </span>            :  */</a>
<span class="lineNum">      51 </span>            : char *
<span class="lineNum">      52 </span><span class="lineCov">        202 : strtokx(const char *s,</span>
<span class="lineNum">      53 </span>            :         const char *whitespace,
<span class="lineNum">      54 </span>            :         const char *delim,
<span class="lineNum">      55 </span>            :         const char *quote,
<span class="lineNum">      56 </span>            :         char escape,
<span class="lineNum">      57 </span>            :         bool e_strings,
<span class="lineNum">      58 </span>            :         bool del_quotes,
<span class="lineNum">      59 </span>            :         int encoding)
<span class="lineNum">      60 </span>            : {
<span class="lineNum">      61 </span>            :     static char *storage = NULL;    /* store the local copy of the users
<span class="lineNum">      62 </span>            :                                      * string here */
<span class="lineNum">      63 </span>            :     static char *string = NULL; /* pointer into storage where to continue on
<span class="lineNum">      64 </span>            :                                  * next call */
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            :     /* variously abused variables: */
<span class="lineNum">      67 </span>            :     unsigned int offset;
<span class="lineNum">      68 </span>            :     char       *start;
<span class="lineNum">      69 </span>            :     char       *p;
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span><span class="lineCov">        202 :     if (s)</span>
<span class="lineNum">      72 </span>            :     {
<span class="lineNum">      73 </span><span class="lineCov">         22 :         free(storage);</span>
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            :         /*
<span class="lineNum">      76 </span>            :          * We may need extra space to insert delimiter nulls for adjacent
<span class="lineNum">      77 </span>            :          * tokens.  2X the space is a gross overestimate, but it's unlikely
<span class="lineNum">      78 </span>            :          * that this code will be used on huge strings anyway.
<span class="lineNum">      79 </span>            :          */
<span class="lineNum">      80 </span><span class="lineCov">         22 :         storage = pg_malloc(2 * strlen(s) + 1);</span>
<span class="lineNum">      81 </span><span class="lineCov">         22 :         strcpy(storage, s);</span>
<span class="lineNum">      82 </span><span class="lineCov">         22 :         string = storage;</span>
<span class="lineNum">      83 </span>            :     }
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span><span class="lineCov">        202 :     if (!storage)</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :     /* skip leading whitespace */
<span class="lineNum">      89 </span><span class="lineCov">        202 :     offset = strspn(string, whitespace);</span>
<span class="lineNum">      90 </span><span class="lineCov">        202 :     start = &amp;string[offset];</span>
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :     /* end of string reached? */
<span class="lineNum">      93 </span><span class="lineCov">        202 :     if (*start == '\0')</span>
<span class="lineNum">      94 </span>            :     {
<span class="lineNum">      95 </span>            :         /* technically we don't need to free here, but we're nice */
<span class="lineNum">      96 </span><span class="lineCov">          8 :         free(storage);</span>
<span class="lineNum">      97 </span><span class="lineCov">          8 :         storage = NULL;</span>
<span class="lineNum">      98 </span><span class="lineCov">          8 :         string = NULL;</span>
<span class="lineNum">      99 </span><span class="lineCov">          8 :         return NULL;</span>
<span class="lineNum">     100 </span>            :     }
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :     /* test if delimiter character */
<span class="lineNum">     103 </span><span class="lineCov">        194 :     if (delim &amp;&amp; strchr(delim, *start))</span>
<span class="lineNum">     104 </span>            :     {
<span class="lineNum">     105 </span>            :         /*
<span class="lineNum">     106 </span>            :          * If not at end of string, we need to insert a null to terminate the
<span class="lineNum">     107 </span>            :          * returned token.  We can just overwrite the next character if it
<span class="lineNum">     108 </span>            :          * happens to be in the whitespace set ... otherwise move over the
<span class="lineNum">     109 </span>            :          * rest of the string to make room.  (This is why we allocated extra
<span class="lineNum">     110 </span>            :          * space above).
<span class="lineNum">     111 </span>            :          */
<span class="lineNum">     112 </span><span class="lineCov">         28 :         p = start + 1;</span>
<span class="lineNum">     113 </span><span class="lineCov">         28 :         if (*p != '\0')</span>
<span class="lineNum">     114 </span>            :         {
<span class="lineNum">     115 </span><span class="lineCov">         28 :             if (!strchr(whitespace, *p))</span>
<span class="lineNum">     116 </span><span class="lineCov">         16 :                 memmove(p + 1, p, strlen(p) + 1);</span>
<span class="lineNum">     117 </span><span class="lineCov">         28 :             *p = '\0';</span>
<span class="lineNum">     118 </span><span class="lineCov">         28 :             string = p + 1;</span>
<span class="lineNum">     119 </span>            :         }
<span class="lineNum">     120 </span>            :         else
<span class="lineNum">     121 </span>            :         {
<span class="lineNum">     122 </span>            :             /* at end of string, so no extra work */
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :             string = p;</span>
<span class="lineNum">     124 </span>            :         }
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span><span class="lineCov">         28 :         return start;</span>
<span class="lineNum">     127 </span>            :     }
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            :     /* check for E string */
<span class="lineNum">     130 </span><span class="lineCov">        166 :     p = start;</span>
<span class="lineNum">     131 </span><span class="lineCov">        260 :     if (e_strings &amp;&amp;</span>
<span class="lineNum">     132 </span><span class="lineCov">        188 :         (*p == 'E' || *p == 'e') &amp;&amp;</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :         p[1] == '\'')</span>
<span class="lineNum">     134 </span>            :     {
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :         quote = &quot;'&quot;;</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :         escape = '\\';          /* if std strings before, not any more */</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :         p++;</span>
<span class="lineNum">     138 </span>            :     }
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :     /* test if quoting character */
<span class="lineNum">     141 </span><span class="lineCov">        166 :     if (quote &amp;&amp; strchr(quote, *p))</span>
<span class="lineNum">     142 </span>            :     {
<span class="lineNum">     143 </span>            :         /* okay, we have a quoted token, now scan for the closer */
<span class="lineNum">     144 </span><span class="lineCov">         18 :         char        thisquote = *p++;</span>
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span><span class="lineCov">         54 :         for (; *p; p += PQmblen(p, encoding))</span>
<span class="lineNum">     147 </span>            :         {
<span class="lineNum">     148 </span><span class="lineCov">         54 :             if (*p == escape &amp;&amp; p[1] != '\0')</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :                 p++;            /* process escaped anything */</span>
<span class="lineNum">     150 </span><span class="lineCov">         54 :             else if (*p == thisquote &amp;&amp; p[1] == thisquote)</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :                 p++;            /* process doubled quote */</span>
<span class="lineNum">     152 </span><span class="lineCov">         54 :             else if (*p == thisquote)</span>
<span class="lineNum">     153 </span>            :             {
<span class="lineNum">     154 </span><span class="lineCov">         18 :                 p++;            /* skip trailing quote */</span>
<span class="lineNum">     155 </span><span class="lineCov">         18 :                 break;</span>
<span class="lineNum">     156 </span>            :             }
<span class="lineNum">     157 </span>            :         }
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            :         /*
<span class="lineNum">     160 </span>            :          * If not at end of string, we need to insert a null to terminate the
<span class="lineNum">     161 </span>            :          * returned token.  See notes above.
<span class="lineNum">     162 </span>            :          */
<span class="lineNum">     163 </span><span class="lineCov">         18 :         if (*p != '\0')</span>
<span class="lineNum">     164 </span>            :         {
<span class="lineNum">     165 </span><span class="lineCov">         18 :             if (!strchr(whitespace, *p))</span>
<span class="lineNum">     166 </span><span class="lineCov">         10 :                 memmove(p + 1, p, strlen(p) + 1);</span>
<span class="lineNum">     167 </span><span class="lineCov">         18 :             *p = '\0';</span>
<span class="lineNum">     168 </span><span class="lineCov">         18 :             string = p + 1;</span>
<span class="lineNum">     169 </span>            :         }
<span class="lineNum">     170 </span>            :         else
<span class="lineNum">     171 </span>            :         {
<span class="lineNum">     172 </span>            :             /* at end of string, so no extra work */
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :             string = p;</span>
<span class="lineNum">     174 </span>            :         }
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :         /* Clean up the token if caller wants that */
<span class="lineNum">     177 </span><span class="lineCov">         18 :         if (del_quotes)</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :             strip_quotes(start, thisquote, escape, encoding);</span>
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span><span class="lineCov">         18 :         return start;</span>
<span class="lineNum">     181 </span>            :     }
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            :     /*
<span class="lineNum">     184 </span>            :      * Otherwise no quoting character.  Scan till next whitespace, delimiter
<span class="lineNum">     185 </span>            :      * or quote.  NB: at this point, *start is known not to be '\0',
<span class="lineNum">     186 </span>            :      * whitespace, delim, or quote, so we will consume at least one character.
<span class="lineNum">     187 </span>            :      */
<span class="lineNum">     188 </span><span class="lineCov">        148 :     offset = strcspn(start, whitespace);</span>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineCov">        148 :     if (delim)</span>
<span class="lineNum">     191 </span>            :     {
<span class="lineNum">     192 </span><span class="lineCov">        134 :         unsigned int offset2 = strcspn(start, delim);</span>
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span><span class="lineCov">        134 :         if (offset &gt; offset2)</span>
<span class="lineNum">     195 </span><span class="lineCov">         24 :             offset = offset2;</span>
<span class="lineNum">     196 </span>            :     }
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span><span class="lineCov">        148 :     if (quote)</span>
<span class="lineNum">     199 </span>            :     {
<span class="lineNum">     200 </span><span class="lineCov">        134 :         unsigned int offset2 = strcspn(start, quote);</span>
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span><span class="lineCov">        134 :         if (offset &gt; offset2)</span>
<span class="lineNum">     203 </span><span class="lineCov">          8 :             offset = offset2;</span>
<span class="lineNum">     204 </span>            :     }
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineCov">        148 :     p = start + offset;</span>
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            :     /*
<span class="lineNum">     209 </span>            :      * If not at end of string, we need to insert a null to terminate the
<span class="lineNum">     210 </span>            :      * returned token.  See notes above.
<span class="lineNum">     211 </span>            :      */
<span class="lineNum">     212 </span><span class="lineCov">        148 :     if (*p != '\0')</span>
<span class="lineNum">     213 </span>            :     {
<span class="lineNum">     214 </span><span class="lineCov">        126 :         if (!strchr(whitespace, *p))</span>
<span class="lineNum">     215 </span><span class="lineCov">         28 :             memmove(p + 1, p, strlen(p) + 1);</span>
<span class="lineNum">     216 </span><span class="lineCov">        126 :         *p = '\0';</span>
<span class="lineNum">     217 </span><span class="lineCov">        126 :         string = p + 1;</span>
<span class="lineNum">     218 </span>            :     }
<span class="lineNum">     219 </span>            :     else
<span class="lineNum">     220 </span>            :     {
<span class="lineNum">     221 </span>            :         /* at end of string, so no extra work */
<span class="lineNum">     222 </span><span class="lineCov">         22 :         string = p;</span>
<span class="lineNum">     223 </span>            :     }
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span><span class="lineCov">        148 :     return start;</span>
<span class="lineNum">     226 </span>            : }
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            : /*
<span class="lineNum">     230 </span>            :  * strip_quotes
<span class="lineNum">     231 </span>            :  *
<span class="lineNum">     232 </span>            :  * Remove quotes from the string at *source.  Leading and trailing occurrences
<span class="lineNum">     233 </span>            :  * of 'quote' are removed; embedded double occurrences of 'quote' are reduced
<span class="lineNum">     234 </span>            :  * to single occurrences; if 'escape' is not 0 then 'escape' removes special
<span class="lineNum">     235 </span>            :  * significance of next character.
<span class="lineNum">     236 </span>            :  *
<span class="lineNum">     237 </span>            :  * Note that the source string is overwritten in-place.
<a name="238"><span class="lineNum">     238 </span>            :  */</a>
<span class="lineNum">     239 </span>            : void
<span class="lineNum">     240 </span><span class="lineNoCov">          0 : strip_quotes(char *source, char quote, char escape, int encoding)</span>
<span class="lineNum">     241 </span>            : {
<span class="lineNum">     242 </span>            :     char       *src;
<span class="lineNum">     243 </span>            :     char       *dst;
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     Assert(source != NULL);</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     Assert(quote != '\0');</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     src = dst = source;</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     if (*src &amp;&amp; *src == quote)</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         src++;                  /* skip leading quote */</span>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     while (*src)</span>
<span class="lineNum">     254 </span>            :     {
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :         char        c = *src;</span>
<span class="lineNum">     256 </span>            :         int         i;
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :         if (c == quote &amp;&amp; src[1] == '\0')</span>
<span class="lineNum">     259 </span>            :             break;              /* skip trailing quote */
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :         else if (c == quote &amp;&amp; src[1] == quote)</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :             src++;              /* process doubled quote */</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :         else if (c == escape &amp;&amp; src[1] != '\0')</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :             src++;              /* process escaped character */</span>
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         i = PQmblen(src, encoding);</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :         while (i--)</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :             *dst++ = *src++;</span>
<span class="lineNum">     268 </span>            :     }
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :     *dst = '\0';</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            : /*
<span class="lineNum">     275 </span>            :  * quote_if_needed
<span class="lineNum">     276 </span>            :  *
<span class="lineNum">     277 </span>            :  * Opposite of strip_quotes().  If &quot;source&quot; denotes itself literally without
<span class="lineNum">     278 </span>            :  * quoting or escaping, returns NULL.  Otherwise, returns a malloc'd copy with
<span class="lineNum">     279 </span>            :  * quoting and escaping applied:
<span class="lineNum">     280 </span>            :  *
<span class="lineNum">     281 </span>            :  * source -         string to parse
<span class="lineNum">     282 </span>            :  * entails_quote -  any of these present?  need outer quotes
<span class="lineNum">     283 </span>            :  * quote -          doubled within string, affixed to both ends
<span class="lineNum">     284 </span>            :  * escape -         doubled within string
<span class="lineNum">     285 </span>            :  * encoding -       the active character-set encoding
<span class="lineNum">     286 </span>            :  *
<span class="lineNum">     287 </span>            :  * Do not use this as a substitute for PQescapeStringConn().  Use it for
<span class="lineNum">     288 </span>            :  * strings to be parsed by strtokx() or psql_scan_slash_option().
<a name="289"><span class="lineNum">     289 </span>            :  */</a>
<span class="lineNum">     290 </span>            : char *
<span class="lineNum">     291 </span><span class="lineNoCov">          0 : quote_if_needed(const char *source, const char *entails_quote,</span>
<span class="lineNum">     292 </span>            :                 char quote, char escape, int encoding)
<span class="lineNum">     293 </span>            : {
<span class="lineNum">     294 </span>            :     const char *src;
<span class="lineNum">     295 </span>            :     char       *ret;
<span class="lineNum">     296 </span>            :     char       *dst;
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     bool        need_quotes = false;</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     Assert(source != NULL);</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     Assert(quote != '\0');</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     src = source;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     dst = ret = pg_malloc(2 * strlen(src) + 3); /* excess */</span>
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     *dst++ = quote;</span>
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     while (*src)</span>
<span class="lineNum">     308 </span>            :     {
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         char        c = *src;</span>
<span class="lineNum">     310 </span>            :         int         i;
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :         if (c == quote)</span>
<span class="lineNum">     313 </span>            :         {
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :             need_quotes = true;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :             *dst++ = quote;</span>
<span class="lineNum">     316 </span>            :         }
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :         else if (c == escape)</span>
<span class="lineNum">     318 </span>            :         {
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :             need_quotes = true;</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :             *dst++ = escape;</span>
<span class="lineNum">     321 </span>            :         }
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         else if (strchr(entails_quote, c))</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :             need_quotes = true;</span>
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         i = PQmblen(src, encoding);</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :         while (i--)</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :             *dst++ = *src++;</span>
<span class="lineNum">     328 </span>            :     }
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     *dst++ = quote;</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     *dst = '\0';</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     if (!need_quotes)</span>
<span class="lineNum">     334 </span>            :     {
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :         free(ret);</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :         ret = NULL;</span>
<span class="lineNum">     337 </span>            :     }
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     return ret;</span>
<span class="lineNum">     340 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
