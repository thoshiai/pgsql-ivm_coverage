<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/interfaces/ecpg/pgtypeslib/datetime.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/interfaces/ecpg/pgtypeslib</a> - datetime.c<span style="font-size: 80%;"> (source / <a href="datetime.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">269</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* src/interfaces/ecpg/pgtypeslib/datetime.c */</a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            : #include &quot;postgres_fe.h&quot;
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : #include &lt;time.h&gt;
<span class="lineNum">       6 </span>            : #include &lt;ctype.h&gt;
<span class="lineNum">       7 </span>            : #include &lt;limits.h&gt;
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;dt.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;pgtypes_date.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;pgtypes_error.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;pgtypeslib_extern.h&quot;
<a name="13"><span class="lineNum">      13 </span>            : </a>
<span class="lineNum">      14 </span>            : date *
<span class="lineNum">      15 </span><span class="lineNoCov">          0 : PGTYPESdate_new(void)</span>
<span class="lineNum">      16 </span>            : {
<span class="lineNum">      17 </span>            :     date       *result;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span><span class="lineNoCov">          0 :     result = (date *) pgtypes_alloc(sizeof(date));</span>
<span class="lineNum">      20 </span>            :     /* result can be NULL if we run out of memory */
<span class="lineNum">      21 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">      22 </span>            : }
<a name="23"><span class="lineNum">      23 </span>            : </a>
<span class="lineNum">      24 </span>            : void
<span class="lineNum">      25 </span><span class="lineNoCov">          0 : PGTYPESdate_free(date * d)</span>
<span class="lineNum">      26 </span>            : {
<span class="lineNum">      27 </span><span class="lineNoCov">          0 :     free(d);</span>
<span class="lineNum">      28 </span><span class="lineNoCov">          0 : }</span>
<a name="29"><span class="lineNum">      29 </span>            : </a>
<span class="lineNum">      30 </span>            : date
<span class="lineNum">      31 </span><span class="lineNoCov">          0 : PGTYPESdate_from_timestamp(timestamp dt)</span>
<span class="lineNum">      32 </span>            : {
<span class="lineNum">      33 </span>            :     date        dDate;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span><span class="lineNoCov">          0 :     dDate = 0;                  /* suppress compiler warning */</span>
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span><span class="lineNoCov">          0 :     if (!TIMESTAMP_NOT_FINITE(dt))</span>
<span class="lineNum">      38 </span>            :     {
<span class="lineNum">      39 </span>            :         /* Microseconds to days */
<span class="lineNum">      40 </span><span class="lineNoCov">          0 :         dDate = (dt / USECS_PER_DAY);</span>
<span class="lineNum">      41 </span>            :     }
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span><span class="lineNoCov">          0 :     return dDate;</span>
<span class="lineNum">      44 </span>            : }
<a name="45"><span class="lineNum">      45 </span>            : </a>
<span class="lineNum">      46 </span>            : date
<span class="lineNum">      47 </span><span class="lineNoCov">          0 : PGTYPESdate_from_asc(char *str, char **endptr)</span>
<span class="lineNum">      48 </span>            : {
<span class="lineNum">      49 </span>            :     date        dDate;
<span class="lineNum">      50 </span>            :     fsec_t      fsec;
<span class="lineNum">      51 </span>            :     struct tm   tt,
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :                *tm = &amp;tt;</span>
<span class="lineNum">      53 </span>            :     int         dtype;
<span class="lineNum">      54 </span>            :     int         nf;
<span class="lineNum">      55 </span>            :     char       *field[MAXDATEFIELDS];
<span class="lineNum">      56 </span>            :     int         ftype[MAXDATEFIELDS];
<span class="lineNum">      57 </span>            :     char        lowstr[MAXDATELEN + MAXDATEFIELDS];
<span class="lineNum">      58 </span>            :     char       *realptr;
<span class="lineNum">      59 </span><span class="lineNoCov">          0 :     char      **ptr = (endptr != NULL) ? endptr : &amp;realptr;</span>
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :     bool        EuroDates = false;</span>
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :     errno = 0;</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     if (strlen(str) &gt; MAXDATELEN)</span>
<span class="lineNum">      65 </span>            :     {
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :         errno = PGTYPES_DATE_BAD_DATE;</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 :         return INT_MIN;</span>
<span class="lineNum">      68 </span>            :     }
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :     if (ParseDateTime(str, lowstr, field, ftype, &amp;nf, ptr) != 0 ||</span>
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :         DecodeDateTime(field, ftype, nf, &amp;dtype, tm, &amp;fsec, EuroDates) != 0)</span>
<span class="lineNum">      72 </span>            :     {
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :         errno = PGTYPES_DATE_BAD_DATE;</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :         return INT_MIN;</span>
<span class="lineNum">      75 </span>            :     }
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :     switch (dtype)</span>
<span class="lineNum">      78 </span>            :     {
<span class="lineNum">      79 </span>            :         case DTK_DATE:
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            :         case DTK_EPOCH:
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :             if (GetEpochTime(tm) &lt; 0)</span>
<span class="lineNum">      84 </span>            :             {
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :                 errno = PGTYPES_DATE_BAD_DATE;</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :                 return INT_MIN;</span>
<span class="lineNum">      87 </span>            :             }
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            :         default:
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :             errno = PGTYPES_DATE_BAD_DATE;</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :             return INT_MIN;</span>
<span class="lineNum">      93 </span>            :     }
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :     dDate = (date2j(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday) - date2j(2000, 1, 1));</span>
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :     return dDate;</span>
<span class="lineNum">      98 </span>            : }
<a name="99"><span class="lineNum">      99 </span>            : </a>
<span class="lineNum">     100 </span>            : char *
<span class="lineNum">     101 </span><span class="lineNoCov">          0 : PGTYPESdate_to_asc(date dDate)</span>
<span class="lineNum">     102 </span>            : {
<span class="lineNum">     103 </span>            :     struct tm   tt,
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :                *tm = &amp;tt;</span>
<span class="lineNum">     105 </span>            :     char        buf[MAXDATELEN + 1];
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :     int         DateStyle = 1;</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :     bool        EuroDates = false;</span>
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     j2date(dDate + date2j(2000, 1, 1), &amp;(tm-&gt;tm_year), &amp;(tm-&gt;tm_mon), &amp;(tm-&gt;tm_mday));</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :     EncodeDateOnly(tm, DateStyle, buf, EuroDates);</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     return pgtypes_strdup(buf);</span>
<span class="lineNum">     112 </span>            : }
<a name="113"><span class="lineNum">     113 </span>            : </a>
<span class="lineNum">     114 </span>            : void
<span class="lineNum">     115 </span><span class="lineNoCov">          0 : PGTYPESdate_julmdy(date jd, int *mdy)</span>
<span class="lineNum">     116 </span>            : {
<span class="lineNum">     117 </span>            :     int         y,
<span class="lineNum">     118 </span>            :                 m,
<span class="lineNum">     119 </span>            :                 d;
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     j2date((int) (jd + date2j(2000, 1, 1)), &amp;y, &amp;m, &amp;d);</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     mdy[0] = m;</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :     mdy[1] = d;</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :     mdy[2] = y;</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 : }</span>
<a name="126"><span class="lineNum">     126 </span>            : </a>
<span class="lineNum">     127 </span>            : void
<span class="lineNum">     128 </span><span class="lineNoCov">          0 : PGTYPESdate_mdyjul(int *mdy, date * jdate)</span>
<span class="lineNum">     129 </span>            : {
<span class="lineNum">     130 </span>            :     /* month is mdy[0] */
<span class="lineNum">     131 </span>            :     /* day   is mdy[1] */
<span class="lineNum">     132 </span>            :     /* year  is mdy[2] */
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :     *jdate = (date) (date2j(mdy[2], mdy[0], mdy[1]) - date2j(2000, 1, 1));</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 : }</span>
<a name="136"><span class="lineNum">     136 </span>            : </a>
<span class="lineNum">     137 </span>            : int
<span class="lineNum">     138 </span><span class="lineNoCov">          0 : PGTYPESdate_dayofweek(date dDate)</span>
<span class="lineNum">     139 </span>            : {
<span class="lineNum">     140 </span>            :     /*
<span class="lineNum">     141 </span>            :      * Sunday:  0 Monday:      1 Tuesday:     2 Wednesday:   3 Thursday: 4
<span class="lineNum">     142 </span>            :      * Friday:      5 Saturday:    6
<span class="lineNum">     143 </span>            :      */
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :     return (int) (dDate + date2j(2000, 1, 1) + 1) % 7;</span>
<span class="lineNum">     145 </span>            : }
<a name="146"><span class="lineNum">     146 </span>            : </a>
<span class="lineNum">     147 </span>            : void
<span class="lineNum">     148 </span><span class="lineNoCov">          0 : PGTYPESdate_today(date * d)</span>
<span class="lineNum">     149 </span>            : {
<span class="lineNum">     150 </span>            :     struct tm   ts;
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :     GetCurrentDateTime(&amp;ts);</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     if (errno == 0)</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :         *d = date2j(ts.tm_year, ts.tm_mon, ts.tm_mday) - date2j(2000, 1, 1);</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     156 </span>            : }
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : #define PGTYPES_DATE_NUM_MAX_DIGITS     20  /* should suffice for most
<span class="lineNum">     159 </span>            :                                              * years... */
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            : #define PGTYPES_FMTDATE_DAY_DIGITS_LZ       1   /* LZ means &quot;leading zeroes&quot; */
<span class="lineNum">     162 </span>            : #define PGTYPES_FMTDATE_DOW_LITERAL_SHORT   2
<span class="lineNum">     163 </span>            : #define PGTYPES_FMTDATE_MONTH_DIGITS_LZ     3
<span class="lineNum">     164 </span>            : #define PGTYPES_FMTDATE_MONTH_LITERAL_SHORT 4
<span class="lineNum">     165 </span>            : #define PGTYPES_FMTDATE_YEAR_DIGITS_SHORT   5
<span class="lineNum">     166 </span>            : #define PGTYPES_FMTDATE_YEAR_DIGITS_LONG    6
<a name="167"><span class="lineNum">     167 </span>            : </a>
<span class="lineNum">     168 </span>            : int
<span class="lineNum">     169 </span><span class="lineNoCov">          0 : PGTYPESdate_fmt_asc(date dDate, const char *fmtstring, char *outbuf)</span>
<span class="lineNum">     170 </span>            : {
<span class="lineNum">     171 </span>            :     static struct
<span class="lineNum">     172 </span>            :     {
<span class="lineNum">     173 </span>            :         char       *format;
<span class="lineNum">     174 </span>            :         int         component;
<span class="lineNum">     175 </span>            :     }           mapping[] =
<span class="lineNum">     176 </span>            :     {
<span class="lineNum">     177 </span>            :         /*
<span class="lineNum">     178 </span>            :          * format items have to be sorted according to their length, since the
<span class="lineNum">     179 </span>            :          * first pattern that matches gets replaced by its value
<span class="lineNum">     180 </span>            :          */
<span class="lineNum">     181 </span>            :         {
<span class="lineNum">     182 </span>            :             &quot;ddd&quot;, PGTYPES_FMTDATE_DOW_LITERAL_SHORT
<span class="lineNum">     183 </span>            :         },
<span class="lineNum">     184 </span>            :         {
<span class="lineNum">     185 </span>            :             &quot;dd&quot;, PGTYPES_FMTDATE_DAY_DIGITS_LZ
<span class="lineNum">     186 </span>            :         },
<span class="lineNum">     187 </span>            :         {
<span class="lineNum">     188 </span>            :             &quot;mmm&quot;, PGTYPES_FMTDATE_MONTH_LITERAL_SHORT
<span class="lineNum">     189 </span>            :         },
<span class="lineNum">     190 </span>            :         {
<span class="lineNum">     191 </span>            :             &quot;mm&quot;, PGTYPES_FMTDATE_MONTH_DIGITS_LZ
<span class="lineNum">     192 </span>            :         },
<span class="lineNum">     193 </span>            :         {
<span class="lineNum">     194 </span>            :             &quot;yyyy&quot;, PGTYPES_FMTDATE_YEAR_DIGITS_LONG
<span class="lineNum">     195 </span>            :         },
<span class="lineNum">     196 </span>            :         {
<span class="lineNum">     197 </span>            :             &quot;yy&quot;, PGTYPES_FMTDATE_YEAR_DIGITS_SHORT
<span class="lineNum">     198 </span>            :         },
<span class="lineNum">     199 </span>            :         {
<span class="lineNum">     200 </span>            :             NULL, 0
<span class="lineNum">     201 </span>            :         }
<span class="lineNum">     202 </span>            :     };
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            :     union un_fmt_comb replace_val;
<span class="lineNum">     205 </span>            :     int         replace_type;
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :     int         i;
<span class="lineNum">     208 </span>            :     int         dow;
<span class="lineNum">     209 </span>            :     char       *start_pattern;
<span class="lineNum">     210 </span>            :     struct tm   tm;
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            :     /* copy the string over */
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     strcpy(outbuf, fmtstring);</span>
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :     /* get the date */
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     j2date(dDate + date2j(2000, 1, 1), &amp;(tm.tm_year), &amp;(tm.tm_mon), &amp;(tm.tm_mday));</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     dow = PGTYPESdate_dayofweek(dDate);</span>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :     for (i = 0; mapping[i].format != NULL; i++)</span>
<span class="lineNum">     220 </span>            :     {
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         while ((start_pattern = strstr(outbuf, mapping[i].format)) != NULL)</span>
<span class="lineNum">     222 </span>            :         {
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :             switch (mapping[i].component)</span>
<span class="lineNum">     224 </span>            :             {
<span class="lineNum">     225 </span>            :                 case PGTYPES_FMTDATE_DOW_LITERAL_SHORT:
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :                     replace_val.str_val = pgtypes_date_weekdays_short[dow];</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :                     replace_type = PGTYPES_TYPE_STRING_CONSTANT;</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     229 </span>            :                 case PGTYPES_FMTDATE_DAY_DIGITS_LZ:
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :                     replace_val.uint_val = tm.tm_mday;</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :                     replace_type = PGTYPES_TYPE_UINT_2_LZ;</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     233 </span>            :                 case PGTYPES_FMTDATE_MONTH_LITERAL_SHORT:
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :                     replace_val.str_val = months[tm.tm_mon - 1];</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :                     replace_type = PGTYPES_TYPE_STRING_CONSTANT;</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     237 </span>            :                 case PGTYPES_FMTDATE_MONTH_DIGITS_LZ:
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :                     replace_val.uint_val = tm.tm_mon;</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :                     replace_type = PGTYPES_TYPE_UINT_2_LZ;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     241 </span>            :                 case PGTYPES_FMTDATE_YEAR_DIGITS_LONG:
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :                     replace_val.uint_val = tm.tm_year;</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :                     replace_type = PGTYPES_TYPE_UINT_4_LZ;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     245 </span>            :                 case PGTYPES_FMTDATE_YEAR_DIGITS_SHORT:
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :                     replace_val.uint_val = tm.tm_year % 100;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :                     replace_type = PGTYPES_TYPE_UINT_2_LZ;</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     249 </span>            :                 default:
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            :                     /*
<span class="lineNum">     252 </span>            :                      * should not happen, set something anyway
<span class="lineNum">     253 </span>            :                      */
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :                     replace_val.str_val = &quot; &quot;;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :                     replace_type = PGTYPES_TYPE_STRING_CONSTANT;</span>
<span class="lineNum">     256 </span>            :             }
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :             switch (replace_type)</span>
<span class="lineNum">     258 </span>            :             {
<span class="lineNum">     259 </span>            :                 case PGTYPES_TYPE_STRING_MALLOCED:
<span class="lineNum">     260 </span>            :                 case PGTYPES_TYPE_STRING_CONSTANT:
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :                     memcpy(start_pattern, replace_val.str_val,</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :                            strlen(replace_val.str_val));</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :                     if (replace_type == PGTYPES_TYPE_STRING_MALLOCED)</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :                         free(replace_val.str_val);</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     266 </span>            :                 case PGTYPES_TYPE_UINT:
<span class="lineNum">     267 </span>            :                     {
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :                         char       *t = pgtypes_alloc(PGTYPES_DATE_NUM_MAX_DIGITS);</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :                         if (!t)</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :                             return -1;</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :                         snprintf(t, PGTYPES_DATE_NUM_MAX_DIGITS,</span>
<span class="lineNum">     273 </span>            :                                  &quot;%u&quot;, replace_val.uint_val);
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :                         memcpy(start_pattern, t, strlen(t));</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :                         free(t);</span>
<span class="lineNum">     276 </span>            :                     }
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     278 </span>            :                 case PGTYPES_TYPE_UINT_2_LZ:
<span class="lineNum">     279 </span>            :                     {
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :                         char       *t = pgtypes_alloc(PGTYPES_DATE_NUM_MAX_DIGITS);</span>
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :                         if (!t)</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :                             return -1;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :                         snprintf(t, PGTYPES_DATE_NUM_MAX_DIGITS,</span>
<span class="lineNum">     285 </span>            :                                  &quot;%02u&quot;, replace_val.uint_val);
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :                         memcpy(start_pattern, t, strlen(t));</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :                         free(t);</span>
<span class="lineNum">     288 </span>            :                     }
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     290 </span>            :                 case PGTYPES_TYPE_UINT_4_LZ:
<span class="lineNum">     291 </span>            :                     {
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :                         char       *t = pgtypes_alloc(PGTYPES_DATE_NUM_MAX_DIGITS);</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :                         if (!t)</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :                             return -1;</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :                         snprintf(t, PGTYPES_DATE_NUM_MAX_DIGITS,</span>
<span class="lineNum">     297 </span>            :                                  &quot;%04u&quot;, replace_val.uint_val);
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :                         memcpy(start_pattern, t, strlen(t));</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :                         free(t);</span>
<span class="lineNum">     300 </span>            :                     }
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     302 </span>            :                 default:
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            :                     /*
<span class="lineNum">     305 </span>            :                      * doesn't happen (we set replace_type to
<span class="lineNum">     306 </span>            :                      * PGTYPES_TYPE_STRING_CONSTANT in case of an error above)
<span class="lineNum">     307 </span>            :                      */
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     309 </span>            :             }
<span class="lineNum">     310 </span>            :         }
<span class="lineNum">     311 </span>            :     }
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     313 </span>            : }
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            : /*
<span class="lineNum">     317 </span>            :  * PGTYPESdate_defmt_asc
<span class="lineNum">     318 </span>            :  *
<span class="lineNum">     319 </span>            :  * function works as follows:
<span class="lineNum">     320 </span>            :  *   - first we analyze the parameters
<span class="lineNum">     321 </span>            :  *   - if this is a special case with no delimiters, add delimiters
<span class="lineNum">     322 </span>            :  *   - find the tokens. First we look for numerical values. If we have found
<span class="lineNum">     323 </span>            :  *     less than 3 tokens, we check for the months' names and thereafter for
<span class="lineNum">     324 </span>            :  *     the abbreviations of the months' names.
<span class="lineNum">     325 </span>            :  *   - then we see which parameter should be the date, the month and the
<span class="lineNum">     326 </span>            :  *     year and from these values we calculate the date
<span class="lineNum">     327 </span>            :  */
<span class="lineNum">     328 </span>            : 
<a name="329"><span class="lineNum">     329 </span>            : #define PGTYPES_DATE_MONTH_MAXLENGTH        20  /* probably even less  :-) */</a>
<span class="lineNum">     330 </span>            : int
<span class="lineNum">     331 </span><span class="lineNoCov">          0 : PGTYPESdate_defmt_asc(date * d, const char *fmt, const char *str)</span>
<span class="lineNum">     332 </span>            : {
<span class="lineNum">     333 </span>            :     /*
<span class="lineNum">     334 </span>            :      * token[2] = { 4,6 } means that token 2 starts at position 4 and ends at
<span class="lineNum">     335 </span>            :      * (including) position 6
<span class="lineNum">     336 </span>            :      */
<span class="lineNum">     337 </span>            :     int         token[3][2];
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :     int         token_values[3] = {-1, -1, -1};</span>
<span class="lineNum">     339 </span>            :     char       *fmt_token_order;
<span class="lineNum">     340 </span>            :     char       *fmt_ystart,
<span class="lineNum">     341 </span>            :                *fmt_mstart,
<span class="lineNum">     342 </span>            :                *fmt_dstart;
<span class="lineNum">     343 </span>            :     unsigned int i;
<span class="lineNum">     344 </span>            :     int         reading_digit;
<span class="lineNum">     345 </span>            :     int         token_count;
<span class="lineNum">     346 </span>            :     char       *str_copy;
<span class="lineNum">     347 </span>            :     struct tm   tm;
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     tm.tm_year = tm.tm_mon = tm.tm_mday = 0;    /* keep compiler quiet */</span>
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     if (!d || !str || !fmt)</span>
<span class="lineNum">     352 </span>            :     {
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :         errno = PGTYPES_DATE_ERR_EARGS;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     355 </span>            :     }
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            :     /* analyze the fmt string */
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     fmt_ystart = strstr(fmt, &quot;yy&quot;);</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     fmt_mstart = strstr(fmt, &quot;mm&quot;);</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     fmt_dstart = strstr(fmt, &quot;dd&quot;);</span>
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :     if (!fmt_ystart || !fmt_mstart || !fmt_dstart)</span>
<span class="lineNum">     363 </span>            :     {
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :         errno = PGTYPES_DATE_ERR_EARGS;</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     366 </span>            :     }
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     if (fmt_ystart &lt; fmt_mstart)</span>
<span class="lineNum">     369 </span>            :     {
<span class="lineNum">     370 </span>            :         /* y m */
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :         if (fmt_dstart &lt; fmt_ystart)</span>
<span class="lineNum">     372 </span>            :         {
<span class="lineNum">     373 </span>            :             /* d y m */
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :             fmt_token_order = &quot;dym&quot;;</span>
<span class="lineNum">     375 </span>            :         }
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         else if (fmt_dstart &gt; fmt_mstart)</span>
<span class="lineNum">     377 </span>            :         {
<span class="lineNum">     378 </span>            :             /* y m d */
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :             fmt_token_order = &quot;ymd&quot;;</span>
<span class="lineNum">     380 </span>            :         }
<span class="lineNum">     381 </span>            :         else
<span class="lineNum">     382 </span>            :         {
<span class="lineNum">     383 </span>            :             /* y d m */
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :             fmt_token_order = &quot;ydm&quot;;</span>
<span class="lineNum">     385 </span>            :         }
<span class="lineNum">     386 </span>            :     }
<span class="lineNum">     387 </span>            :     else
<span class="lineNum">     388 </span>            :     {
<span class="lineNum">     389 </span>            :         /* fmt_ystart &gt; fmt_mstart */
<span class="lineNum">     390 </span>            :         /* m y */
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :         if (fmt_dstart &lt; fmt_mstart)</span>
<span class="lineNum">     392 </span>            :         {
<span class="lineNum">     393 </span>            :             /* d m y */
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :             fmt_token_order = &quot;dmy&quot;;</span>
<span class="lineNum">     395 </span>            :         }
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :         else if (fmt_dstart &gt; fmt_ystart)</span>
<span class="lineNum">     397 </span>            :         {
<span class="lineNum">     398 </span>            :             /* m y d */
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :             fmt_token_order = &quot;myd&quot;;</span>
<span class="lineNum">     400 </span>            :         }
<span class="lineNum">     401 </span>            :         else
<span class="lineNum">     402 </span>            :         {
<span class="lineNum">     403 </span>            :             /* m d y */
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :             fmt_token_order = &quot;mdy&quot;;</span>
<span class="lineNum">     405 </span>            :         }
<span class="lineNum">     406 </span>            :     }
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :     /*
<span class="lineNum">     409 </span>            :      * handle the special cases where there is no delimiter between the
<span class="lineNum">     410 </span>            :      * digits. If we see this:
<span class="lineNum">     411 </span>            :      *
<span class="lineNum">     412 </span>            :      * only digits, 6 or 8 bytes then it might be ddmmyy and ddmmyyyy (or
<span class="lineNum">     413 </span>            :      * similar)
<span class="lineNum">     414 </span>            :      *
<span class="lineNum">     415 </span>            :      * we reduce it to a string with delimiters and continue processing
<span class="lineNum">     416 </span>            :      */
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :     /* check if we have only digits */
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     reading_digit = 1;</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :     for (i = 0; str[i]; i++)</span>
<span class="lineNum">     421 </span>            :     {
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :         if (!isdigit((unsigned char) str[i]))</span>
<span class="lineNum">     423 </span>            :         {
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :             reading_digit = 0;</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     426 </span>            :         }
<span class="lineNum">     427 </span>            :     }
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :     if (reading_digit)</span>
<span class="lineNum">     429 </span>            :     {
<span class="lineNum">     430 </span>            :         int         frag_length[3];
<span class="lineNum">     431 </span>            :         int         target_pos;
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :         i = strlen(str);</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :         if (i != 8 &amp;&amp; i != 6)</span>
<span class="lineNum">     435 </span>            :         {
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :             errno = PGTYPES_DATE_ERR_ENOSHORTDATE;</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :             return -1;</span>
<span class="lineNum">     438 </span>            :         }
<span class="lineNum">     439 </span>            :         /* okay, this really is the special case */
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            :         /*
<span class="lineNum">     442 </span>            :          * as long as the string, one additional byte for the terminator and 2
<span class="lineNum">     443 </span>            :          * for the delimiters between the 3 fields
<span class="lineNum">     444 </span>            :          */
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :         str_copy = pgtypes_alloc(strlen(str) + 1 + 2);</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :         if (!str_copy)</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :             return -1;</span>
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            :         /* determine length of the fragments */
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :         if (i == 6)</span>
<span class="lineNum">     451 </span>            :         {
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :             frag_length[0] = 2;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :             frag_length[1] = 2;</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :             frag_length[2] = 2;</span>
<span class="lineNum">     455 </span>            :         }
<span class="lineNum">     456 </span>            :         else
<span class="lineNum">     457 </span>            :         {
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :             if (fmt_token_order[0] == 'y')</span>
<span class="lineNum">     459 </span>            :             {
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :                 frag_length[0] = 4;</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :                 frag_length[1] = 2;</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :                 frag_length[2] = 2;</span>
<span class="lineNum">     463 </span>            :             }
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :             else if (fmt_token_order[1] == 'y')</span>
<span class="lineNum">     465 </span>            :             {
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :                 frag_length[0] = 2;</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :                 frag_length[1] = 4;</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :                 frag_length[2] = 2;</span>
<span class="lineNum">     469 </span>            :             }
<span class="lineNum">     470 </span>            :             else
<span class="lineNum">     471 </span>            :             {
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :                 frag_length[0] = 2;</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :                 frag_length[1] = 2;</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                 frag_length[2] = 4;</span>
<span class="lineNum">     475 </span>            :             }
<span class="lineNum">     476 </span>            :         }
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :         target_pos = 0;</span>
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            :         /*
<span class="lineNum">     480 </span>            :          * XXX: Here we could calculate the positions of the tokens and save
<span class="lineNum">     481 </span>            :          * the for loop down there where we again check with isdigit() for
<span class="lineNum">     482 </span>            :          * digits.
<span class="lineNum">     483 </span>            :          */
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; 3; i++)</span>
<span class="lineNum">     485 </span>            :         {
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :             int         start_pos = 0;</span>
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :             if (i &gt;= 1)</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :                 start_pos += frag_length[0];</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :             if (i == 2)</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :                 start_pos += frag_length[1];</span>
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :             strncpy(str_copy + target_pos, str + start_pos,</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :                     frag_length[i]);</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :             target_pos += frag_length[i];</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :             if (i != 2)</span>
<span class="lineNum">     497 </span>            :             {
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :                 str_copy[target_pos] = ' ';</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :                 target_pos++;</span>
<span class="lineNum">     500 </span>            :             }
<span class="lineNum">     501 </span>            :         }
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :         str_copy[target_pos] = '\0';</span>
<span class="lineNum">     503 </span>            :     }
<span class="lineNum">     504 </span>            :     else
<span class="lineNum">     505 </span>            :     {
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :         str_copy = pgtypes_strdup(str);</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :         if (!str_copy)</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :             return -1;</span>
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span>            :         /* convert the whole string to lower case */
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :         for (i = 0; str_copy[i]; i++)</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :             str_copy[i] = (char) pg_tolower((unsigned char) str_copy[i]);</span>
<span class="lineNum">     513 </span>            :     }
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            :     /* look for numerical tokens */
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :     reading_digit = 0;</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :     token_count = 0;</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; strlen(str_copy); i++)</span>
<span class="lineNum">     519 </span>            :     {
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :         if (!isdigit((unsigned char) str_copy[i]) &amp;&amp; reading_digit)</span>
<span class="lineNum">     521 </span>            :         {
<span class="lineNum">     522 </span>            :             /* the token is finished */
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :             token[token_count][1] = i - 1;</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :             reading_digit = 0;</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :             token_count++;</span>
<span class="lineNum">     526 </span>            :         }
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :         else if (isdigit((unsigned char) str_copy[i]) &amp;&amp; !reading_digit)</span>
<span class="lineNum">     528 </span>            :         {
<span class="lineNum">     529 </span>            :             /* we have found a token */
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :             token[token_count][0] = i;</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :             reading_digit = 1;</span>
<span class="lineNum">     532 </span>            :         }
<span class="lineNum">     533 </span>            :     }
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span>            :     /*
<span class="lineNum">     536 </span>            :      * we're at the end of the input string, but maybe we are still reading a
<span class="lineNum">     537 </span>            :      * number...
<span class="lineNum">     538 </span>            :      */
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     if (reading_digit)</span>
<span class="lineNum">     540 </span>            :     {
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :         token[token_count][1] = i - 1;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :         token_count++;</span>
<span class="lineNum">     543 </span>            :     }
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     if (token_count &lt; 2)</span>
<span class="lineNum">     547 </span>            :     {
<span class="lineNum">     548 </span>            :         /*
<span class="lineNum">     549 </span>            :          * not all tokens found, no way to find 2 missing tokens with string
<span class="lineNum">     550 </span>            :          * matches
<span class="lineNum">     551 </span>            :          */
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :         free(str_copy);</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         errno = PGTYPES_DATE_ERR_ENOSHORTDATE;</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     555 </span>            :     }
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     if (token_count != 3)</span>
<span class="lineNum">     558 </span>            :     {
<span class="lineNum">     559 </span>            :         /*
<span class="lineNum">     560 </span>            :          * not all tokens found but we may find another one with string
<span class="lineNum">     561 </span>            :          * matches by testing for the months names and months abbreviations
<span class="lineNum">     562 </span>            :          */
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :         char       *month_lower_tmp = pgtypes_alloc(PGTYPES_DATE_MONTH_MAXLENGTH);</span>
<span class="lineNum">     564 </span>            :         char       *start_pos;
<span class="lineNum">     565 </span>            :         int         j;
<span class="lineNum">     566 </span>            :         int         offset;
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :         int         found = 0;</span>
<span class="lineNum">     568 </span>            :         char      **list;
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :         if (!month_lower_tmp)</span>
<span class="lineNum">     571 </span>            :         {
<span class="lineNum">     572 </span>            :             /* free variables we alloc'ed before */
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :             free(str_copy);</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :             return -1;</span>
<span class="lineNum">     575 </span>            :         }
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :         list = pgtypes_date_months;</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :         for (i = 0; list[i]; i++)</span>
<span class="lineNum">     578 </span>            :         {
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :             for (j = 0; j &lt; PGTYPES_DATE_MONTH_MAXLENGTH; j++)</span>
<span class="lineNum">     580 </span>            :             {
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :                 month_lower_tmp[j] = (char) pg_tolower((unsigned char) list[i][j]);</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :                 if (!month_lower_tmp[j])</span>
<span class="lineNum">     583 </span>            :                 {
<span class="lineNum">     584 </span>            :                     /* properly terminated */
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     586 </span>            :                 }
<span class="lineNum">     587 </span>            :             }
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :             if ((start_pos = strstr(str_copy, month_lower_tmp)))</span>
<span class="lineNum">     589 </span>            :             {
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :                 offset = start_pos - str_copy;</span>
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span>            :                 /*
<span class="lineNum">     593 </span>            :                  * sort the new token into the numeric tokens, shift them if
<span class="lineNum">     594 </span>            :                  * necessary
<span class="lineNum">     595 </span>            :                  */
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :                 if (offset &lt; token[0][0])</span>
<span class="lineNum">     597 </span>            :                 {
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :                     token[2][0] = token[1][0];</span>
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :                     token[2][1] = token[1][1];</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :                     token[1][0] = token[0][0];</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :                     token[1][1] = token[0][1];</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :                     token_count = 0;</span>
<span class="lineNum">     603 </span>            :                 }
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :                 else if (offset &lt; token[1][0])</span>
<span class="lineNum">     605 </span>            :                 {
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :                     token[2][0] = token[1][0];</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :                     token[2][1] = token[1][1];</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :                     token_count = 1;</span>
<span class="lineNum">     609 </span>            :                 }
<span class="lineNum">     610 </span>            :                 else
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :                     token_count = 2;</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :                 token[token_count][0] = offset;</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :                 token[token_count][1] = offset + strlen(month_lower_tmp) - 1;</span>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span>            :                 /*
<span class="lineNum">     616 </span>            :                  * the value is the index of the month in the array of months
<span class="lineNum">     617 </span>            :                  * + 1 (January is month 0)
<span class="lineNum">     618 </span>            :                  */
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :                 token_values[token_count] = i + 1;</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :                 found = 1;</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     622 </span>            :             }
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            :             /*
<span class="lineNum">     625 </span>            :              * evil[tm] hack: if we read the pgtypes_date_months and haven't
<span class="lineNum">     626 </span>            :              * found a match, reset list to point to months (abbreviations)
<span class="lineNum">     627 </span>            :              * and reset the counter variable i
<span class="lineNum">     628 </span>            :              */
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :             if (list == pgtypes_date_months)</span>
<span class="lineNum">     630 </span>            :             {
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :                 if (list[i + 1] == NULL)</span>
<span class="lineNum">     632 </span>            :                 {
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :                     list = months;</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :                     i = -1;</span>
<span class="lineNum">     635 </span>            :                 }
<span class="lineNum">     636 </span>            :             }
<span class="lineNum">     637 </span>            :         }
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :         if (!found)</span>
<span class="lineNum">     639 </span>            :         {
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :             free(month_lower_tmp);</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :             free(str_copy);</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :             errno = PGTYPES_DATE_ERR_ENOTDMY;</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :             return -1;</span>
<span class="lineNum">     644 </span>            :         }
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            :         /*
<span class="lineNum">     647 </span>            :          * here we found a month. token[token_count] and
<span class="lineNum">     648 </span>            :          * token_values[token_count] reflect the month's details.
<span class="lineNum">     649 </span>            :          *
<span class="lineNum">     650 </span>            :          * only the month can be specified with a literal. Here we can do a
<span class="lineNum">     651 </span>            :          * quick check if the month is at the right position according to the
<span class="lineNum">     652 </span>            :          * format string because we can check if the token that we expect to
<span class="lineNum">     653 </span>            :          * be the month is at the position of the only token that already has
<span class="lineNum">     654 </span>            :          * a value. If we wouldn't check here we could say &quot;December 4 1990&quot;
<span class="lineNum">     655 </span>            :          * with a fmt string of &quot;dd mm yy&quot; for 12 April 1990.
<span class="lineNum">     656 </span>            :          */
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :         if (fmt_token_order[token_count] != 'm')</span>
<span class="lineNum">     658 </span>            :         {
<span class="lineNum">     659 </span>            :             /* deal with the error later on */
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :             token_values[token_count] = -1;</span>
<span class="lineNum">     661 </span>            :         }
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         free(month_lower_tmp);</span>
<span class="lineNum">     663 </span>            :     }
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            :     /* terminate the tokens with ASCII-0 and get their values */
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; 3; i++)</span>
<span class="lineNum">     667 </span>            :     {
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :         *(str_copy + token[i][1] + 1) = '\0';</span>
<span class="lineNum">     669 </span>            :         /* A month already has a value set, check for token_value == -1 */
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :         if (token_values[i] == -1)</span>
<span class="lineNum">     671 </span>            :         {
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :             errno = 0;</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :             token_values[i] = strtol(str_copy + token[i][0], (char **) NULL, 10);</span>
<span class="lineNum">     674 </span>            :             /* strtol sets errno in case of an error */
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :             if (errno)</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :                 token_values[i] = -1;</span>
<span class="lineNum">     677 </span>            :         }
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :         if (fmt_token_order[i] == 'd')</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :             tm.tm_mday = token_values[i];</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :         else if (fmt_token_order[i] == 'm')</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :             tm.tm_mon = token_values[i];</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :         else if (fmt_token_order[i] == 'y')</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :             tm.tm_year = token_values[i];</span>
<span class="lineNum">     684 </span>            :     }
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :     free(str_copy);</span>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     if (tm.tm_mday &lt; 1 || tm.tm_mday &gt; 31)</span>
<span class="lineNum">     688 </span>            :     {
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :         errno = PGTYPES_DATE_BAD_DAY;</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     691 </span>            :     }
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :     if (tm.tm_mon &lt; 1 || tm.tm_mon &gt; MONTHS_PER_YEAR)</span>
<span class="lineNum">     694 </span>            :     {
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :         errno = PGTYPES_DATE_BAD_MONTH;</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     697 </span>            :     }
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     if (tm.tm_mday == 31 &amp;&amp; (tm.tm_mon == 4 || tm.tm_mon == 6 || tm.tm_mon == 9 || tm.tm_mon == 11))</span>
<span class="lineNum">     700 </span>            :     {
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :         errno = PGTYPES_DATE_BAD_DAY;</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     703 </span>            :     }
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     if (tm.tm_mon == 2 &amp;&amp; tm.tm_mday &gt; 29)</span>
<span class="lineNum">     706 </span>            :     {
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :         errno = PGTYPES_DATE_BAD_DAY;</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     709 </span>            :     }
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :     *d = date2j(tm.tm_year, tm.tm_mon, tm.tm_mday) - date2j(2000, 1, 1);</span>
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     714 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
