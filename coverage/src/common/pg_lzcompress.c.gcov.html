<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/common/pg_lzcompress.c</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">src/common</a> - pg_lzcompress.c<span style="font-size: 80%;"> (source / <a href="pg_lzcompress.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">119</td>
            <td class="headerCovTableEntry">131</td>
            <td class="headerCovTableEntryHi">90.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* ----------</a>
<span class="lineNum">       2 </span>            :  * pg_lzcompress.c -
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  *      This is an implementation of LZ compression for PostgreSQL.
<span class="lineNum">       5 </span>            :  *      It uses a simple history table and generates 2-3 byte tags
<span class="lineNum">       6 </span>            :  *      capable of backward copy information for 3-273 bytes with
<span class="lineNum">       7 </span>            :  *      a max offset of 4095.
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  *      Entry routines:
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  *          int32
<span class="lineNum">      12 </span>            :  *          pglz_compress(const char *source, int32 slen, char *dest,
<span class="lineNum">      13 </span>            :  *                        const PGLZ_Strategy *strategy);
<span class="lineNum">      14 </span>            :  *
<span class="lineNum">      15 </span>            :  *              source is the input data to be compressed.
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  *              slen is the length of the input data.
<span class="lineNum">      18 </span>            :  *
<span class="lineNum">      19 </span>            :  *              dest is the output area for the compressed result.
<span class="lineNum">      20 </span>            :  *                  It must be at least as big as PGLZ_MAX_OUTPUT(slen).
<span class="lineNum">      21 </span>            :  *
<span class="lineNum">      22 </span>            :  *              strategy is a pointer to some information controlling
<span class="lineNum">      23 </span>            :  *                  the compression algorithm. If NULL, the compiled
<span class="lineNum">      24 </span>            :  *                  in default strategy is used.
<span class="lineNum">      25 </span>            :  *
<span class="lineNum">      26 </span>            :  *              The return value is the number of bytes written in the
<span class="lineNum">      27 </span>            :  *              buffer dest, or -1 if compression fails; in the latter
<span class="lineNum">      28 </span>            :  *              case the contents of dest are undefined.
<span class="lineNum">      29 </span>            :  *
<span class="lineNum">      30 </span>            :  *          int32
<span class="lineNum">      31 </span>            :  *          pglz_decompress(const char *source, int32 slen, char *dest,
<span class="lineNum">      32 </span>            :  *                          int32 rawsize, bool check_complete)
<span class="lineNum">      33 </span>            :  *
<span class="lineNum">      34 </span>            :  *              source is the compressed input.
<span class="lineNum">      35 </span>            :  *
<span class="lineNum">      36 </span>            :  *              slen is the length of the compressed input.
<span class="lineNum">      37 </span>            :  *
<span class="lineNum">      38 </span>            :  *              dest is the area where the uncompressed data will be
<span class="lineNum">      39 </span>            :  *                  written to. It is the callers responsibility to
<span class="lineNum">      40 </span>            :  *                  provide enough space.
<span class="lineNum">      41 </span>            :  *
<span class="lineNum">      42 </span>            :  *                  The data is written to buff exactly as it was handed
<span class="lineNum">      43 </span>            :  *                  to pglz_compress(). No terminating zero byte is added.
<span class="lineNum">      44 </span>            :  *
<span class="lineNum">      45 </span>            :  *              rawsize is the length of the uncompressed data.
<span class="lineNum">      46 </span>            :  *
<span class="lineNum">      47 </span>            :  *              check_complete is a flag to let us know if -1 should be
<span class="lineNum">      48 </span>            :  *                  returned in cases where we don't reach the end of the
<span class="lineNum">      49 </span>            :  *                  source or dest buffers, or not.  This should be false
<span class="lineNum">      50 </span>            :  *                  if the caller is asking for only a partial result and
<span class="lineNum">      51 </span>            :  *                  true otherwise.
<span class="lineNum">      52 </span>            :  *
<span class="lineNum">      53 </span>            :  *              The return value is the number of bytes written in the
<span class="lineNum">      54 </span>            :  *              buffer dest, or -1 if decompression fails.
<span class="lineNum">      55 </span>            :  *
<span class="lineNum">      56 </span>            :  *      The decompression algorithm and internal data format:
<span class="lineNum">      57 </span>            :  *
<span class="lineNum">      58 </span>            :  *          It is made with the compressed data itself.
<span class="lineNum">      59 </span>            :  *
<span class="lineNum">      60 </span>            :  *          The data representation is easiest explained by describing
<span class="lineNum">      61 </span>            :  *          the process of decompression.
<span class="lineNum">      62 </span>            :  *
<span class="lineNum">      63 </span>            :  *          If compressed_size == rawsize, then the data
<span class="lineNum">      64 </span>            :  *          is stored uncompressed as plain bytes. Thus, the decompressor
<span class="lineNum">      65 </span>            :  *          simply copies rawsize bytes to the destination.
<span class="lineNum">      66 </span>            :  *
<span class="lineNum">      67 </span>            :  *          Otherwise the first byte tells what to do the next 8 times.
<span class="lineNum">      68 </span>            :  *          We call this the control byte.
<span class="lineNum">      69 </span>            :  *
<span class="lineNum">      70 </span>            :  *          An unset bit in the control byte means, that one uncompressed
<span class="lineNum">      71 </span>            :  *          byte follows, which is copied from input to output.
<span class="lineNum">      72 </span>            :  *
<span class="lineNum">      73 </span>            :  *          A set bit in the control byte means, that a tag of 2-3 bytes
<span class="lineNum">      74 </span>            :  *          follows. A tag contains information to copy some bytes, that
<span class="lineNum">      75 </span>            :  *          are already in the output buffer, to the current location in
<span class="lineNum">      76 </span>            :  *          the output. Let's call the three tag bytes T1, T2 and T3. The
<span class="lineNum">      77 </span>            :  *          position of the data to copy is coded as an offset from the
<span class="lineNum">      78 </span>            :  *          actual output position.
<span class="lineNum">      79 </span>            :  *
<span class="lineNum">      80 </span>            :  *          The offset is in the upper nibble of T1 and in T2.
<span class="lineNum">      81 </span>            :  *          The length is in the lower nibble of T1.
<span class="lineNum">      82 </span>            :  *
<span class="lineNum">      83 </span>            :  *          So the 16 bits of a 2 byte tag are coded as
<span class="lineNum">      84 </span>            :  *
<span class="lineNum">      85 </span>            :  *              7---T1--0  7---T2--0
<span class="lineNum">      86 </span>            :  *              OOOO LLLL  OOOO OOOO
<span class="lineNum">      87 </span>            :  *
<span class="lineNum">      88 </span>            :  *          This limits the offset to 1-4095 (12 bits) and the length
<span class="lineNum">      89 </span>            :  *          to 3-18 (4 bits) because 3 is always added to it. To emit
<span class="lineNum">      90 </span>            :  *          a tag of 2 bytes with a length of 2 only saves one control
<span class="lineNum">      91 </span>            :  *          bit. But we lose one byte in the possible length of a tag.
<span class="lineNum">      92 </span>            :  *
<span class="lineNum">      93 </span>            :  *          In the actual implementation, the 2 byte tag's length is
<span class="lineNum">      94 </span>            :  *          limited to 3-17, because the value 0xF in the length nibble
<span class="lineNum">      95 </span>            :  *          has special meaning. It means, that the next following
<span class="lineNum">      96 </span>            :  *          byte (T3) has to be added to the length value of 18. That
<span class="lineNum">      97 </span>            :  *          makes total limits of 1-4095 for offset and 3-273 for length.
<span class="lineNum">      98 </span>            :  *
<span class="lineNum">      99 </span>            :  *          Now that we have successfully decoded a tag. We simply copy
<span class="lineNum">     100 </span>            :  *          the output that occurred &lt;offset&gt; bytes back to the current
<span class="lineNum">     101 </span>            :  *          output location in the specified &lt;length&gt;. Thus, a
<span class="lineNum">     102 </span>            :  *          sequence of 200 spaces (think about bpchar fields) could be
<span class="lineNum">     103 </span>            :  *          coded in 4 bytes. One literal space and a three byte tag to
<span class="lineNum">     104 </span>            :  *          copy 199 bytes with a -1 offset. Whow - that's a compression
<span class="lineNum">     105 </span>            :  *          rate of 98%! Well, the implementation needs to save the
<span class="lineNum">     106 </span>            :  *          original data size too, so we need another 4 bytes for it
<span class="lineNum">     107 </span>            :  *          and end up with a total compression rate of 96%, what's still
<span class="lineNum">     108 </span>            :  *          worth a Whow.
<span class="lineNum">     109 </span>            :  *
<span class="lineNum">     110 </span>            :  *      The compression algorithm
<span class="lineNum">     111 </span>            :  *
<span class="lineNum">     112 </span>            :  *          The following uses numbers used in the default strategy.
<span class="lineNum">     113 </span>            :  *
<span class="lineNum">     114 </span>            :  *          The compressor works best for attributes of a size between
<span class="lineNum">     115 </span>            :  *          1K and 1M. For smaller items there's not that much chance of
<span class="lineNum">     116 </span>            :  *          redundancy in the character sequence (except for large areas
<span class="lineNum">     117 </span>            :  *          of identical bytes like trailing spaces) and for bigger ones
<span class="lineNum">     118 </span>            :  *          our 4K maximum look-back distance is too small.
<span class="lineNum">     119 </span>            :  *
<span class="lineNum">     120 </span>            :  *          The compressor creates a table for lists of positions.
<span class="lineNum">     121 </span>            :  *          For each input position (except the last 3), a hash key is
<span class="lineNum">     122 </span>            :  *          built from the 4 next input bytes and the position remembered
<span class="lineNum">     123 </span>            :  *          in the appropriate list. Thus, the table points to linked
<span class="lineNum">     124 </span>            :  *          lists of likely to be at least in the first 4 characters
<span class="lineNum">     125 </span>            :  *          matching strings. This is done on the fly while the input
<span class="lineNum">     126 </span>            :  *          is compressed into the output area.  Table entries are only
<span class="lineNum">     127 </span>            :  *          kept for the last 4096 input positions, since we cannot use
<span class="lineNum">     128 </span>            :  *          back-pointers larger than that anyway.  The size of the hash
<span class="lineNum">     129 </span>            :  *          table is chosen based on the size of the input - a larger table
<span class="lineNum">     130 </span>            :  *          has a larger startup cost, as it needs to be initialized to
<span class="lineNum">     131 </span>            :  *          zero, but reduces the number of hash collisions on long inputs.
<span class="lineNum">     132 </span>            :  *
<span class="lineNum">     133 </span>            :  *          For each byte in the input, its hash key (built from this
<span class="lineNum">     134 </span>            :  *          byte and the next 3) is used to find the appropriate list
<span class="lineNum">     135 </span>            :  *          in the table. The lists remember the positions of all bytes
<span class="lineNum">     136 </span>            :  *          that had the same hash key in the past in increasing backward
<span class="lineNum">     137 </span>            :  *          offset order. Now for all entries in the used lists, the
<span class="lineNum">     138 </span>            :  *          match length is computed by comparing the characters from the
<span class="lineNum">     139 </span>            :  *          entries position with the characters from the actual input
<span class="lineNum">     140 </span>            :  *          position.
<span class="lineNum">     141 </span>            :  *
<span class="lineNum">     142 </span>            :  *          The compressor starts with a so called &quot;good_match&quot; of 128.
<span class="lineNum">     143 </span>            :  *          It is a &quot;prefer speed against compression ratio&quot; optimizer.
<span class="lineNum">     144 </span>            :  *          So if the first entry looked at already has 128 or more
<span class="lineNum">     145 </span>            :  *          matching characters, the lookup stops and that position is
<span class="lineNum">     146 </span>            :  *          used for the next tag in the output.
<span class="lineNum">     147 </span>            :  *
<span class="lineNum">     148 </span>            :  *          For each subsequent entry in the history list, the &quot;good_match&quot;
<span class="lineNum">     149 </span>            :  *          is lowered by 10%. So the compressor will be more happy with
<span class="lineNum">     150 </span>            :  *          short matches the farer it has to go back in the history.
<span class="lineNum">     151 </span>            :  *          Another &quot;speed against ratio&quot; preference characteristic of
<span class="lineNum">     152 </span>            :  *          the algorithm.
<span class="lineNum">     153 </span>            :  *
<span class="lineNum">     154 </span>            :  *          Thus there are 3 stop conditions for the lookup of matches:
<span class="lineNum">     155 </span>            :  *
<span class="lineNum">     156 </span>            :  *              - a match &gt;= good_match is found
<span class="lineNum">     157 </span>            :  *              - there are no more history entries to look at
<span class="lineNum">     158 </span>            :  *              - the next history entry is already too far back
<span class="lineNum">     159 </span>            :  *                to be coded into a tag.
<span class="lineNum">     160 </span>            :  *
<span class="lineNum">     161 </span>            :  *          Finally the match algorithm checks that at least a match
<span class="lineNum">     162 </span>            :  *          of 3 or more bytes has been found, because that is the smallest
<span class="lineNum">     163 </span>            :  *          amount of copy information to code into a tag. If so, a tag
<span class="lineNum">     164 </span>            :  *          is omitted and all the input bytes covered by that are just
<span class="lineNum">     165 </span>            :  *          scanned for the history add's, otherwise a literal character
<span class="lineNum">     166 </span>            :  *          is omitted and only his history entry added.
<span class="lineNum">     167 </span>            :  *
<span class="lineNum">     168 </span>            :  *      Acknowledgments:
<span class="lineNum">     169 </span>            :  *
<span class="lineNum">     170 </span>            :  *          Many thanks to Adisak Pochanayon, who's article about SLZ
<span class="lineNum">     171 </span>            :  *          inspired me to write the PostgreSQL compression this way.
<span class="lineNum">     172 </span>            :  *
<span class="lineNum">     173 </span>            :  *          Jan Wieck
<span class="lineNum">     174 </span>            :  *
<span class="lineNum">     175 </span>            :  * Copyright (c) 1999-2019, PostgreSQL Global Development Group
<span class="lineNum">     176 </span>            :  *
<span class="lineNum">     177 </span>            :  * src/common/pg_lzcompress.c
<span class="lineNum">     178 </span>            :  * ----------
<span class="lineNum">     179 </span>            :  */
<span class="lineNum">     180 </span>            : #ifndef FRONTEND
<span class="lineNum">     181 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">     182 </span>            : #else
<span class="lineNum">     183 </span>            : #include &quot;postgres_fe.h&quot;
<span class="lineNum">     184 </span>            : #endif
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            : #include &lt;limits.h&gt;
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            : #include &quot;common/pg_lzcompress.h&quot;
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            : /* ----------
<span class="lineNum">     192 </span>            :  * Local definitions
<span class="lineNum">     193 </span>            :  * ----------
<span class="lineNum">     194 </span>            :  */
<span class="lineNum">     195 </span>            : #define PGLZ_MAX_HISTORY_LISTS  8192    /* must be power of 2 */
<span class="lineNum">     196 </span>            : #define PGLZ_HISTORY_SIZE       4096
<span class="lineNum">     197 </span>            : #define PGLZ_MAX_MATCH          273
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            : /* ----------
<span class="lineNum">     201 </span>            :  * PGLZ_HistEntry -
<span class="lineNum">     202 </span>            :  *
<span class="lineNum">     203 </span>            :  *      Linked list for the backward history lookup
<span class="lineNum">     204 </span>            :  *
<span class="lineNum">     205 </span>            :  * All the entries sharing a hash key are linked in a doubly linked list.
<span class="lineNum">     206 </span>            :  * This makes it easy to remove an entry when it's time to recycle it
<span class="lineNum">     207 </span>            :  * (because it's more than 4K positions old).
<span class="lineNum">     208 </span>            :  * ----------
<span class="lineNum">     209 </span>            :  */
<span class="lineNum">     210 </span>            : typedef struct PGLZ_HistEntry
<span class="lineNum">     211 </span>            : {
<span class="lineNum">     212 </span>            :     struct PGLZ_HistEntry *next;    /* links for my hash key's list */
<span class="lineNum">     213 </span>            :     struct PGLZ_HistEntry *prev;
<span class="lineNum">     214 </span>            :     int         hindex;         /* my current hash key */
<span class="lineNum">     215 </span>            :     const char *pos;            /* my input position */
<span class="lineNum">     216 </span>            : } PGLZ_HistEntry;
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            : /* ----------
<span class="lineNum">     220 </span>            :  * The provided standard strategies
<span class="lineNum">     221 </span>            :  * ----------
<span class="lineNum">     222 </span>            :  */
<span class="lineNum">     223 </span>            : static const PGLZ_Strategy strategy_default_data = {
<span class="lineNum">     224 </span>            :     32,                         /* Data chunks less than 32 bytes are not
<span class="lineNum">     225 </span>            :                                  * compressed */
<span class="lineNum">     226 </span>            :     INT_MAX,                    /* No upper limit on what we'll try to
<span class="lineNum">     227 </span>            :                                  * compress */
<span class="lineNum">     228 </span>            :     25,                         /* Require 25% compression rate, or not worth
<span class="lineNum">     229 </span>            :                                  * it */
<span class="lineNum">     230 </span>            :     1024,                       /* Give up if no compression in the first 1KB */
<span class="lineNum">     231 </span>            :     128,                        /* Stop history lookup if a match of 128 bytes
<span class="lineNum">     232 </span>            :                                  * is found */
<span class="lineNum">     233 </span>            :     10                          /* Lower good match size by 10% at every loop
<span class="lineNum">     234 </span>            :                                  * iteration */
<span class="lineNum">     235 </span>            : };
<span class="lineNum">     236 </span>            : const PGLZ_Strategy *const PGLZ_strategy_default = &amp;strategy_default_data;
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            : static const PGLZ_Strategy strategy_always_data = {
<span class="lineNum">     240 </span>            :     0,                          /* Chunks of any size are compressed */
<span class="lineNum">     241 </span>            :     INT_MAX,
<span class="lineNum">     242 </span>            :     0,                          /* It's enough to save one single byte */
<span class="lineNum">     243 </span>            :     INT_MAX,                    /* Never give up early */
<span class="lineNum">     244 </span>            :     128,                        /* Stop history lookup if a match of 128 bytes
<span class="lineNum">     245 </span>            :                                  * is found */
<span class="lineNum">     246 </span>            :     6                           /* Look harder for a good match */
<span class="lineNum">     247 </span>            : };
<span class="lineNum">     248 </span>            : const PGLZ_Strategy *const PGLZ_strategy_always = &amp;strategy_always_data;
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            : /* ----------
<span class="lineNum">     252 </span>            :  * Statically allocated work arrays for history
<span class="lineNum">     253 </span>            :  * ----------
<span class="lineNum">     254 </span>            :  */
<span class="lineNum">     255 </span>            : static int16 hist_start[PGLZ_MAX_HISTORY_LISTS];
<span class="lineNum">     256 </span>            : static PGLZ_HistEntry hist_entries[PGLZ_HISTORY_SIZE + 1];
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : /*
<span class="lineNum">     259 </span>            :  * Element 0 in hist_entries is unused, and means 'invalid'. Likewise,
<span class="lineNum">     260 </span>            :  * INVALID_ENTRY_PTR in next/prev pointers mean 'invalid'.
<span class="lineNum">     261 </span>            :  */
<span class="lineNum">     262 </span>            : #define INVALID_ENTRY           0
<span class="lineNum">     263 </span>            : #define INVALID_ENTRY_PTR       (&amp;hist_entries[INVALID_ENTRY])
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : /* ----------
<span class="lineNum">     266 </span>            :  * pglz_hist_idx -
<span class="lineNum">     267 </span>            :  *
<span class="lineNum">     268 </span>            :  *      Computes the history table slot for the lookup by the next 4
<span class="lineNum">     269 </span>            :  *      characters in the input.
<span class="lineNum">     270 </span>            :  *
<span class="lineNum">     271 </span>            :  * NB: because we use the next 4 characters, we are not guaranteed to
<span class="lineNum">     272 </span>            :  * find 3-character matches; they very possibly will be in the wrong
<span class="lineNum">     273 </span>            :  * hash list.  This seems an acceptable tradeoff for spreading out the
<span class="lineNum">     274 </span>            :  * hash keys more.
<span class="lineNum">     275 </span>            :  * ----------
<span class="lineNum">     276 </span>            :  */
<span class="lineNum">     277 </span>            : #define pglz_hist_idx(_s,_e, _mask) (                                       \
<span class="lineNum">     278 </span>            :             ((((_e) - (_s)) &lt; 4) ? (int) (_s)[0] :                           \
<span class="lineNum">     279 </span>            :              (((_s)[0] &lt;&lt; 6) ^ ((_s)[1] &lt;&lt; 4) ^                             \
<span class="lineNum">     280 </span>            :               ((_s)[2] &lt;&lt; 2) ^ (_s)[3])) &amp; (_mask)                \
<span class="lineNum">     281 </span>            :         )
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            : /* ----------
<span class="lineNum">     285 </span>            :  * pglz_hist_add -
<span class="lineNum">     286 </span>            :  *
<span class="lineNum">     287 </span>            :  *      Adds a new entry to the history table.
<span class="lineNum">     288 </span>            :  *
<span class="lineNum">     289 </span>            :  * If _recycle is true, then we are recycling a previously used entry,
<span class="lineNum">     290 </span>            :  * and must first delink it from its old hashcode's linked list.
<span class="lineNum">     291 </span>            :  *
<span class="lineNum">     292 </span>            :  * NOTE: beware of multiple evaluations of macro's arguments, and note that
<span class="lineNum">     293 </span>            :  * _hn and _recycle are modified in the macro.
<span class="lineNum">     294 </span>            :  * ----------
<span class="lineNum">     295 </span>            :  */
<span class="lineNum">     296 </span>            : #define pglz_hist_add(_hs,_he,_hn,_recycle,_s,_e, _mask)    \
<span class="lineNum">     297 </span>            : do {                                    \
<span class="lineNum">     298 </span>            :             int __hindex = pglz_hist_idx((_s),(_e), (_mask));               \
<span class="lineNum">     299 </span>            :             int16 *__myhsp = &amp;(_hs)[__hindex];                              \
<span class="lineNum">     300 </span>            :             PGLZ_HistEntry *__myhe = &amp;(_he)[_hn];                           \
<span class="lineNum">     301 </span>            :             if (_recycle) {                                                 \
<span class="lineNum">     302 </span>            :                 if (__myhe-&gt;prev == NULL)                                    \
<span class="lineNum">     303 </span>            :                     (_hs)[__myhe-&gt;hindex] = __myhe-&gt;next - (_he);         \
<span class="lineNum">     304 </span>            :                 else                                                        \
<span class="lineNum">     305 </span>            :                     __myhe-&gt;prev-&gt;next = __myhe-&gt;next;                     \
<span class="lineNum">     306 </span>            :                 if (__myhe-&gt;next != NULL)                                    \
<span class="lineNum">     307 </span>            :                     __myhe-&gt;next-&gt;prev = __myhe-&gt;prev;                     \
<span class="lineNum">     308 </span>            :             }                                                               \
<span class="lineNum">     309 </span>            :             __myhe-&gt;next = &amp;(_he)[*__myhsp];                             \
<span class="lineNum">     310 </span>            :             __myhe-&gt;prev = NULL;                                         \
<span class="lineNum">     311 </span>            :             __myhe-&gt;hindex = __hindex;                                       \
<span class="lineNum">     312 </span>            :             __myhe-&gt;pos  = (_s);                                         \
<span class="lineNum">     313 </span>            :             /* If there was an existing entry in this hash slot, link */    \
<span class="lineNum">     314 </span>            :             /* this new entry to it. However, the 0th entry in the */       \
<span class="lineNum">     315 </span>            :             /* entries table is unused, so we can freely scribble on it. */ \
<span class="lineNum">     316 </span>            :             /* So don't bother checking if the slot was used - we'll */     \
<span class="lineNum">     317 </span>            :             /* scribble on the unused entry if it was not, but that's */    \
<span class="lineNum">     318 </span>            :             /* harmless. Avoiding the branch in this critical path */       \
<span class="lineNum">     319 </span>            :             /* speeds this up a little bit. */                              \
<span class="lineNum">     320 </span>            :             /* if (*__myhsp != INVALID_ENTRY) */                            \
<span class="lineNum">     321 </span>            :                 (_he)[(*__myhsp)].prev = __myhe;                            \
<span class="lineNum">     322 </span>            :             *__myhsp = _hn;                                                 \
<span class="lineNum">     323 </span>            :             if (++(_hn) &gt;= PGLZ_HISTORY_SIZE + 1) {                          \
<span class="lineNum">     324 </span>            :                 (_hn) = 1;                                                  \
<span class="lineNum">     325 </span>            :                 (_recycle) = true;                                          \
<span class="lineNum">     326 </span>            :             }                                                               \
<span class="lineNum">     327 </span>            : } while (0)
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            : /* ----------
<span class="lineNum">     331 </span>            :  * pglz_out_ctrl -
<span class="lineNum">     332 </span>            :  *
<span class="lineNum">     333 </span>            :  *      Outputs the last and allocates a new control byte if needed.
<span class="lineNum">     334 </span>            :  * ----------
<span class="lineNum">     335 </span>            :  */
<span class="lineNum">     336 </span>            : #define pglz_out_ctrl(__ctrlp,__ctrlb,__ctrl,__buf) \
<span class="lineNum">     337 </span>            : do { \
<span class="lineNum">     338 </span>            :     if ((__ctrl &amp; 0xff) == 0)                                               \
<span class="lineNum">     339 </span>            :     {                                                                       \
<span class="lineNum">     340 </span>            :         *(__ctrlp) = __ctrlb;                                               \
<span class="lineNum">     341 </span>            :         __ctrlp = (__buf)++;                                                \
<span class="lineNum">     342 </span>            :         __ctrlb = 0;                                                        \
<span class="lineNum">     343 </span>            :         __ctrl = 1;                                                         \
<span class="lineNum">     344 </span>            :     }                                                                       \
<span class="lineNum">     345 </span>            : } while (0)
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            : /* ----------
<span class="lineNum">     349 </span>            :  * pglz_out_literal -
<span class="lineNum">     350 </span>            :  *
<span class="lineNum">     351 </span>            :  *      Outputs a literal byte to the destination buffer including the
<span class="lineNum">     352 </span>            :  *      appropriate control bit.
<span class="lineNum">     353 </span>            :  * ----------
<span class="lineNum">     354 </span>            :  */
<span class="lineNum">     355 </span>            : #define pglz_out_literal(_ctrlp,_ctrlb,_ctrl,_buf,_byte) \
<span class="lineNum">     356 </span>            : do { \
<span class="lineNum">     357 </span>            :     pglz_out_ctrl(_ctrlp,_ctrlb,_ctrl,_buf);                                \
<span class="lineNum">     358 </span>            :     *(_buf)++ = (unsigned char)(_byte);                                     \
<span class="lineNum">     359 </span>            :     _ctrl &lt;&lt;= 1;                                                          \
<span class="lineNum">     360 </span>            : } while (0)
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            : /* ----------
<span class="lineNum">     364 </span>            :  * pglz_out_tag -
<span class="lineNum">     365 </span>            :  *
<span class="lineNum">     366 </span>            :  *      Outputs a backward reference tag of 2-4 bytes (depending on
<span class="lineNum">     367 </span>            :  *      offset and length) to the destination buffer including the
<span class="lineNum">     368 </span>            :  *      appropriate control bit.
<span class="lineNum">     369 </span>            :  * ----------
<span class="lineNum">     370 </span>            :  */
<span class="lineNum">     371 </span>            : #define pglz_out_tag(_ctrlp,_ctrlb,_ctrl,_buf,_len,_off) \
<span class="lineNum">     372 </span>            : do { \
<span class="lineNum">     373 </span>            :     pglz_out_ctrl(_ctrlp,_ctrlb,_ctrl,_buf);                                \
<span class="lineNum">     374 </span>            :     _ctrlb |= _ctrl;                                                        \
<span class="lineNum">     375 </span>            :     _ctrl &lt;&lt;= 1;                                                          \
<span class="lineNum">     376 </span>            :     if (_len &gt; 17)                                                           \
<span class="lineNum">     377 </span>            :     {                                                                       \
<span class="lineNum">     378 </span>            :         (_buf)[0] = (unsigned char)((((_off) &amp; 0xf00) &gt;&gt; 4) | 0x0f);      \
<span class="lineNum">     379 </span>            :         (_buf)[1] = (unsigned char)(((_off) &amp; 0xff));                       \
<span class="lineNum">     380 </span>            :         (_buf)[2] = (unsigned char)((_len) - 18);                           \
<span class="lineNum">     381 </span>            :         (_buf) += 3;                                                        \
<span class="lineNum">     382 </span>            :     } else {                                                                \
<span class="lineNum">     383 </span>            :         (_buf)[0] = (unsigned char)((((_off) &amp; 0xf00) &gt;&gt; 4) | ((_len) - 3)); \
<span class="lineNum">     384 </span>            :         (_buf)[1] = (unsigned char)((_off) &amp; 0xff);                         \
<span class="lineNum">     385 </span>            :         (_buf) += 2;                                                        \
<span class="lineNum">     386 </span>            :     }                                                                       \
<span class="lineNum">     387 </span>            : } while (0)
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            : /* ----------
<span class="lineNum">     391 </span>            :  * pglz_find_match -
<span class="lineNum">     392 </span>            :  *
<span class="lineNum">     393 </span>            :  *      Lookup the history table if the actual input stream matches
<span class="lineNum">     394 </span>            :  *      another sequence of characters, starting somewhere earlier
<span class="lineNum">     395 </span>            :  *      in the input buffer.
<span class="lineNum">     396 </span>            :  * ----------
<a name="397"><span class="lineNum">     397 </span>            :  */</a>
<span class="lineNum">     398 </span>            : static inline int
<span class="lineNum">     399 </span><span class="lineCov">    4240702 : pglz_find_match(int16 *hstart, const char *input, const char *end,</span>
<span class="lineNum">     400 </span>            :                 int *lenp, int *offp, int good_match, int good_drop, int mask)
<span class="lineNum">     401 </span>            : {
<span class="lineNum">     402 </span>            :     PGLZ_HistEntry *hent;
<span class="lineNum">     403 </span>            :     int16       hentno;
<span class="lineNum">     404 </span><span class="lineCov">    4240702 :     int32       len = 0;</span>
<span class="lineNum">     405 </span><span class="lineCov">    4240702 :     int32       off = 0;</span>
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            :     /*
<span class="lineNum">     408 </span>            :      * Traverse the linked history list until a good enough match is found.
<span class="lineNum">     409 </span>            :      */
<span class="lineNum">     410 </span><span class="lineCov">    4240702 :     hentno = hstart[pglz_hist_idx(input, end, mask)];</span>
<span class="lineNum">     411 </span><span class="lineCov">    4240702 :     hent = &amp;hist_entries[hentno];</span>
<span class="lineNum">     412 </span><span class="lineCov">   19605976 :     while (hent != INVALID_ENTRY_PTR)</span>
<span class="lineNum">     413 </span>            :     {
<span class="lineNum">     414 </span><span class="lineCov">   11227344 :         const char *ip = input;</span>
<span class="lineNum">     415 </span><span class="lineCov">   11227344 :         const char *hp = hent-&gt;pos;</span>
<span class="lineNum">     416 </span>            :         int32       thisoff;
<span class="lineNum">     417 </span>            :         int32       thislen;
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            :         /*
<span class="lineNum">     420 </span>            :          * Stop if the offset does not fit into our tag anymore.
<span class="lineNum">     421 </span>            :          */
<span class="lineNum">     422 </span><span class="lineCov">   11227344 :         thisoff = ip - hp;</span>
<span class="lineNum">     423 </span><span class="lineCov">   11227344 :         if (thisoff &gt;= 0x0fff)</span>
<span class="lineNum">     424 </span><span class="lineCov">       2328 :             break;</span>
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            :         /*
<span class="lineNum">     427 </span>            :          * Determine length of match. A better match must be larger than the
<span class="lineNum">     428 </span>            :          * best so far. And if we already have a match of 16 or more bytes,
<span class="lineNum">     429 </span>            :          * it's worth the call overhead to use memcmp() to check if this match
<span class="lineNum">     430 </span>            :          * is equal for the same size. After that we must fallback to
<span class="lineNum">     431 </span>            :          * character by character comparison to know the exact position where
<span class="lineNum">     432 </span>            :          * the diff occurred.
<span class="lineNum">     433 </span>            :          */
<span class="lineNum">     434 </span><span class="lineCov">   11225016 :         thislen = 0;</span>
<span class="lineNum">     435 </span><span class="lineCov">   11225016 :         if (len &gt;= 16)</span>
<span class="lineNum">     436 </span>            :         {
<span class="lineNum">     437 </span><span class="lineCov">     393874 :             if (memcmp(ip, hp, len) == 0)</span>
<span class="lineNum">     438 </span>            :             {
<span class="lineNum">     439 </span><span class="lineCov">     142682 :                 thislen = len;</span>
<span class="lineNum">     440 </span><span class="lineCov">     142682 :                 ip += len;</span>
<span class="lineNum">     441 </span><span class="lineCov">     142682 :                 hp += len;</span>
<span class="lineNum">     442 </span><span class="lineCov">     499622 :                 while (ip &lt; end &amp;&amp; *ip == *hp &amp;&amp; thislen &lt; PGLZ_MAX_MATCH)</span>
<span class="lineNum">     443 </span>            :                 {
<span class="lineNum">     444 </span><span class="lineCov">     214258 :                     thislen++;</span>
<span class="lineNum">     445 </span><span class="lineCov">     214258 :                     ip++;</span>
<span class="lineNum">     446 </span><span class="lineCov">     214258 :                     hp++;</span>
<span class="lineNum">     447 </span>            :                 }
<span class="lineNum">     448 </span>            :             }
<span class="lineNum">     449 </span>            :         }
<span class="lineNum">     450 </span>            :         else
<span class="lineNum">     451 </span>            :         {
<span class="lineNum">     452 </span><span class="lineCov">   75000266 :             while (ip &lt; end &amp;&amp; *ip == *hp &amp;&amp; thislen &lt; PGLZ_MAX_MATCH)</span>
<span class="lineNum">     453 </span>            :             {
<span class="lineNum">     454 </span><span class="lineCov">   53337982 :                 thislen++;</span>
<span class="lineNum">     455 </span><span class="lineCov">   53337982 :                 ip++;</span>
<span class="lineNum">     456 </span><span class="lineCov">   53337982 :                 hp++;</span>
<span class="lineNum">     457 </span>            :             }
<span class="lineNum">     458 </span>            :         }
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            :         /*
<span class="lineNum">     461 </span>            :          * Remember this match as the best (if it is)
<span class="lineNum">     462 </span>            :          */
<span class="lineNum">     463 </span><span class="lineCov">   11225016 :         if (thislen &gt; len)</span>
<span class="lineNum">     464 </span>            :         {
<span class="lineNum">     465 </span><span class="lineCov">    2207482 :             len = thislen;</span>
<span class="lineNum">     466 </span><span class="lineCov">    2207482 :             off = thisoff;</span>
<span class="lineNum">     467 </span>            :         }
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            :         /*
<span class="lineNum">     470 </span>            :          * Advance to the next history entry
<span class="lineNum">     471 </span>            :          */
<span class="lineNum">     472 </span><span class="lineCov">   11225016 :         hent = hent-&gt;next;</span>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :         /*
<span class="lineNum">     475 </span>            :          * Be happy with lesser good matches the more entries we visited. But
<span class="lineNum">     476 </span>            :          * no point in doing calculation if we're at end of list.
<span class="lineNum">     477 </span>            :          */
<span class="lineNum">     478 </span><span class="lineCov">   11225016 :         if (hent != INVALID_ENTRY_PTR)</span>
<span class="lineNum">     479 </span>            :         {
<span class="lineNum">     480 </span><span class="lineCov">    9143934 :             if (len &gt;= good_match)</span>
<span class="lineNum">     481 </span><span class="lineCov">     100444 :                 break;</span>
<span class="lineNum">     482 </span><span class="lineCov">    9043490 :             good_match -= (good_match * good_drop) / 100;</span>
<span class="lineNum">     483 </span>            :         }
<span class="lineNum">     484 </span>            :     }
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :     /*
<span class="lineNum">     487 </span>            :      * Return match information only if it results at least in one byte
<span class="lineNum">     488 </span>            :      * reduction.
<span class="lineNum">     489 </span>            :      */
<span class="lineNum">     490 </span><span class="lineCov">    4240702 :     if (len &gt; 2)</span>
<span class="lineNum">     491 </span>            :     {
<span class="lineNum">     492 </span><span class="lineCov">    1312834 :         *lenp = len;</span>
<span class="lineNum">     493 </span><span class="lineCov">    1312834 :         *offp = off;</span>
<span class="lineNum">     494 </span><span class="lineCov">    1312834 :         return 1;</span>
<span class="lineNum">     495 </span>            :     }
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span><span class="lineCov">    2927868 :     return 0;</span>
<span class="lineNum">     498 </span>            : }
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            : /* ----------
<span class="lineNum">     502 </span>            :  * pglz_compress -
<span class="lineNum">     503 </span>            :  *
<span class="lineNum">     504 </span>            :  *      Compresses source into dest using strategy. Returns the number of
<span class="lineNum">     505 </span>            :  *      bytes written in buffer dest, or -1 if compression fails.
<span class="lineNum">     506 </span>            :  * ----------
<a name="507"><span class="lineNum">     507 </span>            :  */</a>
<span class="lineNum">     508 </span>            : int32
<span class="lineNum">     509 </span><span class="lineCov">       4440 : pglz_compress(const char *source, int32 slen, char *dest,</span>
<span class="lineNum">     510 </span>            :               const PGLZ_Strategy *strategy)
<span class="lineNum">     511 </span>            : {
<span class="lineNum">     512 </span><span class="lineCov">       4440 :     unsigned char *bp = (unsigned char *) dest;</span>
<span class="lineNum">     513 </span><span class="lineCov">       4440 :     unsigned char *bstart = bp;</span>
<span class="lineNum">     514 </span><span class="lineCov">       4440 :     int         hist_next = 1;</span>
<span class="lineNum">     515 </span><span class="lineCov">       4440 :     bool        hist_recycle = false;</span>
<span class="lineNum">     516 </span><span class="lineCov">       4440 :     const char *dp = source;</span>
<span class="lineNum">     517 </span><span class="lineCov">       4440 :     const char *dend = source + slen;</span>
<span class="lineNum">     518 </span><span class="lineCov">       4440 :     unsigned char ctrl_dummy = 0;</span>
<span class="lineNum">     519 </span><span class="lineCov">       4440 :     unsigned char *ctrlp = &amp;ctrl_dummy;</span>
<span class="lineNum">     520 </span><span class="lineCov">       4440 :     unsigned char ctrlb = 0;</span>
<span class="lineNum">     521 </span><span class="lineCov">       4440 :     unsigned char ctrl = 0;</span>
<span class="lineNum">     522 </span><span class="lineCov">       4440 :     bool        found_match = false;</span>
<span class="lineNum">     523 </span>            :     int32       match_len;
<span class="lineNum">     524 </span>            :     int32       match_off;
<span class="lineNum">     525 </span>            :     int32       good_match;
<span class="lineNum">     526 </span>            :     int32       good_drop;
<span class="lineNum">     527 </span>            :     int32       result_size;
<span class="lineNum">     528 </span>            :     int32       result_max;
<span class="lineNum">     529 </span>            :     int32       need_rate;
<span class="lineNum">     530 </span>            :     int         hashsz;
<span class="lineNum">     531 </span>            :     int         mask;
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            :     /*
<span class="lineNum">     534 </span>            :      * Our fallback strategy is the default.
<span class="lineNum">     535 </span>            :      */
<span class="lineNum">     536 </span><span class="lineCov">       4440 :     if (strategy == NULL)</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :         strategy = PGLZ_strategy_default;</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            :     /*
<span class="lineNum">     540 </span>            :      * If the strategy forbids compression (at all or if source chunk size out
<span class="lineNum">     541 </span>            :      * of range), fail.
<span class="lineNum">     542 </span>            :      */
<span class="lineNum">     543 </span><span class="lineCov">       8880 :     if (strategy-&gt;match_size_good &lt;= 0 ||</span>
<span class="lineNum">     544 </span><span class="lineCov">       8880 :         slen &lt; strategy-&gt;min_input_size ||</span>
<span class="lineNum">     545 </span><span class="lineCov">       4440 :         slen &gt; strategy-&gt;max_input_size)</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            :     /*
<span class="lineNum">     549 </span>            :      * Limit the match parameters to the supported range.
<span class="lineNum">     550 </span>            :      */
<span class="lineNum">     551 </span><span class="lineCov">       4440 :     good_match = strategy-&gt;match_size_good;</span>
<span class="lineNum">     552 </span><span class="lineCov">       4440 :     if (good_match &gt; PGLZ_MAX_MATCH)</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         good_match = PGLZ_MAX_MATCH;</span>
<span class="lineNum">     554 </span><span class="lineCov">       4440 :     else if (good_match &lt; 17)</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :         good_match = 17;</span>
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineCov">       4440 :     good_drop = strategy-&gt;match_size_drop;</span>
<span class="lineNum">     558 </span><span class="lineCov">       4440 :     if (good_drop &lt; 0)</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :         good_drop = 0;</span>
<span class="lineNum">     560 </span><span class="lineCov">       4440 :     else if (good_drop &gt; 100)</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :         good_drop = 100;</span>
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span><span class="lineCov">       4440 :     need_rate = strategy-&gt;min_comp_rate;</span>
<span class="lineNum">     564 </span><span class="lineCov">       4440 :     if (need_rate &lt; 0)</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :         need_rate = 0;</span>
<span class="lineNum">     566 </span><span class="lineCov">       4440 :     else if (need_rate &gt; 99)</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :         need_rate = 99;</span>
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            :     /*
<span class="lineNum">     570 </span>            :      * Compute the maximum result size allowed by the strategy, namely the
<span class="lineNum">     571 </span>            :      * input size minus the minimum wanted compression rate.  This had better
<span class="lineNum">     572 </span>            :      * be &lt;= slen, else we might overrun the provided output buffer.
<span class="lineNum">     573 </span>            :      */
<span class="lineNum">     574 </span><span class="lineCov">       4440 :     if (slen &gt; (INT_MAX / 100))</span>
<span class="lineNum">     575 </span>            :     {
<span class="lineNum">     576 </span>            :         /* Approximate to avoid overflow */
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :         result_max = (slen / 100) * (100 - need_rate);</span>
<span class="lineNum">     578 </span>            :     }
<span class="lineNum">     579 </span>            :     else
<span class="lineNum">     580 </span><span class="lineCov">       4440 :         result_max = (slen * (100 - need_rate)) / 100;</span>
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            :     /*
<span class="lineNum">     583 </span>            :      * Experiments suggest that these hash sizes work pretty well. A large
<span class="lineNum">     584 </span>            :      * hash table minimizes collision, but has a higher startup cost. For a
<span class="lineNum">     585 </span>            :      * small input, the startup cost dominates. The table size must be a power
<span class="lineNum">     586 </span>            :      * of two.
<span class="lineNum">     587 </span>            :      */
<span class="lineNum">     588 </span><span class="lineCov">       4440 :     if (slen &lt; 128)</span>
<span class="lineNum">     589 </span><span class="lineCov">          4 :         hashsz = 512;</span>
<span class="lineNum">     590 </span><span class="lineCov">       4436 :     else if (slen &lt; 256)</span>
<span class="lineNum">     591 </span><span class="lineCov">          8 :         hashsz = 1024;</span>
<span class="lineNum">     592 </span><span class="lineCov">       4428 :     else if (slen &lt; 512)</span>
<span class="lineNum">     593 </span><span class="lineCov">         50 :         hashsz = 2048;</span>
<span class="lineNum">     594 </span><span class="lineCov">       4378 :     else if (slen &lt; 1024)</span>
<span class="lineNum">     595 </span><span class="lineCov">         12 :         hashsz = 4096;</span>
<span class="lineNum">     596 </span>            :     else
<span class="lineNum">     597 </span><span class="lineCov">       4366 :         hashsz = 8192;</span>
<span class="lineNum">     598 </span><span class="lineCov">       4440 :     mask = hashsz - 1;</span>
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span>            :     /*
<span class="lineNum">     601 </span>            :      * Initialize the history lists to empty.  We do not need to zero the
<span class="lineNum">     602 </span>            :      * hist_entries[] array; its entries are initialized as they are used.
<span class="lineNum">     603 </span>            :      */
<span class="lineNum">     604 </span><span class="lineCov">       4440 :     memset(hist_start, 0, hashsz * sizeof(int16));</span>
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            :     /*
<span class="lineNum">     607 </span>            :      * Compress the source directly into the output buffer.
<span class="lineNum">     608 </span>            :      */
<span class="lineNum">     609 </span><span class="lineCov">    4249582 :     while (dp &lt; dend)</span>
<span class="lineNum">     610 </span>            :     {
<span class="lineNum">     611 </span>            :         /*
<span class="lineNum">     612 </span>            :          * If we already exceeded the maximum result size, fail.
<span class="lineNum">     613 </span>            :          *
<span class="lineNum">     614 </span>            :          * We check once per loop; since the loop body could emit as many as 4
<span class="lineNum">     615 </span>            :          * bytes (a control byte and 3-byte tag), PGLZ_MAX_OUTPUT() had better
<span class="lineNum">     616 </span>            :          * allow 4 slop bytes.
<span class="lineNum">     617 </span>            :          */
<span class="lineNum">     618 </span><span class="lineCov">    4240716 :         if (bp - bstart &gt;= result_max)</span>
<span class="lineNum">     619 </span><span class="lineCov">         14 :             return -1;</span>
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            :         /*
<span class="lineNum">     622 </span>            :          * If we've emitted more than first_success_by bytes without finding
<span class="lineNum">     623 </span>            :          * anything compressible at all, fail.  This lets us fall out
<span class="lineNum">     624 </span>            :          * reasonably quickly when looking at incompressible input (such as
<span class="lineNum">     625 </span>            :          * pre-compressed data).
<span class="lineNum">     626 </span>            :          */
<span class="lineNum">     627 </span><span class="lineCov">    4240702 :         if (!found_match &amp;&amp; bp - bstart &gt;= strategy-&gt;first_success_by)</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :             return -1;</span>
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            :         /*
<span class="lineNum">     631 </span>            :          * Try to find a match in the history
<span class="lineNum">     632 </span>            :          */
<span class="lineNum">     633 </span><span class="lineCov">    4240702 :         if (pglz_find_match(hist_start, dp, dend, &amp;match_len,</span>
<span class="lineNum">     634 </span>            :                             &amp;match_off, good_match, good_drop, mask))
<span class="lineNum">     635 </span>            :         {
<span class="lineNum">     636 </span>            :             /*
<span class="lineNum">     637 </span>            :              * Create the tag and add history entries for all matched
<span class="lineNum">     638 </span>            :              * characters.
<span class="lineNum">     639 </span>            :              */
<span class="lineNum">     640 </span><span class="lineCov">    1312834 :             pglz_out_tag(ctrlp, ctrlb, ctrl, bp, match_len, match_off);</span>
<span class="lineNum">     641 </span><span class="lineCov">   30360858 :             while (match_len--)</span>
<span class="lineNum">     642 </span>            :             {
<span class="lineNum">     643 </span><span class="lineCov">   27735190 :                 pglz_hist_add(hist_start, hist_entries,</span>
<span class="lineNum">     644 </span>            :                               hist_next, hist_recycle,
<span class="lineNum">     645 </span>            :                               dp, dend, mask);
<span class="lineNum">     646 </span><span class="lineCov">   27735190 :                 dp++;           /* Do not do this ++ in the line above! */</span>
<span class="lineNum">     647 </span>            :                 /* The macro would do it four times - Jan.  */
<span class="lineNum">     648 </span>            :             }
<span class="lineNum">     649 </span><span class="lineCov">    1312834 :             found_match = true;</span>
<span class="lineNum">     650 </span>            :         }
<span class="lineNum">     651 </span>            :         else
<span class="lineNum">     652 </span>            :         {
<span class="lineNum">     653 </span>            :             /*
<span class="lineNum">     654 </span>            :              * No match found. Copy one literal byte.
<span class="lineNum">     655 </span>            :              */
<span class="lineNum">     656 </span><span class="lineCov">    2927868 :             pglz_out_literal(ctrlp, ctrlb, ctrl, bp, *dp);</span>
<span class="lineNum">     657 </span><span class="lineCov">    2927868 :             pglz_hist_add(hist_start, hist_entries,</span>
<span class="lineNum">     658 </span>            :                           hist_next, hist_recycle,
<span class="lineNum">     659 </span>            :                           dp, dend, mask);
<span class="lineNum">     660 </span><span class="lineCov">    2927868 :             dp++;               /* Do not do this ++ in the line above! */</span>
<span class="lineNum">     661 </span>            :             /* The macro would do it four times - Jan.  */
<span class="lineNum">     662 </span>            :         }
<span class="lineNum">     663 </span>            :     }
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            :     /*
<span class="lineNum">     666 </span>            :      * Write out the last control byte and check that we haven't overrun the
<span class="lineNum">     667 </span>            :      * output size allowed by the strategy.
<span class="lineNum">     668 </span>            :      */
<span class="lineNum">     669 </span><span class="lineCov">       4426 :     *ctrlp = ctrlb;</span>
<span class="lineNum">     670 </span><span class="lineCov">       4426 :     result_size = bp - bstart;</span>
<span class="lineNum">     671 </span><span class="lineCov">       4426 :     if (result_size &gt;= result_max)</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            :     /* success */
<span class="lineNum">     675 </span><span class="lineCov">       4426 :     return result_size;</span>
<span class="lineNum">     676 </span>            : }
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            : /* ----------
<span class="lineNum">     680 </span>            :  * pglz_decompress -
<span class="lineNum">     681 </span>            :  *
<span class="lineNum">     682 </span>            :  *      Decompresses source into dest. Returns the number of bytes
<span class="lineNum">     683 </span>            :  *      decompressed in the destination buffer, and *optionally*
<span class="lineNum">     684 </span>            :  *      checks that both the source and dest buffers have been
<span class="lineNum">     685 </span>            :  *      fully read and written to, respectively.
<span class="lineNum">     686 </span>            :  * ----------
<a name="687"><span class="lineNum">     687 </span>            :  */</a>
<span class="lineNum">     688 </span>            : int32
<span class="lineNum">     689 </span><span class="lineCov">      14382 : pglz_decompress(const char *source, int32 slen, char *dest,</span>
<span class="lineNum">     690 </span>            :                 int32 rawsize, bool check_complete)
<span class="lineNum">     691 </span>            : {
<span class="lineNum">     692 </span>            :     const unsigned char *sp;
<span class="lineNum">     693 </span>            :     const unsigned char *srcend;
<span class="lineNum">     694 </span>            :     unsigned char *dp;
<span class="lineNum">     695 </span>            :     unsigned char *destend;
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span><span class="lineCov">      14382 :     sp = (const unsigned char *) source;</span>
<span class="lineNum">     698 </span><span class="lineCov">      14382 :     srcend = ((const unsigned char *) source) + slen;</span>
<span class="lineNum">     699 </span><span class="lineCov">      14382 :     dp = (unsigned char *) dest;</span>
<span class="lineNum">     700 </span><span class="lineCov">      14382 :     destend = dp + rawsize;</span>
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span><span class="lineCov">    1606456 :     while (sp &lt; srcend &amp;&amp; dp &lt; destend)</span>
<span class="lineNum">     703 </span>            :     {
<span class="lineNum">     704 </span>            :         /*
<span class="lineNum">     705 </span>            :          * Read one control byte and process the next 8 items (or as many as
<span class="lineNum">     706 </span>            :          * remain in the compressed input).
<span class="lineNum">     707 </span>            :          */
<span class="lineNum">     708 </span><span class="lineCov">    1577692 :         unsigned char ctrl = *sp++;</span>
<span class="lineNum">     709 </span>            :         int         ctrlc;
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span><span class="lineCov">   14149600 :         for (ctrlc = 0; ctrlc &lt; 8 &amp;&amp; sp &lt; srcend &amp;&amp; dp &lt; destend; ctrlc++)</span>
<span class="lineNum">     712 </span>            :         {
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span><span class="lineCov">   12571908 :             if (ctrl &amp; 1)</span>
<span class="lineNum">     715 </span>            :             {
<span class="lineNum">     716 </span>            :                 /*
<span class="lineNum">     717 </span>            :                  * Otherwise it contains the match length minus 3 and the
<span class="lineNum">     718 </span>            :                  * upper 4 bits of the offset. The next following byte
<span class="lineNum">     719 </span>            :                  * contains the lower 8 bits of the offset. If the length is
<span class="lineNum">     720 </span>            :                  * coded as 18, another extension tag byte tells how much
<span class="lineNum">     721 </span>            :                  * longer the match really was (0-255).
<span class="lineNum">     722 </span>            :                  */
<span class="lineNum">     723 </span>            :                 int32       len;
<span class="lineNum">     724 </span>            :                 int32       off;
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span><span class="lineCov">    3919560 :                 len = (sp[0] &amp; 0x0f) + 3;</span>
<span class="lineNum">     727 </span><span class="lineCov">    3919560 :                 off = ((sp[0] &amp; 0xf0) &lt;&lt; 4) | sp[1];</span>
<span class="lineNum">     728 </span><span class="lineCov">    3919560 :                 sp += 2;</span>
<span class="lineNum">     729 </span><span class="lineCov">    3919560 :                 if (len == 18)</span>
<span class="lineNum">     730 </span><span class="lineCov">     697350 :                     len += *sp++;</span>
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            :                 /*
<span class="lineNum">     733 </span>            :                  * Now we copy the bytes specified by the tag from OUTPUT to
<span class="lineNum">     734 </span>            :                  * OUTPUT. It is dangerous and platform dependent to use
<span class="lineNum">     735 </span>            :                  * memcpy() here, because the copied areas could overlap
<span class="lineNum">     736 </span>            :                  * extremely!
<span class="lineNum">     737 </span>            :                  */
<span class="lineNum">     738 </span><span class="lineCov">    3919560 :                 len = Min(len, destend - dp);</span>
<span class="lineNum">     739 </span><span class="lineCov">  112956028 :                 while (len--)</span>
<span class="lineNum">     740 </span>            :                 {
<span class="lineNum">     741 </span><span class="lineCov">  105116908 :                     *dp = dp[-off];</span>
<span class="lineNum">     742 </span><span class="lineCov">  105116908 :                     dp++;</span>
<span class="lineNum">     743 </span>            :                 }
<span class="lineNum">     744 </span>            :             }
<span class="lineNum">     745 </span>            :             else
<span class="lineNum">     746 </span>            :             {
<span class="lineNum">     747 </span>            :                 /*
<span class="lineNum">     748 </span>            :                  * An unset control bit means LITERAL BYTE. So we just copy
<span class="lineNum">     749 </span>            :                  * one from INPUT to OUTPUT.
<span class="lineNum">     750 </span>            :                  */
<span class="lineNum">     751 </span><span class="lineCov">    8652348 :                 *dp++ = *sp++;</span>
<span class="lineNum">     752 </span>            :             }
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span>            :             /*
<span class="lineNum">     755 </span>            :              * Advance the control bit
<span class="lineNum">     756 </span>            :              */
<span class="lineNum">     757 </span><span class="lineCov">   12571908 :             ctrl &gt;&gt;= 1;</span>
<span class="lineNum">     758 </span>            :         }
<span class="lineNum">     759 </span>            :     }
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            :     /*
<span class="lineNum">     762 </span>            :      * Check we decompressed the right amount. If we are slicing, then we
<span class="lineNum">     763 </span>            :      * won't necessarily be at the end of the source or dest buffers when we
<span class="lineNum">     764 </span>            :      * hit a stop, so we don't test them.
<span class="lineNum">     765 </span>            :      */
<span class="lineNum">     766 </span><span class="lineCov">      14382 :     if (check_complete &amp;&amp; (dp != destend || sp != srcend))</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            :     /*
<span class="lineNum">     770 </span>            :      * That's it.
<span class="lineNum">     771 </span>            :      */
<span class="lineNum">     772 </span><span class="lineCov">      14382 :     return (char *) dp - dest;</span>
<span class="lineNum">     773 </span>            : }
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span>            : /* ----------
<span class="lineNum">     777 </span>            :  * pglz_max_compressed_size -
<span class="lineNum">     778 </span>            :  *
<span class="lineNum">     779 </span>            :  *      Calculate the maximum compressed size for a given amount of raw data.
<span class="lineNum">     780 </span>            :  *      Return the maximum size, or total compressed size if maximum size is
<span class="lineNum">     781 </span>            :  *      larger than total compressed size.
<span class="lineNum">     782 </span>            :  *
<span class="lineNum">     783 </span>            :  * We can't use PGLZ_MAX_OUTPUT for this purpose, because that's used to size
<span class="lineNum">     784 </span>            :  * the compression buffer (and abort the compression). It does not really say
<span class="lineNum">     785 </span>            :  * what's the maximum compressed size for an input of a given length, and it
<span class="lineNum">     786 </span>            :  * may happen that while the whole value is compressible (and thus fits into
<span class="lineNum">     787 </span>            :  * PGLZ_MAX_OUTPUT nicely), the prefix is not compressible at all.
<span class="lineNum">     788 </span>            :  * ----------
<a name="789"><span class="lineNum">     789 </span>            :  */</a>
<span class="lineNum">     790 </span>            : int32
<span class="lineNum">     791 </span><span class="lineCov">         10 : pglz_maximum_compressed_size(int32 rawsize, int32 total_compressed_size)</span>
<span class="lineNum">     792 </span>            : {
<span class="lineNum">     793 </span>            :     int32 compressed_size;
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            :     /*
<span class="lineNum">     796 </span>            :      * pglz uses one control bit per byte, so we need (rawsize * 9) bits. We
<span class="lineNum">     797 </span>            :      * care about bytes though, so we add 7 to make sure we include the last
<span class="lineNum">     798 </span>            :      * incomplete byte (integer division rounds down).
<span class="lineNum">     799 </span>            :      *
<span class="lineNum">     800 </span>            :      * XXX Use int64 to prevent overflow during calculation.
<span class="lineNum">     801 </span>            :      */
<span class="lineNum">     802 </span><span class="lineCov">         10 :     compressed_size = (int32) ((int64) rawsize * 9 + 7) / 8;</span>
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            :     /*
<span class="lineNum">     805 </span>            :      * Maximum compressed size can't be larger than total compressed size.
<span class="lineNum">     806 </span>            :      */
<span class="lineNum">     807 </span><span class="lineCov">         10 :     compressed_size = Min(compressed_size, total_compressed_size);</span>
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span><span class="lineCov">         10 :     return compressed_size;</span>
<span class="lineNum">     810 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
