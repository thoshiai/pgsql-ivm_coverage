<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/pl/plpgsql/src/pl_handler.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/pl/plpgsql/src</a> - pl_handler.c<span style="font-size: 80%;"> (source / <a href="pl_handler.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">141</td>
            <td class="headerCovTableEntry">165</td>
            <td class="headerCovTableEntryMed">85.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * pl_handler.c     - Handler for the PL/pgSQL
<span class="lineNum">       4 </span>            :  *            procedural language
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * IDENTIFICATION
<span class="lineNum">      11 </span>            :  *    src/pl/plpgsql/src/pl_handler.c
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      14 </span>            :  */
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &quot;access/htup_details.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;catalog/pg_proc.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;catalog/pg_type.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;funcapi.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;miscadmin.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;plpgsql.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;utils/builtins.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;utils/guc.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;utils/lsyscache.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;utils/syscache.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;utils/varlena.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : static bool plpgsql_extra_checks_check_hook(char **newvalue, void **extra, GucSource source);
<span class="lineNum">      31 </span>            : static void plpgsql_extra_warnings_assign_hook(const char *newvalue, void *extra);
<a name="32"><span class="lineNum">      32 </span>            : static void plpgsql_extra_errors_assign_hook(const char *newvalue, void *extra);</a>
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span><span class="lineCov">        788 : PG_MODULE_MAGIC;</span>
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : /* Custom GUC variable */
<span class="lineNum">      37 </span>            : static const struct config_enum_entry variable_conflict_options[] = {
<span class="lineNum">      38 </span>            :     {&quot;error&quot;, PLPGSQL_RESOLVE_ERROR, false},
<span class="lineNum">      39 </span>            :     {&quot;use_variable&quot;, PLPGSQL_RESOLVE_VARIABLE, false},
<span class="lineNum">      40 </span>            :     {&quot;use_column&quot;, PLPGSQL_RESOLVE_COLUMN, false},
<span class="lineNum">      41 </span>            :     {NULL, 0, false}
<span class="lineNum">      42 </span>            : };
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : int         plpgsql_variable_conflict = PLPGSQL_RESOLVE_ERROR;
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : bool        plpgsql_print_strict_params = false;
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : bool        plpgsql_check_asserts = true;
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : char       *plpgsql_extra_warnings_string = NULL;
<span class="lineNum">      51 </span>            : char       *plpgsql_extra_errors_string = NULL;
<span class="lineNum">      52 </span>            : int         plpgsql_extra_warnings;
<span class="lineNum">      53 </span>            : int         plpgsql_extra_errors;
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : /* Hook for plugins */
<span class="lineNum">      56 </span>            : PLpgSQL_plugin **plpgsql_plugin_ptr = NULL;
<span class="lineNum">      57 </span>            : 
<a name="58"><span class="lineNum">      58 </span>            : </a>
<span class="lineNum">      59 </span>            : static bool
<span class="lineNum">      60 </span><span class="lineCov">       1598 : plpgsql_extra_checks_check_hook(char **newvalue, void **extra, GucSource source)</span>
<span class="lineNum">      61 </span>            : {
<span class="lineNum">      62 </span>            :     char       *rawstring;
<span class="lineNum">      63 </span>            :     List       *elemlist;
<span class="lineNum">      64 </span>            :     ListCell   *l;
<span class="lineNum">      65 </span><span class="lineCov">       1598 :     int         extrachecks = 0;</span>
<span class="lineNum">      66 </span>            :     int        *myextra;
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span><span class="lineCov">       1598 :     if (pg_strcasecmp(*newvalue, &quot;all&quot;) == 0)</span>
<span class="lineNum">      69 </span><span class="lineCov">          4 :         extrachecks = PLPGSQL_XCHECK_ALL;</span>
<span class="lineNum">      70 </span><span class="lineCov">       1594 :     else if (pg_strcasecmp(*newvalue, &quot;none&quot;) == 0)</span>
<span class="lineNum">      71 </span><span class="lineCov">       1580 :         extrachecks = PLPGSQL_XCHECK_NONE;</span>
<span class="lineNum">      72 </span>            :     else
<span class="lineNum">      73 </span>            :     {
<span class="lineNum">      74 </span>            :         /* Need a modifiable copy of string */
<span class="lineNum">      75 </span><span class="lineCov">         14 :         rawstring = pstrdup(*newvalue);</span>
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            :         /* Parse string into list of identifiers */
<span class="lineNum">      78 </span><span class="lineCov">         14 :         if (!SplitIdentifierString(rawstring, ',', &amp;elemlist))</span>
<span class="lineNum">      79 </span>            :         {
<span class="lineNum">      80 </span>            :             /* syntax error in list */
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :             GUC_check_errdetail(&quot;List syntax is invalid.&quot;);</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :             pfree(rawstring);</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :             list_free(elemlist);</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">      85 </span>            :         }
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span><span class="lineCov">         28 :         foreach(l, elemlist)</span>
<span class="lineNum">      88 </span>            :         {
<span class="lineNum">      89 </span><span class="lineCov">         14 :             char       *tok = (char *) lfirst(l);</span>
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span><span class="lineCov">         14 :             if (pg_strcasecmp(tok, &quot;shadowed_variables&quot;) == 0)</span>
<span class="lineNum">      92 </span><span class="lineCov">          6 :                 extrachecks |= PLPGSQL_XCHECK_SHADOWVAR;</span>
<span class="lineNum">      93 </span><span class="lineCov">          8 :             else if (pg_strcasecmp(tok, &quot;too_many_rows&quot;) == 0)</span>
<span class="lineNum">      94 </span><span class="lineCov">          4 :                 extrachecks |= PLPGSQL_XCHECK_TOOMANYROWS;</span>
<span class="lineNum">      95 </span><span class="lineCov">          4 :             else if (pg_strcasecmp(tok, &quot;strict_multi_assignment&quot;) == 0)</span>
<span class="lineNum">      96 </span><span class="lineCov">          4 :                 extrachecks |= PLPGSQL_XCHECK_STRICTMULTIASSIGNMENT;</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :             else if (pg_strcasecmp(tok, &quot;all&quot;) == 0 || pg_strcasecmp(tok, &quot;none&quot;) == 0)</span>
<span class="lineNum">      98 </span>            :             {
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :                 GUC_check_errdetail(&quot;Key word \&quot;%s\&quot; cannot be combined with other key words.&quot;, tok);</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :                 pfree(rawstring);</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :                 list_free(elemlist);</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     103 </span>            :             }
<span class="lineNum">     104 </span>            :             else
<span class="lineNum">     105 </span>            :             {
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :                 GUC_check_errdetail(&quot;Unrecognized key word: \&quot;%s\&quot;.&quot;, tok);</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :                 pfree(rawstring);</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :                 list_free(elemlist);</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     110 </span>            :             }
<span class="lineNum">     111 </span>            :         }
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span><span class="lineCov">         14 :         pfree(rawstring);</span>
<span class="lineNum">     114 </span><span class="lineCov">         14 :         list_free(elemlist);</span>
<span class="lineNum">     115 </span>            :     }
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span><span class="lineCov">       1598 :     myextra = (int *) malloc(sizeof(int));</span>
<span class="lineNum">     118 </span><span class="lineCov">       1598 :     if (!myextra)</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     120 </span><span class="lineCov">       1598 :     *myextra = extrachecks;</span>
<span class="lineNum">     121 </span><span class="lineCov">       1598 :     *extra = (void *) myextra;</span>
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span><span class="lineCov">       1598 :     return true;</span>
<span class="lineNum">     124 </span>            : }
<a name="125"><span class="lineNum">     125 </span>            : </a>
<span class="lineNum">     126 </span>            : static void
<span class="lineNum">     127 </span><span class="lineCov">        806 : plpgsql_extra_warnings_assign_hook(const char *newvalue, void *extra)</span>
<span class="lineNum">     128 </span>            : {
<span class="lineNum">     129 </span><span class="lineCov">        806 :     plpgsql_extra_warnings = *((int *) extra);</span>
<span class="lineNum">     130 </span><span class="lineCov">        806 : }</span>
<a name="131"><span class="lineNum">     131 </span>            : </a>
<span class="lineNum">     132 </span>            : static void
<span class="lineNum">     133 </span><span class="lineCov">        804 : plpgsql_extra_errors_assign_hook(const char *newvalue, void *extra)</span>
<span class="lineNum">     134 </span>            : {
<span class="lineNum">     135 </span><span class="lineCov">        804 :     plpgsql_extra_errors = *((int *) extra);</span>
<span class="lineNum">     136 </span><span class="lineCov">        804 : }</span>
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            : /*
<span class="lineNum">     140 </span>            :  * _PG_init()           - library load-time initialization
<span class="lineNum">     141 </span>            :  *
<span class="lineNum">     142 </span>            :  * DO NOT make this static nor change its name!
<a name="143"><span class="lineNum">     143 </span>            :  */</a>
<span class="lineNum">     144 </span>            : void
<span class="lineNum">     145 </span><span class="lineCov">        788 : _PG_init(void)</span>
<span class="lineNum">     146 </span>            : {
<span class="lineNum">     147 </span>            :     /* Be sure we do initialization only once (should be redundant now) */
<span class="lineNum">     148 </span>            :     static bool inited = false;
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span><span class="lineCov">        788 :     if (inited)</span>
<span class="lineNum">     151 </span><span class="lineCov">        788 :         return;</span>
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineCov">        788 :     pg_bindtextdomain(TEXTDOMAIN);</span>
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span><span class="lineCov">        788 :     DefineCustomEnumVariable(&quot;plpgsql.variable_conflict&quot;,</span>
<span class="lineNum">     156 </span>            :                              gettext_noop(&quot;Sets handling of conflicts between PL/pgSQL variable names and table column names.&quot;),
<span class="lineNum">     157 </span>            :                              NULL,
<span class="lineNum">     158 </span>            :                              &amp;plpgsql_variable_conflict,
<span class="lineNum">     159 </span>            :                              PLPGSQL_RESOLVE_ERROR,
<span class="lineNum">     160 </span>            :                              variable_conflict_options,
<span class="lineNum">     161 </span>            :                              PGC_SUSET, 0,
<span class="lineNum">     162 </span>            :                              NULL, NULL, NULL);
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span><span class="lineCov">        788 :     DefineCustomBoolVariable(&quot;plpgsql.print_strict_params&quot;,</span>
<span class="lineNum">     165 </span>            :                              gettext_noop(&quot;Print information about parameters in the DETAIL part of the error messages generated on INTO ... STRICT failures.&quot;),
<span class="lineNum">     166 </span>            :                              NULL,
<span class="lineNum">     167 </span>            :                              &amp;plpgsql_print_strict_params,
<span class="lineNum">     168 </span>            :                              false,
<span class="lineNum">     169 </span>            :                              PGC_USERSET, 0,
<span class="lineNum">     170 </span>            :                              NULL, NULL, NULL);
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineCov">        788 :     DefineCustomBoolVariable(&quot;plpgsql.check_asserts&quot;,</span>
<span class="lineNum">     173 </span>            :                              gettext_noop(&quot;Perform checks given in ASSERT statements.&quot;),
<span class="lineNum">     174 </span>            :                              NULL,
<span class="lineNum">     175 </span>            :                              &amp;plpgsql_check_asserts,
<span class="lineNum">     176 </span>            :                              true,
<span class="lineNum">     177 </span>            :                              PGC_USERSET, 0,
<span class="lineNum">     178 </span>            :                              NULL, NULL, NULL);
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span><span class="lineCov">        788 :     DefineCustomStringVariable(&quot;plpgsql.extra_warnings&quot;,</span>
<span class="lineNum">     181 </span>            :                                gettext_noop(&quot;List of programming constructs that should produce a warning.&quot;),
<span class="lineNum">     182 </span>            :                                NULL,
<span class="lineNum">     183 </span>            :                                &amp;plpgsql_extra_warnings_string,
<span class="lineNum">     184 </span>            :                                &quot;none&quot;,
<span class="lineNum">     185 </span>            :                                PGC_USERSET, GUC_LIST_INPUT,
<span class="lineNum">     186 </span>            :                                plpgsql_extra_checks_check_hook,
<span class="lineNum">     187 </span>            :                                plpgsql_extra_warnings_assign_hook,
<span class="lineNum">     188 </span>            :                                NULL);
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineCov">        788 :     DefineCustomStringVariable(&quot;plpgsql.extra_errors&quot;,</span>
<span class="lineNum">     191 </span>            :                                gettext_noop(&quot;List of programming constructs that should produce an error.&quot;),
<span class="lineNum">     192 </span>            :                                NULL,
<span class="lineNum">     193 </span>            :                                &amp;plpgsql_extra_errors_string,
<span class="lineNum">     194 </span>            :                                &quot;none&quot;,
<span class="lineNum">     195 </span>            :                                PGC_USERSET, GUC_LIST_INPUT,
<span class="lineNum">     196 </span>            :                                plpgsql_extra_checks_check_hook,
<span class="lineNum">     197 </span>            :                                plpgsql_extra_errors_assign_hook,
<span class="lineNum">     198 </span>            :                                NULL);
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span><span class="lineCov">        788 :     EmitWarningsOnPlaceholders(&quot;plpgsql&quot;);</span>
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span><span class="lineCov">        788 :     plpgsql_HashTableInit();</span>
<span class="lineNum">     203 </span><span class="lineCov">        788 :     RegisterXactCallback(plpgsql_xact_cb, NULL);</span>
<span class="lineNum">     204 </span><span class="lineCov">        788 :     RegisterSubXactCallback(plpgsql_subxact_cb, NULL);</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :     /* Set up a rendezvous point with optional instrumentation plugin */
<span class="lineNum">     207 </span><span class="lineCov">        788 :     plpgsql_plugin_ptr = (PLpgSQL_plugin **) find_rendezvous_variable(&quot;PLpgSQL_plugin&quot;);</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span><span class="lineCov">        788 :     inited = true;</span>
<span class="lineNum">     210 </span>            : }
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            : /* ----------
<span class="lineNum">     213 </span>            :  * plpgsql_call_handler
<span class="lineNum">     214 </span>            :  *
<span class="lineNum">     215 </span>            :  * The PostgreSQL function manager and trigger manager
<span class="lineNum">     216 </span>            :  * call this function for execution of PL/pgSQL procedures.
<a name="217"><span class="lineNum">     217 </span>            :  * ----------</a>
<span class="lineNum">     218 </span>            :  */
<span class="lineNum">     219 </span><span class="lineCov">         92 : PG_FUNCTION_INFO_V1(plpgsql_call_handler);</span>
<a name="220"><span class="lineNum">     220 </span>            : </a>
<span class="lineNum">     221 </span>            : Datum
<span class="lineNum">     222 </span><span class="lineCov">      26702 : plpgsql_call_handler(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     223 </span>            : {
<span class="lineNum">     224 </span>            :     bool        nonatomic;
<span class="lineNum">     225 </span>            :     PLpgSQL_function *func;
<span class="lineNum">     226 </span>            :     PLpgSQL_execstate *save_cur_estate;
<span class="lineNum">     227 </span>            :     Datum       retval;
<span class="lineNum">     228 </span>            :     int         rc;
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span><span class="lineCov">      57640 :     nonatomic = fcinfo-&gt;context &amp;&amp;</span>
<span class="lineNum">     231 </span><span class="lineCov">      26704 :         IsA(fcinfo-&gt;context, CallContext) &amp;&amp;</span>
<span class="lineNum">     232 </span><span class="lineCov">          2 :         !castNode(CallContext, fcinfo-&gt;context)-&gt;atomic;</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            :     /*
<span class="lineNum">     235 </span>            :      * Connect to SPI manager
<span class="lineNum">     236 </span>            :      */
<span class="lineNum">     237 </span><span class="lineCov">      26702 :     if ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT)</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;SPI_connect failed: %s&quot;, SPI_result_code_string(rc));</span>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            :     /* Find or compile the function */
<span class="lineNum">     241 </span><span class="lineCov">      26702 :     func = plpgsql_compile(fcinfo, false);</span>
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :     /* Must save and restore prior value of cur_estate */
<span class="lineNum">     244 </span><span class="lineCov">      26702 :     save_cur_estate = func-&gt;cur_estate;</span>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            :     /* Mark the function as busy, so it can't be deleted from under us */
<span class="lineNum">     247 </span><span class="lineCov">      26702 :     func-&gt;use_count++;</span>
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span><span class="lineCov">      26702 :     PG_TRY();</span>
<span class="lineNum">     250 </span>            :     {
<span class="lineNum">     251 </span>            :         /*
<span class="lineNum">     252 </span>            :          * Determine if called as function or trigger and call appropriate
<span class="lineNum">     253 </span>            :          * subhandler
<span class="lineNum">     254 </span>            :          */
<span class="lineNum">     255 </span><span class="lineCov">      26702 :         if (CALLED_AS_TRIGGER(fcinfo))</span>
<span class="lineNum">     256 </span><span class="lineCov">       4002 :             retval = PointerGetDatum(plpgsql_exec_trigger(func,</span>
<span class="lineNum">     257 </span>            :                                                           (TriggerData *) fcinfo-&gt;context));
<span class="lineNum">     258 </span><span class="lineCov">      22700 :         else if (CALLED_AS_EVENT_TRIGGER(fcinfo))</span>
<span class="lineNum">     259 </span>            :         {
<span class="lineNum">     260 </span><span class="lineCov">        132 :             plpgsql_exec_event_trigger(func,</span>
<span class="lineNum">     261 </span><span class="lineCov">        132 :                                        (EventTriggerData *) fcinfo-&gt;context);</span>
<span class="lineNum">     262 </span><span class="lineCov">        124 :             retval = (Datum) 0;</span>
<span class="lineNum">     263 </span>            :         }
<span class="lineNum">     264 </span>            :         else
<span class="lineNum">     265 </span><span class="lineCov">      22568 :             retval = plpgsql_exec_function(func, fcinfo, NULL, !nonatomic);</span>
<span class="lineNum">     266 </span>            :     }
<span class="lineNum">     267 </span><span class="lineCov">        190 :     PG_FINALLY();</span>
<span class="lineNum">     268 </span>            :     {
<span class="lineNum">     269 </span>            :         /* Decrement use-count, restore cur_estate */
<span class="lineNum">     270 </span><span class="lineCov">      26702 :         func-&gt;use_count--;</span>
<span class="lineNum">     271 </span><span class="lineCov">      26702 :         func-&gt;cur_estate = save_cur_estate;</span>
<span class="lineNum">     272 </span>            :     }
<span class="lineNum">     273 </span><span class="lineCov">      26702 :     PG_END_TRY();</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :     /*
<span class="lineNum">     276 </span>            :      * Disconnect from SPI manager
<span class="lineNum">     277 </span>            :      */
<span class="lineNum">     278 </span><span class="lineCov">      26512 :     if ((rc = SPI_finish()) != SPI_OK_FINISH)</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;SPI_finish failed: %s&quot;, SPI_result_code_string(rc));</span>
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineCov">      26512 :     return retval;</span>
<span class="lineNum">     282 </span>            : }
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            : /* ----------
<span class="lineNum">     285 </span>            :  * plpgsql_inline_handler
<span class="lineNum">     286 </span>            :  *
<span class="lineNum">     287 </span>            :  * Called by PostgreSQL to execute an anonymous code block
<a name="288"><span class="lineNum">     288 </span>            :  * ----------</a>
<span class="lineNum">     289 </span>            :  */
<span class="lineNum">     290 </span><span class="lineCov">         32 : PG_FUNCTION_INFO_V1(plpgsql_inline_handler);</span>
<a name="291"><span class="lineNum">     291 </span>            : </a>
<span class="lineNum">     292 </span>            : Datum
<span class="lineNum">     293 </span><span class="lineCov">        106 : plpgsql_inline_handler(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     294 </span>            : {
<span class="lineNum">     295 </span><span class="lineCov">        106 :     LOCAL_FCINFO(fake_fcinfo, 0);</span>
<span class="lineNum">     296 </span><span class="lineCov">        106 :     InlineCodeBlock *codeblock = castNode(InlineCodeBlock, DatumGetPointer(PG_GETARG_DATUM(0)));</span>
<span class="lineNum">     297 </span>            :     PLpgSQL_function *func;
<span class="lineNum">     298 </span>            :     FmgrInfo    flinfo;
<span class="lineNum">     299 </span>            :     EState     *simple_eval_estate;
<span class="lineNum">     300 </span>            :     Datum       retval;
<span class="lineNum">     301 </span>            :     int         rc;
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            :     /*
<span class="lineNum">     304 </span>            :      * Connect to SPI manager
<span class="lineNum">     305 </span>            :      */
<span class="lineNum">     306 </span><span class="lineCov">        106 :     if ((rc = SPI_connect_ext(codeblock-&gt;atomic ? 0 : SPI_OPT_NONATOMIC)) != SPI_OK_CONNECT)</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;SPI_connect failed: %s&quot;, SPI_result_code_string(rc));</span>
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            :     /* Compile the anonymous code block */
<span class="lineNum">     310 </span><span class="lineCov">        106 :     func = plpgsql_compile_inline(codeblock-&gt;source_text);</span>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :     /* Mark the function as busy, just pro forma */
<span class="lineNum">     313 </span><span class="lineCov">        104 :     func-&gt;use_count++;</span>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :     /*
<span class="lineNum">     316 </span>            :      * Set up a fake fcinfo with just enough info to satisfy
<span class="lineNum">     317 </span>            :      * plpgsql_exec_function().  In particular note that this sets things up
<span class="lineNum">     318 </span>            :      * with no arguments passed.
<span class="lineNum">     319 </span>            :      */
<span class="lineNum">     320 </span><span class="lineCov">        104 :     MemSet(fake_fcinfo, 0, SizeForFunctionCallInfo(0));</span>
<span class="lineNum">     321 </span><span class="lineCov">        104 :     MemSet(&amp;flinfo, 0, sizeof(flinfo));</span>
<span class="lineNum">     322 </span><span class="lineCov">        104 :     fake_fcinfo-&gt;flinfo = &amp;flinfo;</span>
<span class="lineNum">     323 </span><span class="lineCov">        104 :     flinfo.fn_oid = InvalidOid;</span>
<span class="lineNum">     324 </span><span class="lineCov">        104 :     flinfo.fn_mcxt = CurrentMemoryContext;</span>
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            :     /* Create a private EState for simple-expression execution */
<span class="lineNum">     327 </span><span class="lineCov">        104 :     simple_eval_estate = CreateExecutorState();</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :     /* And run the function */
<span class="lineNum">     330 </span><span class="lineCov">        104 :     PG_TRY();</span>
<span class="lineNum">     331 </span>            :     {
<span class="lineNum">     332 </span><span class="lineCov">        104 :         retval = plpgsql_exec_function(func, fake_fcinfo, simple_eval_estate, codeblock-&gt;atomic);</span>
<span class="lineNum">     333 </span>            :     }
<span class="lineNum">     334 </span><span class="lineCov">         50 :     PG_CATCH();</span>
<span class="lineNum">     335 </span>            :     {
<span class="lineNum">     336 </span>            :         /*
<span class="lineNum">     337 </span>            :          * We need to clean up what would otherwise be long-lived resources
<span class="lineNum">     338 </span>            :          * accumulated by the failed DO block, principally cached plans for
<span class="lineNum">     339 </span>            :          * statements (which can be flushed with plpgsql_free_function_memory)
<span class="lineNum">     340 </span>            :          * and execution trees for simple expressions, which are in the
<span class="lineNum">     341 </span>            :          * private EState.
<span class="lineNum">     342 </span>            :          *
<span class="lineNum">     343 </span>            :          * Before releasing the private EState, we must clean up any
<span class="lineNum">     344 </span>            :          * simple_econtext_stack entries pointing into it, which we can do by
<span class="lineNum">     345 </span>            :          * invoking the subxact callback.  (It will be called again later if
<span class="lineNum">     346 </span>            :          * some outer control level does a subtransaction abort, but no harm
<span class="lineNum">     347 </span>            :          * is done.)  We cheat a bit knowing that plpgsql_subxact_cb does not
<span class="lineNum">     348 </span>            :          * pay attention to its parentSubid argument.
<span class="lineNum">     349 </span>            :          */
<span class="lineNum">     350 </span><span class="lineCov">         50 :         plpgsql_subxact_cb(SUBXACT_EVENT_ABORT_SUB,</span>
<span class="lineNum">     351 </span>            :                            GetCurrentSubTransactionId(),
<span class="lineNum">     352 </span>            :                            0, NULL);
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :         /* Clean up the private EState */
<span class="lineNum">     355 </span><span class="lineCov">         50 :         FreeExecutorState(simple_eval_estate);</span>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            :         /* Function should now have no remaining use-counts ... */
<span class="lineNum">     358 </span><span class="lineCov">         50 :         func-&gt;use_count--;</span>
<span class="lineNum">     359 </span><span class="lineCov">         50 :         Assert(func-&gt;use_count == 0);</span>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :         /* ... so we can free subsidiary storage */
<span class="lineNum">     362 </span><span class="lineCov">         50 :         plpgsql_free_function_memory(func);</span>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            :         /* And propagate the error */
<span class="lineNum">     365 </span><span class="lineCov">         50 :         PG_RE_THROW();</span>
<span class="lineNum">     366 </span>            :     }
<span class="lineNum">     367 </span><span class="lineCov">         54 :     PG_END_TRY();</span>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            :     /* Clean up the private EState */
<span class="lineNum">     370 </span><span class="lineCov">         54 :     FreeExecutorState(simple_eval_estate);</span>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            :     /* Function should now have no remaining use-counts ... */
<span class="lineNum">     373 </span><span class="lineCov">         54 :     func-&gt;use_count--;</span>
<span class="lineNum">     374 </span><span class="lineCov">         54 :     Assert(func-&gt;use_count == 0);</span>
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            :     /* ... so we can free subsidiary storage */
<span class="lineNum">     377 </span><span class="lineCov">         54 :     plpgsql_free_function_memory(func);</span>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :     /*
<span class="lineNum">     380 </span>            :      * Disconnect from SPI manager
<span class="lineNum">     381 </span>            :      */
<span class="lineNum">     382 </span><span class="lineCov">         54 :     if ((rc = SPI_finish()) != SPI_OK_FINISH)</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;SPI_finish failed: %s&quot;, SPI_result_code_string(rc));</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span><span class="lineCov">         54 :     return retval;</span>
<span class="lineNum">     386 </span>            : }
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            : /* ----------
<span class="lineNum">     389 </span>            :  * plpgsql_validator
<span class="lineNum">     390 </span>            :  *
<span class="lineNum">     391 </span>            :  * This function attempts to validate a PL/pgSQL function at
<span class="lineNum">     392 </span>            :  * CREATE FUNCTION time.
<a name="393"><span class="lineNum">     393 </span>            :  * ----------</a>
<span class="lineNum">     394 </span>            :  */
<span class="lineNum">     395 </span><span class="lineCov">         98 : PG_FUNCTION_INFO_V1(plpgsql_validator);</span>
<a name="396"><span class="lineNum">     396 </span>            : </a>
<span class="lineNum">     397 </span>            : Datum
<span class="lineNum">     398 </span><span class="lineCov">        758 : plpgsql_validator(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     399 </span>            : {
<span class="lineNum">     400 </span><span class="lineCov">        758 :     Oid         funcoid = PG_GETARG_OID(0);</span>
<span class="lineNum">     401 </span>            :     HeapTuple   tuple;
<span class="lineNum">     402 </span>            :     Form_pg_proc proc;
<span class="lineNum">     403 </span>            :     char        functyptype;
<span class="lineNum">     404 </span>            :     int         numargs;
<span class="lineNum">     405 </span>            :     Oid        *argtypes;
<span class="lineNum">     406 </span>            :     char      **argnames;
<span class="lineNum">     407 </span>            :     char       *argmodes;
<span class="lineNum">     408 </span><span class="lineCov">        758 :     bool        is_dml_trigger = false;</span>
<span class="lineNum">     409 </span><span class="lineCov">        758 :     bool        is_event_trigger = false;</span>
<span class="lineNum">     410 </span>            :     int         i;
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span><span class="lineCov">        758 :     if (!CheckFunctionValidatorAccess(fcinfo-&gt;flinfo-&gt;fn_oid, funcoid))</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :         PG_RETURN_VOID();</span>
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            :     /* Get the new function's pg_proc entry */
<span class="lineNum">     416 </span><span class="lineCov">        758 :     tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));</span>
<span class="lineNum">     417 </span><span class="lineCov">        758 :     if (!HeapTupleIsValid(tuple))</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cache lookup failed for function %u&quot;, funcoid);</span>
<span class="lineNum">     419 </span><span class="lineCov">        758 :     proc = (Form_pg_proc) GETSTRUCT(tuple);</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span><span class="lineCov">        758 :     functyptype = get_typtype(proc-&gt;prorettype);</span>
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            :     /* Disallow pseudotype result */
<span class="lineNum">     424 </span>            :     /* except for TRIGGER, RECORD, VOID, or polymorphic */
<span class="lineNum">     425 </span><span class="lineCov">        758 :     if (functyptype == TYPTYPE_PSEUDO)</span>
<span class="lineNum">     426 </span>            :     {
<span class="lineNum">     427 </span>            :         /* we assume OPAQUE with no arguments means a trigger */
<span class="lineNum">     428 </span><span class="lineCov">        634 :         if (proc-&gt;prorettype == TRIGGEROID ||</span>
<span class="lineNum">     429 </span><span class="lineCov">        216 :             (proc-&gt;prorettype == OPAQUEOID &amp;&amp; proc-&gt;pronargs == 0))</span>
<span class="lineNum">     430 </span><span class="lineCov">        202 :             is_dml_trigger = true;</span>
<span class="lineNum">     431 </span><span class="lineCov">        216 :         else if (proc-&gt;prorettype == EVTTRIGGEROID)</span>
<span class="lineNum">     432 </span><span class="lineCov">         24 :             is_event_trigger = true;</span>
<span class="lineNum">     433 </span><span class="lineCov">        350 :         else if (proc-&gt;prorettype != RECORDOID &amp;&amp;</span>
<span class="lineNum">     434 </span><span class="lineCov">        160 :                  proc-&gt;prorettype != VOIDOID &amp;&amp;</span>
<span class="lineNum">     435 </span><span class="lineCov">          4 :                  !IsPolymorphicType(proc-&gt;prorettype))</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">     437 </span>            :                     (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">     438 </span>            :                      errmsg(&quot;PL/pgSQL functions cannot return type %s&quot;,
<span class="lineNum">     439 </span>            :                             format_type_be(proc-&gt;prorettype))));
<span class="lineNum">     440 </span>            :     }
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :     /* Disallow pseudotypes in arguments (either IN or OUT) */
<span class="lineNum">     443 </span>            :     /* except for RECORD and polymorphic */
<span class="lineNum">     444 </span><span class="lineCov">        758 :     numargs = get_func_arg_info(tuple,</span>
<span class="lineNum">     445 </span>            :                                 &amp;argtypes, &amp;argnames, &amp;argmodes);
<span class="lineNum">     446 </span><span class="lineCov">       1178 :     for (i = 0; i &lt; numargs; i++)</span>
<span class="lineNum">     447 </span>            :     {
<span class="lineNum">     448 </span><span class="lineCov">        420 :         if (get_typtype(argtypes[i]) == TYPTYPE_PSEUDO)</span>
<span class="lineNum">     449 </span>            :         {
<span class="lineNum">     450 </span><span class="lineCov">         60 :             if (argtypes[i] != RECORDOID &amp;&amp;</span>
<span class="lineNum">     451 </span><span class="lineCov">         50 :                 !IsPolymorphicType(argtypes[i]))</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :                 ereport(ERROR,</span>
<span class="lineNum">     453 </span>            :                         (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">     454 </span>            :                          errmsg(&quot;PL/pgSQL functions cannot accept type %s&quot;,
<span class="lineNum">     455 </span>            :                                 format_type_be(argtypes[i]))));
<span class="lineNum">     456 </span>            :         }
<span class="lineNum">     457 </span>            :     }
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :     /* Postpone body checks if !check_function_bodies */
<span class="lineNum">     460 </span><span class="lineCov">        758 :     if (check_function_bodies)</span>
<span class="lineNum">     461 </span>            :     {
<span class="lineNum">     462 </span><span class="lineCov">        758 :         LOCAL_FCINFO(fake_fcinfo, 0);</span>
<span class="lineNum">     463 </span>            :         FmgrInfo    flinfo;
<span class="lineNum">     464 </span>            :         int         rc;
<span class="lineNum">     465 </span>            :         TriggerData trigdata;
<span class="lineNum">     466 </span>            :         EventTriggerData etrigdata;
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            :         /*
<span class="lineNum">     469 </span>            :          * Connect to SPI manager (is this needed for compilation?)
<span class="lineNum">     470 </span>            :          */
<span class="lineNum">     471 </span><span class="lineCov">        758 :         if ((rc = SPI_connect()) != SPI_OK_CONNECT)</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;SPI_connect failed: %s&quot;, SPI_result_code_string(rc));</span>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :         /*
<span class="lineNum">     475 </span>            :          * Set up a fake fcinfo with just enough info to satisfy
<span class="lineNum">     476 </span>            :          * plpgsql_compile().
<span class="lineNum">     477 </span>            :          */
<span class="lineNum">     478 </span><span class="lineCov">        758 :         MemSet(fake_fcinfo, 0, SizeForFunctionCallInfo(0));</span>
<span class="lineNum">     479 </span><span class="lineCov">        758 :         MemSet(&amp;flinfo, 0, sizeof(flinfo));</span>
<span class="lineNum">     480 </span><span class="lineCov">        758 :         fake_fcinfo-&gt;flinfo = &amp;flinfo;</span>
<span class="lineNum">     481 </span><span class="lineCov">        758 :         flinfo.fn_oid = funcoid;</span>
<span class="lineNum">     482 </span><span class="lineCov">        758 :         flinfo.fn_mcxt = CurrentMemoryContext;</span>
<span class="lineNum">     483 </span><span class="lineCov">        758 :         if (is_dml_trigger)</span>
<span class="lineNum">     484 </span>            :         {
<span class="lineNum">     485 </span><span class="lineCov">        202 :             MemSet(&amp;trigdata, 0, sizeof(trigdata));</span>
<span class="lineNum">     486 </span><span class="lineCov">        202 :             trigdata.type = T_TriggerData;</span>
<span class="lineNum">     487 </span><span class="lineCov">        202 :             fake_fcinfo-&gt;context = (Node *) &amp;trigdata;</span>
<span class="lineNum">     488 </span>            :         }
<span class="lineNum">     489 </span><span class="lineCov">        556 :         else if (is_event_trigger)</span>
<span class="lineNum">     490 </span>            :         {
<span class="lineNum">     491 </span><span class="lineCov">         24 :             MemSet(&amp;etrigdata, 0, sizeof(etrigdata));</span>
<span class="lineNum">     492 </span><span class="lineCov">         24 :             etrigdata.type = T_EventTriggerData;</span>
<span class="lineNum">     493 </span><span class="lineCov">         24 :             fake_fcinfo-&gt;context = (Node *) &amp;etrigdata;</span>
<span class="lineNum">     494 </span>            :         }
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            :         /* Test-compile the function */
<span class="lineNum">     497 </span><span class="lineCov">        758 :         plpgsql_compile(fake_fcinfo, true);</span>
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            :         /*
<span class="lineNum">     500 </span>            :          * Disconnect from SPI manager
<span class="lineNum">     501 </span>            :          */
<span class="lineNum">     502 </span><span class="lineCov">        728 :         if ((rc = SPI_finish()) != SPI_OK_FINISH)</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;SPI_finish failed: %s&quot;, SPI_result_code_string(rc));</span>
<span class="lineNum">     504 </span>            :     }
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span><span class="lineCov">        728 :     ReleaseSysCache(tuple);</span>
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span><span class="lineCov">        728 :     PG_RETURN_VOID();</span>
<span class="lineNum">     509 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
