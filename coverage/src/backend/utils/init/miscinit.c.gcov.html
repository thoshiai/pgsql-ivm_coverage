<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/utils/init/miscinit.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/backend/utils/init</a> - miscinit.c<span style="font-size: 80%;"> (source / <a href="miscinit.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">259</td>
            <td class="headerCovTableEntry">415</td>
            <td class="headerCovTableEntryLo">62.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">35</td>
            <td class="headerCovTableEntry">40</td>
            <td class="headerCovTableEntryMed">87.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * miscinit.c
<span class="lineNum">       4 </span>            :  *    miscellaneous initialization support stuff
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * IDENTIFICATION
<span class="lineNum">      11 </span>            :  *    src/backend/utils/init/miscinit.c
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      14 </span>            :  */
<span class="lineNum">      15 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &lt;sys/param.h&gt;
<span class="lineNum">      18 </span>            : #include &lt;signal.h&gt;
<span class="lineNum">      19 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;sys/file.h&gt;
<span class="lineNum">      21 </span>            : #include &lt;sys/stat.h&gt;
<span class="lineNum">      22 </span>            : #include &lt;sys/time.h&gt;
<span class="lineNum">      23 </span>            : #include &lt;fcntl.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">      25 </span>            : #include &lt;grp.h&gt;
<span class="lineNum">      26 </span>            : #include &lt;pwd.h&gt;
<span class="lineNum">      27 </span>            : #include &lt;netinet/in.h&gt;
<span class="lineNum">      28 </span>            : #include &lt;arpa/inet.h&gt;
<span class="lineNum">      29 </span>            : #ifdef HAVE_UTIME_H
<span class="lineNum">      30 </span>            : #include &lt;utime.h&gt;
<span class="lineNum">      31 </span>            : #endif
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : #include &quot;access/htup_details.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;catalog/pg_authid.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;common/file_perm.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;libpq/libpq.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;mb/pg_wchar.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;miscadmin.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;pgstat.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;postmaster/autovacuum.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;postmaster/postmaster.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;storage/fd.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;storage/ipc.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;storage/latch.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;storage/pg_shmem.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;storage/pmsignal.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;storage/proc.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;storage/procarray.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;utils/builtins.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;utils/guc.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;utils/inval.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;utils/memutils.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;utils/pidfile.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;utils/syscache.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;utils/varlena.h&quot;
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : #define DIRECTORY_LOCK_FILE     &quot;postmaster.pid&quot;
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : ProcessingMode Mode = InitProcessing;
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : /* List of lock files to be removed at proc exit */
<span class="lineNum">      63 </span>            : static List *lock_files = NIL;
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : static Latch LocalLatchData;
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : /* ----------------------------------------------------------------
<span class="lineNum">      68 </span>            :  *      ignoring system indexes support stuff
<span class="lineNum">      69 </span>            :  *
<span class="lineNum">      70 </span>            :  * NOTE: &quot;ignoring system indexes&quot; means we do not use the system indexes
<span class="lineNum">      71 </span>            :  * for lookups (either in hardwired catalog accesses or in planner-generated
<span class="lineNum">      72 </span>            :  * plans).  We do, however, still update the indexes when a catalog
<span class="lineNum">      73 </span>            :  * modification is made.
<span class="lineNum">      74 </span>            :  * ----------------------------------------------------------------
<span class="lineNum">      75 </span>            :  */
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : bool        IgnoreSystemIndexes = false;
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : /* ----------------------------------------------------------------
<span class="lineNum">      81 </span>            :  *              database path / name support stuff
<span class="lineNum">      82 </span>            :  * ----------------------------------------------------------------
<span class="lineNum">      83 </span>            :  */
<a name="84"><span class="lineNum">      84 </span>            : </a>
<span class="lineNum">      85 </span>            : void
<span class="lineNum">      86 </span><span class="lineCov">       1208 : SetDatabasePath(const char *path)</span>
<span class="lineNum">      87 </span>            : {
<span class="lineNum">      88 </span>            :     /* This should happen only once per process */
<span class="lineNum">      89 </span><span class="lineCov">       1208 :     Assert(!DatabasePath);</span>
<span class="lineNum">      90 </span><span class="lineCov">       1208 :     DatabasePath = MemoryContextStrdup(TopMemoryContext, path);</span>
<span class="lineNum">      91 </span><span class="lineCov">       1208 : }</span>
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : /*
<span class="lineNum">      94 </span>            :  * Validate the proposed data directory.
<span class="lineNum">      95 </span>            :  *
<span class="lineNum">      96 </span>            :  * Also initialize file and directory create modes and mode mask.
<a name="97"><span class="lineNum">      97 </span>            :  */</a>
<span class="lineNum">      98 </span>            : void
<span class="lineNum">      99 </span><span class="lineCov">       1228 : checkDataDir(void)</span>
<span class="lineNum">     100 </span>            : {
<span class="lineNum">     101 </span>            :     struct stat stat_buf;
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span><span class="lineCov">       1228 :     Assert(DataDir);</span>
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span><span class="lineCov">       1228 :     if (stat(DataDir, &amp;stat_buf) != 0)</span>
<span class="lineNum">     106 </span>            :     {
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :         if (errno == ENOENT)</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     109 </span>            :                     (errcode_for_file_access(),
<span class="lineNum">     110 </span>            :                      errmsg(&quot;data directory \&quot;%s\&quot; does not exist&quot;,
<span class="lineNum">     111 </span>            :                             DataDir)));
<span class="lineNum">     112 </span>            :         else
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     114 </span>            :                     (errcode_for_file_access(),
<span class="lineNum">     115 </span>            :                      errmsg(&quot;could not read permissions of directory \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">     116 </span>            :                             DataDir)));
<span class="lineNum">     117 </span>            :     }
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            :     /* eventual chdir would fail anyway, but let's test ... */
<span class="lineNum">     120 </span><span class="lineCov">       1228 :     if (!S_ISDIR(stat_buf.st_mode))</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">     122 </span>            :                 (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),
<span class="lineNum">     123 </span>            :                  errmsg(&quot;specified data directory \&quot;%s\&quot; is not a directory&quot;,
<span class="lineNum">     124 </span>            :                         DataDir)));
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            :     /*
<span class="lineNum">     127 </span>            :      * Check that the directory belongs to my userid; if not, reject.
<span class="lineNum">     128 </span>            :      *
<span class="lineNum">     129 </span>            :      * This check is an essential part of the interlock that prevents two
<span class="lineNum">     130 </span>            :      * postmasters from starting in the same directory (see CreateLockFile()).
<span class="lineNum">     131 </span>            :      * Do not remove or weaken it.
<span class="lineNum">     132 </span>            :      *
<span class="lineNum">     133 </span>            :      * XXX can we safely enable this check on Windows?
<span class="lineNum">     134 </span>            :      */
<span class="lineNum">     135 </span>            : #if !defined(WIN32) &amp;&amp; !defined(__CYGWIN__)
<span class="lineNum">     136 </span><span class="lineCov">       1228 :     if (stat_buf.st_uid != geteuid())</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">     138 </span>            :                 (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),
<span class="lineNum">     139 </span>            :                  errmsg(&quot;data directory \&quot;%s\&quot; has wrong ownership&quot;,
<span class="lineNum">     140 </span>            :                         DataDir),
<span class="lineNum">     141 </span>            :                  errhint(&quot;The server must be started by the user that owns the data directory.&quot;)));
<span class="lineNum">     142 </span>            : #endif
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            :     /*
<span class="lineNum">     145 </span>            :      * Check if the directory has correct permissions.  If not, reject.
<span class="lineNum">     146 </span>            :      *
<span class="lineNum">     147 </span>            :      * Only two possible modes are allowed, 0700 and 0750.  The latter mode
<span class="lineNum">     148 </span>            :      * indicates that group read/execute should be allowed on all newly
<span class="lineNum">     149 </span>            :      * created files and directories.
<span class="lineNum">     150 </span>            :      *
<span class="lineNum">     151 </span>            :      * XXX temporarily suppress check when on Windows, because there may not
<span class="lineNum">     152 </span>            :      * be proper support for Unix-y file permissions.  Need to think of a
<span class="lineNum">     153 </span>            :      * reasonable check to apply on Windows.
<span class="lineNum">     154 </span>            :      */
<span class="lineNum">     155 </span>            : #if !defined(WIN32) &amp;&amp; !defined(__CYGWIN__)
<span class="lineNum">     156 </span><span class="lineCov">       1228 :     if (stat_buf.st_mode &amp; PG_MODE_MASK_GROUP)</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">     158 </span>            :                 (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),
<span class="lineNum">     159 </span>            :                  errmsg(&quot;data directory \&quot;%s\&quot; has invalid permissions&quot;,
<span class="lineNum">     160 </span>            :                         DataDir),
<span class="lineNum">     161 </span>            :                  errdetail(&quot;Permissions should be u=rwx (0700) or u=rwx,g=rx (0750).&quot;)));
<span class="lineNum">     162 </span>            : #endif
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :     /*
<span class="lineNum">     165 </span>            :      * Reset creation modes and mask based on the mode of the data directory.
<span class="lineNum">     166 </span>            :      *
<span class="lineNum">     167 </span>            :      * The mask was set earlier in startup to disallow group permissions on
<span class="lineNum">     168 </span>            :      * newly created files and directories.  However, if group read/execute
<span class="lineNum">     169 </span>            :      * are present on the data directory then modify the create modes and mask
<span class="lineNum">     170 </span>            :      * to allow group read/execute on newly created files and directories and
<span class="lineNum">     171 </span>            :      * set the data_directory_mode GUC.
<span class="lineNum">     172 </span>            :      *
<span class="lineNum">     173 </span>            :      * Suppress when on Windows, because there may not be proper support for
<span class="lineNum">     174 </span>            :      * Unix-y file permissions.
<span class="lineNum">     175 </span>            :      */
<span class="lineNum">     176 </span>            : #if !defined(WIN32) &amp;&amp; !defined(__CYGWIN__)
<span class="lineNum">     177 </span><span class="lineCov">       1228 :     SetDataDirectoryCreatePerm(stat_buf.st_mode);</span>
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span><span class="lineCov">       1228 :     umask(pg_mode_mask);</span>
<span class="lineNum">     180 </span><span class="lineCov">       1228 :     data_directory_mode = pg_dir_create_mode;</span>
<span class="lineNum">     181 </span>            : #endif
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            :     /* Check for PG_VERSION */
<span class="lineNum">     184 </span><span class="lineCov">       1228 :     ValidatePgVersion(DataDir);</span>
<span class="lineNum">     185 </span><span class="lineCov">       1228 : }</span>
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            : /*
<span class="lineNum">     188 </span>            :  * Set data directory, but make sure it's an absolute path.  Use this,
<span class="lineNum">     189 </span>            :  * never set DataDir directly.
<a name="190"><span class="lineNum">     190 </span>            :  */</a>
<span class="lineNum">     191 </span>            : void
<span class="lineNum">     192 </span><span class="lineCov">       1228 : SetDataDir(const char *dir)</span>
<span class="lineNum">     193 </span>            : {
<span class="lineNum">     194 </span>            :     char       *new;
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span><span class="lineCov">       1228 :     AssertArg(dir);</span>
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :     /* If presented path is relative, convert to absolute */
<span class="lineNum">     199 </span><span class="lineCov">       1228 :     new = make_absolute_path(dir);</span>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span><span class="lineCov">       1228 :     if (DataDir)</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :         free(DataDir);</span>
<span class="lineNum">     203 </span><span class="lineCov">       1228 :     DataDir = new;</span>
<span class="lineNum">     204 </span><span class="lineCov">       1228 : }</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            : /*
<span class="lineNum">     207 </span>            :  * Change working directory to DataDir.  Most of the postmaster and backend
<span class="lineNum">     208 </span>            :  * code assumes that we are in DataDir so it can use relative paths to access
<span class="lineNum">     209 </span>            :  * stuff in and under the data directory.  For convenience during path
<span class="lineNum">     210 </span>            :  * setup, however, we don't force the chdir to occur during SetDataDir.
<a name="211"><span class="lineNum">     211 </span>            :  */</a>
<span class="lineNum">     212 </span>            : void
<span class="lineNum">     213 </span><span class="lineCov">       1228 : ChangeToDataDir(void)</span>
<span class="lineNum">     214 </span>            : {
<span class="lineNum">     215 </span><span class="lineCov">       1228 :     AssertState(DataDir);</span>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineCov">       1228 :     if (chdir(DataDir) &lt; 0)</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">     219 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">     220 </span>            :                  errmsg(&quot;could not change directory to \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">     221 </span>            :                         DataDir)));
<span class="lineNum">     222 </span><span class="lineCov">       1228 : }</span>
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            : /* ----------------------------------------------------------------
<span class="lineNum">     226 </span>            :  *  User ID state
<span class="lineNum">     227 </span>            :  *
<span class="lineNum">     228 </span>            :  * We have to track several different values associated with the concept
<span class="lineNum">     229 </span>            :  * of &quot;user ID&quot;.
<span class="lineNum">     230 </span>            :  *
<span class="lineNum">     231 </span>            :  * AuthenticatedUserId is determined at connection start and never changes.
<span class="lineNum">     232 </span>            :  *
<span class="lineNum">     233 </span>            :  * SessionUserId is initially the same as AuthenticatedUserId, but can be
<span class="lineNum">     234 </span>            :  * changed by SET SESSION AUTHORIZATION (if AuthenticatedUserIsSuperuser).
<span class="lineNum">     235 </span>            :  * This is the ID reported by the SESSION_USER SQL function.
<span class="lineNum">     236 </span>            :  *
<span class="lineNum">     237 </span>            :  * OuterUserId is the current user ID in effect at the &quot;outer level&quot; (outside
<span class="lineNum">     238 </span>            :  * any transaction or function).  This is initially the same as SessionUserId,
<span class="lineNum">     239 </span>            :  * but can be changed by SET ROLE to any role that SessionUserId is a
<span class="lineNum">     240 </span>            :  * member of.  (XXX rename to something like CurrentRoleId?)
<span class="lineNum">     241 </span>            :  *
<span class="lineNum">     242 </span>            :  * CurrentUserId is the current effective user ID; this is the one to use
<span class="lineNum">     243 </span>            :  * for all normal permissions-checking purposes.  At outer level this will
<span class="lineNum">     244 </span>            :  * be the same as OuterUserId, but it changes during calls to SECURITY
<span class="lineNum">     245 </span>            :  * DEFINER functions, as well as locally in some specialized commands.
<span class="lineNum">     246 </span>            :  *
<span class="lineNum">     247 </span>            :  * SecurityRestrictionContext holds flags indicating reason(s) for changing
<span class="lineNum">     248 </span>            :  * CurrentUserId.  In some cases we need to lock down operations that are
<span class="lineNum">     249 </span>            :  * not directly controlled by privilege settings, and this provides a
<span class="lineNum">     250 </span>            :  * convenient way to do it.
<span class="lineNum">     251 </span>            :  * ----------------------------------------------------------------
<span class="lineNum">     252 </span>            :  */
<span class="lineNum">     253 </span>            : static Oid  AuthenticatedUserId = InvalidOid;
<span class="lineNum">     254 </span>            : static Oid  SessionUserId = InvalidOid;
<span class="lineNum">     255 </span>            : static Oid  OuterUserId = InvalidOid;
<span class="lineNum">     256 </span>            : static Oid  CurrentUserId = InvalidOid;
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : /* We also have to remember the superuser state of some of these levels */
<span class="lineNum">     259 </span>            : static bool AuthenticatedUserIsSuperuser = false;
<span class="lineNum">     260 </span>            : static bool SessionUserIsSuperuser = false;
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : static int  SecurityRestrictionContext = 0;
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            : /* We also remember if a SET ROLE is currently active */
<span class="lineNum">     265 </span>            : static bool SetRoleIsActive = false;
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            : /*
<span class="lineNum">     268 </span>            :  * Initialize the basic environment for a postmaster child
<span class="lineNum">     269 </span>            :  *
<span class="lineNum">     270 </span>            :  * Should be called as early as possible after the child's startup.
<a name="271"><span class="lineNum">     271 </span>            :  */</a>
<span class="lineNum">     272 </span>            : void
<span class="lineNum">     273 </span><span class="lineCov">       1218 : InitPostmasterChild(void)</span>
<span class="lineNum">     274 </span>            : {
<span class="lineNum">     275 </span><span class="lineCov">       1218 :     IsUnderPostmaster = true;   /* we are a postmaster subprocess now */</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineCov">       1218 :     InitProcessGlobals();</span>
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            :     /*
<span class="lineNum">     280 </span>            :      * make sure stderr is in binary mode before anything can possibly be
<span class="lineNum">     281 </span>            :      * written to it, in case it's actually the syslogger pipe, so the pipe
<span class="lineNum">     282 </span>            :      * chunking protocol isn't disturbed. Non-logpipe data gets translated on
<span class="lineNum">     283 </span>            :      * redirection (e.g. via pg_ctl -l) anyway.
<span class="lineNum">     284 </span>            :      */
<span class="lineNum">     285 </span>            : #ifdef WIN32
<span class="lineNum">     286 </span>            :     _setmode(fileno(stderr), _O_BINARY);
<span class="lineNum">     287 </span>            : #endif
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :     /* We don't want the postmaster's proc_exit() handlers */
<span class="lineNum">     290 </span><span class="lineCov">       1218 :     on_exit_reset();</span>
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :     /* Initialize process-local latch support */
<span class="lineNum">     293 </span><span class="lineCov">       1218 :     InitializeLatchSupport();</span>
<span class="lineNum">     294 </span><span class="lineCov">       1218 :     MyLatch = &amp;LocalLatchData;</span>
<span class="lineNum">     295 </span><span class="lineCov">       1218 :     InitLatch(MyLatch);</span>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :     /*
<span class="lineNum">     298 </span>            :      * If possible, make this process a group leader, so that the postmaster
<span class="lineNum">     299 </span>            :      * can signal any child processes too. Not all processes will have
<span class="lineNum">     300 </span>            :      * children, but for consistency we make all postmaster child processes do
<span class="lineNum">     301 </span>            :      * this.
<span class="lineNum">     302 </span>            :      */
<span class="lineNum">     303 </span>            : #ifdef HAVE_SETSID
<span class="lineNum">     304 </span><span class="lineCov">       1218 :     if (setsid() &lt; 0)</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         elog(FATAL, &quot;setsid() failed: %m&quot;);</span>
<span class="lineNum">     306 </span>            : #endif
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :     /* Request a signal if the postmaster dies, if possible. */
<span class="lineNum">     309 </span><span class="lineCov">       1218 :     PostmasterDeathSignalInit();</span>
<span class="lineNum">     310 </span><span class="lineCov">       1218 : }</span>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : /*
<span class="lineNum">     313 </span>            :  * Initialize the basic environment for a standalone process.
<span class="lineNum">     314 </span>            :  *
<span class="lineNum">     315 </span>            :  * argv0 has to be suitable to find the program's executable.
<a name="316"><span class="lineNum">     316 </span>            :  */</a>
<span class="lineNum">     317 </span>            : void
<span class="lineNum">     318 </span><span class="lineCov">          8 : InitStandaloneProcess(const char *argv0)</span>
<span class="lineNum">     319 </span>            : {
<span class="lineNum">     320 </span><span class="lineCov">          8 :     Assert(!IsPostmasterEnvironment);</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span><span class="lineCov">          8 :     InitProcessGlobals();</span>
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            :     /* Initialize process-local latch support */
<span class="lineNum">     325 </span><span class="lineCov">          8 :     InitializeLatchSupport();</span>
<span class="lineNum">     326 </span><span class="lineCov">          8 :     MyLatch = &amp;LocalLatchData;</span>
<span class="lineNum">     327 </span><span class="lineCov">          8 :     InitLatch(MyLatch);</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :     /* Compute paths, no postmaster to inherit from */
<span class="lineNum">     330 </span><span class="lineCov">          8 :     if (my_exec_path[0] == '\0')</span>
<span class="lineNum">     331 </span>            :     {
<span class="lineNum">     332 </span><span class="lineCov">          8 :         if (find_my_exec(argv0, my_exec_path) &lt; 0)</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :             elog(FATAL, &quot;%s: could not locate my own executable path&quot;,</span>
<span class="lineNum">     334 </span>            :                  argv0);
<span class="lineNum">     335 </span>            :     }
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span><span class="lineCov">          8 :     if (pkglib_path[0] == '\0')</span>
<span class="lineNum">     338 </span><span class="lineCov">          8 :         get_pkglib_path(my_exec_path, pkglib_path);</span>
<span class="lineNum">     339 </span><span class="lineCov">          8 : }</span>
<a name="340"><span class="lineNum">     340 </span>            : </a>
<span class="lineNum">     341 </span>            : void
<span class="lineNum">     342 </span><span class="lineCov">       1220 : SwitchToSharedLatch(void)</span>
<span class="lineNum">     343 </span>            : {
<span class="lineNum">     344 </span><span class="lineCov">       1220 :     Assert(MyLatch == &amp;LocalLatchData);</span>
<span class="lineNum">     345 </span><span class="lineCov">       1220 :     Assert(MyProc != NULL);</span>
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span><span class="lineCov">       1220 :     MyLatch = &amp;MyProc-&gt;procLatch;</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span><span class="lineCov">       1220 :     if (FeBeWaitSet)</span>
<span class="lineNum">     350 </span><span class="lineCov">        454 :         ModifyWaitEvent(FeBeWaitSet, 1, WL_LATCH_SET, MyLatch);</span>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            :     /*
<span class="lineNum">     353 </span>            :      * Set the shared latch as the local one might have been set. This
<span class="lineNum">     354 </span>            :      * shouldn't normally be necessary as code is supposed to check the
<span class="lineNum">     355 </span>            :      * condition before waiting for the latch, but a bit care can't hurt.
<span class="lineNum">     356 </span>            :      */
<span class="lineNum">     357 </span><span class="lineCov">       1220 :     SetLatch(MyLatch);</span>
<span class="lineNum">     358 </span><span class="lineCov">       1220 : }</span>
<a name="359"><span class="lineNum">     359 </span>            : </a>
<span class="lineNum">     360 </span>            : void
<span class="lineNum">     361 </span><span class="lineCov">       1220 : SwitchBackToLocalLatch(void)</span>
<span class="lineNum">     362 </span>            : {
<span class="lineNum">     363 </span><span class="lineCov">       1220 :     Assert(MyLatch != &amp;LocalLatchData);</span>
<span class="lineNum">     364 </span><span class="lineCov">       1220 :     Assert(MyProc != NULL &amp;&amp; MyLatch == &amp;MyProc-&gt;procLatch);</span>
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span><span class="lineCov">       1220 :     MyLatch = &amp;LocalLatchData;</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineCov">       1220 :     if (FeBeWaitSet)</span>
<span class="lineNum">     369 </span><span class="lineCov">        454 :         ModifyWaitEvent(FeBeWaitSet, 1, WL_LATCH_SET, MyLatch);</span>
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span><span class="lineCov">       1220 :     SetLatch(MyLatch);</span>
<span class="lineNum">     372 </span><span class="lineCov">       1220 : }</span>
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            : /*
<span class="lineNum">     375 </span>            :  * GetUserId - get the current effective user ID.
<span class="lineNum">     376 </span>            :  *
<span class="lineNum">     377 </span>            :  * Note: there's no SetUserId() anymore; use SetUserIdAndSecContext().
<a name="378"><span class="lineNum">     378 </span>            :  */</a>
<span class="lineNum">     379 </span>            : Oid
<span class="lineNum">     380 </span><span class="lineCov">    1122944 : GetUserId(void)</span>
<span class="lineNum">     381 </span>            : {
<span class="lineNum">     382 </span><span class="lineCov">    1122944 :     AssertState(OidIsValid(CurrentUserId));</span>
<span class="lineNum">     383 </span><span class="lineCov">    1122944 :     return CurrentUserId;</span>
<span class="lineNum">     384 </span>            : }
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            : /*
<span class="lineNum">     388 </span>            :  * GetOuterUserId/SetOuterUserId - get/set the outer-level user ID.
<a name="389"><span class="lineNum">     389 </span>            :  */</a>
<span class="lineNum">     390 </span>            : Oid
<span class="lineNum">     391 </span><span class="lineCov">        268 : GetOuterUserId(void)</span>
<span class="lineNum">     392 </span>            : {
<span class="lineNum">     393 </span><span class="lineCov">        268 :     AssertState(OidIsValid(OuterUserId));</span>
<span class="lineNum">     394 </span><span class="lineCov">        268 :     return OuterUserId;</span>
<span class="lineNum">     395 </span>            : }
<span class="lineNum">     396 </span>            : 
<a name="397"><span class="lineNum">     397 </span>            : </a>
<span class="lineNum">     398 </span>            : static void
<span class="lineNum">     399 </span><span class="lineCov">       1034 : SetOuterUserId(Oid userid)</span>
<span class="lineNum">     400 </span>            : {
<span class="lineNum">     401 </span><span class="lineCov">       1034 :     AssertState(SecurityRestrictionContext == 0);</span>
<span class="lineNum">     402 </span><span class="lineCov">       1034 :     AssertArg(OidIsValid(userid));</span>
<span class="lineNum">     403 </span><span class="lineCov">       1034 :     OuterUserId = userid;</span>
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            :     /* We force the effective user ID to match, too */
<span class="lineNum">     406 </span><span class="lineCov">       1034 :     CurrentUserId = userid;</span>
<span class="lineNum">     407 </span><span class="lineCov">       1034 : }</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            : /*
<span class="lineNum">     411 </span>            :  * GetSessionUserId/SetSessionUserId - get/set the session user ID.
<a name="412"><span class="lineNum">     412 </span>            :  */</a>
<span class="lineNum">     413 </span>            : Oid
<span class="lineNum">     414 </span><span class="lineCov">       2866 : GetSessionUserId(void)</span>
<span class="lineNum">     415 </span>            : {
<span class="lineNum">     416 </span><span class="lineCov">       2866 :     AssertState(OidIsValid(SessionUserId));</span>
<span class="lineNum">     417 </span><span class="lineCov">       2866 :     return SessionUserId;</span>
<span class="lineNum">     418 </span>            : }
<span class="lineNum">     419 </span>            : 
<a name="420"><span class="lineNum">     420 </span>            : </a>
<span class="lineNum">     421 </span>            : static void
<span class="lineNum">     422 </span><span class="lineCov">       3872 : SetSessionUserId(Oid userid, bool is_superuser)</span>
<span class="lineNum">     423 </span>            : {
<span class="lineNum">     424 </span><span class="lineCov">       3872 :     AssertState(SecurityRestrictionContext == 0);</span>
<span class="lineNum">     425 </span><span class="lineCov">       3872 :     AssertArg(OidIsValid(userid));</span>
<span class="lineNum">     426 </span><span class="lineCov">       3872 :     SessionUserId = userid;</span>
<span class="lineNum">     427 </span><span class="lineCov">       3872 :     SessionUserIsSuperuser = is_superuser;</span>
<span class="lineNum">     428 </span><span class="lineCov">       3872 :     SetRoleIsActive = false;</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :     /* We force the effective user IDs to match, too */
<span class="lineNum">     431 </span><span class="lineCov">       3872 :     OuterUserId = userid;</span>
<span class="lineNum">     432 </span><span class="lineCov">       3872 :     CurrentUserId = userid;</span>
<span class="lineNum">     433 </span><span class="lineCov">       3872 : }</span>
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            : /*
<span class="lineNum">     436 </span>            :  * GetAuthenticatedUserId - get the authenticated user ID
<a name="437"><span class="lineNum">     437 </span>            :  */</a>
<span class="lineNum">     438 </span>            : Oid
<span class="lineNum">     439 </span><span class="lineCov">        214 : GetAuthenticatedUserId(void)</span>
<span class="lineNum">     440 </span>            : {
<span class="lineNum">     441 </span><span class="lineCov">        214 :     AssertState(OidIsValid(AuthenticatedUserId));</span>
<span class="lineNum">     442 </span><span class="lineCov">        214 :     return AuthenticatedUserId;</span>
<span class="lineNum">     443 </span>            : }
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : /*
<span class="lineNum">     447 </span>            :  * GetUserIdAndSecContext/SetUserIdAndSecContext - get/set the current user ID
<span class="lineNum">     448 </span>            :  * and the SecurityRestrictionContext flags.
<span class="lineNum">     449 </span>            :  *
<span class="lineNum">     450 </span>            :  * Currently there are three valid bits in SecurityRestrictionContext:
<span class="lineNum">     451 </span>            :  *
<span class="lineNum">     452 </span>            :  * SECURITY_LOCAL_USERID_CHANGE indicates that we are inside an operation
<span class="lineNum">     453 </span>            :  * that is temporarily changing CurrentUserId via these functions.  This is
<span class="lineNum">     454 </span>            :  * needed to indicate that the actual value of CurrentUserId is not in sync
<span class="lineNum">     455 </span>            :  * with guc.c's internal state, so SET ROLE has to be disallowed.
<span class="lineNum">     456 </span>            :  *
<span class="lineNum">     457 </span>            :  * SECURITY_RESTRICTED_OPERATION indicates that we are inside an operation
<span class="lineNum">     458 </span>            :  * that does not wish to trust called user-defined functions at all.  This
<span class="lineNum">     459 </span>            :  * bit prevents not only SET ROLE, but various other changes of session state
<span class="lineNum">     460 </span>            :  * that normally is unprotected but might possibly be used to subvert the
<span class="lineNum">     461 </span>            :  * calling session later.  An example is replacing an existing prepared
<span class="lineNum">     462 </span>            :  * statement with new code, which will then be executed with the outer
<span class="lineNum">     463 </span>            :  * session's permissions when the prepared statement is next used.  Since
<span class="lineNum">     464 </span>            :  * these restrictions are fairly draconian, we apply them only in contexts
<span class="lineNum">     465 </span>            :  * where the called functions are really supposed to be side-effect-free
<span class="lineNum">     466 </span>            :  * anyway, such as VACUUM/ANALYZE/REINDEX.
<span class="lineNum">     467 </span>            :  *
<span class="lineNum">     468 </span>            :  * SECURITY_NOFORCE_RLS indicates that we are inside an operation which should
<span class="lineNum">     469 </span>            :  * ignore the FORCE ROW LEVEL SECURITY per-table indication.  This is used to
<span class="lineNum">     470 </span>            :  * ensure that FORCE RLS does not mistakenly break referential integrity
<span class="lineNum">     471 </span>            :  * checks.  Note that this is intentionally only checked when running as the
<span class="lineNum">     472 </span>            :  * owner of the table (which should always be the case for referential
<span class="lineNum">     473 </span>            :  * integrity checks).
<span class="lineNum">     474 </span>            :  *
<span class="lineNum">     475 </span>            :  * Unlike GetUserId, GetUserIdAndSecContext does *not* Assert that the current
<span class="lineNum">     476 </span>            :  * value of CurrentUserId is valid; nor does SetUserIdAndSecContext require
<span class="lineNum">     477 </span>            :  * the new value to be valid.  In fact, these routines had better not
<span class="lineNum">     478 </span>            :  * ever throw any kind of error.  This is because they are used by
<span class="lineNum">     479 </span>            :  * StartTransaction and AbortTransaction to save/restore the settings,
<span class="lineNum">     480 </span>            :  * and during the first transaction within a backend, the value to be saved
<span class="lineNum">     481 </span>            :  * and perhaps restored is indeed invalid.  We have to be able to get
<span class="lineNum">     482 </span>            :  * through AbortTransaction without asserting in case InitPostgres fails.
<a name="483"><span class="lineNum">     483 </span>            :  */</a>
<span class="lineNum">     484 </span>            : void
<span class="lineNum">     485 </span><span class="lineCov">      83780 : GetUserIdAndSecContext(Oid *userid, int *sec_context)</span>
<span class="lineNum">     486 </span>            : {
<span class="lineNum">     487 </span><span class="lineCov">      83780 :     *userid = CurrentUserId;</span>
<span class="lineNum">     488 </span><span class="lineCov">      83780 :     *sec_context = SecurityRestrictionContext;</span>
<span class="lineNum">     489 </span><span class="lineCov">      83780 : }</span>
<a name="490"><span class="lineNum">     490 </span>            : </a>
<span class="lineNum">     491 </span>            : void
<span class="lineNum">     492 </span><span class="lineCov">      32790 : SetUserIdAndSecContext(Oid userid, int sec_context)</span>
<span class="lineNum">     493 </span>            : {
<span class="lineNum">     494 </span><span class="lineCov">      32790 :     CurrentUserId = userid;</span>
<span class="lineNum">     495 </span><span class="lineCov">      32790 :     SecurityRestrictionContext = sec_context;</span>
<span class="lineNum">     496 </span><span class="lineCov">      32790 : }</span>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            : /*
<span class="lineNum">     500 </span>            :  * InLocalUserIdChange - are we inside a local change of CurrentUserId?
<a name="501"><span class="lineNum">     501 </span>            :  */</a>
<span class="lineNum">     502 </span>            : bool
<span class="lineNum">     503 </span><span class="lineCov">       2914 : InLocalUserIdChange(void)</span>
<span class="lineNum">     504 </span>            : {
<span class="lineNum">     505 </span><span class="lineCov">       2914 :     return (SecurityRestrictionContext &amp; SECURITY_LOCAL_USERID_CHANGE) != 0;</span>
<span class="lineNum">     506 </span>            : }
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            : /*
<span class="lineNum">     509 </span>            :  * InSecurityRestrictedOperation - are we inside a security-restricted command?
<a name="510"><span class="lineNum">     510 </span>            :  */</a>
<span class="lineNum">     511 </span>            : bool
<span class="lineNum">     512 </span><span class="lineCov">       3970 : InSecurityRestrictedOperation(void)</span>
<span class="lineNum">     513 </span>            : {
<span class="lineNum">     514 </span><span class="lineCov">       3970 :     return (SecurityRestrictionContext &amp; SECURITY_RESTRICTED_OPERATION) != 0;</span>
<span class="lineNum">     515 </span>            : }
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            : /*
<span class="lineNum">     518 </span>            :  * InNoForceRLSOperation - are we ignoring FORCE ROW LEVEL SECURITY ?
<a name="519"><span class="lineNum">     519 </span>            :  */</a>
<span class="lineNum">     520 </span>            : bool
<span class="lineNum">     521 </span><span class="lineCov">         58 : InNoForceRLSOperation(void)</span>
<span class="lineNum">     522 </span>            : {
<span class="lineNum">     523 </span><span class="lineCov">         58 :     return (SecurityRestrictionContext &amp; SECURITY_NOFORCE_RLS) != 0;</span>
<span class="lineNum">     524 </span>            : }
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            : /*
<span class="lineNum">     528 </span>            :  * These are obsolete versions of Get/SetUserIdAndSecContext that are
<span class="lineNum">     529 </span>            :  * only provided for bug-compatibility with some rather dubious code in
<span class="lineNum">     530 </span>            :  * pljava.  We allow the userid to be set, but only when not inside a
<span class="lineNum">     531 </span>            :  * security restriction context.
<a name="532"><span class="lineNum">     532 </span>            :  */</a>
<span class="lineNum">     533 </span>            : void
<span class="lineNum">     534 </span><span class="lineNoCov">          0 : GetUserIdAndContext(Oid *userid, bool *sec_def_context)</span>
<span class="lineNum">     535 </span>            : {
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :     *userid = CurrentUserId;</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :     *sec_def_context = InLocalUserIdChange();</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 : }</span>
<a name="539"><span class="lineNum">     539 </span>            : </a>
<span class="lineNum">     540 </span>            : void
<span class="lineNum">     541 </span><span class="lineNoCov">          0 : SetUserIdAndContext(Oid userid, bool sec_def_context)</span>
<span class="lineNum">     542 </span>            : {
<span class="lineNum">     543 </span>            :     /* We throw the same error SET ROLE would. */
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :     if (InSecurityRestrictedOperation())</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">     546 </span>            :                 (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
<span class="lineNum">     547 </span>            :                  errmsg(&quot;cannot set parameter \&quot;%s\&quot; within security-restricted operation&quot;,
<span class="lineNum">     548 </span>            :                         &quot;role&quot;)));
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     CurrentUserId = userid;</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :     if (sec_def_context)</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :         SecurityRestrictionContext |= SECURITY_LOCAL_USERID_CHANGE;</span>
<span class="lineNum">     552 </span>            :     else
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         SecurityRestrictionContext &amp;= ~SECURITY_LOCAL_USERID_CHANGE;</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            : /*
<span class="lineNum">     558 </span>            :  * Check whether specified role has explicit REPLICATION privilege
<a name="559"><span class="lineNum">     559 </span>            :  */</a>
<span class="lineNum">     560 </span>            : bool
<span class="lineNum">     561 </span><span class="lineNoCov">          0 : has_rolreplication(Oid roleid)</span>
<span class="lineNum">     562 </span>            : {
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     bool        result = false;</span>
<span class="lineNum">     564 </span>            :     HeapTuple   utup;
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :     utup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :     if (HeapTupleIsValid(utup))</span>
<span class="lineNum">     568 </span>            :     {
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :         result = ((Form_pg_authid) GETSTRUCT(utup))-&gt;rolreplication;</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :         ReleaseSysCache(utup);</span>
<span class="lineNum">     571 </span>            :     }
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">     573 </span>            : }
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span>            : /*
<span class="lineNum">     576 </span>            :  * Initialize user identity during normal backend startup
<a name="577"><span class="lineNum">     577 </span>            :  */</a>
<span class="lineNum">     578 </span>            : void
<span class="lineNum">     579 </span><span class="lineCov">       1200 : InitializeSessionUserId(const char *rolename, Oid roleid)</span>
<span class="lineNum">     580 </span>            : {
<span class="lineNum">     581 </span>            :     HeapTuple   roleTup;
<span class="lineNum">     582 </span>            :     Form_pg_authid rform;
<span class="lineNum">     583 </span>            :     char       *rname;
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span>            :     /*
<span class="lineNum">     586 </span>            :      * Don't do scans if we're bootstrapping, none of the system catalogs
<span class="lineNum">     587 </span>            :      * exist yet, and they should be owned by postgres anyway.
<span class="lineNum">     588 </span>            :      */
<span class="lineNum">     589 </span><span class="lineCov">       1200 :     AssertState(!IsBootstrapProcessingMode());</span>
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            :     /* call only once */
<span class="lineNum">     592 </span><span class="lineCov">       1200 :     AssertState(!OidIsValid(AuthenticatedUserId));</span>
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span>            :     /*
<span class="lineNum">     595 </span>            :      * Make sure syscache entries are flushed for recent catalog changes. This
<span class="lineNum">     596 </span>            :      * allows us to find roles that were created on-the-fly during
<span class="lineNum">     597 </span>            :      * authentication.
<span class="lineNum">     598 </span>            :      */
<span class="lineNum">     599 </span><span class="lineCov">       1200 :     AcceptInvalidationMessages();</span>
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span><span class="lineCov">       1200 :     if (rolename != NULL)</span>
<span class="lineNum">     602 </span>            :     {
<span class="lineNum">     603 </span><span class="lineCov">        454 :         roleTup = SearchSysCache1(AUTHNAME, PointerGetDatum(rolename));</span>
<span class="lineNum">     604 </span><span class="lineCov">        454 :         if (!HeapTupleIsValid(roleTup))</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     606 </span>            :                     (errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),
<span class="lineNum">     607 </span>            :                      errmsg(&quot;role \&quot;%s\&quot; does not exist&quot;, rolename)));
<span class="lineNum">     608 </span>            :     }
<span class="lineNum">     609 </span>            :     else
<span class="lineNum">     610 </span>            :     {
<span class="lineNum">     611 </span><span class="lineCov">        746 :         roleTup = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));</span>
<span class="lineNum">     612 </span><span class="lineCov">        746 :         if (!HeapTupleIsValid(roleTup))</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     614 </span>            :                     (errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),
<span class="lineNum">     615 </span>            :                      errmsg(&quot;role with OID %u does not exist&quot;, roleid)));
<span class="lineNum">     616 </span>            :     }
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span><span class="lineCov">       1200 :     rform = (Form_pg_authid) GETSTRUCT(roleTup);</span>
<span class="lineNum">     619 </span><span class="lineCov">       1200 :     roleid = rform-&gt;oid;</span>
<span class="lineNum">     620 </span><span class="lineCov">       1200 :     rname = NameStr(rform-&gt;rolname);</span>
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span><span class="lineCov">       1200 :     AuthenticatedUserId = roleid;</span>
<span class="lineNum">     623 </span><span class="lineCov">       1200 :     AuthenticatedUserIsSuperuser = rform-&gt;rolsuper;</span>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span>            :     /* This sets OuterUserId/CurrentUserId too */
<span class="lineNum">     626 </span><span class="lineCov">       1200 :     SetSessionUserId(roleid, AuthenticatedUserIsSuperuser);</span>
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span>            :     /* Also mark our PGPROC entry with the authenticated user id */
<span class="lineNum">     629 </span>            :     /* (We assume this is an atomic store so no lock is needed) */
<span class="lineNum">     630 </span><span class="lineCov">       1200 :     MyProc-&gt;roleId = roleid;</span>
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            :     /*
<span class="lineNum">     633 </span>            :      * These next checks are not enforced when in standalone mode, so that
<span class="lineNum">     634 </span>            :      * there is a way to recover from sillinesses like &quot;UPDATE pg_authid SET
<span class="lineNum">     635 </span>            :      * rolcanlogin = false;&quot;.
<span class="lineNum">     636 </span>            :      */
<span class="lineNum">     637 </span><span class="lineCov">       1200 :     if (IsUnderPostmaster)</span>
<span class="lineNum">     638 </span>            :     {
<span class="lineNum">     639 </span>            :         /*
<span class="lineNum">     640 </span>            :          * Is role allowed to login at all?
<span class="lineNum">     641 </span>            :          */
<span class="lineNum">     642 </span><span class="lineCov">       1200 :         if (!rform-&gt;rolcanlogin)</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     644 </span>            :                     (errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),
<span class="lineNum">     645 </span>            :                      errmsg(&quot;role \&quot;%s\&quot; is not permitted to log in&quot;,
<span class="lineNum">     646 </span>            :                             rname)));
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            :         /*
<span class="lineNum">     649 </span>            :          * Check connection limit for this role.
<span class="lineNum">     650 </span>            :          *
<span class="lineNum">     651 </span>            :          * There is a race condition here --- we create our PGPROC before
<span class="lineNum">     652 </span>            :          * checking for other PGPROCs.  If two backends did this at about the
<span class="lineNum">     653 </span>            :          * same time, they might both think they were over the limit, while
<span class="lineNum">     654 </span>            :          * ideally one should succeed and one fail.  Getting that to work
<span class="lineNum">     655 </span>            :          * exactly seems more trouble than it is worth, however; instead we
<span class="lineNum">     656 </span>            :          * just document that the connection limit is approximate.
<span class="lineNum">     657 </span>            :          */
<span class="lineNum">     658 </span><span class="lineCov">       1200 :         if (rform-&gt;rolconnlimit &gt;= 0 &amp;&amp;</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :             !AuthenticatedUserIsSuperuser &amp;&amp;</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :             CountUserBackends(roleid) &gt; rform-&gt;rolconnlimit)</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     662 </span>            :                     (errcode(ERRCODE_TOO_MANY_CONNECTIONS),
<span class="lineNum">     663 </span>            :                      errmsg(&quot;too many connections for role \&quot;%s\&quot;&quot;,
<span class="lineNum">     664 </span>            :                             rname)));
<span class="lineNum">     665 </span>            :     }
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            :     /* Record username and superuser status as GUC settings too */
<span class="lineNum">     668 </span><span class="lineCov">       1200 :     SetConfigOption(&quot;session_authorization&quot;, rname,</span>
<span class="lineNum">     669 </span>            :                     PGC_BACKEND, PGC_S_OVERRIDE);
<span class="lineNum">     670 </span><span class="lineCov">       1200 :     SetConfigOption(&quot;is_superuser&quot;,</span>
<span class="lineNum">     671 </span>            :                     AuthenticatedUserIsSuperuser ? &quot;on&quot; : &quot;off&quot;,
<span class="lineNum">     672 </span>            :                     PGC_INTERNAL, PGC_S_OVERRIDE);
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span><span class="lineCov">       1200 :     ReleaseSysCache(roleTup);</span>
<span class="lineNum">     675 </span><span class="lineCov">       1200 : }</span>
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            : /*
<span class="lineNum">     679 </span>            :  * Initialize user identity during special backend startup
<a name="680"><span class="lineNum">     680 </span>            :  */</a>
<span class="lineNum">     681 </span>            : void
<span class="lineNum">     682 </span><span class="lineCov">         10 : InitializeSessionUserIdStandalone(void)</span>
<span class="lineNum">     683 </span>            : {
<span class="lineNum">     684 </span>            :     /*
<span class="lineNum">     685 </span>            :      * This function should only be called in single-user mode, in autovacuum
<span class="lineNum">     686 </span>            :      * workers, and in background workers.
<span class="lineNum">     687 </span>            :      */
<span class="lineNum">     688 </span><span class="lineCov">         10 :     AssertState(!IsUnderPostmaster || IsAutoVacuumWorkerProcess() || IsBackgroundWorker);</span>
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            :     /* call only once */
<span class="lineNum">     691 </span><span class="lineCov">         10 :     AssertState(!OidIsValid(AuthenticatedUserId));</span>
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span><span class="lineCov">         10 :     AuthenticatedUserId = BOOTSTRAP_SUPERUSERID;</span>
<span class="lineNum">     694 </span><span class="lineCov">         10 :     AuthenticatedUserIsSuperuser = true;</span>
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span><span class="lineCov">         10 :     SetSessionUserId(BOOTSTRAP_SUPERUSERID, true);</span>
<span class="lineNum">     697 </span><span class="lineCov">         10 : }</span>
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span>            : /*
<span class="lineNum">     701 </span>            :  * Change session auth ID while running
<span class="lineNum">     702 </span>            :  *
<span class="lineNum">     703 </span>            :  * Only a superuser may set auth ID to something other than himself.  Note
<span class="lineNum">     704 </span>            :  * that in case of multiple SETs in a single session, the original userid's
<span class="lineNum">     705 </span>            :  * superuserness is what matters.  But we set the GUC variable is_superuser
<span class="lineNum">     706 </span>            :  * to indicate whether the *current* session userid is a superuser.
<span class="lineNum">     707 </span>            :  *
<span class="lineNum">     708 </span>            :  * Note: this is not an especially clean place to do the permission check.
<span class="lineNum">     709 </span>            :  * It's OK because the check does not require catalog access and can't
<span class="lineNum">     710 </span>            :  * fail during an end-of-transaction GUC reversion, but we may someday
<span class="lineNum">     711 </span>            :  * have to push it up into assign_session_authorization.
<a name="712"><span class="lineNum">     712 </span>            :  */</a>
<span class="lineNum">     713 </span>            : void
<span class="lineNum">     714 </span><span class="lineCov">       2662 : SetSessionAuthorization(Oid userid, bool is_superuser)</span>
<span class="lineNum">     715 </span>            : {
<span class="lineNum">     716 </span>            :     /* Must have authenticated already, else can't make permission check */
<span class="lineNum">     717 </span><span class="lineCov">       2662 :     AssertState(OidIsValid(AuthenticatedUserId));</span>
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span><span class="lineCov">       3198 :     if (userid != AuthenticatedUserId &amp;&amp;</span>
<span class="lineNum">     720 </span><span class="lineCov">        536 :         !AuthenticatedUserIsSuperuser)</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">     722 </span>            :                 (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
<span class="lineNum">     723 </span>            :                  errmsg(&quot;permission denied to set session authorization&quot;)));
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span><span class="lineCov">       2662 :     SetSessionUserId(userid, is_superuser);</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span><span class="lineCov">       2662 :     SetConfigOption(&quot;is_superuser&quot;,</span>
<span class="lineNum">     728 </span>            :                     is_superuser ? &quot;on&quot; : &quot;off&quot;,
<span class="lineNum">     729 </span>            :                     PGC_INTERNAL, PGC_S_OVERRIDE);
<span class="lineNum">     730 </span><span class="lineCov">       2662 : }</span>
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            : /*
<span class="lineNum">     733 </span>            :  * Report current role id
<span class="lineNum">     734 </span>            :  *      This follows the semantics of SET ROLE, ie return the outer-level ID
<span class="lineNum">     735 </span>            :  *      not the current effective ID, and return InvalidOid when the setting
<span class="lineNum">     736 </span>            :  *      is logically SET ROLE NONE.
<a name="737"><span class="lineNum">     737 </span>            :  */</a>
<span class="lineNum">     738 </span>            : Oid
<span class="lineNum">     739 </span><span class="lineCov">        216 : GetCurrentRoleId(void)</span>
<span class="lineNum">     740 </span>            : {
<span class="lineNum">     741 </span><span class="lineCov">        216 :     if (SetRoleIsActive)</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :         return OuterUserId;</span>
<span class="lineNum">     743 </span>            :     else
<span class="lineNum">     744 </span><span class="lineCov">        216 :         return InvalidOid;</span>
<span class="lineNum">     745 </span>            : }
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            : /*
<span class="lineNum">     748 </span>            :  * Change Role ID while running (SET ROLE)
<span class="lineNum">     749 </span>            :  *
<span class="lineNum">     750 </span>            :  * If roleid is InvalidOid, we are doing SET ROLE NONE: revert to the
<span class="lineNum">     751 </span>            :  * session user authorization.  In this case the is_superuser argument
<span class="lineNum">     752 </span>            :  * is ignored.
<span class="lineNum">     753 </span>            :  *
<span class="lineNum">     754 </span>            :  * When roleid is not InvalidOid, the caller must have checked whether
<span class="lineNum">     755 </span>            :  * the session user has permission to become that role.  (We cannot check
<span class="lineNum">     756 </span>            :  * here because this routine must be able to execute in a failed transaction
<span class="lineNum">     757 </span>            :  * to restore a prior value of the ROLE GUC variable.)
<a name="758"><span class="lineNum">     758 </span>            :  */</a>
<span class="lineNum">     759 </span>            : void
<span class="lineNum">     760 </span><span class="lineCov">       2262 : SetCurrentRoleId(Oid roleid, bool is_superuser)</span>
<span class="lineNum">     761 </span>            : {
<span class="lineNum">     762 </span>            :     /*
<span class="lineNum">     763 </span>            :      * Get correct info if it's SET ROLE NONE
<span class="lineNum">     764 </span>            :      *
<span class="lineNum">     765 </span>            :      * If SessionUserId hasn't been set yet, just do nothing --- the eventual
<span class="lineNum">     766 </span>            :      * SetSessionUserId call will fix everything.  This is needed since we
<span class="lineNum">     767 </span>            :      * will get called during GUC initialization.
<span class="lineNum">     768 </span>            :      */
<span class="lineNum">     769 </span><span class="lineCov">       2262 :     if (!OidIsValid(roleid))</span>
<span class="lineNum">     770 </span>            :     {
<span class="lineNum">     771 </span><span class="lineCov">       2092 :         if (!OidIsValid(SessionUserId))</span>
<span class="lineNum">     772 </span><span class="lineCov">       3490 :             return;</span>
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span><span class="lineCov">        864 :         roleid = SessionUserId;</span>
<span class="lineNum">     775 </span><span class="lineCov">        864 :         is_superuser = SessionUserIsSuperuser;</span>
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span><span class="lineCov">        864 :         SetRoleIsActive = false;</span>
<span class="lineNum">     778 </span>            :     }
<span class="lineNum">     779 </span>            :     else
<span class="lineNum">     780 </span><span class="lineCov">        170 :         SetRoleIsActive = true;</span>
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span><span class="lineCov">       1034 :     SetOuterUserId(roleid);</span>
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span><span class="lineCov">       1034 :     SetConfigOption(&quot;is_superuser&quot;,</span>
<span class="lineNum">     785 </span>            :                     is_superuser ? &quot;on&quot; : &quot;off&quot;,
<span class="lineNum">     786 </span>            :                     PGC_INTERNAL, PGC_S_OVERRIDE);
<span class="lineNum">     787 </span>            : }
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            : /*
<span class="lineNum">     791 </span>            :  * Get user name from user oid, returns NULL for nonexistent roleid if noerr
<span class="lineNum">     792 </span>            :  * is true.
<a name="793"><span class="lineNum">     793 </span>            :  */</a>
<span class="lineNum">     794 </span>            : char *
<span class="lineNum">     795 </span><span class="lineCov">       1828 : GetUserNameFromId(Oid roleid, bool noerr)</span>
<span class="lineNum">     796 </span>            : {
<span class="lineNum">     797 </span>            :     HeapTuple   tuple;
<span class="lineNum">     798 </span>            :     char       *result;
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span><span class="lineCov">       1828 :     tuple = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));</span>
<span class="lineNum">     801 </span><span class="lineCov">       1828 :     if (!HeapTupleIsValid(tuple))</span>
<span class="lineNum">     802 </span>            :     {
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :         if (!noerr)</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">     805 </span>            :                     (errcode(ERRCODE_UNDEFINED_OBJECT),
<span class="lineNum">     806 </span>            :                      errmsg(&quot;invalid role OID: %u&quot;, roleid)));
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :         result = NULL;</span>
<span class="lineNum">     808 </span>            :     }
<span class="lineNum">     809 </span>            :     else
<span class="lineNum">     810 </span>            :     {
<span class="lineNum">     811 </span><span class="lineCov">       1828 :         result = pstrdup(NameStr(((Form_pg_authid) GETSTRUCT(tuple))-&gt;rolname));</span>
<span class="lineNum">     812 </span><span class="lineCov">       1828 :         ReleaseSysCache(tuple);</span>
<span class="lineNum">     813 </span>            :     }
<span class="lineNum">     814 </span><span class="lineCov">       1828 :     return result;</span>
<span class="lineNum">     815 </span>            : }
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span>            : /*-------------------------------------------------------------------------
<span class="lineNum">     819 </span>            :  *              Interlock-file support
<span class="lineNum">     820 </span>            :  *
<span class="lineNum">     821 </span>            :  * These routines are used to create both a data-directory lockfile
<span class="lineNum">     822 </span>            :  * ($DATADIR/postmaster.pid) and Unix-socket-file lockfiles ($SOCKFILE.lock).
<span class="lineNum">     823 </span>            :  * Both kinds of files contain the same info initially, although we can add
<span class="lineNum">     824 </span>            :  * more information to a data-directory lockfile after it's created, using
<span class="lineNum">     825 </span>            :  * AddToDataDirLockFile().  See miscadmin.h for documentation of the contents
<span class="lineNum">     826 </span>            :  * of these lockfiles.
<span class="lineNum">     827 </span>            :  *
<span class="lineNum">     828 </span>            :  * On successful lockfile creation, a proc_exit callback to remove the
<span class="lineNum">     829 </span>            :  * lockfile is automatically created.
<span class="lineNum">     830 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">     831 </span>            :  */
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            : /*
<span class="lineNum">     834 </span>            :  * proc_exit callback to remove lockfiles.
<a name="835"><span class="lineNum">     835 </span>            :  */</a>
<span class="lineNum">     836 </span>            : static void
<span class="lineNum">     837 </span><span class="lineCov">         10 : UnlinkLockFiles(int status, Datum arg)</span>
<span class="lineNum">     838 </span>            : {
<span class="lineNum">     839 </span>            :     ListCell   *l;
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span><span class="lineCov">         22 :     foreach(l, lock_files)</span>
<span class="lineNum">     842 </span>            :     {
<span class="lineNum">     843 </span><span class="lineCov">         12 :         char       *curfile = (char *) lfirst(l);</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span><span class="lineCov">         12 :         unlink(curfile);</span>
<span class="lineNum">     846 </span>            :         /* Should we complain if the unlink fails? */
<span class="lineNum">     847 </span>            :     }
<span class="lineNum">     848 </span>            :     /* Since we're about to exit, no need to reclaim storage */
<span class="lineNum">     849 </span><span class="lineCov">         10 :     lock_files = NIL;</span>
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span>            :     /*
<span class="lineNum">     852 </span>            :      * Lock file removal should always be the last externally visible action
<span class="lineNum">     853 </span>            :      * of a postmaster or standalone backend, while we won't come here at all
<span class="lineNum">     854 </span>            :      * when exiting postmaster child processes.  Therefore, this is a good
<span class="lineNum">     855 </span>            :      * place to log completion of shutdown.  We could alternatively teach
<span class="lineNum">     856 </span>            :      * proc_exit() to do it, but that seems uglier.  In a standalone backend,
<span class="lineNum">     857 </span>            :      * use NOTICE elevel to be less chatty.
<span class="lineNum">     858 </span>            :      */
<span class="lineNum">     859 </span><span class="lineCov">         10 :     ereport(IsPostmasterEnvironment ? LOG : NOTICE,</span>
<span class="lineNum">     860 </span>            :             (errmsg(&quot;database system is shut down&quot;)));
<span class="lineNum">     861 </span><span class="lineCov">         10 : }</span>
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            : /*
<span class="lineNum">     864 </span>            :  * Create a lockfile.
<span class="lineNum">     865 </span>            :  *
<span class="lineNum">     866 </span>            :  * filename is the path name of the lockfile to create.
<span class="lineNum">     867 </span>            :  * amPostmaster is used to determine how to encode the output PID.
<span class="lineNum">     868 </span>            :  * socketDir is the Unix socket directory path to include (possibly empty).
<span class="lineNum">     869 </span>            :  * isDDLock and refName are used to determine what error message to produce.
<a name="870"><span class="lineNum">     870 </span>            :  */</a>
<span class="lineNum">     871 </span>            : static void
<span class="lineNum">     872 </span><span class="lineCov">       2448 : CreateLockFile(const char *filename, bool amPostmaster,</span>
<span class="lineNum">     873 </span>            :                const char *socketDir,
<span class="lineNum">     874 </span>            :                bool isDDLock, const char *refName)
<span class="lineNum">     875 </span>            : {
<span class="lineNum">     876 </span>            :     int         fd;
<span class="lineNum">     877 </span>            :     char        buffer[MAXPGPATH * 2 + 256];
<span class="lineNum">     878 </span>            :     int         ntries;
<span class="lineNum">     879 </span>            :     int         len;
<span class="lineNum">     880 </span>            :     int         encoded_pid;
<span class="lineNum">     881 </span>            :     pid_t       other_pid;
<span class="lineNum">     882 </span>            :     pid_t       my_pid,
<span class="lineNum">     883 </span>            :                 my_p_pid,
<span class="lineNum">     884 </span>            :                 my_gp_pid;
<span class="lineNum">     885 </span>            :     const char *envvar;
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span>            :     /*
<span class="lineNum">     888 </span>            :      * If the PID in the lockfile is our own PID or our parent's or
<span class="lineNum">     889 </span>            :      * grandparent's PID, then the file must be stale (probably left over from
<span class="lineNum">     890 </span>            :      * a previous system boot cycle).  We need to check this because of the
<span class="lineNum">     891 </span>            :      * likelihood that a reboot will assign exactly the same PID as we had in
<span class="lineNum">     892 </span>            :      * the previous reboot, or one that's only one or two counts larger and
<span class="lineNum">     893 </span>            :      * hence the lockfile's PID now refers to an ancestor shell process.  We
<span class="lineNum">     894 </span>            :      * allow pg_ctl to pass down its parent shell PID (our grandparent PID)
<span class="lineNum">     895 </span>            :      * via the environment variable PG_GRANDPARENT_PID; this is so that
<span class="lineNum">     896 </span>            :      * launching the postmaster via pg_ctl can be just as reliable as
<span class="lineNum">     897 </span>            :      * launching it directly.  There is no provision for detecting
<span class="lineNum">     898 </span>            :      * further-removed ancestor processes, but if the init script is written
<span class="lineNum">     899 </span>            :      * carefully then all but the immediate parent shell will be root-owned
<span class="lineNum">     900 </span>            :      * processes and so the kill test will fail with EPERM.  Note that we
<span class="lineNum">     901 </span>            :      * cannot get a false negative this way, because an existing postmaster
<span class="lineNum">     902 </span>            :      * would surely never launch a competing postmaster or pg_ctl process
<span class="lineNum">     903 </span>            :      * directly.
<span class="lineNum">     904 </span>            :      */
<span class="lineNum">     905 </span><span class="lineCov">       2448 :     my_pid = getpid();</span>
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span>            : #ifndef WIN32
<span class="lineNum">     908 </span><span class="lineCov">       2448 :     my_p_pid = getppid();</span>
<span class="lineNum">     909 </span>            : #else
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            :     /*
<span class="lineNum">     912 </span>            :      * Windows hasn't got getppid(), but doesn't need it since it's not using
<span class="lineNum">     913 </span>            :      * real kill() either...
<span class="lineNum">     914 </span>            :      */
<span class="lineNum">     915 </span>            :     my_p_pid = 0;
<span class="lineNum">     916 </span>            : #endif
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span><span class="lineCov">       2448 :     envvar = getenv(&quot;PG_GRANDPARENT_PID&quot;);</span>
<span class="lineNum">     919 </span><span class="lineCov">       2448 :     if (envvar)</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :         my_gp_pid = atoi(envvar);</span>
<span class="lineNum">     921 </span>            :     else
<span class="lineNum">     922 </span><span class="lineCov">       2448 :         my_gp_pid = 0;</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span>            :     /*
<span class="lineNum">     925 </span>            :      * We need a loop here because of race conditions.  But don't loop forever
<span class="lineNum">     926 </span>            :      * (for example, a non-writable $PGDATA directory might cause a failure
<span class="lineNum">     927 </span>            :      * that won't go away).  100 tries seems like plenty.
<span class="lineNum">     928 </span>            :      */
<span class="lineNum">     929 </span><span class="lineCov">       2448 :     for (ntries = 0;; ntries++)</span>
<span class="lineNum">     930 </span>            :     {
<span class="lineNum">     931 </span>            :         /*
<span class="lineNum">     932 </span>            :          * Try to create the lock file --- O_EXCL makes this atomic.
<span class="lineNum">     933 </span>            :          *
<span class="lineNum">     934 </span>            :          * Think not to make the file protection weaker than 0600/0640.  See
<span class="lineNum">     935 </span>            :          * comments below.
<span class="lineNum">     936 </span>            :          */
<span class="lineNum">     937 </span><span class="lineCov">       2448 :         fd = open(filename, O_RDWR | O_CREAT | O_EXCL, pg_file_create_mode);</span>
<span class="lineNum">     938 </span><span class="lineCov">       2448 :         if (fd &gt;= 0)</span>
<span class="lineNum">     939 </span><span class="lineCov">       2448 :             break;              /* Success; exit the retry loop */</span>
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            :         /*
<span class="lineNum">     942 </span>            :          * Couldn't create the pid file. Probably it already exists.
<span class="lineNum">     943 </span>            :          */
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :         if ((errno != EEXIST &amp;&amp; errno != EACCES) || ntries &gt; 100)</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     946 </span>            :                     (errcode_for_file_access(),
<span class="lineNum">     947 </span>            :                      errmsg(&quot;could not create lock file \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">     948 </span>            :                             filename)));
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            :         /*
<span class="lineNum">     951 </span>            :          * Read the file to get the old owner's PID.  Note race condition
<span class="lineNum">     952 </span>            :          * here: file might have been deleted since we tried to create it.
<span class="lineNum">     953 </span>            :          */
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :         fd = open(filename, O_RDONLY, pg_file_create_mode);</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :         if (fd &lt; 0)</span>
<span class="lineNum">     956 </span>            :         {
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :             if (errno == ENOENT)</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :                 continue;       /* race condition; try again */</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     960 </span>            :                     (errcode_for_file_access(),
<span class="lineNum">     961 </span>            :                      errmsg(&quot;could not open lock file \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">     962 </span>            :                             filename)));
<span class="lineNum">     963 </span>            :         }
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :         pgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_READ);</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :         if ((len = read(fd, buffer, sizeof(buffer) - 1)) &lt; 0)</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     967 </span>            :                     (errcode_for_file_access(),
<span class="lineNum">     968 </span>            :                      errmsg(&quot;could not read lock file \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">     969 </span>            :                             filename)));
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :         pgstat_report_wait_end();</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :         close(fd);</span>
<span class="lineNum">     972 </span>            : 
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :         if (len == 0)</span>
<span class="lineNum">     974 </span>            :         {
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     976 </span>            :                     (errcode(ERRCODE_LOCK_FILE_EXISTS),
<span class="lineNum">     977 </span>            :                      errmsg(&quot;lock file \&quot;%s\&quot; is empty&quot;, filename),
<span class="lineNum">     978 </span>            :                      errhint(&quot;Either another server is starting, or the lock file is the remnant of a previous server startup crash.&quot;)));
<span class="lineNum">     979 </span>            :         }
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :         buffer[len] = '\0';</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :         encoded_pid = atoi(buffer);</span>
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span>            :         /* if pid &lt; 0, the pid is for postgres, not postmaster */
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :         other_pid = (pid_t) (encoded_pid &lt; 0 ? -encoded_pid : encoded_pid);</span>
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :         if (other_pid &lt;= 0)</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :             elog(FATAL, &quot;bogus data in lock file \&quot;%s\&quot;: \&quot;%s\&quot;&quot;,</span>
<span class="lineNum">     989 </span>            :                  filename, buffer);
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            :         /*
<span class="lineNum">     992 </span>            :          * Check to see if the other process still exists
<span class="lineNum">     993 </span>            :          *
<span class="lineNum">     994 </span>            :          * Per discussion above, my_pid, my_p_pid, and my_gp_pid can be
<span class="lineNum">     995 </span>            :          * ignored as false matches.
<span class="lineNum">     996 </span>            :          *
<span class="lineNum">     997 </span>            :          * Normally kill() will fail with ESRCH if the given PID doesn't
<span class="lineNum">     998 </span>            :          * exist.
<span class="lineNum">     999 </span>            :          *
<span class="lineNum">    1000 </span>            :          * We can treat the EPERM-error case as okay because that error
<span class="lineNum">    1001 </span>            :          * implies that the existing process has a different userid than we
<span class="lineNum">    1002 </span>            :          * do, which means it cannot be a competing postmaster.  A postmaster
<span class="lineNum">    1003 </span>            :          * cannot successfully attach to a data directory owned by a userid
<span class="lineNum">    1004 </span>            :          * other than its own, as enforced in checkDataDir(). Also, since we
<span class="lineNum">    1005 </span>            :          * create the lockfiles mode 0600/0640, we'd have failed above if the
<span class="lineNum">    1006 </span>            :          * lockfile belonged to another userid --- which means that whatever
<span class="lineNum">    1007 </span>            :          * process kill() is reporting about isn't the one that made the
<span class="lineNum">    1008 </span>            :          * lockfile.  (NOTE: this last consideration is the only one that
<span class="lineNum">    1009 </span>            :          * keeps us from blowing away a Unix socket file belonging to an
<span class="lineNum">    1010 </span>            :          * instance of Postgres being run by someone else, at least on
<span class="lineNum">    1011 </span>            :          * machines where /tmp hasn't got a stickybit.)
<span class="lineNum">    1012 </span>            :          */
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :         if (other_pid != my_pid &amp;&amp; other_pid != my_p_pid &amp;&amp;</span>
<span class="lineNum">    1014 </span>            :             other_pid != my_gp_pid)
<span class="lineNum">    1015 </span>            :         {
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :             if (kill(other_pid, 0) == 0 ||</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :                 (errno != ESRCH &amp;&amp; errno != EPERM))</span>
<span class="lineNum">    1018 </span>            :             {
<span class="lineNum">    1019 </span>            :                 /* lockfile belongs to a live process */
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :                 ereport(FATAL,</span>
<span class="lineNum">    1021 </span>            :                         (errcode(ERRCODE_LOCK_FILE_EXISTS),
<span class="lineNum">    1022 </span>            :                          errmsg(&quot;lock file \&quot;%s\&quot; already exists&quot;,
<span class="lineNum">    1023 </span>            :                                 filename),
<span class="lineNum">    1024 </span>            :                          isDDLock ?
<span class="lineNum">    1025 </span>            :                          (encoded_pid &lt; 0 ?
<span class="lineNum">    1026 </span>            :                           errhint(&quot;Is another postgres (PID %d) running in data directory \&quot;%s\&quot;?&quot;,
<span class="lineNum">    1027 </span>            :                                   (int) other_pid, refName) :
<span class="lineNum">    1028 </span>            :                           errhint(&quot;Is another postmaster (PID %d) running in data directory \&quot;%s\&quot;?&quot;,
<span class="lineNum">    1029 </span>            :                                   (int) other_pid, refName)) :
<span class="lineNum">    1030 </span>            :                          (encoded_pid &lt; 0 ?
<span class="lineNum">    1031 </span>            :                           errhint(&quot;Is another postgres (PID %d) using socket file \&quot;%s\&quot;?&quot;,
<span class="lineNum">    1032 </span>            :                                   (int) other_pid, refName) :
<span class="lineNum">    1033 </span>            :                           errhint(&quot;Is another postmaster (PID %d) using socket file \&quot;%s\&quot;?&quot;,
<span class="lineNum">    1034 </span>            :                                   (int) other_pid, refName))));
<span class="lineNum">    1035 </span>            :             }
<span class="lineNum">    1036 </span>            :         }
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span>            :         /*
<span class="lineNum">    1039 </span>            :          * No, the creating process did not exist.  However, it could be that
<span class="lineNum">    1040 </span>            :          * the postmaster crashed (or more likely was kill -9'd by a clueless
<span class="lineNum">    1041 </span>            :          * admin) but has left orphan backends behind.  Check for this by
<span class="lineNum">    1042 </span>            :          * looking to see if there is an associated shmem segment that is
<span class="lineNum">    1043 </span>            :          * still in use.
<span class="lineNum">    1044 </span>            :          *
<span class="lineNum">    1045 </span>            :          * Note: because postmaster.pid is written in multiple steps, we might
<span class="lineNum">    1046 </span>            :          * not find the shmem ID values in it; we can't treat that as an
<span class="lineNum">    1047 </span>            :          * error.
<span class="lineNum">    1048 </span>            :          */
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :         if (isDDLock)</span>
<span class="lineNum">    1050 </span>            :         {
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :             char       *ptr = buffer;</span>
<span class="lineNum">    1052 </span>            :             unsigned long id1,
<span class="lineNum">    1053 </span>            :                         id2;
<span class="lineNum">    1054 </span>            :             int         lineno;
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :             for (lineno = 1; lineno &lt; LOCK_FILE_LINE_SHMEM_KEY; lineno++)</span>
<span class="lineNum">    1057 </span>            :             {
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :                 if ((ptr = strchr(ptr, '\n')) == NULL)</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :                 ptr++;</span>
<span class="lineNum">    1061 </span>            :             }
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :             if (ptr != NULL &amp;&amp;</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :                 sscanf(ptr, &quot;%lu %lu&quot;, &amp;id1, &amp;id2) == 2)</span>
<span class="lineNum">    1065 </span>            :             {
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :                 if (PGSharedMemoryIsInUse(id1, id2))</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :                     ereport(FATAL,</span>
<span class="lineNum">    1068 </span>            :                             (errcode(ERRCODE_LOCK_FILE_EXISTS),
<span class="lineNum">    1069 </span>            :                              errmsg(&quot;pre-existing shared memory block (key %lu, ID %lu) is still in use&quot;,
<span class="lineNum">    1070 </span>            :                                     id1, id2),
<span class="lineNum">    1071 </span>            :                              errhint(&quot;Terminate any old server processes associated with data directory \&quot;%s\&quot;.&quot;,
<span class="lineNum">    1072 </span>            :                                      refName)));
<span class="lineNum">    1073 </span>            :             }
<span class="lineNum">    1074 </span>            :         }
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span>            :         /*
<span class="lineNum">    1077 </span>            :          * Looks like nobody's home.  Unlink the file and try again to create
<span class="lineNum">    1078 </span>            :          * it.  Need a loop because of possible race condition against other
<span class="lineNum">    1079 </span>            :          * would-be creators.
<span class="lineNum">    1080 </span>            :          */
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :         if (unlink(filename) &lt; 0)</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">    1083 </span>            :                     (errcode_for_file_access(),
<span class="lineNum">    1084 </span>            :                      errmsg(&quot;could not remove old lock file \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">    1085 </span>            :                             filename),
<span class="lineNum">    1086 </span>            :                      errhint(&quot;The file seems accidentally left over, but &quot;
<span class="lineNum">    1087 </span>            :                              &quot;it could not be removed. Please remove the file &quot;
<span class="lineNum">    1088 </span>            :                              &quot;by hand and try again.&quot;)));
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span>            :     /*
<span class="lineNum">    1092 </span>            :      * Successfully created the file, now fill it.  See comment in miscadmin.h
<span class="lineNum">    1093 </span>            :      * about the contents.  Note that we write the same first five lines into
<span class="lineNum">    1094 </span>            :      * both datadir and socket lockfiles; although more stuff may get added to
<span class="lineNum">    1095 </span>            :      * the datadir lockfile later.
<span class="lineNum">    1096 </span>            :      */
<span class="lineNum">    1097 </span><span class="lineCov">       2448 :     snprintf(buffer, sizeof(buffer), &quot;%d\n%s\n%ld\n%d\n%s\n&quot;,</span>
<span class="lineNum">    1098 </span>            :              amPostmaster ? (int) my_pid : -((int) my_pid),
<span class="lineNum">    1099 </span>            :              DataDir,
<span class="lineNum">    1100 </span>            :              (long) MyStartTime,
<span class="lineNum">    1101 </span>            :              PostPortNumber,
<span class="lineNum">    1102 </span>            :              socketDir);
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span>            :     /*
<span class="lineNum">    1105 </span>            :      * In a standalone backend, the next line (LOCK_FILE_LINE_LISTEN_ADDR)
<span class="lineNum">    1106 </span>            :      * will never receive data, so fill it in as empty now.
<span class="lineNum">    1107 </span>            :      */
<span class="lineNum">    1108 </span><span class="lineCov">       2448 :     if (isDDLock &amp;&amp; !amPostmaster)</span>
<span class="lineNum">    1109 </span><span class="lineCov">          8 :         strlcat(buffer, &quot;\n&quot;, sizeof(buffer));</span>
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span><span class="lineCov">       2448 :     errno = 0;</span>
<span class="lineNum">    1112 </span><span class="lineCov">       2448 :     pgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_WRITE);</span>
<span class="lineNum">    1113 </span><span class="lineCov">       2448 :     if (write(fd, buffer, strlen(buffer)) != strlen(buffer))</span>
<span class="lineNum">    1114 </span>            :     {
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :         int         save_errno = errno;</span>
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :         close(fd);</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :         unlink(filename);</span>
<span class="lineNum">    1119 </span>            :         /* if write didn't set errno, assume problem is no disk space */
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :         errno = save_errno ? save_errno : ENOSPC;</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">    1122 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1123 </span>            :                  errmsg(&quot;could not write lock file \&quot;%s\&quot;: %m&quot;, filename)));
<span class="lineNum">    1124 </span>            :     }
<span class="lineNum">    1125 </span><span class="lineCov">       2448 :     pgstat_report_wait_end();</span>
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span><span class="lineCov">       2448 :     pgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_SYNC);</span>
<span class="lineNum">    1128 </span><span class="lineCov">       2448 :     if (pg_fsync(fd) != 0)</span>
<span class="lineNum">    1129 </span>            :     {
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :         int         save_errno = errno;</span>
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :         close(fd);</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :         unlink(filename);</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :         errno = save_errno;</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">    1136 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1137 </span>            :                  errmsg(&quot;could not write lock file \&quot;%s\&quot;: %m&quot;, filename)));
<span class="lineNum">    1138 </span>            :     }
<span class="lineNum">    1139 </span><span class="lineCov">       2448 :     pgstat_report_wait_end();</span>
<span class="lineNum">    1140 </span><span class="lineCov">       2448 :     if (close(fd) != 0)</span>
<span class="lineNum">    1141 </span>            :     {
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :         int         save_errno = errno;</span>
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :         unlink(filename);</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :         errno = save_errno;</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">    1147 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1148 </span>            :                  errmsg(&quot;could not write lock file \&quot;%s\&quot;: %m&quot;, filename)));
<span class="lineNum">    1149 </span>            :     }
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span>            :     /*
<span class="lineNum">    1152 </span>            :      * Arrange to unlink the lock file(s) at proc_exit.  If this is the first
<span class="lineNum">    1153 </span>            :      * one, set up the on_proc_exit function to do it; then add this lock file
<span class="lineNum">    1154 </span>            :      * to the list of files to unlink.
<span class="lineNum">    1155 </span>            :      */
<span class="lineNum">    1156 </span><span class="lineCov">       2448 :     if (lock_files == NIL)</span>
<span class="lineNum">    1157 </span><span class="lineCov">       1228 :         on_proc_exit(UnlinkLockFiles, 0);</span>
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span>            :     /*
<span class="lineNum">    1160 </span>            :      * Use lcons so that the lock files are unlinked in reverse order of
<span class="lineNum">    1161 </span>            :      * creation; this is critical!
<span class="lineNum">    1162 </span>            :      */
<span class="lineNum">    1163 </span><span class="lineCov">       2448 :     lock_files = lcons(pstrdup(filename), lock_files);</span>
<span class="lineNum">    1164 </span><span class="lineCov">       2448 : }</span>
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span>            : /*
<span class="lineNum">    1167 </span>            :  * Create the data directory lockfile.
<span class="lineNum">    1168 </span>            :  *
<span class="lineNum">    1169 </span>            :  * When this is called, we must have already switched the working
<span class="lineNum">    1170 </span>            :  * directory to DataDir, so we can just use a relative path.  This
<span class="lineNum">    1171 </span>            :  * helps ensure that we are locking the directory we should be.
<span class="lineNum">    1172 </span>            :  *
<span class="lineNum">    1173 </span>            :  * Note that the socket directory path line is initially written as empty.
<span class="lineNum">    1174 </span>            :  * postmaster.c will rewrite it upon creating the first Unix socket.
<a name="1175"><span class="lineNum">    1175 </span>            :  */</a>
<span class="lineNum">    1176 </span>            : void
<span class="lineNum">    1177 </span><span class="lineCov">       1228 : CreateDataDirLockFile(bool amPostmaster)</span>
<span class="lineNum">    1178 </span>            : {
<span class="lineNum">    1179 </span><span class="lineCov">       1228 :     CreateLockFile(DIRECTORY_LOCK_FILE, amPostmaster, &quot;&quot;, true, DataDir);</span>
<span class="lineNum">    1180 </span><span class="lineCov">       1228 : }</span>
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span>            : /*
<span class="lineNum">    1183 </span>            :  * Create a lockfile for the specified Unix socket file.
<a name="1184"><span class="lineNum">    1184 </span>            :  */</a>
<span class="lineNum">    1185 </span>            : void
<span class="lineNum">    1186 </span><span class="lineCov">       1220 : CreateSocketLockFile(const char *socketfile, bool amPostmaster,</span>
<span class="lineNum">    1187 </span>            :                      const char *socketDir)
<span class="lineNum">    1188 </span>            : {
<span class="lineNum">    1189 </span>            :     char        lockfile[MAXPGPATH];
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span><span class="lineCov">       1220 :     snprintf(lockfile, sizeof(lockfile), &quot;%s.lock&quot;, socketfile);</span>
<span class="lineNum">    1192 </span><span class="lineCov">       1220 :     CreateLockFile(lockfile, amPostmaster, socketDir, false, socketfile);</span>
<span class="lineNum">    1193 </span><span class="lineCov">       1220 : }</span>
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span>            : /*
<span class="lineNum">    1196 </span>            :  * TouchSocketLockFiles -- mark socket lock files as recently accessed
<span class="lineNum">    1197 </span>            :  *
<span class="lineNum">    1198 </span>            :  * This routine should be called every so often to ensure that the socket
<span class="lineNum">    1199 </span>            :  * lock files have a recent mod or access date.  That saves them
<span class="lineNum">    1200 </span>            :  * from being removed by overenthusiastic /tmp-directory-cleaner daemons.
<span class="lineNum">    1201 </span>            :  * (Another reason we should never have put the socket file in /tmp...)
<a name="1202"><span class="lineNum">    1202 </span>            :  */</a>
<span class="lineNum">    1203 </span>            : void
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 : TouchSocketLockFiles(void)</span>
<span class="lineNum">    1205 </span>            : {
<span class="lineNum">    1206 </span>            :     ListCell   *l;
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :     foreach(l, lock_files)</span>
<span class="lineNum">    1209 </span>            :     {
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :         char       *socketLockFile = (char *) lfirst(l);</span>
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            :         /* No need to touch the data directory lock file, we trust */
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :         if (strcmp(socketLockFile, DIRECTORY_LOCK_FILE) == 0)</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span>            :         /*
<span class="lineNum">    1217 </span>            :          * utime() is POSIX standard, utimes() is a common alternative; if we
<span class="lineNum">    1218 </span>            :          * have neither, fall back to actually reading the file (which only
<span class="lineNum">    1219 </span>            :          * sets the access time not mod time, but that should be enough in
<span class="lineNum">    1220 </span>            :          * most cases).  In all paths, we ignore errors.
<span class="lineNum">    1221 </span>            :          */
<span class="lineNum">    1222 </span>            : #ifdef HAVE_UTIME
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :         utime(socketLockFile, NULL);</span>
<span class="lineNum">    1224 </span>            : #else                           /* !HAVE_UTIME */
<span class="lineNum">    1225 </span>            : #ifdef HAVE_UTIMES
<span class="lineNum">    1226 </span>            :         utimes(socketLockFile, NULL);
<span class="lineNum">    1227 </span>            : #else                           /* !HAVE_UTIMES */
<span class="lineNum">    1228 </span>            :         int         fd;
<span class="lineNum">    1229 </span>            :         char        buffer[1];
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span>            :         fd = open(socketLockFile, O_RDONLY | PG_BINARY, 0);
<span class="lineNum">    1232 </span>            :         if (fd &gt;= 0)
<span class="lineNum">    1233 </span>            :         {
<span class="lineNum">    1234 </span>            :             read(fd, buffer, sizeof(buffer));
<span class="lineNum">    1235 </span>            :             close(fd);
<span class="lineNum">    1236 </span>            :         }
<span class="lineNum">    1237 </span>            : #endif                          /* HAVE_UTIMES */
<span class="lineNum">    1238 </span>            : #endif                          /* HAVE_UTIME */
<span class="lineNum">    1239 </span>            :     }
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1241 </span>            : 
<span class="lineNum">    1242 </span>            : 
<span class="lineNum">    1243 </span>            : /*
<span class="lineNum">    1244 </span>            :  * Add (or replace) a line in the data directory lock file.
<span class="lineNum">    1245 </span>            :  * The given string should not include a trailing newline.
<span class="lineNum">    1246 </span>            :  *
<span class="lineNum">    1247 </span>            :  * Note: because we don't truncate the file, if we were to rewrite a line
<span class="lineNum">    1248 </span>            :  * with less data than it had before, there would be garbage after the last
<span class="lineNum">    1249 </span>            :  * line.  While we could fix that by adding a truncate call, that would make
<span class="lineNum">    1250 </span>            :  * the file update non-atomic, which we'd rather avoid.  Therefore, callers
<span class="lineNum">    1251 </span>            :  * should endeavor never to shorten a line once it's been written.
<a name="1252"><span class="lineNum">    1252 </span>            :  */</a>
<span class="lineNum">    1253 </span>            : void
<span class="lineNum">    1254 </span><span class="lineCov">       6096 : AddToDataDirLockFile(int target_line, const char *str)</span>
<span class="lineNum">    1255 </span>            : {
<span class="lineNum">    1256 </span>            :     int         fd;
<span class="lineNum">    1257 </span>            :     int         len;
<span class="lineNum">    1258 </span>            :     int         lineno;
<span class="lineNum">    1259 </span>            :     char       *srcptr;
<span class="lineNum">    1260 </span>            :     char       *destptr;
<span class="lineNum">    1261 </span>            :     char        srcbuffer[BLCKSZ];
<span class="lineNum">    1262 </span>            :     char        destbuffer[BLCKSZ];
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span><span class="lineCov">       6096 :     fd = open(DIRECTORY_LOCK_FILE, O_RDWR | PG_BINARY, 0);</span>
<span class="lineNum">    1265 </span><span class="lineCov">       6096 :     if (fd &lt; 0)</span>
<span class="lineNum">    1266 </span>            :     {
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :         ereport(LOG,</span>
<span class="lineNum">    1268 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1269 </span>            :                  errmsg(&quot;could not open file \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">    1270 </span>            :                         DIRECTORY_LOCK_FILE)));
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1272 </span>            :     }
<span class="lineNum">    1273 </span><span class="lineCov">       6096 :     pgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_ADDTODATADIR_READ);</span>
<span class="lineNum">    1274 </span><span class="lineCov">       6096 :     len = read(fd, srcbuffer, sizeof(srcbuffer) - 1);</span>
<span class="lineNum">    1275 </span><span class="lineCov">       6096 :     pgstat_report_wait_end();</span>
<span class="lineNum">    1276 </span><span class="lineCov">       6096 :     if (len &lt; 0)</span>
<span class="lineNum">    1277 </span>            :     {
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :         ereport(LOG,</span>
<span class="lineNum">    1279 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1280 </span>            :                  errmsg(&quot;could not read from file \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">    1281 </span>            :                         DIRECTORY_LOCK_FILE)));
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :         close(fd);</span>
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1284 </span>            :     }
<span class="lineNum">    1285 </span><span class="lineCov">       6096 :     srcbuffer[len] = '\0';</span>
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            :     /*
<span class="lineNum">    1288 </span>            :      * Advance over lines we are not supposed to rewrite, then copy them to
<span class="lineNum">    1289 </span>            :      * destbuffer.
<span class="lineNum">    1290 </span>            :      */
<span class="lineNum">    1291 </span><span class="lineCov">       6096 :     srcptr = srcbuffer;</span>
<span class="lineNum">    1292 </span><span class="lineCov">      40220 :     for (lineno = 1; lineno &lt; target_line; lineno++)</span>
<span class="lineNum">    1293 </span>            :     {
<span class="lineNum">    1294 </span><span class="lineCov">      35344 :         char       *eol = strchr(srcptr, '\n');</span>
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span><span class="lineCov">      35344 :         if (eol == NULL)</span>
<span class="lineNum">    1297 </span><span class="lineCov">       1220 :             break;              /* not enough lines in file yet */</span>
<span class="lineNum">    1298 </span><span class="lineCov">      34124 :         srcptr = eol + 1;</span>
<span class="lineNum">    1299 </span>            :     }
<span class="lineNum">    1300 </span><span class="lineCov">       6096 :     memcpy(destbuffer, srcbuffer, srcptr - srcbuffer);</span>
<span class="lineNum">    1301 </span><span class="lineCov">       6096 :     destptr = destbuffer + (srcptr - srcbuffer);</span>
<span class="lineNum">    1302 </span>            : 
<span class="lineNum">    1303 </span>            :     /*
<span class="lineNum">    1304 </span>            :      * Fill in any missing lines before the target line, in case lines are
<span class="lineNum">    1305 </span>            :      * added to the file out of order.
<span class="lineNum">    1306 </span>            :      */
<span class="lineNum">    1307 </span><span class="lineCov">       7316 :     for (; lineno &lt; target_line; lineno++)</span>
<span class="lineNum">    1308 </span>            :     {
<span class="lineNum">    1309 </span><span class="lineCov">       1220 :         if (destptr &lt; destbuffer + sizeof(destbuffer))</span>
<span class="lineNum">    1310 </span><span class="lineCov">       1220 :             *destptr++ = '\n';</span>
<span class="lineNum">    1311 </span>            :     }
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span>            :     /*
<span class="lineNum">    1314 </span>            :      * Write or rewrite the target line.
<span class="lineNum">    1315 </span>            :      */
<span class="lineNum">    1316 </span><span class="lineCov">       6096 :     snprintf(destptr, destbuffer + sizeof(destbuffer) - destptr, &quot;%s\n&quot;, str);</span>
<span class="lineNum">    1317 </span><span class="lineCov">       6096 :     destptr += strlen(destptr);</span>
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span>            :     /*
<span class="lineNum">    1320 </span>            :      * If there are more lines in the old file, append them to destbuffer.
<span class="lineNum">    1321 </span>            :      */
<span class="lineNum">    1322 </span><span class="lineCov">       6096 :     if ((srcptr = strchr(srcptr, '\n')) != NULL)</span>
<span class="lineNum">    1323 </span>            :     {
<span class="lineNum">    1324 </span><span class="lineCov">       3648 :         srcptr++;</span>
<span class="lineNum">    1325 </span><span class="lineCov">       3648 :         snprintf(destptr, destbuffer + sizeof(destbuffer) - destptr, &quot;%s&quot;,</span>
<span class="lineNum">    1326 </span>            :                  srcptr);
<span class="lineNum">    1327 </span>            :     }
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span>            :     /*
<span class="lineNum">    1330 </span>            :      * And rewrite the data.  Since we write in a single kernel call, this
<span class="lineNum">    1331 </span>            :      * update should appear atomic to onlookers.
<span class="lineNum">    1332 </span>            :      */
<span class="lineNum">    1333 </span><span class="lineCov">       6096 :     len = strlen(destbuffer);</span>
<span class="lineNum">    1334 </span><span class="lineCov">       6096 :     errno = 0;</span>
<span class="lineNum">    1335 </span><span class="lineCov">       6096 :     pgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_ADDTODATADIR_WRITE);</span>
<span class="lineNum">    1336 </span><span class="lineCov">      12192 :     if (lseek(fd, (off_t) 0, SEEK_SET) != 0 ||</span>
<span class="lineNum">    1337 </span><span class="lineCov">       6096 :         (int) write(fd, destbuffer, len) != len)</span>
<span class="lineNum">    1338 </span>            :     {
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :         pgstat_report_wait_end();</span>
<span class="lineNum">    1340 </span>            :         /* if write didn't set errno, assume problem is no disk space */
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :         if (errno == 0)</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :             errno = ENOSPC;</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :         ereport(LOG,</span>
<span class="lineNum">    1344 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1345 </span>            :                  errmsg(&quot;could not write to file \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">    1346 </span>            :                         DIRECTORY_LOCK_FILE)));
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :         close(fd);</span>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1349 </span>            :     }
<span class="lineNum">    1350 </span><span class="lineCov">       6096 :     pgstat_report_wait_end();</span>
<span class="lineNum">    1351 </span><span class="lineCov">       6096 :     pgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_ADDTODATADIR_SYNC);</span>
<span class="lineNum">    1352 </span><span class="lineCov">       6096 :     if (pg_fsync(fd) != 0)</span>
<span class="lineNum">    1353 </span>            :     {
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :         ereport(LOG,</span>
<span class="lineNum">    1355 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1356 </span>            :                  errmsg(&quot;could not write to file \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">    1357 </span>            :                         DIRECTORY_LOCK_FILE)));
<span class="lineNum">    1358 </span>            :     }
<span class="lineNum">    1359 </span><span class="lineCov">       6096 :     pgstat_report_wait_end();</span>
<span class="lineNum">    1360 </span><span class="lineCov">       6096 :     if (close(fd) != 0)</span>
<span class="lineNum">    1361 </span>            :     {
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :         ereport(LOG,</span>
<span class="lineNum">    1363 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1364 </span>            :                  errmsg(&quot;could not write to file \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">    1365 </span>            :                         DIRECTORY_LOCK_FILE)));
<span class="lineNum">    1366 </span>            :     }
<span class="lineNum">    1367 </span>            : }
<span class="lineNum">    1368 </span>            : 
<span class="lineNum">    1369 </span>            : 
<span class="lineNum">    1370 </span>            : /*
<span class="lineNum">    1371 </span>            :  * Recheck that the data directory lock file still exists with expected
<span class="lineNum">    1372 </span>            :  * content.  Return true if the lock file appears OK, false if it isn't.
<span class="lineNum">    1373 </span>            :  *
<span class="lineNum">    1374 </span>            :  * We call this periodically in the postmaster.  The idea is that if the
<span class="lineNum">    1375 </span>            :  * lock file has been removed or replaced by another postmaster, we should
<span class="lineNum">    1376 </span>            :  * do a panic database shutdown.  Therefore, we should return true if there
<span class="lineNum">    1377 </span>            :  * is any doubt: we do not want to cause a panic shutdown unnecessarily.
<span class="lineNum">    1378 </span>            :  * Transient failures like EINTR or ENFILE should not cause us to fail.
<span class="lineNum">    1379 </span>            :  * (If there really is something wrong, we'll detect it on a future recheck.)
<a name="1380"><span class="lineNum">    1380 </span>            :  */</a>
<span class="lineNum">    1381 </span>            : bool
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 : RecheckDataDirLockFile(void)</span>
<span class="lineNum">    1383 </span>            : {
<span class="lineNum">    1384 </span>            :     int         fd;
<span class="lineNum">    1385 </span>            :     int         len;
<span class="lineNum">    1386 </span>            :     long        file_pid;
<span class="lineNum">    1387 </span>            :     char        buffer[BLCKSZ];
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :     fd = open(DIRECTORY_LOCK_FILE, O_RDWR | PG_BINARY, 0);</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :     if (fd &lt; 0)</span>
<span class="lineNum">    1391 </span>            :     {
<span class="lineNum">    1392 </span>            :         /*
<span class="lineNum">    1393 </span>            :          * There are many foreseeable false-positive error conditions.  For
<span class="lineNum">    1394 </span>            :          * safety, fail only on enumerated clearly-something-is-wrong
<span class="lineNum">    1395 </span>            :          * conditions.
<span class="lineNum">    1396 </span>            :          */
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :         switch (errno)</span>
<span class="lineNum">    1398 </span>            :         {
<span class="lineNum">    1399 </span>            :             case ENOENT:
<span class="lineNum">    1400 </span>            :             case ENOTDIR:
<span class="lineNum">    1401 </span>            :                 /* disaster */
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :                 ereport(LOG,</span>
<span class="lineNum">    1403 </span>            :                         (errcode_for_file_access(),
<span class="lineNum">    1404 </span>            :                          errmsg(&quot;could not open file \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">    1405 </span>            :                                 DIRECTORY_LOCK_FILE)));
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    1407 </span>            :             default:
<span class="lineNum">    1408 </span>            :                 /* non-fatal, at least for now */
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :                 ereport(LOG,</span>
<span class="lineNum">    1410 </span>            :                         (errcode_for_file_access(),
<span class="lineNum">    1411 </span>            :                          errmsg(&quot;could not open file \&quot;%s\&quot;: %m; continuing anyway&quot;,
<span class="lineNum">    1412 </span>            :                                 DIRECTORY_LOCK_FILE)));
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">    1414 </span>            :         }
<span class="lineNum">    1415 </span>            :     }
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :     pgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_RECHECKDATADIR_READ);</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :     len = read(fd, buffer, sizeof(buffer) - 1);</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :     pgstat_report_wait_end();</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :     if (len &lt; 0)</span>
<span class="lineNum">    1420 </span>            :     {
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :         ereport(LOG,</span>
<span class="lineNum">    1422 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1423 </span>            :                  errmsg(&quot;could not read from file \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">    1424 </span>            :                         DIRECTORY_LOCK_FILE)));
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :         close(fd);</span>
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :         return true;            /* treat read failure as nonfatal */</span>
<span class="lineNum">    1427 </span>            :     }
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :     buffer[len] = '\0';</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :     close(fd);</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :     file_pid = atol(buffer);</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :     if (file_pid == getpid())</span>
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :         return true;            /* all is well */</span>
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span>            :     /* Trouble: someone's overwritten the lock file */
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :     ereport(LOG,</span>
<span class="lineNum">    1436 </span>            :             (errmsg(&quot;lock file \&quot;%s\&quot; contains wrong PID: %ld instead of %ld&quot;,
<span class="lineNum">    1437 </span>            :                     DIRECTORY_LOCK_FILE, file_pid, (long) getpid())));
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1439 </span>            : }
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span>            : /*-------------------------------------------------------------------------
<span class="lineNum">    1443 </span>            :  *              Version checking support
<span class="lineNum">    1444 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">    1445 </span>            :  */
<span class="lineNum">    1446 </span>            : 
<span class="lineNum">    1447 </span>            : /*
<span class="lineNum">    1448 </span>            :  * Determine whether the PG_VERSION file in directory `path' indicates
<span class="lineNum">    1449 </span>            :  * a data version compatible with the version of this program.
<span class="lineNum">    1450 </span>            :  *
<span class="lineNum">    1451 </span>            :  * If compatible, return. Otherwise, ereport(FATAL).
<a name="1452"><span class="lineNum">    1452 </span>            :  */</a>
<span class="lineNum">    1453 </span>            : void
<span class="lineNum">    1454 </span><span class="lineCov">       2434 : ValidatePgVersion(const char *path)</span>
<span class="lineNum">    1455 </span>            : {
<span class="lineNum">    1456 </span>            :     char        full_path[MAXPGPATH];
<span class="lineNum">    1457 </span>            :     FILE       *file;
<span class="lineNum">    1458 </span>            :     int         ret;
<span class="lineNum">    1459 </span>            :     long        file_major;
<span class="lineNum">    1460 </span>            :     long        my_major;
<span class="lineNum">    1461 </span>            :     char       *endptr;
<span class="lineNum">    1462 </span>            :     char        file_version_string[64];
<span class="lineNum">    1463 </span><span class="lineCov">       2434 :     const char *my_version_string = PG_VERSION;</span>
<span class="lineNum">    1464 </span>            : 
<span class="lineNum">    1465 </span><span class="lineCov">       2434 :     my_major = strtol(my_version_string, &amp;endptr, 10);</span>
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span><span class="lineCov">       2434 :     snprintf(full_path, sizeof(full_path), &quot;%s/PG_VERSION&quot;, path);</span>
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span><span class="lineCov">       2434 :     file = AllocateFile(full_path, &quot;r&quot;);</span>
<span class="lineNum">    1470 </span><span class="lineCov">       2434 :     if (!file)</span>
<span class="lineNum">    1471 </span>            :     {
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :         if (errno == ENOENT)</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">    1474 </span>            :                     (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
<span class="lineNum">    1475 </span>            :                      errmsg(&quot;\&quot;%s\&quot; is not a valid data directory&quot;,
<span class="lineNum">    1476 </span>            :                             path),
<span class="lineNum">    1477 </span>            :                      errdetail(&quot;File \&quot;%s\&quot; is missing.&quot;, full_path)));
<span class="lineNum">    1478 </span>            :         else
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">    1480 </span>            :                     (errcode_for_file_access(),
<span class="lineNum">    1481 </span>            :                      errmsg(&quot;could not open file \&quot;%s\&quot;: %m&quot;, full_path)));
<span class="lineNum">    1482 </span>            :     }
<span class="lineNum">    1483 </span>            : 
<span class="lineNum">    1484 </span><span class="lineCov">       2434 :     file_version_string[0] = '\0';</span>
<span class="lineNum">    1485 </span><span class="lineCov">       2434 :     ret = fscanf(file, &quot;%63s&quot;, file_version_string);</span>
<span class="lineNum">    1486 </span><span class="lineCov">       2434 :     file_major = strtol(file_version_string, &amp;endptr, 10);</span>
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span><span class="lineCov">       2434 :     if (ret != 1 || endptr == file_version_string)</span>
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">    1490 </span>            :                 (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
<span class="lineNum">    1491 </span>            :                  errmsg(&quot;\&quot;%s\&quot; is not a valid data directory&quot;,
<span class="lineNum">    1492 </span>            :                         path),
<span class="lineNum">    1493 </span>            :                  errdetail(&quot;File \&quot;%s\&quot; does not contain valid data.&quot;,
<span class="lineNum">    1494 </span>            :                            full_path),
<span class="lineNum">    1495 </span>            :                  errhint(&quot;You might need to initdb.&quot;)));
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span><span class="lineCov">       2434 :     FreeFile(file);</span>
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span><span class="lineCov">       2434 :     if (my_major != file_major)</span>
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">    1501 </span>            :                 (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
<span class="lineNum">    1502 </span>            :                  errmsg(&quot;database files are incompatible with server&quot;),
<span class="lineNum">    1503 </span>            :                  errdetail(&quot;The data directory was initialized by PostgreSQL version %s, &quot;
<span class="lineNum">    1504 </span>            :                            &quot;which is not compatible with this version %s.&quot;,
<span class="lineNum">    1505 </span>            :                            file_version_string, my_version_string)));
<span class="lineNum">    1506 </span><span class="lineCov">       2434 : }</span>
<span class="lineNum">    1507 </span>            : 
<span class="lineNum">    1508 </span>            : /*-------------------------------------------------------------------------
<span class="lineNum">    1509 </span>            :  *              Library preload support
<span class="lineNum">    1510 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">    1511 </span>            :  */
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span>            : /*
<span class="lineNum">    1514 </span>            :  * GUC variables: lists of library names to be preloaded at postmaster
<span class="lineNum">    1515 </span>            :  * start and at backend start
<span class="lineNum">    1516 </span>            :  */
<span class="lineNum">    1517 </span>            : char       *session_preload_libraries_string = NULL;
<span class="lineNum">    1518 </span>            : char       *shared_preload_libraries_string = NULL;
<span class="lineNum">    1519 </span>            : char       *local_preload_libraries_string = NULL;
<span class="lineNum">    1520 </span>            : 
<span class="lineNum">    1521 </span>            : /* Flag telling that we are loading shared_preload_libraries */
<span class="lineNum">    1522 </span>            : bool        process_shared_preload_libraries_in_progress = false;
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span>            : /*
<span class="lineNum">    1525 </span>            :  * load the shared libraries listed in 'libraries'
<span class="lineNum">    1526 </span>            :  *
<span class="lineNum">    1527 </span>            :  * 'gucname': name of GUC variable, for error reports
<span class="lineNum">    1528 </span>            :  * 'restricted': if true, force libraries to be in $libdir/plugins/
<a name="1529"><span class="lineNum">    1529 </span>            :  */</a>
<span class="lineNum">    1530 </span>            : static void
<span class="lineNum">    1531 </span><span class="lineCov">       2132 : load_libraries(const char *libraries, const char *gucname, bool restricted)</span>
<span class="lineNum">    1532 </span>            : {
<span class="lineNum">    1533 </span>            :     char       *rawstring;
<span class="lineNum">    1534 </span>            :     List       *elemlist;
<span class="lineNum">    1535 </span>            :     ListCell   *l;
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span><span class="lineCov">       2132 :     if (libraries == NULL || libraries[0] == '\0')</span>
<span class="lineNum">    1538 </span><span class="lineCov">       4264 :         return;                 /* nothing to do */</span>
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span>            :     /* Need a modifiable copy of string */
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :     rawstring = pstrdup(libraries);</span>
<span class="lineNum">    1542 </span>            : 
<span class="lineNum">    1543 </span>            :     /* Parse string into list of filename paths */
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :     if (!SplitDirectoriesString(rawstring, ',', &amp;elemlist))</span>
<span class="lineNum">    1545 </span>            :     {
<span class="lineNum">    1546 </span>            :         /* syntax error in list */
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :         list_free_deep(elemlist);</span>
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :         pfree(rawstring);</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :         ereport(LOG,</span>
<span class="lineNum">    1550 </span>            :                 (errcode(ERRCODE_SYNTAX_ERROR),
<span class="lineNum">    1551 </span>            :                  errmsg(&quot;invalid list syntax in parameter \&quot;%s\&quot;&quot;,
<span class="lineNum">    1552 </span>            :                         gucname)));
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1554 </span>            :     }
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :     foreach(l, elemlist)</span>
<span class="lineNum">    1557 </span>            :     {
<span class="lineNum">    1558 </span>            :         /* Note that filename was already canonicalized */
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :         char       *filename = (char *) lfirst(l);</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :         char       *expanded = NULL;</span>
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span>            :         /* If restricting, insert $libdir/plugins if not mentioned already */
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :         if (restricted &amp;&amp; first_dir_separator(filename) == NULL)</span>
<span class="lineNum">    1564 </span>            :         {
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :             expanded = psprintf(&quot;$libdir/plugins/%s&quot;, filename);</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :             filename = expanded;</span>
<span class="lineNum">    1567 </span>            :         }
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :         load_file(filename, restricted);</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :         ereport(DEBUG1,</span>
<span class="lineNum">    1570 </span>            :                 (errmsg(&quot;loaded library \&quot;%s\&quot;&quot;, filename)));
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :         if (expanded)</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :             pfree(expanded);</span>
<span class="lineNum">    1573 </span>            :     }
<span class="lineNum">    1574 </span>            : 
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :     list_free_deep(elemlist);</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :     pfree(rawstring);</span>
<span class="lineNum">    1577 </span>            : }
<span class="lineNum">    1578 </span>            : 
<span class="lineNum">    1579 </span>            : /*
<span class="lineNum">    1580 </span>            :  * process any libraries that should be preloaded at postmaster start
<a name="1581"><span class="lineNum">    1581 </span>            :  */</a>
<span class="lineNum">    1582 </span>            : void
<span class="lineNum">    1583 </span><span class="lineCov">       1220 : process_shared_preload_libraries(void)</span>
<span class="lineNum">    1584 </span>            : {
<span class="lineNum">    1585 </span><span class="lineCov">       1220 :     process_shared_preload_libraries_in_progress = true;</span>
<span class="lineNum">    1586 </span><span class="lineCov">       1220 :     load_libraries(shared_preload_libraries_string,</span>
<span class="lineNum">    1587 </span>            :                    &quot;shared_preload_libraries&quot;,
<span class="lineNum">    1588 </span>            :                    false);
<span class="lineNum">    1589 </span><span class="lineCov">       1220 :     process_shared_preload_libraries_in_progress = false;</span>
<span class="lineNum">    1590 </span><span class="lineCov">       1220 : }</span>
<span class="lineNum">    1591 </span>            : 
<span class="lineNum">    1592 </span>            : /*
<span class="lineNum">    1593 </span>            :  * process any libraries that should be preloaded at backend start
<a name="1594"><span class="lineNum">    1594 </span>            :  */</a>
<span class="lineNum">    1595 </span>            : void
<span class="lineNum">    1596 </span><span class="lineCov">        456 : process_session_preload_libraries(void)</span>
<span class="lineNum">    1597 </span>            : {
<span class="lineNum">    1598 </span><span class="lineCov">        456 :     load_libraries(session_preload_libraries_string,</span>
<span class="lineNum">    1599 </span>            :                    &quot;session_preload_libraries&quot;,
<span class="lineNum">    1600 </span>            :                    false);
<span class="lineNum">    1601 </span><span class="lineCov">        456 :     load_libraries(local_preload_libraries_string,</span>
<span class="lineNum">    1602 </span>            :                    &quot;local_preload_libraries&quot;,
<span class="lineNum">    1603 </span>            :                    true);
<span class="lineNum">    1604 </span><span class="lineCov">        456 : }</span>
<a name="1605"><span class="lineNum">    1605 </span>            : </a>
<span class="lineNum">    1606 </span>            : void
<span class="lineNum">    1607 </span><span class="lineCov">        788 : pg_bindtextdomain(const char *domain)</span>
<span class="lineNum">    1608 </span>            : {
<span class="lineNum">    1609 </span>            : #ifdef ENABLE_NLS
<span class="lineNum">    1610 </span>            :     if (my_exec_path[0] != '\0')
<span class="lineNum">    1611 </span>            :     {
<span class="lineNum">    1612 </span>            :         char        locale_path[MAXPGPATH];
<span class="lineNum">    1613 </span>            : 
<span class="lineNum">    1614 </span>            :         get_locale_path(my_exec_path, locale_path);
<span class="lineNum">    1615 </span>            :         bindtextdomain(domain, locale_path);
<span class="lineNum">    1616 </span>            :         pg_bind_textdomain_codeset(domain);
<span class="lineNum">    1617 </span>            :     }
<span class="lineNum">    1618 </span>            : #endif
<span class="lineNum">    1619 </span><span class="lineCov">        788 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
