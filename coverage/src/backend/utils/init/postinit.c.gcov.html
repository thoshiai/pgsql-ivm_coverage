<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/utils/init/postinit.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/backend/utils/init</a> - postinit.c<span style="font-size: 80%;"> (source / <a href="postinit.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">239</td>
            <td class="headerCovTableEntry">305</td>
            <td class="headerCovTableEntryMed">78.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">13</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntryMed">81.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * postinit.c
<span class="lineNum">       4 </span>            :  *    postgres initialization utilities
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * IDENTIFICATION
<span class="lineNum">      11 </span>            :  *    src/backend/utils/init/postinit.c
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  *
<span class="lineNum">      14 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      15 </span>            :  */
<span class="lineNum">      16 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &lt;ctype.h&gt;
<span class="lineNum">      19 </span>            : #include &lt;fcntl.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;access/genam.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;access/heapam.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;access/htup_details.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;access/session.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;access/sysattr.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;access/tableam.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;access/xact.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;access/xlog.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;catalog/catalog.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;catalog/indexing.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;catalog/namespace.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;catalog/pg_authid.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;catalog/pg_database.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;catalog/pg_db_role_setting.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;catalog/pg_tablespace.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;libpq/auth.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;libpq/libpq-be.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;mb/pg_wchar.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;miscadmin.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;pgstat.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;postmaster/autovacuum.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;postmaster/postmaster.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;replication/walsender.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;storage/bufmgr.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;storage/fd.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;storage/ipc.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;storage/lmgr.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;storage/proc.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;storage/procarray.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;storage/procsignal.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;storage/sinvaladt.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;storage/smgr.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;storage/sync.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;tcop/tcopprot.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;utils/acl.h&quot;
<span class="lineNum">      57 </span>            : #include &quot;utils/fmgroids.h&quot;
<span class="lineNum">      58 </span>            : #include &quot;utils/guc.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;utils/memutils.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;utils/pg_locale.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;utils/portal.h&quot;
<span class="lineNum">      62 </span>            : #include &quot;utils/ps_status.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;utils/snapmgr.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;utils/syscache.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;utils/timeout.h&quot;
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : static HeapTuple GetDatabaseTuple(const char *dbname);
<span class="lineNum">      68 </span>            : static HeapTuple GetDatabaseTupleByOid(Oid dboid);
<span class="lineNum">      69 </span>            : static void PerformAuthentication(Port *port);
<span class="lineNum">      70 </span>            : static void CheckMyDatabase(const char *name, bool am_superuser, bool override_allow_connections);
<span class="lineNum">      71 </span>            : static void InitCommunication(void);
<span class="lineNum">      72 </span>            : static void ShutdownPostgres(int code, Datum arg);
<span class="lineNum">      73 </span>            : static void StatementTimeoutHandler(void);
<span class="lineNum">      74 </span>            : static void LockTimeoutHandler(void);
<span class="lineNum">      75 </span>            : static void IdleInTransactionSessionTimeoutHandler(void);
<span class="lineNum">      76 </span>            : static bool ThereIsAtLeastOneRole(void);
<span class="lineNum">      77 </span>            : static void process_startup_options(Port *port, bool am_superuser);
<span class="lineNum">      78 </span>            : static void process_settings(Oid databaseid, Oid roleid);
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : /*** InitPostgres support ***/
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            : /*
<span class="lineNum">      85 </span>            :  * GetDatabaseTuple -- fetch the pg_database row for a database
<span class="lineNum">      86 </span>            :  *
<span class="lineNum">      87 </span>            :  * This is used during backend startup when we don't yet have any access to
<span class="lineNum">      88 </span>            :  * system catalogs in general.  In the worst case, we can seqscan pg_database
<span class="lineNum">      89 </span>            :  * using nothing but the hard-wired descriptor that relcache.c creates for
<span class="lineNum">      90 </span>            :  * pg_database.  In more typical cases, relcache.c was able to load
<span class="lineNum">      91 </span>            :  * descriptors for both pg_database and its indexes from the shared relcache
<span class="lineNum">      92 </span>            :  * cache file, and so we can do an indexscan.  criticalSharedRelcachesBuilt
<span class="lineNum">      93 </span>            :  * tells whether we got the cached descriptors.
<a name="94"><span class="lineNum">      94 </span>            :  */</a>
<span class="lineNum">      95 </span>            : static HeapTuple
<span class="lineNum">      96 </span><span class="lineCov">       1662 : GetDatabaseTuple(const char *dbname)</span>
<span class="lineNum">      97 </span>            : {
<span class="lineNum">      98 </span>            :     HeapTuple   tuple;
<span class="lineNum">      99 </span>            :     Relation    relation;
<span class="lineNum">     100 </span>            :     SysScanDesc scan;
<span class="lineNum">     101 </span>            :     ScanKeyData key[1];
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            :     /*
<span class="lineNum">     104 </span>            :      * form a scan key
<span class="lineNum">     105 </span>            :      */
<span class="lineNum">     106 </span><span class="lineCov">       1662 :     ScanKeyInit(&amp;key[0],</span>
<span class="lineNum">     107 </span>            :                 Anum_pg_database_datname,
<span class="lineNum">     108 </span>            :                 BTEqualStrategyNumber, F_NAMEEQ,
<span class="lineNum">     109 </span>            :                 CStringGetDatum(dbname));
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :     /*
<span class="lineNum">     112 </span>            :      * Open pg_database and fetch a tuple.  Force heap scan if we haven't yet
<span class="lineNum">     113 </span>            :      * built the critical shared relcache entries (i.e., we're starting up
<span class="lineNum">     114 </span>            :      * without a shared relcache cache file).
<span class="lineNum">     115 </span>            :      */
<span class="lineNum">     116 </span><span class="lineCov">       1662 :     relation = table_open(DatabaseRelationId, AccessShareLock);</span>
<span class="lineNum">     117 </span><span class="lineCov">       1662 :     scan = systable_beginscan(relation, DatabaseNameIndexId,</span>
<span class="lineNum">     118 </span>            :                               criticalSharedRelcachesBuilt,
<span class="lineNum">     119 </span>            :                               NULL,
<span class="lineNum">     120 </span>            :                               1, key);
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span><span class="lineCov">       1662 :     tuple = systable_getnext(scan);</span>
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            :     /* Must copy tuple before releasing buffer */
<span class="lineNum">     125 </span><span class="lineCov">       1662 :     if (HeapTupleIsValid(tuple))</span>
<span class="lineNum">     126 </span><span class="lineCov">       1662 :         tuple = heap_copytuple(tuple);</span>
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :     /* all done */
<span class="lineNum">     129 </span><span class="lineCov">       1662 :     systable_endscan(scan);</span>
<span class="lineNum">     130 </span><span class="lineCov">       1662 :     table_close(relation, AccessShareLock);</span>
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span><span class="lineCov">       1662 :     return tuple;</span>
<span class="lineNum">     133 </span>            : }
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : /*
<span class="lineNum">     136 </span>            :  * GetDatabaseTupleByOid -- as above, but search by database OID
<a name="137"><span class="lineNum">     137 </span>            :  */</a>
<span class="lineNum">     138 </span>            : static HeapTuple
<span class="lineNum">     139 </span><span class="lineCov">        750 : GetDatabaseTupleByOid(Oid dboid)</span>
<span class="lineNum">     140 </span>            : {
<span class="lineNum">     141 </span>            :     HeapTuple   tuple;
<span class="lineNum">     142 </span>            :     Relation    relation;
<span class="lineNum">     143 </span>            :     SysScanDesc scan;
<span class="lineNum">     144 </span>            :     ScanKeyData key[1];
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            :     /*
<span class="lineNum">     147 </span>            :      * form a scan key
<span class="lineNum">     148 </span>            :      */
<span class="lineNum">     149 </span><span class="lineCov">        750 :     ScanKeyInit(&amp;key[0],</span>
<span class="lineNum">     150 </span>            :                 Anum_pg_database_oid,
<span class="lineNum">     151 </span>            :                 BTEqualStrategyNumber, F_OIDEQ,
<span class="lineNum">     152 </span>            :                 ObjectIdGetDatum(dboid));
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :     /*
<span class="lineNum">     155 </span>            :      * Open pg_database and fetch a tuple.  Force heap scan if we haven't yet
<span class="lineNum">     156 </span>            :      * built the critical shared relcache entries (i.e., we're starting up
<span class="lineNum">     157 </span>            :      * without a shared relcache cache file).
<span class="lineNum">     158 </span>            :      */
<span class="lineNum">     159 </span><span class="lineCov">        750 :     relation = table_open(DatabaseRelationId, AccessShareLock);</span>
<span class="lineNum">     160 </span><span class="lineCov">        750 :     scan = systable_beginscan(relation, DatabaseOidIndexId,</span>
<span class="lineNum">     161 </span>            :                               criticalSharedRelcachesBuilt,
<span class="lineNum">     162 </span>            :                               NULL,
<span class="lineNum">     163 </span>            :                               1, key);
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span><span class="lineCov">        750 :     tuple = systable_getnext(scan);</span>
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :     /* Must copy tuple before releasing buffer */
<span class="lineNum">     168 </span><span class="lineCov">        750 :     if (HeapTupleIsValid(tuple))</span>
<span class="lineNum">     169 </span><span class="lineCov">        750 :         tuple = heap_copytuple(tuple);</span>
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            :     /* all done */
<span class="lineNum">     172 </span><span class="lineCov">        750 :     systable_endscan(scan);</span>
<span class="lineNum">     173 </span><span class="lineCov">        750 :     table_close(relation, AccessShareLock);</span>
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span><span class="lineCov">        750 :     return tuple;</span>
<span class="lineNum">     176 </span>            : }
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : /*
<span class="lineNum">     180 </span>            :  * PerformAuthentication -- authenticate a remote client
<span class="lineNum">     181 </span>            :  *
<span class="lineNum">     182 </span>            :  * returns: nothing.  Will not return at all if there's any failure.
<a name="183"><span class="lineNum">     183 </span>            :  */</a>
<span class="lineNum">     184 </span>            : static void
<span class="lineNum">     185 </span><span class="lineCov">        454 : PerformAuthentication(Port *port)</span>
<span class="lineNum">     186 </span>            : {
<span class="lineNum">     187 </span>            :     /* This should be set already, but let's make sure */
<span class="lineNum">     188 </span><span class="lineCov">        454 :     ClientAuthInProgress = true;    /* limit visibility of log messages */</span>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :     /*
<span class="lineNum">     191 </span>            :      * In EXEC_BACKEND case, we didn't inherit the contents of pg_hba.conf
<span class="lineNum">     192 </span>            :      * etcetera from the postmaster, and have to load them ourselves.
<span class="lineNum">     193 </span>            :      *
<span class="lineNum">     194 </span>            :      * FIXME: [fork/exec] Ugh.  Is there a way around this overhead?
<span class="lineNum">     195 </span>            :      */
<span class="lineNum">     196 </span>            : #ifdef EXEC_BACKEND
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :     /*
<span class="lineNum">     199 </span>            :      * load_hba() and load_ident() want to work within the PostmasterContext,
<span class="lineNum">     200 </span>            :      * so create that if it doesn't exist (which it won't).  We'll delete it
<span class="lineNum">     201 </span>            :      * again later, in PostgresMain.
<span class="lineNum">     202 </span>            :      */
<span class="lineNum">     203 </span>            :     if (PostmasterContext == NULL)
<span class="lineNum">     204 </span>            :         PostmasterContext = AllocSetContextCreate(TopMemoryContext,
<span class="lineNum">     205 </span>            :                                                   &quot;Postmaster&quot;,
<span class="lineNum">     206 </span>            :                                                   ALLOCSET_DEFAULT_SIZES);
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            :     if (!load_hba())
<span class="lineNum">     209 </span>            :     {
<span class="lineNum">     210 </span>            :         /*
<span class="lineNum">     211 </span>            :          * It makes no sense to continue if we fail to load the HBA file,
<span class="lineNum">     212 </span>            :          * since there is no way to connect to the database in this case.
<span class="lineNum">     213 </span>            :          */
<span class="lineNum">     214 </span>            :         ereport(FATAL,
<span class="lineNum">     215 </span>            :                 (errmsg(&quot;could not load pg_hba.conf&quot;)));
<span class="lineNum">     216 </span>            :     }
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            :     if (!load_ident())
<span class="lineNum">     219 </span>            :     {
<span class="lineNum">     220 </span>            :         /*
<span class="lineNum">     221 </span>            :          * It is ok to continue if we fail to load the IDENT file, although it
<span class="lineNum">     222 </span>            :          * means that you cannot log in using any of the authentication
<span class="lineNum">     223 </span>            :          * methods that need a user name mapping. load_ident() already logged
<span class="lineNum">     224 </span>            :          * the details of error to the log.
<span class="lineNum">     225 </span>            :          */
<span class="lineNum">     226 </span>            :     }
<span class="lineNum">     227 </span>            : #endif
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :     /*
<span class="lineNum">     230 </span>            :      * Set up a timeout in case a buggy or malicious client fails to respond
<span class="lineNum">     231 </span>            :      * during authentication.  Since we're inside a transaction and might do
<span class="lineNum">     232 </span>            :      * database access, we have to use the statement_timeout infrastructure.
<span class="lineNum">     233 </span>            :      */
<span class="lineNum">     234 </span><span class="lineCov">        454 :     enable_timeout_after(STATEMENT_TIMEOUT, AuthenticationTimeout * 1000);</span>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :     /*
<span class="lineNum">     237 </span>            :      * Now perform authentication exchange.
<span class="lineNum">     238 </span>            :      */
<span class="lineNum">     239 </span><span class="lineCov">        454 :     ClientAuthentication(port); /* might not return, if failure */</span>
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            :     /*
<span class="lineNum">     242 </span>            :      * Done with authentication.  Disable the timeout, and log if needed.
<span class="lineNum">     243 </span>            :      */
<span class="lineNum">     244 </span><span class="lineCov">        454 :     disable_timeout(STATEMENT_TIMEOUT, false);</span>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineCov">        454 :     if (Log_connections)</span>
<span class="lineNum">     247 </span>            :     {
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         if (am_walsender)</span>
<span class="lineNum">     249 </span>            :         {
<span class="lineNum">     250 </span>            : #ifdef USE_SSL
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :             if (port-&gt;ssl_in_use)</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :                 ereport(LOG,</span>
<span class="lineNum">     253 </span>            :                         (port-&gt;application_name != NULL
<span class="lineNum">     254 </span>            :                          ? errmsg(&quot;replication connection authorized: user=%s application_name=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)&quot;,
<span class="lineNum">     255 </span>            :                                   port-&gt;user_name,
<span class="lineNum">     256 </span>            :                                   port-&gt;application_name,
<span class="lineNum">     257 </span>            :                                   be_tls_get_version(port),
<span class="lineNum">     258 </span>            :                                   be_tls_get_cipher(port),
<span class="lineNum">     259 </span>            :                                   be_tls_get_cipher_bits(port),
<span class="lineNum">     260 </span>            :                                   be_tls_get_compression(port) ? _(&quot;on&quot;) : _(&quot;off&quot;))
<span class="lineNum">     261 </span>            :                          : errmsg(&quot;replication connection authorized: user=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)&quot;,
<span class="lineNum">     262 </span>            :                                   port-&gt;user_name,
<span class="lineNum">     263 </span>            :                                   be_tls_get_version(port),
<span class="lineNum">     264 </span>            :                                   be_tls_get_cipher(port),
<span class="lineNum">     265 </span>            :                                   be_tls_get_cipher_bits(port),
<span class="lineNum">     266 </span>            :                                   be_tls_get_compression(port) ? _(&quot;on&quot;) : _(&quot;off&quot;))));
<span class="lineNum">     267 </span>            :             else
<span class="lineNum">     268 </span>            : #endif
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :                 ereport(LOG,</span>
<span class="lineNum">     270 </span>            :                         (port-&gt;application_name != NULL
<span class="lineNum">     271 </span>            :                          ? errmsg(&quot;replication connection authorized: user=%s application_name=%s&quot;,
<span class="lineNum">     272 </span>            :                                   port-&gt;user_name,
<span class="lineNum">     273 </span>            :                                   port-&gt;application_name)
<span class="lineNum">     274 </span>            :                          : errmsg(&quot;replication connection authorized: user=%s&quot;,
<span class="lineNum">     275 </span>            :                                   port-&gt;user_name)));
<span class="lineNum">     276 </span>            :         }
<span class="lineNum">     277 </span>            :         else
<span class="lineNum">     278 </span>            :         {
<span class="lineNum">     279 </span>            : #ifdef USE_SSL
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :             if (port-&gt;ssl_in_use)</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :                 ereport(LOG,</span>
<span class="lineNum">     282 </span>            :                         (port-&gt;application_name != NULL
<span class="lineNum">     283 </span>            :                          ? errmsg(&quot;connection authorized: user=%s database=%s application_name=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)&quot;,
<span class="lineNum">     284 </span>            :                                   port-&gt;user_name, port-&gt;database_name, port-&gt;application_name,
<span class="lineNum">     285 </span>            :                                   be_tls_get_version(port),
<span class="lineNum">     286 </span>            :                                   be_tls_get_cipher(port),
<span class="lineNum">     287 </span>            :                                   be_tls_get_cipher_bits(port),
<span class="lineNum">     288 </span>            :                                   be_tls_get_compression(port) ? _(&quot;on&quot;) : _(&quot;off&quot;))
<span class="lineNum">     289 </span>            :                          : errmsg(&quot;connection authorized: user=%s database=%s SSL enabled (protocol=%s, cipher=%s, bits=%d, compression=%s)&quot;,
<span class="lineNum">     290 </span>            :                                   port-&gt;user_name, port-&gt;database_name,
<span class="lineNum">     291 </span>            :                                   be_tls_get_version(port),
<span class="lineNum">     292 </span>            :                                   be_tls_get_cipher(port),
<span class="lineNum">     293 </span>            :                                   be_tls_get_cipher_bits(port),
<span class="lineNum">     294 </span>            :                                   be_tls_get_compression(port) ? _(&quot;on&quot;) : _(&quot;off&quot;))));
<span class="lineNum">     295 </span>            :             else
<span class="lineNum">     296 </span>            : #endif
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :                 ereport(LOG,</span>
<span class="lineNum">     298 </span>            :                         (port-&gt;application_name != NULL
<span class="lineNum">     299 </span>            :                          ? errmsg(&quot;connection authorized: user=%s database=%s application_name=%s&quot;,
<span class="lineNum">     300 </span>            :                                   port-&gt;user_name, port-&gt;database_name, port-&gt;application_name)
<span class="lineNum">     301 </span>            :                          : errmsg(&quot;connection authorized: user=%s database=%s&quot;,
<span class="lineNum">     302 </span>            :                                   port-&gt;user_name, port-&gt;database_name)));
<span class="lineNum">     303 </span>            :         }
<span class="lineNum">     304 </span>            :     }
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span><span class="lineCov">        454 :     set_ps_display(&quot;startup&quot;, false);</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineCov">        454 :     ClientAuthInProgress = false;   /* client_min_messages is active now */</span>
<span class="lineNum">     309 </span><span class="lineCov">        454 : }</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : /*
<span class="lineNum">     313 </span>            :  * CheckMyDatabase -- fetch information from the pg_database entry for our DB
<a name="314"><span class="lineNum">     314 </span>            :  */</a>
<span class="lineNum">     315 </span>            : static void
<span class="lineNum">     316 </span><span class="lineCov">       1206 : CheckMyDatabase(const char *name, bool am_superuser, bool override_allow_connections)</span>
<span class="lineNum">     317 </span>            : {
<span class="lineNum">     318 </span>            :     HeapTuple   tup;
<span class="lineNum">     319 </span>            :     Form_pg_database dbform;
<span class="lineNum">     320 </span>            :     char       *collate;
<span class="lineNum">     321 </span>            :     char       *ctype;
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            :     /* Fetch our pg_database row normally, via syscache */
<span class="lineNum">     324 </span><span class="lineCov">       1206 :     tup = SearchSysCache1(DATABASEOID, ObjectIdGetDatum(MyDatabaseId));</span>
<span class="lineNum">     325 </span><span class="lineCov">       1206 :     if (!HeapTupleIsValid(tup))</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cache lookup failed for database %u&quot;, MyDatabaseId);</span>
<span class="lineNum">     327 </span><span class="lineCov">       1206 :     dbform = (Form_pg_database) GETSTRUCT(tup);</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :     /* This recheck is strictly paranoia */
<span class="lineNum">     330 </span><span class="lineCov">       1206 :     if (strcmp(name, NameStr(dbform-&gt;datname)) != 0)</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">     332 </span>            :                 (errcode(ERRCODE_UNDEFINED_DATABASE),
<span class="lineNum">     333 </span>            :                  errmsg(&quot;database \&quot;%s\&quot; has disappeared from pg_database&quot;,
<span class="lineNum">     334 </span>            :                         name),
<span class="lineNum">     335 </span>            :                  errdetail(&quot;Database OID %u now seems to belong to \&quot;%s\&quot;.&quot;,
<span class="lineNum">     336 </span>            :                            MyDatabaseId, NameStr(dbform-&gt;datname))));
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :     /*
<span class="lineNum">     339 </span>            :      * Check permissions to connect to the database.
<span class="lineNum">     340 </span>            :      *
<span class="lineNum">     341 </span>            :      * These checks are not enforced when in standalone mode, so that there is
<span class="lineNum">     342 </span>            :      * a way to recover from disabling all access to all databases, for
<span class="lineNum">     343 </span>            :      * example &quot;UPDATE pg_database SET datallowconn = false;&quot;.
<span class="lineNum">     344 </span>            :      *
<span class="lineNum">     345 </span>            :      * We do not enforce them for autovacuum worker processes either.
<span class="lineNum">     346 </span>            :      */
<span class="lineNum">     347 </span><span class="lineCov">       1206 :     if (IsUnderPostmaster &amp;&amp; !IsAutoVacuumWorkerProcess())</span>
<span class="lineNum">     348 </span>            :     {
<span class="lineNum">     349 </span>            :         /*
<span class="lineNum">     350 </span>            :          * Check that the database is currently allowing connections.
<span class="lineNum">     351 </span>            :          */
<span class="lineNum">     352 </span><span class="lineCov">       1200 :         if (!dbform-&gt;datallowconn &amp;&amp; !override_allow_connections)</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     354 </span>            :                     (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),
<span class="lineNum">     355 </span>            :                      errmsg(&quot;database \&quot;%s\&quot; is not currently accepting connections&quot;,
<span class="lineNum">     356 </span>            :                             name)));
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            :         /*
<span class="lineNum">     359 </span>            :          * Check privilege to connect to the database.  (The am_superuser test
<span class="lineNum">     360 </span>            :          * is redundant, but since we have the flag, might as well check it
<span class="lineNum">     361 </span>            :          * and save a few cycles.)
<span class="lineNum">     362 </span>            :          */
<span class="lineNum">     363 </span><span class="lineCov">       1200 :         if (!am_superuser &amp;&amp;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :             pg_database_aclcheck(MyDatabaseId, GetUserId(),</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :                                  ACL_CONNECT) != ACLCHECK_OK)</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     367 </span>            :                     (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
<span class="lineNum">     368 </span>            :                      errmsg(&quot;permission denied for database \&quot;%s\&quot;&quot;, name),
<span class="lineNum">     369 </span>            :                      errdetail(&quot;User does not have CONNECT privilege.&quot;)));
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            :         /*
<span class="lineNum">     372 </span>            :          * Check connection limit for this database.
<span class="lineNum">     373 </span>            :          *
<span class="lineNum">     374 </span>            :          * There is a race condition here --- we create our PGPROC before
<span class="lineNum">     375 </span>            :          * checking for other PGPROCs.  If two backends did this at about the
<span class="lineNum">     376 </span>            :          * same time, they might both think they were over the limit, while
<span class="lineNum">     377 </span>            :          * ideally one should succeed and one fail.  Getting that to work
<span class="lineNum">     378 </span>            :          * exactly seems more trouble than it is worth, however; instead we
<span class="lineNum">     379 </span>            :          * just document that the connection limit is approximate.
<span class="lineNum">     380 </span>            :          */
<span class="lineNum">     381 </span><span class="lineCov">       1200 :         if (dbform-&gt;datconnlimit &gt;= 0 &amp;&amp;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :             !am_superuser &amp;&amp;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :             CountDBConnections(MyDatabaseId) &gt; dbform-&gt;datconnlimit)</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     385 </span>            :                     (errcode(ERRCODE_TOO_MANY_CONNECTIONS),
<span class="lineNum">     386 </span>            :                      errmsg(&quot;too many connections for database \&quot;%s\&quot;&quot;,
<span class="lineNum">     387 </span>            :                             name)));
<span class="lineNum">     388 </span>            :     }
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :     /*
<span class="lineNum">     391 </span>            :      * OK, we're golden.  Next to-do item is to save the encoding info out of
<span class="lineNum">     392 </span>            :      * the pg_database tuple.
<span class="lineNum">     393 </span>            :      */
<span class="lineNum">     394 </span><span class="lineCov">       1206 :     SetDatabaseEncoding(dbform-&gt;encoding);</span>
<span class="lineNum">     395 </span>            :     /* Record it as a GUC internal option, too */
<span class="lineNum">     396 </span><span class="lineCov">       1206 :     SetConfigOption(&quot;server_encoding&quot;, GetDatabaseEncodingName(),</span>
<span class="lineNum">     397 </span>            :                     PGC_INTERNAL, PGC_S_OVERRIDE);
<span class="lineNum">     398 </span>            :     /* If we have no other source of client_encoding, use server encoding */
<span class="lineNum">     399 </span><span class="lineCov">       1206 :     SetConfigOption(&quot;client_encoding&quot;, GetDatabaseEncodingName(),</span>
<span class="lineNum">     400 </span>            :                     PGC_BACKEND, PGC_S_DYNAMIC_DEFAULT);
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :     /* assign locale variables */
<span class="lineNum">     403 </span><span class="lineCov">       1206 :     collate = NameStr(dbform-&gt;datcollate);</span>
<span class="lineNum">     404 </span><span class="lineCov">       1206 :     ctype = NameStr(dbform-&gt;datctype);</span>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineCov">       1206 :     if (pg_perm_setlocale(LC_COLLATE, collate) == NULL)</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">     408 </span>            :                 (errmsg(&quot;database locale is incompatible with operating system&quot;),
<span class="lineNum">     409 </span>            :                  errdetail(&quot;The database was initialized with LC_COLLATE \&quot;%s\&quot;, &quot;
<span class="lineNum">     410 </span>            :                            &quot; which is not recognized by setlocale().&quot;, collate),
<span class="lineNum">     411 </span>            :                  errhint(&quot;Recreate the database with another locale or install the missing locale.&quot;)));
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineCov">       1206 :     if (pg_perm_setlocale(LC_CTYPE, ctype) == NULL)</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">     415 </span>            :                 (errmsg(&quot;database locale is incompatible with operating system&quot;),
<span class="lineNum">     416 </span>            :                  errdetail(&quot;The database was initialized with LC_CTYPE \&quot;%s\&quot;, &quot;
<span class="lineNum">     417 </span>            :                            &quot; which is not recognized by setlocale().&quot;, ctype),
<span class="lineNum">     418 </span>            :                  errhint(&quot;Recreate the database with another locale or install the missing locale.&quot;)));
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            :     /* Make the locale settings visible as GUC variables, too */
<span class="lineNum">     421 </span><span class="lineCov">       1206 :     SetConfigOption(&quot;lc_collate&quot;, collate, PGC_INTERNAL, PGC_S_OVERRIDE);</span>
<span class="lineNum">     422 </span><span class="lineCov">       1206 :     SetConfigOption(&quot;lc_ctype&quot;, ctype, PGC_INTERNAL, PGC_S_OVERRIDE);</span>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span><span class="lineCov">       1206 :     check_strxfrm_bug();</span>
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineCov">       1206 :     ReleaseSysCache(tup);</span>
<span class="lineNum">     427 </span><span class="lineCov">       1206 : }</span>
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            : /* --------------------------------
<span class="lineNum">     432 </span>            :  *      InitCommunication
<span class="lineNum">     433 </span>            :  *
<span class="lineNum">     434 </span>            :  *      This routine initializes stuff needed for ipc, locking, etc.
<span class="lineNum">     435 </span>            :  *      it should be called something more informative.
<span class="lineNum">     436 </span>            :  * --------------------------------
<a name="437"><span class="lineNum">     437 </span>            :  */</a>
<span class="lineNum">     438 </span>            : static void
<span class="lineNum">     439 </span><span class="lineCov">       1224 : InitCommunication(void)</span>
<span class="lineNum">     440 </span>            : {
<span class="lineNum">     441 </span>            :     /*
<span class="lineNum">     442 </span>            :      * initialize shared memory and semaphores appropriately.
<span class="lineNum">     443 </span>            :      */
<span class="lineNum">     444 </span><span class="lineCov">       1224 :     if (!IsUnderPostmaster)     /* postmaster already did this */</span>
<span class="lineNum">     445 </span>            :     {
<span class="lineNum">     446 </span>            :         /*
<span class="lineNum">     447 </span>            :          * We're running a postgres bootstrap process or a standalone backend,
<span class="lineNum">     448 </span>            :          * so we need to set up shmem.
<span class="lineNum">     449 </span>            :          */
<span class="lineNum">     450 </span><span class="lineCov">          8 :         CreateSharedMemoryAndSemaphores();</span>
<span class="lineNum">     451 </span>            :     }
<span class="lineNum">     452 </span><span class="lineCov">       1224 : }</span>
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            : /*
<span class="lineNum">     456 </span>            :  * pg_split_opts -- split a string of options and append it to an argv array
<span class="lineNum">     457 </span>            :  *
<span class="lineNum">     458 </span>            :  * The caller is responsible for ensuring the argv array is large enough.  The
<span class="lineNum">     459 </span>            :  * maximum possible number of arguments added by this routine is
<span class="lineNum">     460 </span>            :  * (strlen(optstr) + 1) / 2.
<span class="lineNum">     461 </span>            :  *
<span class="lineNum">     462 </span>            :  * Because some option values can contain spaces we allow escaping using
<span class="lineNum">     463 </span>            :  * backslashes, with \\ representing a literal backslash.
<a name="464"><span class="lineNum">     464 </span>            :  */</a>
<span class="lineNum">     465 </span>            : void
<span class="lineNum">     466 </span><span class="lineCov">        908 : pg_split_opts(char **argv, int *argcp, const char *optstr)</span>
<span class="lineNum">     467 </span>            : {
<span class="lineNum">     468 </span>            :     StringInfoData s;
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span><span class="lineCov">        908 :     initStringInfo(&amp;s);</span>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span><span class="lineCov">       2724 :     while (*optstr)</span>
<span class="lineNum">     473 </span>            :     {
<span class="lineNum">     474 </span><span class="lineCov">        908 :         bool        last_was_escape = false;</span>
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span><span class="lineCov">        908 :         resetStringInfo(&amp;s);</span>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            :         /* skip over leading space */
<span class="lineNum">     479 </span><span class="lineCov">       2724 :         while (isspace((unsigned char) *optstr))</span>
<span class="lineNum">     480 </span><span class="lineCov">        908 :             optstr++;</span>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span><span class="lineCov">        908 :         if (*optstr == '\0')</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            :         /*
<span class="lineNum">     486 </span>            :          * Parse a single option, stopping at the first space, unless it's
<span class="lineNum">     487 </span>            :          * escaped.
<span class="lineNum">     488 </span>            :          */
<span class="lineNum">     489 </span><span class="lineCov">      16344 :         while (*optstr)</span>
<span class="lineNum">     490 </span>            :         {
<span class="lineNum">     491 </span><span class="lineCov">      14982 :             if (isspace((unsigned char) *optstr) &amp;&amp; !last_was_escape)</span>
<span class="lineNum">     492 </span><span class="lineCov">        454 :                 break;</span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span><span class="lineCov">      14528 :             if (!last_was_escape &amp;&amp; *optstr == '\\')</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :                 last_was_escape = true;</span>
<span class="lineNum">     496 </span>            :             else
<span class="lineNum">     497 </span>            :             {
<span class="lineNum">     498 </span><span class="lineCov">      14528 :                 last_was_escape = false;</span>
<span class="lineNum">     499 </span><span class="lineCov">      14528 :                 appendStringInfoChar(&amp;s, *optstr);</span>
<span class="lineNum">     500 </span>            :             }
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span><span class="lineCov">      14528 :             optstr++;</span>
<span class="lineNum">     503 </span>            :         }
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            :         /* now store the option in the next argv[] position */
<span class="lineNum">     506 </span><span class="lineCov">        908 :         argv[(*argcp)++] = pstrdup(s.data);</span>
<span class="lineNum">     507 </span>            :     }
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span><span class="lineCov">        908 :     pfree(s.data);</span>
<span class="lineNum">     510 </span><span class="lineCov">        908 : }</span>
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            : /*
<span class="lineNum">     513 </span>            :  * Initialize MaxBackends value from config options.
<span class="lineNum">     514 </span>            :  *
<span class="lineNum">     515 </span>            :  * This must be called after modules have had the chance to register background
<span class="lineNum">     516 </span>            :  * workers in shared_preload_libraries, and before shared memory size is
<span class="lineNum">     517 </span>            :  * determined.
<span class="lineNum">     518 </span>            :  *
<span class="lineNum">     519 </span>            :  * Note that in EXEC_BACKEND environment, the value is passed down from
<span class="lineNum">     520 </span>            :  * postmaster to subprocesses via BackendParameters in SubPostmasterMain; only
<span class="lineNum">     521 </span>            :  * postmaster itself and processes not under postmaster control should call
<span class="lineNum">     522 </span>            :  * this.
<a name="523"><span class="lineNum">     523 </span>            :  */</a>
<span class="lineNum">     524 </span>            : void
<span class="lineNum">     525 </span><span class="lineCov">       1228 : InitializeMaxBackends(void)</span>
<span class="lineNum">     526 </span>            : {
<span class="lineNum">     527 </span><span class="lineCov">       1228 :     Assert(MaxBackends == 0);</span>
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span>            :     /* the extra unit accounts for the autovacuum launcher */
<span class="lineNum">     530 </span><span class="lineCov">       2456 :     MaxBackends = MaxConnections + autovacuum_max_workers + 1 +</span>
<span class="lineNum">     531 </span><span class="lineCov">       1228 :         max_worker_processes + max_wal_senders;</span>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            :     /* internal error because the values were all checked previously */
<span class="lineNum">     534 </span><span class="lineCov">       1228 :     if (MaxBackends &gt; MAX_BACKENDS)</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;too many backends configured&quot;);</span>
<span class="lineNum">     536 </span><span class="lineCov">       1228 : }</span>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            : /*
<span class="lineNum">     539 </span>            :  * Early initialization of a backend (either standalone or under postmaster).
<span class="lineNum">     540 </span>            :  * This happens even before InitPostgres.
<span class="lineNum">     541 </span>            :  *
<span class="lineNum">     542 </span>            :  * This is separate from InitPostgres because it is also called by auxiliary
<span class="lineNum">     543 </span>            :  * processes, such as the background writer process, which may not call
<span class="lineNum">     544 </span>            :  * InitPostgres at all.
<a name="545"><span class="lineNum">     545 </span>            :  */</a>
<span class="lineNum">     546 </span>            : void
<span class="lineNum">     547 </span><span class="lineCov">       1224 : BaseInit(void)</span>
<span class="lineNum">     548 </span>            : {
<span class="lineNum">     549 </span>            :     /*
<span class="lineNum">     550 </span>            :      * Attach to shared memory and semaphores, and initialize our
<span class="lineNum">     551 </span>            :      * input/output/debugging file descriptors.
<span class="lineNum">     552 </span>            :      */
<span class="lineNum">     553 </span><span class="lineCov">       1224 :     InitCommunication();</span>
<span class="lineNum">     554 </span><span class="lineCov">       1224 :     DebugFileOpen();</span>
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            :     /* Do local initialization of file, storage and buffer managers */
<span class="lineNum">     557 </span><span class="lineCov">       1224 :     InitFileAccess();</span>
<span class="lineNum">     558 </span><span class="lineCov">       1224 :     InitSync();</span>
<span class="lineNum">     559 </span><span class="lineCov">       1224 :     smgrinit();</span>
<span class="lineNum">     560 </span><span class="lineCov">       1224 :     InitBufferPoolAccess();</span>
<span class="lineNum">     561 </span><span class="lineCov">       1224 : }</span>
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            : /* --------------------------------
<span class="lineNum">     565 </span>            :  * InitPostgres
<span class="lineNum">     566 </span>            :  *      Initialize POSTGRES.
<span class="lineNum">     567 </span>            :  *
<span class="lineNum">     568 </span>            :  * The database can be specified by name, using the in_dbname parameter, or by
<span class="lineNum">     569 </span>            :  * OID, using the dboid parameter.  In the latter case, the actual database
<span class="lineNum">     570 </span>            :  * name can be returned to the caller in out_dbname.  If out_dbname isn't
<span class="lineNum">     571 </span>            :  * NULL, it must point to a buffer of size NAMEDATALEN.
<span class="lineNum">     572 </span>            :  *
<span class="lineNum">     573 </span>            :  * Similarly, the username can be passed by name, using the username parameter,
<span class="lineNum">     574 </span>            :  * or by OID using the useroid parameter.
<span class="lineNum">     575 </span>            :  *
<span class="lineNum">     576 </span>            :  * In bootstrap mode no parameters are used.  The autovacuum launcher process
<span class="lineNum">     577 </span>            :  * doesn't use any parameters either, because it only goes far enough to be
<span class="lineNum">     578 </span>            :  * able to read pg_database; it doesn't connect to any particular database.
<span class="lineNum">     579 </span>            :  * In walsender mode only username is used.
<span class="lineNum">     580 </span>            :  *
<span class="lineNum">     581 </span>            :  * As of PostgreSQL 8.2, we expect InitProcess() was already called, so we
<span class="lineNum">     582 </span>            :  * already have a PGPROC struct ... but it's not completely filled in yet.
<span class="lineNum">     583 </span>            :  *
<span class="lineNum">     584 </span>            :  * Note:
<span class="lineNum">     585 </span>            :  *      Be very careful with the order of calls in the InitPostgres function.
<span class="lineNum">     586 </span>            :  * --------------------------------
<a name="587"><span class="lineNum">     587 </span>            :  */</a>
<span class="lineNum">     588 </span>            : void
<span class="lineNum">     589 </span><span class="lineCov">       1212 : InitPostgres(const char *in_dbname, Oid dboid, const char *username,</span>
<span class="lineNum">     590 </span>            :              Oid useroid, char *out_dbname, bool override_allow_connections)
<span class="lineNum">     591 </span>            : {
<span class="lineNum">     592 </span><span class="lineCov">       1212 :     bool        bootstrap = IsBootstrapProcessingMode();</span>
<span class="lineNum">     593 </span>            :     bool        am_superuser;
<span class="lineNum">     594 </span>            :     char       *fullpath;
<span class="lineNum">     595 </span>            :     char        dbname[NAMEDATALEN];
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span><span class="lineCov">       1212 :     elog(DEBUG3, &quot;InitPostgres&quot;);</span>
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span>            :     /*
<span class="lineNum">     600 </span>            :      * Add my PGPROC struct to the ProcArray.
<span class="lineNum">     601 </span>            :      *
<span class="lineNum">     602 </span>            :      * Once I have done this, I am visible to other backends!
<span class="lineNum">     603 </span>            :      */
<span class="lineNum">     604 </span><span class="lineCov">       1212 :     InitProcessPhase2();</span>
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            :     /*
<span class="lineNum">     607 </span>            :      * Initialize my entry in the shared-invalidation manager's array of
<span class="lineNum">     608 </span>            :      * per-backend data.
<span class="lineNum">     609 </span>            :      *
<span class="lineNum">     610 </span>            :      * Sets up MyBackendId, a unique backend identifier.
<span class="lineNum">     611 </span>            :      */
<span class="lineNum">     612 </span><span class="lineCov">       1212 :     MyBackendId = InvalidBackendId;</span>
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span><span class="lineCov">       1212 :     SharedInvalBackendInit(false);</span>
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span><span class="lineCov">       1212 :     if (MyBackendId &gt; MaxBackends || MyBackendId &lt;= 0)</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :         elog(FATAL, &quot;bad backend ID: %d&quot;, MyBackendId);</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            :     /* Now that we have a BackendId, we can participate in ProcSignal */
<span class="lineNum">     620 </span><span class="lineCov">       1212 :     ProcSignalInit(MyBackendId);</span>
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            :     /*
<span class="lineNum">     623 </span>            :      * Also set up timeout handlers needed for backend operation.  We need
<span class="lineNum">     624 </span>            :      * these in every case except bootstrap.
<span class="lineNum">     625 </span>            :      */
<span class="lineNum">     626 </span><span class="lineCov">       1212 :     if (!bootstrap)</span>
<span class="lineNum">     627 </span>            :     {
<span class="lineNum">     628 </span><span class="lineCov">       1210 :         RegisterTimeout(DEADLOCK_TIMEOUT, CheckDeadLockAlert);</span>
<span class="lineNum">     629 </span><span class="lineCov">       1210 :         RegisterTimeout(STATEMENT_TIMEOUT, StatementTimeoutHandler);</span>
<span class="lineNum">     630 </span><span class="lineCov">       1210 :         RegisterTimeout(LOCK_TIMEOUT, LockTimeoutHandler);</span>
<span class="lineNum">     631 </span><span class="lineCov">       1210 :         RegisterTimeout(IDLE_IN_TRANSACTION_SESSION_TIMEOUT,</span>
<span class="lineNum">     632 </span>            :                         IdleInTransactionSessionTimeoutHandler);
<span class="lineNum">     633 </span>            :     }
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            :     /*
<span class="lineNum">     636 </span>            :      * bufmgr needs another initialization call too
<span class="lineNum">     637 </span>            :      */
<span class="lineNum">     638 </span><span class="lineCov">       1212 :     InitBufferPoolBackend();</span>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            :     /*
<span class="lineNum">     641 </span>            :      * Initialize local process's access to XLOG.
<span class="lineNum">     642 </span>            :      */
<span class="lineNum">     643 </span><span class="lineCov">       1212 :     if (IsUnderPostmaster)</span>
<span class="lineNum">     644 </span>            :     {
<span class="lineNum">     645 </span>            :         /*
<span class="lineNum">     646 </span>            :          * The postmaster already started the XLOG machinery, but we need to
<span class="lineNum">     647 </span>            :          * call InitXLOGAccess(), if the system isn't in hot-standby mode.
<span class="lineNum">     648 </span>            :          * This is handled by calling RecoveryInProgress and ignoring the
<span class="lineNum">     649 </span>            :          * result.
<span class="lineNum">     650 </span>            :          */
<span class="lineNum">     651 </span><span class="lineCov">       1208 :         (void) RecoveryInProgress();</span>
<span class="lineNum">     652 </span>            :     }
<span class="lineNum">     653 </span>            :     else
<span class="lineNum">     654 </span>            :     {
<span class="lineNum">     655 </span>            :         /*
<span class="lineNum">     656 </span>            :          * We are either a bootstrap process or a standalone backend. Either
<span class="lineNum">     657 </span>            :          * way, start up the XLOG machinery, and register to have it closed
<span class="lineNum">     658 </span>            :          * down at exit.
<span class="lineNum">     659 </span>            :          *
<span class="lineNum">     660 </span>            :          * We don't yet have an aux-process resource owner, but StartupXLOG
<span class="lineNum">     661 </span>            :          * and ShutdownXLOG will need one.  Hence, create said resource owner
<span class="lineNum">     662 </span>            :          * (and register a callback to clean it up after ShutdownXLOG runs).
<span class="lineNum">     663 </span>            :          */
<span class="lineNum">     664 </span><span class="lineCov">          4 :         CreateAuxProcessResourceOwner();</span>
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span><span class="lineCov">          4 :         StartupXLOG();</span>
<span class="lineNum">     667 </span>            :         /* Release (and warn about) any buffer pins leaked in StartupXLOG */
<span class="lineNum">     668 </span><span class="lineCov">          4 :         ReleaseAuxProcessResources(true);</span>
<span class="lineNum">     669 </span>            :         /* Reset CurrentResourceOwner to nothing for the moment */
<span class="lineNum">     670 </span><span class="lineCov">          4 :         CurrentResourceOwner = NULL;</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span><span class="lineCov">          4 :         on_shmem_exit(ShutdownXLOG, 0);</span>
<span class="lineNum">     673 </span>            :     }
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :     /*
<span class="lineNum">     676 </span>            :      * Initialize the relation cache and the system catalog caches.  Note that
<span class="lineNum">     677 </span>            :      * no catalog access happens here; we only set up the hashtable structure.
<span class="lineNum">     678 </span>            :      * We must do this before starting a transaction because transaction abort
<span class="lineNum">     679 </span>            :      * would try to touch these hashtables.
<span class="lineNum">     680 </span>            :      */
<span class="lineNum">     681 </span><span class="lineCov">       1212 :     RelationCacheInitialize();</span>
<span class="lineNum">     682 </span><span class="lineCov">       1212 :     InitCatalogCache();</span>
<span class="lineNum">     683 </span><span class="lineCov">       1212 :     InitPlanCache();</span>
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span>            :     /* Initialize portal manager */
<span class="lineNum">     686 </span><span class="lineCov">       1212 :     EnablePortalManager();</span>
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span>            :     /* Initialize stats collection --- must happen before first xact */
<span class="lineNum">     689 </span><span class="lineCov">       1212 :     if (!bootstrap)</span>
<span class="lineNum">     690 </span><span class="lineCov">       1210 :         pgstat_initialize();</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :     /*
<span class="lineNum">     693 </span>            :      * Load relcache entries for the shared system catalogs.  This must create
<span class="lineNum">     694 </span>            :      * at least entries for pg_database and catalogs used for authentication.
<span class="lineNum">     695 </span>            :      */
<span class="lineNum">     696 </span><span class="lineCov">       1212 :     RelationCacheInitializePhase2();</span>
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            :     /*
<span class="lineNum">     699 </span>            :      * Set up process-exit callback to do pre-shutdown cleanup.  This is the
<span class="lineNum">     700 </span>            :      * first before_shmem_exit callback we register; thus, this will be the
<span class="lineNum">     701 </span>            :      * last thing we do before low-level modules like the buffer manager begin
<span class="lineNum">     702 </span>            :      * to close down.  We need to have this in place before we begin our first
<span class="lineNum">     703 </span>            :      * transaction --- if we fail during the initialization transaction, as is
<span class="lineNum">     704 </span>            :      * entirely possible, we need the AbortTransaction call to clean up.
<span class="lineNum">     705 </span>            :      */
<span class="lineNum">     706 </span><span class="lineCov">       1212 :     before_shmem_exit(ShutdownPostgres, 0);</span>
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            :     /* The autovacuum launcher is done here */
<span class="lineNum">     709 </span><span class="lineCov">       1212 :     if (IsAutoVacuumLauncherProcess())</span>
<span class="lineNum">     710 </span>            :     {
<span class="lineNum">     711 </span>            :         /* report this backend in the PgBackendStatus array */
<span class="lineNum">     712 </span><span class="lineCov">          2 :         pgstat_bestart();</span>
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span><span class="lineCov">          2 :         return;</span>
<span class="lineNum">     715 </span>            :     }
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            :     /*
<span class="lineNum">     718 </span>            :      * Start a new transaction here before first access to db, and get a
<span class="lineNum">     719 </span>            :      * snapshot.  We don't have a use for the snapshot itself, but we're
<span class="lineNum">     720 </span>            :      * interested in the secondary effect that it sets RecentGlobalXmin. (This
<span class="lineNum">     721 </span>            :      * is critical for anything that reads heap pages, because HOT may decide
<span class="lineNum">     722 </span>            :      * to prune them even if the process doesn't attempt to modify any
<span class="lineNum">     723 </span>            :      * tuples.)
<span class="lineNum">     724 </span>            :      */
<span class="lineNum">     725 </span><span class="lineCov">       1210 :     if (!bootstrap)</span>
<span class="lineNum">     726 </span>            :     {
<span class="lineNum">     727 </span>            :         /* statement_timestamp must be set for timeouts to work correctly */
<span class="lineNum">     728 </span><span class="lineCov">       1208 :         SetCurrentStatementStartTimestamp();</span>
<span class="lineNum">     729 </span><span class="lineCov">       1208 :         StartTransactionCommand();</span>
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            :         /*
<span class="lineNum">     732 </span>            :          * transaction_isolation will have been set to the default by the
<span class="lineNum">     733 </span>            :          * above.  If the default is &quot;serializable&quot;, and we are in hot
<span class="lineNum">     734 </span>            :          * standby, we will fail if we don't change it to something lower.
<span class="lineNum">     735 </span>            :          * Fortunately, &quot;read committed&quot; is plenty good enough.
<span class="lineNum">     736 </span>            :          */
<span class="lineNum">     737 </span><span class="lineCov">       1208 :         XactIsoLevel = XACT_READ_COMMITTED;</span>
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span><span class="lineCov">       1208 :         (void) GetTransactionSnapshot();</span>
<span class="lineNum">     740 </span>            :     }
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            :     /*
<span class="lineNum">     743 </span>            :      * Perform client authentication if necessary, then figure out our
<span class="lineNum">     744 </span>            :      * postgres user ID, and see if we are a superuser.
<span class="lineNum">     745 </span>            :      *
<span class="lineNum">     746 </span>            :      * In standalone mode and in autovacuum worker processes, we use a fixed
<span class="lineNum">     747 </span>            :      * ID, otherwise we figure it out from the authenticated user name.
<span class="lineNum">     748 </span>            :      */
<span class="lineNum">     749 </span><span class="lineCov">       1210 :     if (bootstrap || IsAutoVacuumWorkerProcess())</span>
<span class="lineNum">     750 </span>            :     {
<span class="lineNum">     751 </span><span class="lineCov">          6 :         InitializeSessionUserIdStandalone();</span>
<span class="lineNum">     752 </span><span class="lineCov">          6 :         am_superuser = true;</span>
<span class="lineNum">     753 </span>            :     }
<span class="lineNum">     754 </span><span class="lineCov">       1204 :     else if (!IsUnderPostmaster)</span>
<span class="lineNum">     755 </span>            :     {
<span class="lineNum">     756 </span><span class="lineCov">          2 :         InitializeSessionUserIdStandalone();</span>
<span class="lineNum">     757 </span><span class="lineCov">          2 :         am_superuser = true;</span>
<span class="lineNum">     758 </span><span class="lineCov">          2 :         if (!ThereIsAtLeastOneRole())</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :             ereport(WARNING,</span>
<span class="lineNum">     760 </span>            :                     (errcode(ERRCODE_UNDEFINED_OBJECT),
<span class="lineNum">     761 </span>            :                      errmsg(&quot;no roles are defined in this database system&quot;),
<span class="lineNum">     762 </span>            :                      errhint(&quot;You should immediately run CREATE USER \&quot;%s\&quot; SUPERUSER;.&quot;,
<span class="lineNum">     763 </span>            :                              username != NULL ? username : &quot;postgres&quot;)));
<span class="lineNum">     764 </span>            :     }
<span class="lineNum">     765 </span><span class="lineCov">       1202 :     else if (IsBackgroundWorker)</span>
<span class="lineNum">     766 </span>            :     {
<span class="lineNum">     767 </span><span class="lineCov">        748 :         if (username == NULL &amp;&amp; !OidIsValid(useroid))</span>
<span class="lineNum">     768 </span>            :         {
<span class="lineNum">     769 </span><span class="lineCov">          2 :             InitializeSessionUserIdStandalone();</span>
<span class="lineNum">     770 </span><span class="lineCov">          2 :             am_superuser = true;</span>
<span class="lineNum">     771 </span>            :         }
<span class="lineNum">     772 </span>            :         else
<span class="lineNum">     773 </span>            :         {
<span class="lineNum">     774 </span><span class="lineCov">        746 :             InitializeSessionUserId(username, useroid);</span>
<span class="lineNum">     775 </span><span class="lineCov">        746 :             am_superuser = superuser();</span>
<span class="lineNum">     776 </span>            :         }
<span class="lineNum">     777 </span>            :     }
<span class="lineNum">     778 </span>            :     else
<span class="lineNum">     779 </span>            :     {
<span class="lineNum">     780 </span>            :         /* normal multiuser case */
<span class="lineNum">     781 </span><span class="lineCov">        454 :         Assert(MyProcPort != NULL);</span>
<span class="lineNum">     782 </span><span class="lineCov">        454 :         PerformAuthentication(MyProcPort);</span>
<span class="lineNum">     783 </span><span class="lineCov">        454 :         InitializeSessionUserId(username, useroid);</span>
<span class="lineNum">     784 </span><span class="lineCov">        454 :         am_superuser = superuser();</span>
<span class="lineNum">     785 </span>            :     }
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span>            :     /*
<span class="lineNum">     788 </span>            :      * If we're trying to shut down, only superusers can connect, and new
<span class="lineNum">     789 </span>            :      * replication connections are not allowed.
<span class="lineNum">     790 </span>            :      */
<span class="lineNum">     791 </span><span class="lineCov">       1210 :     if ((!am_superuser || am_walsender) &amp;&amp;</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :         MyProcPort != NULL &amp;&amp;</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :         MyProcPort-&gt;canAcceptConnections == CAC_WAITBACKUP)</span>
<span class="lineNum">     794 </span>            :     {
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :         if (am_walsender)</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     797 </span>            :                     (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
<span class="lineNum">     798 </span>            :                      errmsg(&quot;new replication connections are not allowed during database shutdown&quot;)));
<span class="lineNum">     799 </span>            :         else
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     801 </span>            :                     (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
<span class="lineNum">     802 </span>            :                      errmsg(&quot;must be superuser to connect during database shutdown&quot;)));
<span class="lineNum">     803 </span>            :     }
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            :     /*
<span class="lineNum">     806 </span>            :      * Binary upgrades only allowed super-user connections
<span class="lineNum">     807 </span>            :      */
<span class="lineNum">     808 </span><span class="lineCov">       1210 :     if (IsBinaryUpgrade &amp;&amp; !am_superuser)</span>
<span class="lineNum">     809 </span>            :     {
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">     811 </span>            :                 (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
<span class="lineNum">     812 </span>            :                  errmsg(&quot;must be superuser to connect in binary upgrade mode&quot;)));
<span class="lineNum">     813 </span>            :     }
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            :     /*
<span class="lineNum">     816 </span>            :      * The last few connection slots are reserved for superusers.  Replication
<span class="lineNum">     817 </span>            :      * connections are drawn from slots reserved with max_wal_senders and not
<span class="lineNum">     818 </span>            :      * limited by max_connections or superuser_reserved_connections.
<span class="lineNum">     819 </span>            :      */
<span class="lineNum">     820 </span><span class="lineCov">       1210 :     if (!am_superuser &amp;&amp; !am_walsender &amp;&amp;</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :         ReservedBackends &gt; 0 &amp;&amp;</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :         !HaveNFreeProcs(ReservedBackends))</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">     824 </span>            :                 (errcode(ERRCODE_TOO_MANY_CONNECTIONS),
<span class="lineNum">     825 </span>            :                  errmsg(&quot;remaining connection slots are reserved for non-replication superuser connections&quot;)));
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            :     /* Check replication permissions needed for walsender processes. */
<span class="lineNum">     828 </span><span class="lineCov">       1210 :     if (am_walsender)</span>
<span class="lineNum">     829 </span>            :     {
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :         Assert(!bootstrap);</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :         if (!superuser() &amp;&amp; !has_rolreplication(GetUserId()))</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     834 </span>            :                     (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
<span class="lineNum">     835 </span>            :                      errmsg(&quot;must be superuser or replication role to start walsender&quot;)));
<span class="lineNum">     836 </span>            :     }
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span>            :     /*
<span class="lineNum">     839 </span>            :      * If this is a plain walsender only supporting physical replication, we
<span class="lineNum">     840 </span>            :      * don't want to connect to any particular database. Just finish the
<span class="lineNum">     841 </span>            :      * backend startup by processing any options from the startup packet, and
<span class="lineNum">     842 </span>            :      * we're done.
<span class="lineNum">     843 </span>            :      */
<span class="lineNum">     844 </span><span class="lineCov">       1210 :     if (am_walsender &amp;&amp; !am_db_walsender)</span>
<span class="lineNum">     845 </span>            :     {
<span class="lineNum">     846 </span>            :         /* process any options passed in the startup packet */
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :         if (MyProcPort != NULL)</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :             process_startup_options(MyProcPort, am_superuser);</span>
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            :         /* Apply PostAuthDelay as soon as we've read all options */
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :         if (PostAuthDelay &gt; 0)</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :             pg_usleep(PostAuthDelay * 1000000L);</span>
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            :         /* initialize client encoding */
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :         InitializeClientEncoding();</span>
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            :         /* report this backend in the PgBackendStatus array */
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :         pgstat_bestart();</span>
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            :         /* close the transaction we started above */
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :         CommitTransactionCommand();</span>
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     864 </span>            :     }
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span>            :     /*
<span class="lineNum">     867 </span>            :      * Set up the global variables holding database id and default tablespace.
<span class="lineNum">     868 </span>            :      * But note we won't actually try to touch the database just yet.
<span class="lineNum">     869 </span>            :      *
<span class="lineNum">     870 </span>            :      * We take a shortcut in the bootstrap case, otherwise we have to look up
<span class="lineNum">     871 </span>            :      * the db's entry in pg_database.
<span class="lineNum">     872 </span>            :      */
<span class="lineNum">     873 </span><span class="lineCov">       1210 :     if (bootstrap)</span>
<span class="lineNum">     874 </span>            :     {
<span class="lineNum">     875 </span><span class="lineCov">          2 :         MyDatabaseId = TemplateDbOid;</span>
<span class="lineNum">     876 </span><span class="lineCov">          2 :         MyDatabaseTableSpace = DEFAULTTABLESPACE_OID;</span>
<span class="lineNum">     877 </span>            :     }
<span class="lineNum">     878 </span><span class="lineCov">       1208 :     else if (in_dbname != NULL)</span>
<span class="lineNum">     879 </span>            :     {
<span class="lineNum">     880 </span>            :         HeapTuple   tuple;
<span class="lineNum">     881 </span>            :         Form_pg_database dbform;
<span class="lineNum">     882 </span>            : 
<span class="lineNum">     883 </span><span class="lineCov">        456 :         tuple = GetDatabaseTuple(in_dbname);</span>
<span class="lineNum">     884 </span><span class="lineCov">        456 :         if (!HeapTupleIsValid(tuple))</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     886 </span>            :                     (errcode(ERRCODE_UNDEFINED_DATABASE),
<span class="lineNum">     887 </span>            :                      errmsg(&quot;database \&quot;%s\&quot; does not exist&quot;, in_dbname)));
<span class="lineNum">     888 </span><span class="lineCov">        456 :         dbform = (Form_pg_database) GETSTRUCT(tuple);</span>
<span class="lineNum">     889 </span><span class="lineCov">        456 :         MyDatabaseId = dbform-&gt;oid;</span>
<span class="lineNum">     890 </span><span class="lineCov">        456 :         MyDatabaseTableSpace = dbform-&gt;dattablespace;</span>
<span class="lineNum">     891 </span>            :         /* take database name from the caller, just for paranoia */
<span class="lineNum">     892 </span><span class="lineCov">        456 :         strlcpy(dbname, in_dbname, sizeof(dbname));</span>
<span class="lineNum">     893 </span>            :     }
<span class="lineNum">     894 </span><span class="lineCov">        752 :     else if (OidIsValid(dboid))</span>
<span class="lineNum">     895 </span>            :     {
<span class="lineNum">     896 </span>            :         /* caller specified database by OID */
<span class="lineNum">     897 </span>            :         HeapTuple   tuple;
<span class="lineNum">     898 </span>            :         Form_pg_database dbform;
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span><span class="lineCov">        750 :         tuple = GetDatabaseTupleByOid(dboid);</span>
<span class="lineNum">     901 </span><span class="lineCov">        750 :         if (!HeapTupleIsValid(tuple))</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     903 </span>            :                     (errcode(ERRCODE_UNDEFINED_DATABASE),
<span class="lineNum">     904 </span>            :                      errmsg(&quot;database %u does not exist&quot;, dboid)));
<span class="lineNum">     905 </span><span class="lineCov">        750 :         dbform = (Form_pg_database) GETSTRUCT(tuple);</span>
<span class="lineNum">     906 </span><span class="lineCov">        750 :         MyDatabaseId = dbform-&gt;oid;</span>
<span class="lineNum">     907 </span><span class="lineCov">        750 :         MyDatabaseTableSpace = dbform-&gt;dattablespace;</span>
<span class="lineNum">     908 </span><span class="lineCov">        750 :         Assert(MyDatabaseId == dboid);</span>
<span class="lineNum">     909 </span><span class="lineCov">        750 :         strlcpy(dbname, NameStr(dbform-&gt;datname), sizeof(dbname));</span>
<span class="lineNum">     910 </span>            :         /* pass the database name back to the caller */
<span class="lineNum">     911 </span><span class="lineCov">        750 :         if (out_dbname)</span>
<span class="lineNum">     912 </span><span class="lineCov">          4 :             strcpy(out_dbname, dbname);</span>
<span class="lineNum">     913 </span>            :     }
<span class="lineNum">     914 </span>            :     else
<span class="lineNum">     915 </span>            :     {
<span class="lineNum">     916 </span>            :         /*
<span class="lineNum">     917 </span>            :          * If this is a background worker not bound to any particular
<span class="lineNum">     918 </span>            :          * database, we're done now.  Everything that follows only makes sense
<span class="lineNum">     919 </span>            :          * if we are bound to a specific database.  We do need to close the
<span class="lineNum">     920 </span>            :          * transaction we started before returning.
<span class="lineNum">     921 </span>            :          */
<span class="lineNum">     922 </span><span class="lineCov">          2 :         if (!bootstrap)</span>
<span class="lineNum">     923 </span>            :         {
<span class="lineNum">     924 </span><span class="lineCov">          2 :             pgstat_bestart();</span>
<span class="lineNum">     925 </span><span class="lineCov">          2 :             CommitTransactionCommand();</span>
<span class="lineNum">     926 </span>            :         }
<span class="lineNum">     927 </span><span class="lineCov">          2 :         return;</span>
<span class="lineNum">     928 </span>            :     }
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            :     /*
<span class="lineNum">     931 </span>            :      * Now, take a writer's lock on the database we are trying to connect to.
<span class="lineNum">     932 </span>            :      * If there is a concurrently running DROP DATABASE on that database, this
<span class="lineNum">     933 </span>            :      * will block us until it finishes (and has committed its update of
<span class="lineNum">     934 </span>            :      * pg_database).
<span class="lineNum">     935 </span>            :      *
<span class="lineNum">     936 </span>            :      * Note that the lock is not held long, only until the end of this startup
<span class="lineNum">     937 </span>            :      * transaction.  This is OK since we will advertise our use of the
<span class="lineNum">     938 </span>            :      * database in the ProcArray before dropping the lock (in fact, that's the
<span class="lineNum">     939 </span>            :      * next thing to do).  Anyone trying a DROP DATABASE after this point will
<span class="lineNum">     940 </span>            :      * see us in the array once they have the lock.  Ordering is important for
<span class="lineNum">     941 </span>            :      * this because we don't want to advertise ourselves as being in this
<span class="lineNum">     942 </span>            :      * database until we have the lock; otherwise we create what amounts to a
<span class="lineNum">     943 </span>            :      * deadlock with CountOtherDBBackends().
<span class="lineNum">     944 </span>            :      *
<span class="lineNum">     945 </span>            :      * Note: use of RowExclusiveLock here is reasonable because we envision
<span class="lineNum">     946 </span>            :      * our session as being a concurrent writer of the database.  If we had a
<span class="lineNum">     947 </span>            :      * way of declaring a session as being guaranteed-read-only, we could use
<span class="lineNum">     948 </span>            :      * AccessShareLock for such sessions and thereby not conflict against
<span class="lineNum">     949 </span>            :      * CREATE DATABASE.
<span class="lineNum">     950 </span>            :      */
<span class="lineNum">     951 </span><span class="lineCov">       1208 :     if (!bootstrap)</span>
<span class="lineNum">     952 </span><span class="lineCov">       1206 :         LockSharedObject(DatabaseRelationId, MyDatabaseId, 0,</span>
<span class="lineNum">     953 </span>            :                          RowExclusiveLock);
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            :     /*
<span class="lineNum">     956 </span>            :      * Now we can mark our PGPROC entry with the database ID.
<span class="lineNum">     957 </span>            :      *
<span class="lineNum">     958 </span>            :      * We assume this is an atomic store so no lock is needed; though actually
<span class="lineNum">     959 </span>            :      * things would work fine even if it weren't atomic.  Anyone searching the
<span class="lineNum">     960 </span>            :      * ProcArray for this database's ID should hold the database lock, so they
<span class="lineNum">     961 </span>            :      * would not be executing concurrently with this store.  A process looking
<span class="lineNum">     962 </span>            :      * for another database's ID could in theory see a chance match if it read
<span class="lineNum">     963 </span>            :      * a partially-updated databaseId value; but as long as all such searches
<span class="lineNum">     964 </span>            :      * wait and retry, as in CountOtherDBBackends(), they will certainly see
<span class="lineNum">     965 </span>            :      * the correct value on their next try.
<span class="lineNum">     966 </span>            :      */
<span class="lineNum">     967 </span><span class="lineCov">       1208 :     MyProc-&gt;databaseId = MyDatabaseId;</span>
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            :     /*
<span class="lineNum">     970 </span>            :      * We established a catalog snapshot while reading pg_authid and/or
<span class="lineNum">     971 </span>            :      * pg_database; but until we have set up MyDatabaseId, we won't react to
<span class="lineNum">     972 </span>            :      * incoming sinval messages for unshared catalogs, so we won't realize it
<span class="lineNum">     973 </span>            :      * if the snapshot has been invalidated.  Assume it's no good anymore.
<span class="lineNum">     974 </span>            :      */
<span class="lineNum">     975 </span><span class="lineCov">       1208 :     InvalidateCatalogSnapshot();</span>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            :     /*
<span class="lineNum">     978 </span>            :      * Recheck pg_database to make sure the target database hasn't gone away.
<span class="lineNum">     979 </span>            :      * If there was a concurrent DROP DATABASE, this ensures we will die
<span class="lineNum">     980 </span>            :      * cleanly without creating a mess.
<span class="lineNum">     981 </span>            :      */
<span class="lineNum">     982 </span><span class="lineCov">       1208 :     if (!bootstrap)</span>
<span class="lineNum">     983 </span>            :     {
<span class="lineNum">     984 </span>            :         HeapTuple   tuple;
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span><span class="lineCov">       1206 :         tuple = GetDatabaseTuple(dbname);</span>
<span class="lineNum">     987 </span><span class="lineCov">       2412 :         if (!HeapTupleIsValid(tuple) ||</span>
<span class="lineNum">     988 </span><span class="lineCov">       2412 :             MyDatabaseId != ((Form_pg_database) GETSTRUCT(tuple))-&gt;oid ||</span>
<span class="lineNum">     989 </span><span class="lineCov">       1206 :             MyDatabaseTableSpace != ((Form_pg_database) GETSTRUCT(tuple))-&gt;dattablespace)</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     991 </span>            :                     (errcode(ERRCODE_UNDEFINED_DATABASE),
<span class="lineNum">     992 </span>            :                      errmsg(&quot;database \&quot;%s\&quot; does not exist&quot;, dbname),
<span class="lineNum">     993 </span>            :                      errdetail(&quot;It seems to have just been dropped or renamed.&quot;)));
<span class="lineNum">     994 </span>            :     }
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :     /*
<span class="lineNum">     997 </span>            :      * Now we should be able to access the database directory safely. Verify
<span class="lineNum">     998 </span>            :      * it's there and looks reasonable.
<span class="lineNum">     999 </span>            :      */
<span class="lineNum">    1000 </span><span class="lineCov">       1208 :     fullpath = GetDatabasePath(MyDatabaseId, MyDatabaseTableSpace);</span>
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span><span class="lineCov">       1208 :     if (!bootstrap)</span>
<span class="lineNum">    1003 </span>            :     {
<span class="lineNum">    1004 </span><span class="lineCov">       1206 :         if (access(fullpath, F_OK) == -1)</span>
<span class="lineNum">    1005 </span>            :         {
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :             if (errno == ENOENT)</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :                 ereport(FATAL,</span>
<span class="lineNum">    1008 </span>            :                         (errcode(ERRCODE_UNDEFINED_DATABASE),
<span class="lineNum">    1009 </span>            :                          errmsg(&quot;database \&quot;%s\&quot; does not exist&quot;,
<span class="lineNum">    1010 </span>            :                                 dbname),
<span class="lineNum">    1011 </span>            :                          errdetail(&quot;The database subdirectory \&quot;%s\&quot; is missing.&quot;,
<span class="lineNum">    1012 </span>            :                                    fullpath)));
<span class="lineNum">    1013 </span>            :             else
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :                 ereport(FATAL,</span>
<span class="lineNum">    1015 </span>            :                         (errcode_for_file_access(),
<span class="lineNum">    1016 </span>            :                          errmsg(&quot;could not access directory \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">    1017 </span>            :                                 fullpath)));
<span class="lineNum">    1018 </span>            :         }
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span><span class="lineCov">       1206 :         ValidatePgVersion(fullpath);</span>
<span class="lineNum">    1021 </span>            :     }
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span><span class="lineCov">       1208 :     SetDatabasePath(fullpath);</span>
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span>            :     /*
<span class="lineNum">    1026 </span>            :      * It's now possible to do real access to the system catalogs.
<span class="lineNum">    1027 </span>            :      *
<span class="lineNum">    1028 </span>            :      * Load relcache entries for the system catalogs.  This must create at
<span class="lineNum">    1029 </span>            :      * least the minimum set of &quot;nailed-in&quot; cache entries.
<span class="lineNum">    1030 </span>            :      */
<span class="lineNum">    1031 </span><span class="lineCov">       1208 :     RelationCacheInitializePhase3();</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            :     /* set up ACL framework (so CheckMyDatabase can check permissions) */
<span class="lineNum">    1034 </span><span class="lineCov">       1208 :     initialize_acl();</span>
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span>            :     /*
<span class="lineNum">    1037 </span>            :      * Re-read the pg_database row for our database, check permissions and set
<span class="lineNum">    1038 </span>            :      * up database-specific GUC settings.  We can't do this until all the
<span class="lineNum">    1039 </span>            :      * database-access infrastructure is up.  (Also, it wants to know if the
<span class="lineNum">    1040 </span>            :      * user is a superuser, so the above stuff has to happen first.)
<span class="lineNum">    1041 </span>            :      */
<span class="lineNum">    1042 </span><span class="lineCov">       1208 :     if (!bootstrap)</span>
<span class="lineNum">    1043 </span><span class="lineCov">       1206 :         CheckMyDatabase(dbname, am_superuser, override_allow_connections);</span>
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            :     /*
<span class="lineNum">    1046 </span>            :      * Now process any command-line switches and any additional GUC variable
<span class="lineNum">    1047 </span>            :      * settings passed in the startup packet.   We couldn't do this before
<span class="lineNum">    1048 </span>            :      * because we didn't know if client is a superuser.
<span class="lineNum">    1049 </span>            :      */
<span class="lineNum">    1050 </span><span class="lineCov">       1208 :     if (MyProcPort != NULL)</span>
<span class="lineNum">    1051 </span><span class="lineCov">        454 :         process_startup_options(MyProcPort, am_superuser);</span>
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            :     /* Process pg_db_role_setting options */
<span class="lineNum">    1054 </span><span class="lineCov">       1208 :     process_settings(MyDatabaseId, GetSessionUserId());</span>
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span>            :     /* Apply PostAuthDelay as soon as we've read all options */
<span class="lineNum">    1057 </span><span class="lineCov">       1208 :     if (PostAuthDelay &gt; 0)</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :         pg_usleep(PostAuthDelay * 1000000L);</span>
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span>            :     /*
<span class="lineNum">    1061 </span>            :      * Initialize various default states that can't be set up until we've
<span class="lineNum">    1062 </span>            :      * selected the active user and gotten the right GUC settings.
<span class="lineNum">    1063 </span>            :      */
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span>            :     /* set default namespace search path */
<span class="lineNum">    1066 </span><span class="lineCov">       1208 :     InitializeSearchPath();</span>
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span>            :     /* initialize client encoding */
<span class="lineNum">    1069 </span><span class="lineCov">       1208 :     InitializeClientEncoding();</span>
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span>            :     /* Initialize this backend's session state. */
<span class="lineNum">    1072 </span><span class="lineCov">       1208 :     InitializeSession();</span>
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span>            :     /* report this backend in the PgBackendStatus array */
<span class="lineNum">    1075 </span><span class="lineCov">       1208 :     if (!bootstrap)</span>
<span class="lineNum">    1076 </span><span class="lineCov">       1206 :         pgstat_bestart();</span>
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span>            :     /* close the transaction we started above */
<span class="lineNum">    1079 </span><span class="lineCov">       1208 :     if (!bootstrap)</span>
<span class="lineNum">    1080 </span><span class="lineCov">       1206 :         CommitTransactionCommand();</span>
<span class="lineNum">    1081 </span>            : }
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span>            : /*
<span class="lineNum">    1084 </span>            :  * Process any command-line switches and any additional GUC variable
<span class="lineNum">    1085 </span>            :  * settings passed in the startup packet.
<a name="1086"><span class="lineNum">    1086 </span>            :  */</a>
<span class="lineNum">    1087 </span>            : static void
<span class="lineNum">    1088 </span><span class="lineCov">        454 : process_startup_options(Port *port, bool am_superuser)</span>
<span class="lineNum">    1089 </span>            : {
<span class="lineNum">    1090 </span>            :     GucContext  gucctx;
<span class="lineNum">    1091 </span>            :     ListCell   *gucopts;
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span><span class="lineCov">        454 :     gucctx = am_superuser ? PGC_SU_BACKEND : PGC_BACKEND;</span>
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span>            :     /*
<span class="lineNum">    1096 </span>            :      * First process any command-line switches that were included in the
<span class="lineNum">    1097 </span>            :      * startup packet, if we are in a regular backend.
<span class="lineNum">    1098 </span>            :      */
<span class="lineNum">    1099 </span><span class="lineCov">        454 :     if (port-&gt;cmdline_options != NULL)</span>
<span class="lineNum">    1100 </span>            :     {
<span class="lineNum">    1101 </span>            :         /*
<span class="lineNum">    1102 </span>            :          * The maximum possible number of commandline arguments that could
<span class="lineNum">    1103 </span>            :          * come from port-&gt;cmdline_options is (strlen + 1) / 2; see
<span class="lineNum">    1104 </span>            :          * pg_split_opts().
<span class="lineNum">    1105 </span>            :          */
<span class="lineNum">    1106 </span>            :         char      **av;
<span class="lineNum">    1107 </span>            :         int         maxac;
<span class="lineNum">    1108 </span>            :         int         ac;
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span><span class="lineCov">        454 :         maxac = 2 + (strlen(port-&gt;cmdline_options) + 1) / 2;</span>
<span class="lineNum">    1111 </span>            : 
<span class="lineNum">    1112 </span><span class="lineCov">        454 :         av = (char **) palloc(maxac * sizeof(char *));</span>
<span class="lineNum">    1113 </span><span class="lineCov">        454 :         ac = 0;</span>
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span><span class="lineCov">        454 :         av[ac++] = &quot;postgres&quot;;</span>
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span><span class="lineCov">        454 :         pg_split_opts(av, &amp;ac, port-&gt;cmdline_options);</span>
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span><span class="lineCov">        454 :         av[ac] = NULL;</span>
<span class="lineNum">    1120 </span>            : 
<span class="lineNum">    1121 </span><span class="lineCov">        454 :         Assert(ac &lt; maxac);</span>
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span><span class="lineCov">        454 :         (void) process_postgres_switches(ac, av, gucctx, NULL);</span>
<span class="lineNum">    1124 </span>            :     }
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            :     /*
<span class="lineNum">    1127 </span>            :      * Process any additional GUC variable settings passed in startup packet.
<span class="lineNum">    1128 </span>            :      * These are handled exactly like command-line variables.
<span class="lineNum">    1129 </span>            :      */
<span class="lineNum">    1130 </span><span class="lineCov">        454 :     gucopts = list_head(port-&gt;guc_options);</span>
<span class="lineNum">    1131 </span><span class="lineCov">       2274 :     while (gucopts)</span>
<span class="lineNum">    1132 </span>            :     {
<span class="lineNum">    1133 </span>            :         char       *name;
<span class="lineNum">    1134 </span>            :         char       *value;
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span><span class="lineCov">       1366 :         name = lfirst(gucopts);</span>
<span class="lineNum">    1137 </span><span class="lineCov">       1366 :         gucopts = lnext(port-&gt;guc_options, gucopts);</span>
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span><span class="lineCov">       1366 :         value = lfirst(gucopts);</span>
<span class="lineNum">    1140 </span><span class="lineCov">       1366 :         gucopts = lnext(port-&gt;guc_options, gucopts);</span>
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span><span class="lineCov">       1366 :         SetConfigOption(name, value, gucctx, PGC_S_CLIENT);</span>
<span class="lineNum">    1143 </span>            :     }
<span class="lineNum">    1144 </span><span class="lineCov">        454 : }</span>
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span>            : /*
<span class="lineNum">    1147 </span>            :  * Load GUC settings from pg_db_role_setting.
<span class="lineNum">    1148 </span>            :  *
<span class="lineNum">    1149 </span>            :  * We try specific settings for the database/role combination, as well as
<span class="lineNum">    1150 </span>            :  * general for this database and for this user.
<a name="1151"><span class="lineNum">    1151 </span>            :  */</a>
<span class="lineNum">    1152 </span>            : static void
<span class="lineNum">    1153 </span><span class="lineCov">       1208 : process_settings(Oid databaseid, Oid roleid)</span>
<span class="lineNum">    1154 </span>            : {
<span class="lineNum">    1155 </span>            :     Relation    relsetting;
<span class="lineNum">    1156 </span>            :     Snapshot    snapshot;
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span><span class="lineCov">       1208 :     if (!IsUnderPostmaster)</span>
<span class="lineNum">    1159 </span><span class="lineCov">       1212 :         return;</span>
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span><span class="lineCov">       1204 :     relsetting = table_open(DbRoleSettingRelationId, AccessShareLock);</span>
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span>            :     /* read all the settings under the same snapshot for efficiency */
<span class="lineNum">    1164 </span><span class="lineCov">       1204 :     snapshot = RegisterSnapshot(GetCatalogSnapshot(DbRoleSettingRelationId));</span>
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span>            :     /* Later settings are ignored if set earlier. */
<span class="lineNum">    1167 </span><span class="lineCov">       1204 :     ApplySetting(snapshot, databaseid, roleid, relsetting, PGC_S_DATABASE_USER);</span>
<span class="lineNum">    1168 </span><span class="lineCov">       1204 :     ApplySetting(snapshot, InvalidOid, roleid, relsetting, PGC_S_USER);</span>
<span class="lineNum">    1169 </span><span class="lineCov">       1204 :     ApplySetting(snapshot, databaseid, InvalidOid, relsetting, PGC_S_DATABASE);</span>
<span class="lineNum">    1170 </span><span class="lineCov">       1204 :     ApplySetting(snapshot, InvalidOid, InvalidOid, relsetting, PGC_S_GLOBAL);</span>
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span><span class="lineCov">       1204 :     UnregisterSnapshot(snapshot);</span>
<span class="lineNum">    1173 </span><span class="lineCov">       1204 :     table_close(relsetting, AccessShareLock);</span>
<span class="lineNum">    1174 </span>            : }
<span class="lineNum">    1175 </span>            : 
<span class="lineNum">    1176 </span>            : /*
<span class="lineNum">    1177 </span>            :  * Backend-shutdown callback.  Do cleanup that we want to be sure happens
<span class="lineNum">    1178 </span>            :  * before all the supporting modules begin to nail their doors shut via
<span class="lineNum">    1179 </span>            :  * their own callbacks.
<span class="lineNum">    1180 </span>            :  *
<span class="lineNum">    1181 </span>            :  * User-level cleanup, such as temp-relation removal and UNLISTEN, happens
<span class="lineNum">    1182 </span>            :  * via separate callbacks that execute before this one.  We don't combine the
<span class="lineNum">    1183 </span>            :  * callbacks because we still want this one to happen if the user-level
<span class="lineNum">    1184 </span>            :  * cleanup fails.
<a name="1185"><span class="lineNum">    1185 </span>            :  */</a>
<span class="lineNum">    1186 </span>            : static void
<span class="lineNum">    1187 </span><span class="lineCov">       1212 : ShutdownPostgres(int code, Datum arg)</span>
<span class="lineNum">    1188 </span>            : {
<span class="lineNum">    1189 </span>            :     /* Make sure we've killed any active transaction */
<span class="lineNum">    1190 </span><span class="lineCov">       1212 :     AbortOutOfAnyTransaction();</span>
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span>            :     /*
<span class="lineNum">    1193 </span>            :      * User locks are not released by transaction end, so be sure to release
<span class="lineNum">    1194 </span>            :      * them explicitly.
<span class="lineNum">    1195 </span>            :      */
<span class="lineNum">    1196 </span><span class="lineCov">       1212 :     LockReleaseAll(USER_LOCKMETHOD, true);</span>
<span class="lineNum">    1197 </span><span class="lineCov">       1212 : }</span>
<span class="lineNum">    1198 </span>            : 
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span>            : /*
<span class="lineNum">    1201 </span>            :  * STATEMENT_TIMEOUT handler: trigger a query-cancel interrupt.
<a name="1202"><span class="lineNum">    1202 </span>            :  */</a>
<span class="lineNum">    1203 </span>            : static void
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 : StatementTimeoutHandler(void)</span>
<span class="lineNum">    1205 </span>            : {
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :     int         sig = SIGINT;</span>
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span>            :     /*
<span class="lineNum">    1209 </span>            :      * During authentication the timeout is used to deal with
<span class="lineNum">    1210 </span>            :      * authentication_timeout - we want to quit in response to such timeouts.
<span class="lineNum">    1211 </span>            :      */
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :     if (ClientAuthInProgress)</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :         sig = SIGTERM;</span>
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span>            : #ifdef HAVE_SETSID
<span class="lineNum">    1216 </span>            :     /* try to signal whole process group */
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :     kill(-MyProcPid, sig);</span>
<span class="lineNum">    1218 </span>            : #endif
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :     kill(MyProcPid, sig);</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span>            : /*
<span class="lineNum">    1223 </span>            :  * LOCK_TIMEOUT handler: trigger a query-cancel interrupt.
<a name="1224"><span class="lineNum">    1224 </span>            :  */</a>
<span class="lineNum">    1225 </span>            : static void
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 : LockTimeoutHandler(void)</span>
<span class="lineNum">    1227 </span>            : {
<span class="lineNum">    1228 </span>            : #ifdef HAVE_SETSID
<span class="lineNum">    1229 </span>            :     /* try to signal whole process group */
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :     kill(-MyProcPid, SIGINT);</span>
<span class="lineNum">    1231 </span>            : #endif
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :     kill(MyProcPid, SIGINT);</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 : }</span>
<a name="1234"><span class="lineNum">    1234 </span>            : </a>
<span class="lineNum">    1235 </span>            : static void
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 : IdleInTransactionSessionTimeoutHandler(void)</span>
<span class="lineNum">    1237 </span>            : {
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :     IdleInTransactionSessionTimeoutPending = true;</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :     InterruptPending = true;</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :     SetLatch(MyLatch);</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1242 </span>            : 
<span class="lineNum">    1243 </span>            : /*
<span class="lineNum">    1244 </span>            :  * Returns true if at least one role is defined in this database cluster.
<a name="1245"><span class="lineNum">    1245 </span>            :  */</a>
<span class="lineNum">    1246 </span>            : static bool
<span class="lineNum">    1247 </span><span class="lineCov">          2 : ThereIsAtLeastOneRole(void)</span>
<span class="lineNum">    1248 </span>            : {
<span class="lineNum">    1249 </span>            :     Relation    pg_authid_rel;
<span class="lineNum">    1250 </span>            :     TableScanDesc scan;
<span class="lineNum">    1251 </span>            :     bool        result;
<span class="lineNum">    1252 </span>            : 
<span class="lineNum">    1253 </span><span class="lineCov">          2 :     pg_authid_rel = table_open(AuthIdRelationId, AccessShareLock);</span>
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span><span class="lineCov">          2 :     scan = table_beginscan_catalog(pg_authid_rel, 0, NULL);</span>
<span class="lineNum">    1256 </span><span class="lineCov">          2 :     result = (heap_getnext(scan, ForwardScanDirection) != NULL);</span>
<span class="lineNum">    1257 </span>            : 
<span class="lineNum">    1258 </span><span class="lineCov">          2 :     table_endscan(scan);</span>
<span class="lineNum">    1259 </span><span class="lineCov">          2 :     table_close(pg_authid_rel, AccessShareLock);</span>
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span><span class="lineCov">          2 :     return result;</span>
<span class="lineNum">    1262 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
