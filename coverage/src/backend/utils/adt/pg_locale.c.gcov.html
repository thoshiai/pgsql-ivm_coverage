<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/utils/adt/pg_locale.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/backend/utils/adt</a> - pg_locale.c<span style="font-size: 80%;"> (source / <a href="pg_locale.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">336</td>
            <td class="headerCovTableEntry">408</td>
            <td class="headerCovTableEntryMed">82.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">25</td>
            <td class="headerCovTableEntry">25</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-----------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * PostgreSQL locale utilities
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * Portions Copyright (c) 2002-2019, PostgreSQL Global Development Group
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  * src/backend/utils/adt/pg_locale.c
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  *-----------------------------------------------------------------------
<span class="lineNum">      10 </span>            :  */
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : /*----------
<span class="lineNum">      13 </span>            :  * Here is how the locale stuff is handled: LC_COLLATE and LC_CTYPE
<span class="lineNum">      14 </span>            :  * are fixed at CREATE DATABASE time, stored in pg_database, and cannot
<span class="lineNum">      15 </span>            :  * be changed. Thus, the effects of strcoll(), strxfrm(), isupper(),
<span class="lineNum">      16 </span>            :  * toupper(), etc. are always in the same fixed locale.
<span class="lineNum">      17 </span>            :  *
<span class="lineNum">      18 </span>            :  * LC_MESSAGES is settable at run time and will take effect
<span class="lineNum">      19 </span>            :  * immediately.
<span class="lineNum">      20 </span>            :  *
<span class="lineNum">      21 </span>            :  * The other categories, LC_MONETARY, LC_NUMERIC, and LC_TIME are also
<span class="lineNum">      22 </span>            :  * settable at run-time.  However, we don't actually set those locale
<span class="lineNum">      23 </span>            :  * categories permanently.  This would have bizarre effects like no
<span class="lineNum">      24 </span>            :  * longer accepting standard floating-point literals in some locales.
<span class="lineNum">      25 </span>            :  * Instead, we only set these locale categories briefly when needed,
<span class="lineNum">      26 </span>            :  * cache the required information obtained from localeconv() or
<span class="lineNum">      27 </span>            :  * strftime(), and then set the locale categories back to &quot;C&quot;.
<span class="lineNum">      28 </span>            :  * The cached information is only used by the formatting functions
<span class="lineNum">      29 </span>            :  * (to_char, etc.) and the money type.  For the user, this should all be
<span class="lineNum">      30 </span>            :  * transparent.
<span class="lineNum">      31 </span>            :  *
<span class="lineNum">      32 </span>            :  * !!! NOW HEAR THIS !!!
<span class="lineNum">      33 </span>            :  *
<span class="lineNum">      34 </span>            :  * We've been bitten repeatedly by this bug, so let's try to keep it in
<span class="lineNum">      35 </span>            :  * mind in future: on some platforms, the locale functions return pointers
<span class="lineNum">      36 </span>            :  * to static data that will be overwritten by any later locale function.
<span class="lineNum">      37 </span>            :  * Thus, for example, the obvious-looking sequence
<span class="lineNum">      38 </span>            :  *          save = setlocale(category, NULL);
<span class="lineNum">      39 </span>            :  *          if (!setlocale(category, value))
<span class="lineNum">      40 </span>            :  *              fail = true;
<span class="lineNum">      41 </span>            :  *          setlocale(category, save);
<span class="lineNum">      42 </span>            :  * DOES NOT WORK RELIABLY: on some platforms the second setlocale() call
<span class="lineNum">      43 </span>            :  * will change the memory save is pointing at.  To do this sort of thing
<span class="lineNum">      44 </span>            :  * safely, you *must* pstrdup what setlocale returns the first time.
<span class="lineNum">      45 </span>            :  *
<span class="lineNum">      46 </span>            :  * The POSIX locale standard is available here:
<span class="lineNum">      47 </span>            :  *
<span class="lineNum">      48 </span>            :  *  http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap07.html
<span class="lineNum">      49 </span>            :  *----------
<span class="lineNum">      50 </span>            :  */
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : #include &quot;access/htup_details.h&quot;
<span class="lineNum">      58 </span>            : #include &quot;catalog/pg_collation.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;catalog/pg_control.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;mb/pg_wchar.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;utils/builtins.h&quot;
<span class="lineNum">      62 </span>            : #include &quot;utils/formatting.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;utils/hsearch.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;utils/lsyscache.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;utils/memutils.h&quot;
<span class="lineNum">      66 </span>            : #include &quot;utils/pg_locale.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;utils/syscache.h&quot;
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : #ifdef USE_ICU
<span class="lineNum">      70 </span>            : #include &lt;unicode/ucnv.h&gt;
<span class="lineNum">      71 </span>            : #endif
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : #ifdef __GLIBC__
<span class="lineNum">      74 </span>            : #include &lt;gnu/libc-version.h&gt;
<span class="lineNum">      75 </span>            : #endif
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : #ifdef WIN32
<span class="lineNum">      78 </span>            : /*
<span class="lineNum">      79 </span>            :  * This Windows file defines StrNCpy. We don't need it here, so we undefine
<span class="lineNum">      80 </span>            :  * it to keep the compiler quiet, and undefine it again after the file is
<span class="lineNum">      81 </span>            :  * included, so we don't accidentally use theirs.
<span class="lineNum">      82 </span>            :  */
<span class="lineNum">      83 </span>            : #undef StrNCpy
<span class="lineNum">      84 </span>            : #include &lt;shlwapi.h&gt;
<span class="lineNum">      85 </span>            : #ifdef StrNCpy
<span class="lineNum">      86 </span>            : #undef StrNCpy
<span class="lineNum">      87 </span>            : #endif
<span class="lineNum">      88 </span>            : #endif
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : #define     MAX_L10N_DATA       80
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : /* GUC settings */
<span class="lineNum">      94 </span>            : char       *locale_messages;
<span class="lineNum">      95 </span>            : char       *locale_monetary;
<span class="lineNum">      96 </span>            : char       *locale_numeric;
<span class="lineNum">      97 </span>            : char       *locale_time;
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            : /* lc_time localization cache */
<span class="lineNum">     100 </span>            : char       *localized_abbrev_days[7];
<span class="lineNum">     101 </span>            : char       *localized_full_days[7];
<span class="lineNum">     102 </span>            : char       *localized_abbrev_months[12];
<span class="lineNum">     103 </span>            : char       *localized_full_months[12];
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : /* indicates whether locale information cache is valid */
<span class="lineNum">     106 </span>            : static bool CurrentLocaleConvValid = false;
<span class="lineNum">     107 </span>            : static bool CurrentLCTimeValid = false;
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : /* Environment variable storage area */
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : #define LC_ENV_BUFSIZE (NAMEDATALEN + 20)
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : static char lc_collate_envbuf[LC_ENV_BUFSIZE];
<span class="lineNum">     114 </span>            : static char lc_ctype_envbuf[LC_ENV_BUFSIZE];
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            : #ifdef LC_MESSAGES
<span class="lineNum">     117 </span>            : static char lc_messages_envbuf[LC_ENV_BUFSIZE];
<span class="lineNum">     118 </span>            : #endif
<span class="lineNum">     119 </span>            : static char lc_monetary_envbuf[LC_ENV_BUFSIZE];
<span class="lineNum">     120 </span>            : static char lc_numeric_envbuf[LC_ENV_BUFSIZE];
<span class="lineNum">     121 </span>            : static char lc_time_envbuf[LC_ENV_BUFSIZE];
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : /* Cache for collation-related knowledge */
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            : typedef struct
<span class="lineNum">     126 </span>            : {
<span class="lineNum">     127 </span>            :     Oid         collid;         /* hash key: pg_collation OID */
<span class="lineNum">     128 </span>            :     bool        collate_is_c;   /* is collation's LC_COLLATE C? */
<span class="lineNum">     129 </span>            :     bool        ctype_is_c;     /* is collation's LC_CTYPE C? */
<span class="lineNum">     130 </span>            :     bool        flags_valid;    /* true if above flags are valid */
<span class="lineNum">     131 </span>            :     pg_locale_t locale;         /* locale_t struct, or 0 if not valid */
<span class="lineNum">     132 </span>            : } collation_cache_entry;
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : static HTAB *collation_cache = NULL;
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : #if defined(WIN32) &amp;&amp; defined(LC_MESSAGES)
<span class="lineNum">     138 </span>            : static char *IsoLocaleName(const char *);   /* MSVC specific */
<span class="lineNum">     139 </span>            : #endif
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : #ifdef USE_ICU
<span class="lineNum">     142 </span>            : static void icu_set_collation_attributes(UCollator *collator, const char *loc);
<span class="lineNum">     143 </span>            : #endif
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            : /*
<span class="lineNum">     146 </span>            :  * pg_perm_setlocale
<span class="lineNum">     147 </span>            :  *
<span class="lineNum">     148 </span>            :  * This wraps the libc function setlocale(), with two additions.  First, when
<span class="lineNum">     149 </span>            :  * changing LC_CTYPE, update gettext's encoding for the current message
<span class="lineNum">     150 </span>            :  * domain.  GNU gettext automatically tracks LC_CTYPE on most platforms, but
<span class="lineNum">     151 </span>            :  * not on Windows.  Second, if the operation is successful, the corresponding
<span class="lineNum">     152 </span>            :  * LC_XXX environment variable is set to match.  By setting the environment
<span class="lineNum">     153 </span>            :  * variable, we ensure that any subsequent use of setlocale(..., &quot;&quot;) will
<span class="lineNum">     154 </span>            :  * preserve the settings made through this routine.  Of course, LC_ALL must
<span class="lineNum">     155 </span>            :  * also be unset to fully ensure that, but that has to be done elsewhere after
<span class="lineNum">     156 </span>            :  * all the individual LC_XXX variables have been set correctly.  (Thank you
<span class="lineNum">     157 </span>            :  * Perl for making this kluge necessary.)
<a name="158"><span class="lineNum">     158 </span>            :  */</a>
<span class="lineNum">     159 </span>            : char *
<span class="lineNum">     160 </span><span class="lineCov">      14932 : pg_perm_setlocale(int category, const char *locale)</span>
<span class="lineNum">     161 </span>            : {
<span class="lineNum">     162 </span>            :     char       *result;
<span class="lineNum">     163 </span>            :     const char *envvar;
<span class="lineNum">     164 </span>            :     char       *envbuf;
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : #ifndef WIN32
<span class="lineNum">     167 </span><span class="lineCov">      14932 :     result = setlocale(category, locale);</span>
<span class="lineNum">     168 </span>            : #else
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :     /*
<span class="lineNum">     171 </span>            :      * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that
<span class="lineNum">     172 </span>            :      * the given value is good and set it in the environment variables. We
<span class="lineNum">     173 </span>            :      * must ignore attempts to set to &quot;&quot;, which means &quot;keep using the old
<span class="lineNum">     174 </span>            :      * environment value&quot;.
<span class="lineNum">     175 </span>            :      */
<span class="lineNum">     176 </span>            : #ifdef LC_MESSAGES
<span class="lineNum">     177 </span>            :     if (category == LC_MESSAGES)
<span class="lineNum">     178 </span>            :     {
<span class="lineNum">     179 </span>            :         result = (char *) locale;
<span class="lineNum">     180 </span>            :         if (locale == NULL || locale[0] == '\0')
<span class="lineNum">     181 </span>            :             return result;
<span class="lineNum">     182 </span>            :     }
<span class="lineNum">     183 </span>            :     else
<span class="lineNum">     184 </span>            : #endif
<span class="lineNum">     185 </span>            :         result = setlocale(category, locale);
<span class="lineNum">     186 </span>            : #endif                          /* WIN32 */
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span><span class="lineCov">      14932 :     if (result == NULL)</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :         return result;          /* fall out immediately on failure */</span>
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :     /*
<span class="lineNum">     192 </span>            :      * Use the right encoding in translated messages.  Under ENABLE_NLS, let
<span class="lineNum">     193 </span>            :      * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message
<span class="lineNum">     194 </span>            :      * format strings are ASCII, but database-encoding strings may enter the
<span class="lineNum">     195 </span>            :      * message via %s.  This makes the overall message encoding equal to the
<span class="lineNum">     196 </span>            :      * database encoding.
<span class="lineNum">     197 </span>            :      */
<span class="lineNum">     198 </span><span class="lineCov">      14932 :     if (category == LC_CTYPE)</span>
<span class="lineNum">     199 </span>            :     {
<span class="lineNum">     200 </span>            :         static char save_lc_ctype[LC_ENV_BUFSIZE];
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            :         /* copy setlocale() return value before callee invokes it again */
<span class="lineNum">     203 </span><span class="lineCov">       2436 :         strlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));</span>
<span class="lineNum">     204 </span><span class="lineCov">       2436 :         result = save_lc_ctype;</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            : #ifdef ENABLE_NLS
<span class="lineNum">     207 </span>            :         SetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));
<span class="lineNum">     208 </span>            : #else
<span class="lineNum">     209 </span><span class="lineCov">       2436 :         SetMessageEncoding(GetDatabaseEncoding());</span>
<span class="lineNum">     210 </span>            : #endif
<span class="lineNum">     211 </span>            :     }
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span><span class="lineCov">      14932 :     switch (category)</span>
<span class="lineNum">     214 </span>            :     {
<span class="lineNum">     215 </span>            :         case LC_COLLATE:
<span class="lineNum">     216 </span><span class="lineCov">       2436 :             envvar = &quot;LC_COLLATE&quot;;</span>
<span class="lineNum">     217 </span><span class="lineCov">       2436 :             envbuf = lc_collate_envbuf;</span>
<span class="lineNum">     218 </span><span class="lineCov">       2436 :             break;</span>
<span class="lineNum">     219 </span>            :         case LC_CTYPE:
<span class="lineNum">     220 </span><span class="lineCov">       2436 :             envvar = &quot;LC_CTYPE&quot;;</span>
<span class="lineNum">     221 </span><span class="lineCov">       2436 :             envbuf = lc_ctype_envbuf;</span>
<span class="lineNum">     222 </span><span class="lineCov">       2436 :             break;</span>
<span class="lineNum">     223 </span>            : #ifdef LC_MESSAGES
<span class="lineNum">     224 </span>            :         case LC_MESSAGES:
<span class="lineNum">     225 </span><span class="lineCov">       6370 :             envvar = &quot;LC_MESSAGES&quot;;</span>
<span class="lineNum">     226 </span><span class="lineCov">       6370 :             envbuf = lc_messages_envbuf;</span>
<span class="lineNum">     227 </span>            : #ifdef WIN32
<span class="lineNum">     228 </span>            :             result = IsoLocaleName(locale);
<span class="lineNum">     229 </span>            :             if (result == NULL)
<span class="lineNum">     230 </span>            :                 result = (char *) locale;
<span class="lineNum">     231 </span>            : #endif                          /* WIN32 */
<span class="lineNum">     232 </span><span class="lineCov">       6370 :             break;</span>
<span class="lineNum">     233 </span>            : #endif                          /* LC_MESSAGES */
<span class="lineNum">     234 </span>            :         case LC_MONETARY:
<span class="lineNum">     235 </span><span class="lineCov">       1230 :             envvar = &quot;LC_MONETARY&quot;;</span>
<span class="lineNum">     236 </span><span class="lineCov">       1230 :             envbuf = lc_monetary_envbuf;</span>
<span class="lineNum">     237 </span><span class="lineCov">       1230 :             break;</span>
<span class="lineNum">     238 </span>            :         case LC_NUMERIC:
<span class="lineNum">     239 </span><span class="lineCov">       1230 :             envvar = &quot;LC_NUMERIC&quot;;</span>
<span class="lineNum">     240 </span><span class="lineCov">       1230 :             envbuf = lc_numeric_envbuf;</span>
<span class="lineNum">     241 </span><span class="lineCov">       1230 :             break;</span>
<span class="lineNum">     242 </span>            :         case LC_TIME:
<span class="lineNum">     243 </span><span class="lineCov">       1230 :             envvar = &quot;LC_TIME&quot;;</span>
<span class="lineNum">     244 </span><span class="lineCov">       1230 :             envbuf = lc_time_envbuf;</span>
<span class="lineNum">     245 </span><span class="lineCov">       1230 :             break;</span>
<span class="lineNum">     246 </span>            :         default:
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :             elog(FATAL, &quot;unrecognized LC category: %d&quot;, category);</span>
<span class="lineNum">     248 </span>            :             envvar = NULL;      /* keep compiler quiet */
<span class="lineNum">     249 </span>            :             envbuf = NULL;
<span class="lineNum">     250 </span>            :             return NULL;
<span class="lineNum">     251 </span>            :     }
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span><span class="lineCov">      14932 :     snprintf(envbuf, LC_ENV_BUFSIZE - 1, &quot;%s=%s&quot;, envvar, result);</span>
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span><span class="lineCov">      14932 :     if (putenv(envbuf))</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineCov">      14932 :     return result;</span>
<span class="lineNum">     259 </span>            : }
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : /*
<span class="lineNum">     263 </span>            :  * Is the locale name valid for the locale category?
<span class="lineNum">     264 </span>            :  *
<span class="lineNum">     265 </span>            :  * If successful, and canonname isn't NULL, a palloc'd copy of the locale's
<span class="lineNum">     266 </span>            :  * canonical name is stored there.  This is especially useful for figuring out
<span class="lineNum">     267 </span>            :  * what locale name &quot;&quot; means (ie, the server environment value).  (Actually,
<span class="lineNum">     268 </span>            :  * it seems that on most implementations that's the only thing it's good for;
<span class="lineNum">     269 </span>            :  * we could wish that setlocale gave back a canonically spelled version of
<span class="lineNum">     270 </span>            :  * the locale name, but typically it doesn't.)
<a name="271"><span class="lineNum">     271 </span>            :  */</a>
<span class="lineNum">     272 </span>            : bool
<span class="lineNum">     273 </span><span class="lineCov">      18618 : check_locale(int category, const char *locale, char **canonname)</span>
<span class="lineNum">     274 </span>            : {
<span class="lineNum">     275 </span>            :     char       *save;
<span class="lineNum">     276 </span>            :     char       *res;
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span><span class="lineCov">      18618 :     if (canonname)</span>
<span class="lineNum">     279 </span><span class="lineCov">         12 :         *canonname = NULL;      /* in case of failure */</span>
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineCov">      18618 :     save = setlocale(category, NULL);</span>
<span class="lineNum">     282 </span><span class="lineCov">      18618 :     if (!save)</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         return false;           /* won't happen, we hope */</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :     /* save may be pointing at a modifiable scratch variable, see above. */
<span class="lineNum">     286 </span><span class="lineCov">      18618 :     save = pstrdup(save);</span>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :     /* set the locale with setlocale, to see if it accepts it. */
<span class="lineNum">     289 </span><span class="lineCov">      18618 :     res = setlocale(category, locale);</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            :     /* save canonical name if requested. */
<span class="lineNum">     292 </span><span class="lineCov">      18618 :     if (res &amp;&amp; canonname)</span>
<span class="lineNum">     293 </span><span class="lineCov">         12 :         *canonname = pstrdup(res);</span>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :     /* restore old value. */
<span class="lineNum">     296 </span><span class="lineCov">      18618 :     if (!setlocale(category, save))</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :         elog(WARNING, &quot;failed to restore old locale \&quot;%s\&quot;&quot;, save);</span>
<span class="lineNum">     298 </span><span class="lineCov">      18618 :     pfree(save);</span>
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span><span class="lineCov">      18618 :     return (res != NULL);</span>
<span class="lineNum">     301 </span>            : }
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            : /*
<span class="lineNum">     305 </span>            :  * GUC check/assign hooks
<span class="lineNum">     306 </span>            :  *
<span class="lineNum">     307 </span>            :  * For most locale categories, the assign hook doesn't actually set the locale
<span class="lineNum">     308 </span>            :  * permanently, just reset flags so that the next use will cache the
<span class="lineNum">     309 </span>            :  * appropriate values.  (See explanation at the top of this file.)
<span class="lineNum">     310 </span>            :  *
<span class="lineNum">     311 </span>            :  * Note: we accept value = &quot;&quot; as selecting the postmaster's environment
<span class="lineNum">     312 </span>            :  * value, whatever it was (so long as the environment setting is legal).
<span class="lineNum">     313 </span>            :  * This will have been locked down by an earlier call to pg_perm_setlocale.
<a name="314"><span class="lineNum">     314 </span>            :  */</a>
<span class="lineNum">     315 </span>            : bool
<span class="lineNum">     316 </span><span class="lineCov">       5144 : check_locale_monetary(char **newval, void **extra, GucSource source)</span>
<span class="lineNum">     317 </span>            : {
<span class="lineNum">     318 </span><span class="lineCov">       5144 :     return check_locale(LC_MONETARY, *newval, NULL);</span>
<span class="lineNum">     319 </span>            : }
<a name="320"><span class="lineNum">     320 </span>            : </a>
<span class="lineNum">     321 </span>            : void
<span class="lineNum">     322 </span><span class="lineCov">       5140 : assign_locale_monetary(const char *newval, void *extra)</span>
<span class="lineNum">     323 </span>            : {
<span class="lineNum">     324 </span><span class="lineCov">       5140 :     CurrentLocaleConvValid = false;</span>
<span class="lineNum">     325 </span><span class="lineCov">       5140 : }</span>
<a name="326"><span class="lineNum">     326 </span>            : </a>
<span class="lineNum">     327 </span>            : bool
<span class="lineNum">     328 </span><span class="lineCov">       5146 : check_locale_numeric(char **newval, void **extra, GucSource source)</span>
<span class="lineNum">     329 </span>            : {
<span class="lineNum">     330 </span><span class="lineCov">       5146 :     return check_locale(LC_NUMERIC, *newval, NULL);</span>
<span class="lineNum">     331 </span>            : }
<a name="332"><span class="lineNum">     332 </span>            : </a>
<span class="lineNum">     333 </span>            : void
<span class="lineNum">     334 </span><span class="lineCov">       5144 : assign_locale_numeric(const char *newval, void *extra)</span>
<span class="lineNum">     335 </span>            : {
<span class="lineNum">     336 </span><span class="lineCov">       5144 :     CurrentLocaleConvValid = false;</span>
<span class="lineNum">     337 </span><span class="lineCov">       5144 : }</span>
<a name="338"><span class="lineNum">     338 </span>            : </a>
<span class="lineNum">     339 </span>            : bool
<span class="lineNum">     340 </span><span class="lineCov">       5146 : check_locale_time(char **newval, void **extra, GucSource source)</span>
<span class="lineNum">     341 </span>            : {
<span class="lineNum">     342 </span><span class="lineCov">       5146 :     return check_locale(LC_TIME, *newval, NULL);</span>
<span class="lineNum">     343 </span>            : }
<a name="344"><span class="lineNum">     344 </span>            : </a>
<span class="lineNum">     345 </span>            : void
<span class="lineNum">     346 </span><span class="lineCov">       5142 : assign_locale_time(const char *newval, void *extra)</span>
<span class="lineNum">     347 </span>            : {
<span class="lineNum">     348 </span><span class="lineCov">       5142 :     CurrentLCTimeValid = false;</span>
<span class="lineNum">     349 </span><span class="lineCov">       5142 : }</span>
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            : /*
<span class="lineNum">     352 </span>            :  * We allow LC_MESSAGES to actually be set globally.
<span class="lineNum">     353 </span>            :  *
<span class="lineNum">     354 </span>            :  * Note: we normally disallow value = &quot;&quot; because it wouldn't have consistent
<span class="lineNum">     355 </span>            :  * semantics (it'd effectively just use the previous value).  However, this
<span class="lineNum">     356 </span>            :  * is the value passed for PGC_S_DEFAULT, so don't complain in that case,
<span class="lineNum">     357 </span>            :  * not even if the attempted setting fails due to invalid environment value.
<span class="lineNum">     358 </span>            :  * The idea there is just to accept the environment setting *if possible*
<span class="lineNum">     359 </span>            :  * during startup, until we can read the proper value from postgresql.conf.
<a name="360"><span class="lineNum">     360 </span>            :  */</a>
<span class="lineNum">     361 </span>            : bool
<span class="lineNum">     362 </span><span class="lineCov">       5144 : check_locale_messages(char **newval, void **extra, GucSource source)</span>
<span class="lineNum">     363 </span>            : {
<span class="lineNum">     364 </span><span class="lineCov">       5144 :     if (**newval == '\0')</span>
<span class="lineNum">     365 </span>            :     {
<span class="lineNum">     366 </span><span class="lineCov">       1974 :         if (source == PGC_S_DEFAULT)</span>
<span class="lineNum">     367 </span><span class="lineCov">       1974 :             return true;</span>
<span class="lineNum">     368 </span>            :         else
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">     370 </span>            :     }
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            :     /*
<span class="lineNum">     373 </span>            :      * LC_MESSAGES category does not exist everywhere, but accept it anyway
<span class="lineNum">     374 </span>            :      *
<span class="lineNum">     375 </span>            :      * On Windows, we can't even check the value, so accept blindly
<span class="lineNum">     376 </span>            :      */
<span class="lineNum">     377 </span>            : #if defined(LC_MESSAGES) &amp;&amp; !defined(WIN32)
<span class="lineNum">     378 </span><span class="lineCov">       3170 :     return check_locale(LC_MESSAGES, *newval, NULL);</span>
<span class="lineNum">     379 </span>            : #else
<span class="lineNum">     380 </span>            :     return true;
<span class="lineNum">     381 </span>            : #endif
<span class="lineNum">     382 </span>            : }
<a name="383"><span class="lineNum">     383 </span>            : </a>
<span class="lineNum">     384 </span>            : void
<span class="lineNum">     385 </span><span class="lineCov">       5140 : assign_locale_messages(const char *newval, void *extra)</span>
<span class="lineNum">     386 </span>            : {
<span class="lineNum">     387 </span>            :     /*
<span class="lineNum">     388 </span>            :      * LC_MESSAGES category does not exist everywhere, but accept it anyway.
<span class="lineNum">     389 </span>            :      * We ignore failure, as per comment above.
<span class="lineNum">     390 </span>            :      */
<span class="lineNum">     391 </span>            : #ifdef LC_MESSAGES
<span class="lineNum">     392 </span><span class="lineCov">       5140 :     (void) pg_perm_setlocale(LC_MESSAGES, newval);</span>
<span class="lineNum">     393 </span>            : #endif
<span class="lineNum">     394 </span><span class="lineCov">       5140 : }</span>
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : /*
<span class="lineNum">     398 </span>            :  * Frees the malloced content of a struct lconv.  (But not the struct
<span class="lineNum">     399 </span>            :  * itself.)  It's important that this not throw elog(ERROR).
<a name="400"><span class="lineNum">     400 </span>            :  */</a>
<span class="lineNum">     401 </span>            : static void
<span class="lineNum">     402 </span><span class="lineCov">          2 : free_struct_lconv(struct lconv *s)</span>
<span class="lineNum">     403 </span>            : {
<span class="lineNum">     404 </span><span class="lineCov">          2 :     if (s-&gt;decimal_point)</span>
<span class="lineNum">     405 </span><span class="lineCov">          2 :         free(s-&gt;decimal_point);</span>
<span class="lineNum">     406 </span><span class="lineCov">          2 :     if (s-&gt;thousands_sep)</span>
<span class="lineNum">     407 </span><span class="lineCov">          2 :         free(s-&gt;thousands_sep);</span>
<span class="lineNum">     408 </span><span class="lineCov">          2 :     if (s-&gt;grouping)</span>
<span class="lineNum">     409 </span><span class="lineCov">          2 :         free(s-&gt;grouping);</span>
<span class="lineNum">     410 </span><span class="lineCov">          2 :     if (s-&gt;int_curr_symbol)</span>
<span class="lineNum">     411 </span><span class="lineCov">          2 :         free(s-&gt;int_curr_symbol);</span>
<span class="lineNum">     412 </span><span class="lineCov">          2 :     if (s-&gt;currency_symbol)</span>
<span class="lineNum">     413 </span><span class="lineCov">          2 :         free(s-&gt;currency_symbol);</span>
<span class="lineNum">     414 </span><span class="lineCov">          2 :     if (s-&gt;mon_decimal_point)</span>
<span class="lineNum">     415 </span><span class="lineCov">          2 :         free(s-&gt;mon_decimal_point);</span>
<span class="lineNum">     416 </span><span class="lineCov">          2 :     if (s-&gt;mon_thousands_sep)</span>
<span class="lineNum">     417 </span><span class="lineCov">          2 :         free(s-&gt;mon_thousands_sep);</span>
<span class="lineNum">     418 </span><span class="lineCov">          2 :     if (s-&gt;mon_grouping)</span>
<span class="lineNum">     419 </span><span class="lineCov">          2 :         free(s-&gt;mon_grouping);</span>
<span class="lineNum">     420 </span><span class="lineCov">          2 :     if (s-&gt;positive_sign)</span>
<span class="lineNum">     421 </span><span class="lineCov">          2 :         free(s-&gt;positive_sign);</span>
<span class="lineNum">     422 </span><span class="lineCov">          2 :     if (s-&gt;negative_sign)</span>
<span class="lineNum">     423 </span><span class="lineCov">          2 :         free(s-&gt;negative_sign);</span>
<span class="lineNum">     424 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            : /*
<span class="lineNum">     427 </span>            :  * Check that all fields of a struct lconv (or at least, the ones we care
<span class="lineNum">     428 </span>            :  * about) are non-NULL.  The field list must match free_struct_lconv().
<a name="429"><span class="lineNum">     429 </span>            :  */</a>
<span class="lineNum">     430 </span>            : static bool
<span class="lineNum">     431 </span><span class="lineCov">         18 : struct_lconv_is_valid(struct lconv *s)</span>
<span class="lineNum">     432 </span>            : {
<span class="lineNum">     433 </span><span class="lineCov">         18 :     if (s-&gt;decimal_point == NULL)</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     435 </span><span class="lineCov">         18 :     if (s-&gt;thousands_sep == NULL)</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     437 </span><span class="lineCov">         18 :     if (s-&gt;grouping == NULL)</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     439 </span><span class="lineCov">         18 :     if (s-&gt;int_curr_symbol == NULL)</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     441 </span><span class="lineCov">         18 :     if (s-&gt;currency_symbol == NULL)</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     443 </span><span class="lineCov">         18 :     if (s-&gt;mon_decimal_point == NULL)</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     445 </span><span class="lineCov">         18 :     if (s-&gt;mon_thousands_sep == NULL)</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     447 </span><span class="lineCov">         18 :     if (s-&gt;mon_grouping == NULL)</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     449 </span><span class="lineCov">         18 :     if (s-&gt;positive_sign == NULL)</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     451 </span><span class="lineCov">         18 :     if (s-&gt;negative_sign == NULL)</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     453 </span><span class="lineCov">         18 :     return true;</span>
<span class="lineNum">     454 </span>            : }
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            : /*
<span class="lineNum">     458 </span>            :  * Convert the strdup'd string at *str from the specified encoding to the
<span class="lineNum">     459 </span>            :  * database encoding.
<a name="460"><span class="lineNum">     460 </span>            :  */</a>
<span class="lineNum">     461 </span>            : static void
<span class="lineNum">     462 </span><span class="lineCov">        144 : db_encoding_convert(int encoding, char **str)</span>
<span class="lineNum">     463 </span>            : {
<span class="lineNum">     464 </span>            :     char       *pstr;
<span class="lineNum">     465 </span>            :     char       *mstr;
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :     /* convert the string to the database encoding */
<span class="lineNum">     468 </span><span class="lineCov">        144 :     pstr = pg_any_to_server(*str, strlen(*str), encoding);</span>
<span class="lineNum">     469 </span><span class="lineCov">        144 :     if (pstr == *str)</span>
<span class="lineNum">     470 </span><span class="lineCov">        288 :         return;                 /* no conversion happened */</span>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            :     /* need it malloc'd not palloc'd */
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     mstr = strdup(pstr);</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :     if (mstr == NULL)</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">     476 </span>            :                 (errcode(ERRCODE_OUT_OF_MEMORY),
<span class="lineNum">     477 </span>            :                  errmsg(&quot;out of memory&quot;)));
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            :     /* replace old string */
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :     free(*str);</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :     *str = mstr;</span>
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     pfree(pstr);</span>
<span class="lineNum">     484 </span>            : }
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            : /*
<span class="lineNum">     488 </span>            :  * Return the POSIX lconv struct (contains number/money formatting
<span class="lineNum">     489 </span>            :  * information) with locale information for all categories.
<a name="490"><span class="lineNum">     490 </span>            :  */</a>
<span class="lineNum">     491 </span>            : struct lconv *
<span class="lineNum">     492 </span><span class="lineCov">      12728 : PGLC_localeconv(void)</span>
<span class="lineNum">     493 </span>            : {
<span class="lineNum">     494 </span>            :     static struct lconv CurrentLocaleConv;
<span class="lineNum">     495 </span>            :     static bool CurrentLocaleConvAllocated = false;
<span class="lineNum">     496 </span>            :     struct lconv *extlconv;
<span class="lineNum">     497 </span>            :     struct lconv worklconv;
<span class="lineNum">     498 </span>            :     char       *save_lc_monetary;
<span class="lineNum">     499 </span>            :     char       *save_lc_numeric;
<span class="lineNum">     500 </span>            : #ifdef WIN32
<span class="lineNum">     501 </span>            :     char       *save_lc_ctype;
<span class="lineNum">     502 </span>            : #endif
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            :     /* Did we do it already? */
<span class="lineNum">     505 </span><span class="lineCov">      12728 :     if (CurrentLocaleConvValid)</span>
<span class="lineNum">     506 </span><span class="lineCov">      12710 :         return &amp;CurrentLocaleConv;</span>
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            :     /* Free any already-allocated storage */
<span class="lineNum">     509 </span><span class="lineCov">         18 :     if (CurrentLocaleConvAllocated)</span>
<span class="lineNum">     510 </span>            :     {
<span class="lineNum">     511 </span><span class="lineCov">          2 :         free_struct_lconv(&amp;CurrentLocaleConv);</span>
<span class="lineNum">     512 </span><span class="lineCov">          2 :         CurrentLocaleConvAllocated = false;</span>
<span class="lineNum">     513 </span>            :     }
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            :     /*
<span class="lineNum">     516 </span>            :      * This is tricky because we really don't want to risk throwing error
<span class="lineNum">     517 </span>            :      * while the locale is set to other than our usual settings.  Therefore,
<span class="lineNum">     518 </span>            :      * the process is: collect the usual settings, set locale to special
<span class="lineNum">     519 </span>            :      * setting, copy relevant data into worklconv using strdup(), restore
<span class="lineNum">     520 </span>            :      * normal settings, convert data to desired encoding, and finally stash
<span class="lineNum">     521 </span>            :      * the collected data in CurrentLocaleConv.  This makes it safe if we
<span class="lineNum">     522 </span>            :      * throw an error during encoding conversion or run out of memory anywhere
<span class="lineNum">     523 </span>            :      * in the process.  All data pointed to by struct lconv members is
<span class="lineNum">     524 </span>            :      * allocated with strdup, to avoid premature elog(ERROR) and to allow
<span class="lineNum">     525 </span>            :      * using a single cleanup routine.
<span class="lineNum">     526 </span>            :      */
<span class="lineNum">     527 </span><span class="lineCov">         18 :     memset(&amp;worklconv, 0, sizeof(worklconv));</span>
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span>            :     /* Save prevailing values of monetary and numeric locales */
<span class="lineNum">     530 </span><span class="lineCov">         18 :     save_lc_monetary = setlocale(LC_MONETARY, NULL);</span>
<span class="lineNum">     531 </span><span class="lineCov">         18 :     if (!save_lc_monetary)</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;setlocale(NULL) failed&quot;);</span>
<span class="lineNum">     533 </span><span class="lineCov">         18 :     save_lc_monetary = pstrdup(save_lc_monetary);</span>
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span><span class="lineCov">         18 :     save_lc_numeric = setlocale(LC_NUMERIC, NULL);</span>
<span class="lineNum">     536 </span><span class="lineCov">         18 :     if (!save_lc_numeric)</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;setlocale(NULL) failed&quot;);</span>
<span class="lineNum">     538 </span><span class="lineCov">         18 :     save_lc_numeric = pstrdup(save_lc_numeric);</span>
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            : #ifdef WIN32
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span>            :     /*
<span class="lineNum">     543 </span>            :      * The POSIX standard explicitly says that it is undefined what happens if
<span class="lineNum">     544 </span>            :      * LC_MONETARY or LC_NUMERIC imply an encoding (codeset) different from
<span class="lineNum">     545 </span>            :      * that implied by LC_CTYPE.  In practice, all Unix-ish platforms seem to
<span class="lineNum">     546 </span>            :      * believe that localeconv() should return strings that are encoded in the
<span class="lineNum">     547 </span>            :      * codeset implied by the LC_MONETARY or LC_NUMERIC locale name.  Hence,
<span class="lineNum">     548 </span>            :      * once we have successfully collected the localeconv() results, we will
<span class="lineNum">     549 </span>            :      * convert them from that codeset to the desired server encoding.
<span class="lineNum">     550 </span>            :      *
<span class="lineNum">     551 </span>            :      * Windows, of course, resolutely does things its own way; on that
<span class="lineNum">     552 </span>            :      * platform LC_CTYPE has to match LC_MONETARY/LC_NUMERIC to get sane
<span class="lineNum">     553 </span>            :      * results.  Hence, we must temporarily set that category as well.
<span class="lineNum">     554 </span>            :      */
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            :     /* Save prevailing value of ctype locale */
<span class="lineNum">     557 </span>            :     save_lc_ctype = setlocale(LC_CTYPE, NULL);
<span class="lineNum">     558 </span>            :     if (!save_lc_ctype)
<span class="lineNum">     559 </span>            :         elog(ERROR, &quot;setlocale(NULL) failed&quot;);
<span class="lineNum">     560 </span>            :     save_lc_ctype = pstrdup(save_lc_ctype);
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span>            :     /* Here begins the critical section where we must not throw error */
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :     /* use numeric to set the ctype */
<span class="lineNum">     565 </span>            :     setlocale(LC_CTYPE, locale_numeric);
<span class="lineNum">     566 </span>            : #endif
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            :     /* Get formatting information for numeric */
<span class="lineNum">     569 </span><span class="lineCov">         18 :     setlocale(LC_NUMERIC, locale_numeric);</span>
<span class="lineNum">     570 </span><span class="lineCov">         18 :     extlconv = localeconv();</span>
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            :     /* Must copy data now in case setlocale() overwrites it */
<span class="lineNum">     573 </span><span class="lineCov">         18 :     worklconv.decimal_point = strdup(extlconv-&gt;decimal_point);</span>
<span class="lineNum">     574 </span><span class="lineCov">         18 :     worklconv.thousands_sep = strdup(extlconv-&gt;thousands_sep);</span>
<span class="lineNum">     575 </span><span class="lineCov">         18 :     worklconv.grouping = strdup(extlconv-&gt;grouping);</span>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            : #ifdef WIN32
<span class="lineNum">     578 </span>            :     /* use monetary to set the ctype */
<span class="lineNum">     579 </span>            :     setlocale(LC_CTYPE, locale_monetary);
<span class="lineNum">     580 </span>            : #endif
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            :     /* Get formatting information for monetary */
<span class="lineNum">     583 </span><span class="lineCov">         18 :     setlocale(LC_MONETARY, locale_monetary);</span>
<span class="lineNum">     584 </span><span class="lineCov">         18 :     extlconv = localeconv();</span>
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            :     /* Must copy data now in case setlocale() overwrites it */
<span class="lineNum">     587 </span><span class="lineCov">         18 :     worklconv.int_curr_symbol = strdup(extlconv-&gt;int_curr_symbol);</span>
<span class="lineNum">     588 </span><span class="lineCov">         18 :     worklconv.currency_symbol = strdup(extlconv-&gt;currency_symbol);</span>
<span class="lineNum">     589 </span><span class="lineCov">         18 :     worklconv.mon_decimal_point = strdup(extlconv-&gt;mon_decimal_point);</span>
<span class="lineNum">     590 </span><span class="lineCov">         18 :     worklconv.mon_thousands_sep = strdup(extlconv-&gt;mon_thousands_sep);</span>
<span class="lineNum">     591 </span><span class="lineCov">         18 :     worklconv.mon_grouping = strdup(extlconv-&gt;mon_grouping);</span>
<span class="lineNum">     592 </span><span class="lineCov">         18 :     worklconv.positive_sign = strdup(extlconv-&gt;positive_sign);</span>
<span class="lineNum">     593 </span><span class="lineCov">         18 :     worklconv.negative_sign = strdup(extlconv-&gt;negative_sign);</span>
<span class="lineNum">     594 </span>            :     /* Copy scalar fields as well */
<span class="lineNum">     595 </span><span class="lineCov">         18 :     worklconv.int_frac_digits = extlconv-&gt;int_frac_digits;</span>
<span class="lineNum">     596 </span><span class="lineCov">         18 :     worklconv.frac_digits = extlconv-&gt;frac_digits;</span>
<span class="lineNum">     597 </span><span class="lineCov">         18 :     worklconv.p_cs_precedes = extlconv-&gt;p_cs_precedes;</span>
<span class="lineNum">     598 </span><span class="lineCov">         18 :     worklconv.p_sep_by_space = extlconv-&gt;p_sep_by_space;</span>
<span class="lineNum">     599 </span><span class="lineCov">         18 :     worklconv.n_cs_precedes = extlconv-&gt;n_cs_precedes;</span>
<span class="lineNum">     600 </span><span class="lineCov">         18 :     worklconv.n_sep_by_space = extlconv-&gt;n_sep_by_space;</span>
<span class="lineNum">     601 </span><span class="lineCov">         18 :     worklconv.p_sign_posn = extlconv-&gt;p_sign_posn;</span>
<span class="lineNum">     602 </span><span class="lineCov">         18 :     worklconv.n_sign_posn = extlconv-&gt;n_sign_posn;</span>
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            :     /*
<span class="lineNum">     605 </span>            :      * Restore the prevailing locale settings; failure to do so is fatal.
<span class="lineNum">     606 </span>            :      * Possibly we could limp along with nondefault LC_MONETARY or LC_NUMERIC,
<span class="lineNum">     607 </span>            :      * but proceeding with the wrong value of LC_CTYPE would certainly be bad
<span class="lineNum">     608 </span>            :      * news; and considering that the prevailing LC_MONETARY and LC_NUMERIC
<span class="lineNum">     609 </span>            :      * are almost certainly &quot;C&quot;, there's really no reason that restoring those
<span class="lineNum">     610 </span>            :      * should fail.
<span class="lineNum">     611 </span>            :      */
<span class="lineNum">     612 </span>            : #ifdef WIN32
<span class="lineNum">     613 </span>            :     if (!setlocale(LC_CTYPE, save_lc_ctype))
<span class="lineNum">     614 </span>            :         elog(FATAL, &quot;failed to restore LC_CTYPE to \&quot;%s\&quot;&quot;, save_lc_ctype);
<span class="lineNum">     615 </span>            : #endif
<span class="lineNum">     616 </span><span class="lineCov">         18 :     if (!setlocale(LC_MONETARY, save_lc_monetary))</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :         elog(FATAL, &quot;failed to restore LC_MONETARY to \&quot;%s\&quot;&quot;, save_lc_monetary);</span>
<span class="lineNum">     618 </span><span class="lineCov">         18 :     if (!setlocale(LC_NUMERIC, save_lc_numeric))</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :         elog(FATAL, &quot;failed to restore LC_NUMERIC to \&quot;%s\&quot;&quot;, save_lc_numeric);</span>
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            :     /*
<span class="lineNum">     622 </span>            :      * At this point we've done our best to clean up, and can call functions
<span class="lineNum">     623 </span>            :      * that might possibly throw errors with a clean conscience.  But let's
<span class="lineNum">     624 </span>            :      * make sure we don't leak any already-strdup'd fields in worklconv.
<span class="lineNum">     625 </span>            :      */
<span class="lineNum">     626 </span><span class="lineCov">         18 :     PG_TRY();</span>
<span class="lineNum">     627 </span>            :     {
<span class="lineNum">     628 </span>            :         int         encoding;
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            :         /* Release the pstrdup'd locale names */
<span class="lineNum">     631 </span><span class="lineCov">         18 :         pfree(save_lc_monetary);</span>
<span class="lineNum">     632 </span><span class="lineCov">         18 :         pfree(save_lc_numeric);</span>
<span class="lineNum">     633 </span>            : #ifdef WIN32
<span class="lineNum">     634 </span>            :         pfree(save_lc_ctype);
<span class="lineNum">     635 </span>            : #endif
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :         /* If any of the preceding strdup calls failed, complain now. */
<span class="lineNum">     638 </span><span class="lineCov">         18 :         if (!struct_lconv_is_valid(&amp;worklconv))</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">     640 </span>            :                     (errcode(ERRCODE_OUT_OF_MEMORY),
<span class="lineNum">     641 </span>            :                      errmsg(&quot;out of memory&quot;)));
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :         /*
<span class="lineNum">     644 </span>            :          * Now we must perform encoding conversion from whatever's associated
<span class="lineNum">     645 </span>            :          * with the locales into the database encoding.  If we can't identify
<span class="lineNum">     646 </span>            :          * the encoding implied by LC_NUMERIC or LC_MONETARY (ie we get -1),
<span class="lineNum">     647 </span>            :          * use PG_SQL_ASCII, which will result in just validating that the
<span class="lineNum">     648 </span>            :          * strings are OK in the database encoding.
<span class="lineNum">     649 </span>            :          */
<span class="lineNum">     650 </span><span class="lineCov">         18 :         encoding = pg_get_encoding_from_locale(locale_numeric, true);</span>
<span class="lineNum">     651 </span><span class="lineCov">         18 :         if (encoding &lt; 0)</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :             encoding = PG_SQL_ASCII;</span>
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span><span class="lineCov">         18 :         db_encoding_convert(encoding, &amp;worklconv.decimal_point);</span>
<span class="lineNum">     655 </span><span class="lineCov">         18 :         db_encoding_convert(encoding, &amp;worklconv.thousands_sep);</span>
<span class="lineNum">     656 </span>            :         /* grouping is not text and does not require conversion */
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span><span class="lineCov">         18 :         encoding = pg_get_encoding_from_locale(locale_monetary, true);</span>
<span class="lineNum">     659 </span><span class="lineCov">         18 :         if (encoding &lt; 0)</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :             encoding = PG_SQL_ASCII;</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineCov">         18 :         db_encoding_convert(encoding, &amp;worklconv.int_curr_symbol);</span>
<span class="lineNum">     663 </span><span class="lineCov">         18 :         db_encoding_convert(encoding, &amp;worklconv.currency_symbol);</span>
<span class="lineNum">     664 </span><span class="lineCov">         18 :         db_encoding_convert(encoding, &amp;worklconv.mon_decimal_point);</span>
<span class="lineNum">     665 </span><span class="lineCov">         18 :         db_encoding_convert(encoding, &amp;worklconv.mon_thousands_sep);</span>
<span class="lineNum">     666 </span>            :         /* mon_grouping is not text and does not require conversion */
<span class="lineNum">     667 </span><span class="lineCov">         18 :         db_encoding_convert(encoding, &amp;worklconv.positive_sign);</span>
<span class="lineNum">     668 </span><span class="lineCov">         18 :         db_encoding_convert(encoding, &amp;worklconv.negative_sign);</span>
<span class="lineNum">     669 </span>            :     }
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     PG_CATCH();</span>
<span class="lineNum">     671 </span>            :     {
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :         free_struct_lconv(&amp;worklconv);</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :         PG_RE_THROW();</span>
<span class="lineNum">     674 </span>            :     }
<span class="lineNum">     675 </span><span class="lineCov">         18 :     PG_END_TRY();</span>
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            :     /*
<span class="lineNum">     678 </span>            :      * Everything is good, so save the results.
<span class="lineNum">     679 </span>            :      */
<span class="lineNum">     680 </span><span class="lineCov">         18 :     CurrentLocaleConv = worklconv;</span>
<span class="lineNum">     681 </span><span class="lineCov">         18 :     CurrentLocaleConvAllocated = true;</span>
<span class="lineNum">     682 </span><span class="lineCov">         18 :     CurrentLocaleConvValid = true;</span>
<span class="lineNum">     683 </span><span class="lineCov">         18 :     return &amp;CurrentLocaleConv;</span>
<span class="lineNum">     684 </span>            : }
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            : #ifdef WIN32
<span class="lineNum">     687 </span>            : /*
<span class="lineNum">     688 </span>            :  * On Windows, strftime() returns its output in encoding CP_ACP (the default
<span class="lineNum">     689 </span>            :  * operating system codepage for the computer), which is likely different
<span class="lineNum">     690 </span>            :  * from SERVER_ENCODING.  This is especially important in Japanese versions
<span class="lineNum">     691 </span>            :  * of Windows which will use SJIS encoding, which we don't support as a
<span class="lineNum">     692 </span>            :  * server encoding.
<span class="lineNum">     693 </span>            :  *
<span class="lineNum">     694 </span>            :  * So, instead of using strftime(), use wcsftime() to return the value in
<span class="lineNum">     695 </span>            :  * wide characters (internally UTF16) and then convert to UTF8, which we
<span class="lineNum">     696 </span>            :  * know how to handle directly.
<span class="lineNum">     697 </span>            :  *
<span class="lineNum">     698 </span>            :  * Note that this only affects the calls to strftime() in this file, which are
<span class="lineNum">     699 </span>            :  * used to get the locale-aware strings. Other parts of the backend use
<span class="lineNum">     700 </span>            :  * pg_strftime(), which isn't locale-aware and does not need to be replaced.
<span class="lineNum">     701 </span>            :  */
<span class="lineNum">     702 </span>            : static size_t
<span class="lineNum">     703 </span>            : strftime_win32(char *dst, size_t dstlen,
<span class="lineNum">     704 </span>            :                const char *format, const struct tm *tm)
<span class="lineNum">     705 </span>            : {
<span class="lineNum">     706 </span>            :     size_t      len;
<span class="lineNum">     707 </span>            :     wchar_t     wformat[8];     /* formats used below need 3 chars */
<span class="lineNum">     708 </span>            :     wchar_t     wbuf[MAX_L10N_DATA];
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span>            :     /*
<span class="lineNum">     711 </span>            :      * Get a wchar_t version of the format string.  We only actually use
<span class="lineNum">     712 </span>            :      * plain-ASCII formats in this file, so we can say that they're UTF8.
<span class="lineNum">     713 </span>            :      */
<span class="lineNum">     714 </span>            :     len = MultiByteToWideChar(CP_UTF8, 0, format, -1,
<span class="lineNum">     715 </span>            :                               wformat, lengthof(wformat));
<span class="lineNum">     716 </span>            :     if (len == 0)
<span class="lineNum">     717 </span>            :         elog(ERROR, &quot;could not convert format string from UTF-8: error code %lu&quot;,
<span class="lineNum">     718 </span>            :              GetLastError());
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span>            :     len = wcsftime(wbuf, MAX_L10N_DATA, wformat, tm);
<span class="lineNum">     721 </span>            :     if (len == 0)
<span class="lineNum">     722 </span>            :     {
<span class="lineNum">     723 </span>            :         /*
<span class="lineNum">     724 </span>            :          * wcsftime failed, possibly because the result would not fit in
<span class="lineNum">     725 </span>            :          * MAX_L10N_DATA.  Return 0 with the contents of dst unspecified.
<span class="lineNum">     726 </span>            :          */
<span class="lineNum">     727 </span>            :         return 0;
<span class="lineNum">     728 </span>            :     }
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            :     len = WideCharToMultiByte(CP_UTF8, 0, wbuf, len, dst, dstlen - 1,
<span class="lineNum">     731 </span>            :                               NULL, NULL);
<span class="lineNum">     732 </span>            :     if (len == 0)
<span class="lineNum">     733 </span>            :         elog(ERROR, &quot;could not convert string to UTF-8: error code %lu&quot;,
<span class="lineNum">     734 </span>            :              GetLastError());
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            :     dst[len] = '\0';
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            :     return len;
<span class="lineNum">     739 </span>            : }
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            : /* redefine strftime() */
<span class="lineNum">     742 </span>            : #define strftime(a,b,c,d) strftime_win32(a,b,c,d)
<span class="lineNum">     743 </span>            : #endif                          /* WIN32 */
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span>            : /*
<span class="lineNum">     746 </span>            :  * Subroutine for cache_locale_time().
<span class="lineNum">     747 </span>            :  * Convert the given string from encoding &quot;encoding&quot; to the database
<span class="lineNum">     748 </span>            :  * encoding, and store the result at *dst, replacing any previous value.
<a name="749"><span class="lineNum">     749 </span>            :  */</a>
<span class="lineNum">     750 </span>            : static void
<span class="lineNum">     751 </span><span class="lineCov">        380 : cache_single_string(char **dst, const char *src, int encoding)</span>
<span class="lineNum">     752 </span>            : {
<span class="lineNum">     753 </span>            :     char       *ptr;
<span class="lineNum">     754 </span>            :     char       *olddst;
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span>            :     /* Convert the string to the database encoding, or validate it's OK */
<span class="lineNum">     757 </span><span class="lineCov">        380 :     ptr = pg_any_to_server(src, strlen(src), encoding);</span>
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span>            :     /* Store the string in long-lived storage, replacing any previous value */
<span class="lineNum">     760 </span><span class="lineCov">        380 :     olddst = *dst;</span>
<span class="lineNum">     761 </span><span class="lineCov">        380 :     *dst = MemoryContextStrdup(TopMemoryContext, ptr);</span>
<span class="lineNum">     762 </span><span class="lineCov">        380 :     if (olddst)</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :         pfree(olddst);</span>
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            :     /* Might as well clean up any palloc'd conversion result, too */
<span class="lineNum">     766 </span><span class="lineCov">        380 :     if (ptr != src)</span>
<span class="lineNum">     767 </span><span class="lineCov">         76 :         pfree(ptr);</span>
<span class="lineNum">     768 </span><span class="lineCov">        380 : }</span>
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            : /*
<span class="lineNum">     771 </span>            :  * Update the lc_time localization cache variables if needed.
<a name="772"><span class="lineNum">     772 </span>            :  */</a>
<span class="lineNum">     773 </span>            : void
<span class="lineNum">     774 </span><span class="lineCov">       2888 : cache_locale_time(void)</span>
<span class="lineNum">     775 </span>            : {
<span class="lineNum">     776 </span>            :     char        buf[(2 * 7 + 2 * 12) * MAX_L10N_DATA];
<span class="lineNum">     777 </span>            :     char       *bufptr;
<span class="lineNum">     778 </span>            :     time_t      timenow;
<span class="lineNum">     779 </span>            :     struct tm  *timeinfo;
<span class="lineNum">     780 </span><span class="lineCov">       2888 :     bool        strftimefail = false;</span>
<span class="lineNum">     781 </span>            :     int         encoding;
<span class="lineNum">     782 </span>            :     int         i;
<span class="lineNum">     783 </span>            :     char       *save_lc_time;
<span class="lineNum">     784 </span>            : #ifdef WIN32
<span class="lineNum">     785 </span>            :     char       *save_lc_ctype;
<span class="lineNum">     786 </span>            : #endif
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span>            :     /* did we do this already? */
<span class="lineNum">     789 </span><span class="lineCov">       2888 :     if (CurrentLCTimeValid)</span>
<span class="lineNum">     790 </span><span class="lineCov">       5766 :         return;</span>
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span><span class="lineCov">         10 :     elog(DEBUG3, &quot;cache_locale_time() executed; locale: \&quot;%s\&quot;&quot;, locale_time);</span>
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            :     /*
<span class="lineNum">     795 </span>            :      * As in PGLC_localeconv(), it's critical that we not throw error while
<span class="lineNum">     796 </span>            :      * libc's locale settings have nondefault values.  Hence, we just call
<span class="lineNum">     797 </span>            :      * strftime() within the critical section, and then convert and save its
<span class="lineNum">     798 </span>            :      * results afterwards.
<span class="lineNum">     799 </span>            :      */
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            :     /* Save prevailing value of time locale */
<span class="lineNum">     802 </span><span class="lineCov">         10 :     save_lc_time = setlocale(LC_TIME, NULL);</span>
<span class="lineNum">     803 </span><span class="lineCov">         10 :     if (!save_lc_time)</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;setlocale(NULL) failed&quot;);</span>
<span class="lineNum">     805 </span><span class="lineCov">         10 :     save_lc_time = pstrdup(save_lc_time);</span>
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            : #ifdef WIN32
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :     /*
<span class="lineNum">     810 </span>            :      * On Windows, it appears that wcsftime() internally uses LC_CTYPE, so we
<span class="lineNum">     811 </span>            :      * must set it here.  This code looks the same as what PGLC_localeconv()
<span class="lineNum">     812 </span>            :      * does, but the underlying reason is different: this does NOT determine
<span class="lineNum">     813 </span>            :      * the encoding we'll get back from strftime_win32().
<span class="lineNum">     814 </span>            :      */
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            :     /* Save prevailing value of ctype locale */
<span class="lineNum">     817 </span>            :     save_lc_ctype = setlocale(LC_CTYPE, NULL);
<span class="lineNum">     818 </span>            :     if (!save_lc_ctype)
<span class="lineNum">     819 </span>            :         elog(ERROR, &quot;setlocale(NULL) failed&quot;);
<span class="lineNum">     820 </span>            :     save_lc_ctype = pstrdup(save_lc_ctype);
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            :     /* use lc_time to set the ctype */
<span class="lineNum">     823 </span>            :     setlocale(LC_CTYPE, locale_time);
<span class="lineNum">     824 </span>            : #endif
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span><span class="lineCov">         10 :     setlocale(LC_TIME, locale_time);</span>
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            :     /* We use times close to current time as data for strftime(). */
<span class="lineNum">     829 </span><span class="lineCov">         10 :     timenow = time(NULL);</span>
<span class="lineNum">     830 </span><span class="lineCov">         10 :     timeinfo = localtime(&amp;timenow);</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :     /* Store the strftime results in MAX_L10N_DATA-sized portions of buf[] */
<span class="lineNum">     833 </span><span class="lineCov">         10 :     bufptr = buf;</span>
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            :     /*
<span class="lineNum">     836 </span>            :      * MAX_L10N_DATA is sufficient buffer space for every known locale, and
<span class="lineNum">     837 </span>            :      * POSIX defines no strftime() errors.  (Buffer space exhaustion is not an
<span class="lineNum">     838 </span>            :      * error.)  An implementation might report errors (e.g. ENOMEM) by
<span class="lineNum">     839 </span>            :      * returning 0 (or, less plausibly, a negative value) and setting errno.
<span class="lineNum">     840 </span>            :      * Report errno just in case the implementation did that, but clear it in
<span class="lineNum">     841 </span>            :      * advance of the calls so we don't emit a stale, unrelated errno.
<span class="lineNum">     842 </span>            :      */
<span class="lineNum">     843 </span><span class="lineCov">         10 :     errno = 0;</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            :     /* localized days */
<span class="lineNum">     846 </span><span class="lineCov">         80 :     for (i = 0; i &lt; 7; i++)</span>
<span class="lineNum">     847 </span>            :     {
<span class="lineNum">     848 </span><span class="lineCov">         70 :         timeinfo-&gt;tm_wday = i;</span>
<span class="lineNum">     849 </span><span class="lineCov">         70 :         if (strftime(bufptr, MAX_L10N_DATA, &quot;%a&quot;, timeinfo) &lt;= 0)</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :             strftimefail = true;</span>
<span class="lineNum">     851 </span><span class="lineCov">         70 :         bufptr += MAX_L10N_DATA;</span>
<span class="lineNum">     852 </span><span class="lineCov">         70 :         if (strftime(bufptr, MAX_L10N_DATA, &quot;%A&quot;, timeinfo) &lt;= 0)</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :             strftimefail = true;</span>
<span class="lineNum">     854 </span><span class="lineCov">         70 :         bufptr += MAX_L10N_DATA;</span>
<span class="lineNum">     855 </span>            :     }
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            :     /* localized months */
<span class="lineNum">     858 </span><span class="lineCov">        130 :     for (i = 0; i &lt; 12; i++)</span>
<span class="lineNum">     859 </span>            :     {
<span class="lineNum">     860 </span><span class="lineCov">        120 :         timeinfo-&gt;tm_mon = i;</span>
<span class="lineNum">     861 </span><span class="lineCov">        120 :         timeinfo-&gt;tm_mday = 1;   /* make sure we don't have invalid date */</span>
<span class="lineNum">     862 </span><span class="lineCov">        120 :         if (strftime(bufptr, MAX_L10N_DATA, &quot;%b&quot;, timeinfo) &lt;= 0)</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :             strftimefail = true;</span>
<span class="lineNum">     864 </span><span class="lineCov">        120 :         bufptr += MAX_L10N_DATA;</span>
<span class="lineNum">     865 </span><span class="lineCov">        120 :         if (strftime(bufptr, MAX_L10N_DATA, &quot;%B&quot;, timeinfo) &lt;= 0)</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :             strftimefail = true;</span>
<span class="lineNum">     867 </span><span class="lineCov">        120 :         bufptr += MAX_L10N_DATA;</span>
<span class="lineNum">     868 </span>            :     }
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span>            :     /*
<span class="lineNum">     871 </span>            :      * Restore the prevailing locale settings; as in PGLC_localeconv(),
<span class="lineNum">     872 </span>            :      * failure to do so is fatal.
<span class="lineNum">     873 </span>            :      */
<span class="lineNum">     874 </span>            : #ifdef WIN32
<span class="lineNum">     875 </span>            :     if (!setlocale(LC_CTYPE, save_lc_ctype))
<span class="lineNum">     876 </span>            :         elog(FATAL, &quot;failed to restore LC_CTYPE to \&quot;%s\&quot;&quot;, save_lc_ctype);
<span class="lineNum">     877 </span>            : #endif
<span class="lineNum">     878 </span><span class="lineCov">         10 :     if (!setlocale(LC_TIME, save_lc_time))</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :         elog(FATAL, &quot;failed to restore LC_TIME to \&quot;%s\&quot;&quot;, save_lc_time);</span>
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span>            :     /*
<span class="lineNum">     882 </span>            :      * At this point we've done our best to clean up, and can throw errors, or
<span class="lineNum">     883 </span>            :      * call functions that might throw errors, with a clean conscience.
<span class="lineNum">     884 </span>            :      */
<span class="lineNum">     885 </span><span class="lineCov">         10 :     if (strftimefail)</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;strftime() failed: %m&quot;);</span>
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span>            :     /* Release the pstrdup'd locale names */
<span class="lineNum">     889 </span><span class="lineCov">         10 :     pfree(save_lc_time);</span>
<span class="lineNum">     890 </span>            : #ifdef WIN32
<span class="lineNum">     891 </span>            :     pfree(save_lc_ctype);
<span class="lineNum">     892 </span>            : #endif
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            : #ifndef WIN32
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span>            :     /*
<span class="lineNum">     897 </span>            :      * As in PGLC_localeconv(), we must convert strftime()'s output from the
<span class="lineNum">     898 </span>            :      * encoding implied by LC_TIME to the database encoding.  If we can't
<span class="lineNum">     899 </span>            :      * identify the LC_TIME encoding, just perform encoding validation.
<span class="lineNum">     900 </span>            :      */
<span class="lineNum">     901 </span><span class="lineCov">         10 :     encoding = pg_get_encoding_from_locale(locale_time, true);</span>
<span class="lineNum">     902 </span><span class="lineCov">         10 :     if (encoding &lt; 0)</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :         encoding = PG_SQL_ASCII;</span>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span>            : #else
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span>            :     /*
<span class="lineNum">     908 </span>            :      * On Windows, strftime_win32() always returns UTF8 data, so convert from
<span class="lineNum">     909 </span>            :      * that if necessary.
<span class="lineNum">     910 </span>            :      */
<span class="lineNum">     911 </span>            :     encoding = PG_UTF8;
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            : #endif                          /* WIN32 */
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span><span class="lineCov">         10 :     bufptr = buf;</span>
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            :     /* localized days */
<span class="lineNum">     918 </span><span class="lineCov">         80 :     for (i = 0; i &lt; 7; i++)</span>
<span class="lineNum">     919 </span>            :     {
<span class="lineNum">     920 </span><span class="lineCov">         70 :         cache_single_string(&amp;localized_abbrev_days[i], bufptr, encoding);</span>
<span class="lineNum">     921 </span><span class="lineCov">         70 :         bufptr += MAX_L10N_DATA;</span>
<span class="lineNum">     922 </span><span class="lineCov">         70 :         cache_single_string(&amp;localized_full_days[i], bufptr, encoding);</span>
<span class="lineNum">     923 </span><span class="lineCov">         70 :         bufptr += MAX_L10N_DATA;</span>
<span class="lineNum">     924 </span>            :     }
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            :     /* localized months */
<span class="lineNum">     927 </span><span class="lineCov">        130 :     for (i = 0; i &lt; 12; i++)</span>
<span class="lineNum">     928 </span>            :     {
<span class="lineNum">     929 </span><span class="lineCov">        120 :         cache_single_string(&amp;localized_abbrev_months[i], bufptr, encoding);</span>
<span class="lineNum">     930 </span><span class="lineCov">        120 :         bufptr += MAX_L10N_DATA;</span>
<span class="lineNum">     931 </span><span class="lineCov">        120 :         cache_single_string(&amp;localized_full_months[i], bufptr, encoding);</span>
<span class="lineNum">     932 </span><span class="lineCov">        120 :         bufptr += MAX_L10N_DATA;</span>
<span class="lineNum">     933 </span>            :     }
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span><span class="lineCov">         10 :     CurrentLCTimeValid = true;</span>
<span class="lineNum">     936 </span>            : }
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span>            : #if defined(WIN32) &amp;&amp; defined(LC_MESSAGES)
<span class="lineNum">     940 </span>            : /*
<span class="lineNum">     941 </span>            :  * Convert a Windows setlocale() argument to a Unix-style one.
<span class="lineNum">     942 </span>            :  *
<span class="lineNum">     943 </span>            :  * Regardless of platform, we install message catalogs under a Unix-style
<span class="lineNum">     944 </span>            :  * LL[_CC][.ENCODING][@VARIANT] naming convention.  Only LC_MESSAGES settings
<span class="lineNum">     945 </span>            :  * following that style will elicit localized interface strings.
<span class="lineNum">     946 </span>            :  *
<span class="lineNum">     947 </span>            :  * Before Visual Studio 2012 (msvcr110.dll), Windows setlocale() accepted &quot;C&quot;
<span class="lineNum">     948 </span>            :  * (but not &quot;c&quot;) and strings of the form &lt;Language&gt;[_&lt;Country&gt;][.&lt;CodePage&gt;],
<span class="lineNum">     949 </span>            :  * case-insensitive.  setlocale() returns the fully-qualified form; for
<span class="lineNum">     950 </span>            :  * example, setlocale(&quot;thaI&quot;) returns &quot;Thai_Thailand.874&quot;.  Internally,
<span class="lineNum">     951 </span>            :  * setlocale() and _create_locale() select a &quot;locale identifier&quot;[1] and store
<span class="lineNum">     952 </span>            :  * it in an undocumented _locale_t field.  From that LCID, we can retrieve the
<span class="lineNum">     953 </span>            :  * ISO 639 language and the ISO 3166 country.  Character encoding does not
<span class="lineNum">     954 </span>            :  * matter, because the server and client encodings govern that.
<span class="lineNum">     955 </span>            :  *
<span class="lineNum">     956 </span>            :  * Windows Vista introduced the &quot;locale name&quot; concept[2], closely following
<span class="lineNum">     957 </span>            :  * RFC 4646.  Locale identifiers are now deprecated.  Starting with Visual
<span class="lineNum">     958 </span>            :  * Studio 2012, setlocale() accepts locale names in addition to the strings it
<span class="lineNum">     959 </span>            :  * accepted historically.  It does not standardize them; setlocale(&quot;Th-tH&quot;)
<span class="lineNum">     960 </span>            :  * returns &quot;Th-tH&quot;.  setlocale(category, &quot;&quot;) still returns a traditional
<span class="lineNum">     961 </span>            :  * string.  Furthermore, msvcr110.dll changed the undocumented _locale_t
<span class="lineNum">     962 </span>            :  * content to carry locale names instead of locale identifiers.
<span class="lineNum">     963 </span>            :  *
<span class="lineNum">     964 </span>            :  * MinGW headers declare _create_locale(), but msvcrt.dll lacks that symbol.
<span class="lineNum">     965 </span>            :  * IsoLocaleName() always fails in a MinGW-built postgres.exe, so only
<span class="lineNum">     966 </span>            :  * Unix-style values of the lc_messages GUC can elicit localized messages.  In
<span class="lineNum">     967 </span>            :  * particular, every lc_messages setting that initdb can select automatically
<span class="lineNum">     968 </span>            :  * will yield only C-locale messages.  XXX This could be fixed by running the
<span class="lineNum">     969 </span>            :  * fully-qualified locale name through a lookup table.
<span class="lineNum">     970 </span>            :  *
<span class="lineNum">     971 </span>            :  * This function returns a pointer to a static buffer bearing the converted
<span class="lineNum">     972 </span>            :  * name or NULL if conversion fails.
<span class="lineNum">     973 </span>            :  *
<span class="lineNum">     974 </span>            :  * [1] http://msdn.microsoft.com/en-us/library/windows/desktop/dd373763.aspx
<span class="lineNum">     975 </span>            :  * [2] http://msdn.microsoft.com/en-us/library/windows/desktop/dd373814.aspx
<span class="lineNum">     976 </span>            :  */
<span class="lineNum">     977 </span>            : static char *
<span class="lineNum">     978 </span>            : IsoLocaleName(const char *winlocname)
<span class="lineNum">     979 </span>            : {
<span class="lineNum">     980 </span>            : #ifdef _MSC_VER
<span class="lineNum">     981 </span>            :     static char iso_lc_messages[32];
<span class="lineNum">     982 </span>            :     _locale_t   loct = NULL;
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span>            :     if (pg_strcasecmp(&quot;c&quot;, winlocname) == 0 ||
<span class="lineNum">     985 </span>            :         pg_strcasecmp(&quot;posix&quot;, winlocname) == 0)
<span class="lineNum">     986 </span>            :     {
<span class="lineNum">     987 </span>            :         strcpy(iso_lc_messages, &quot;C&quot;);
<span class="lineNum">     988 </span>            :         return iso_lc_messages;
<span class="lineNum">     989 </span>            :     }
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            :     loct = _create_locale(LC_CTYPE, winlocname);
<span class="lineNum">     992 </span>            :     if (loct != NULL)
<span class="lineNum">     993 </span>            :     {
<span class="lineNum">     994 </span>            :         size_t      rc;
<span class="lineNum">     995 </span>            :         char       *hyphen;
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span>            :         /* Locale names use only ASCII, any conversion locale suffices. */
<span class="lineNum">     998 </span>            :         rc = wchar2char(iso_lc_messages, loct-&gt;locinfo-&gt;locale_name[LC_CTYPE],
<span class="lineNum">     999 </span>            :                         sizeof(iso_lc_messages), NULL);
<span class="lineNum">    1000 </span>            :         _free_locale(loct);
<span class="lineNum">    1001 </span>            :         if (rc == -1 || rc == sizeof(iso_lc_messages))
<span class="lineNum">    1002 </span>            :             return NULL;
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            :         /*
<span class="lineNum">    1005 </span>            :          * Since the message catalogs sit on a case-insensitive filesystem, we
<span class="lineNum">    1006 </span>            :          * need not standardize letter case here.  So long as we do not ship
<span class="lineNum">    1007 </span>            :          * message catalogs for which it would matter, we also need not
<span class="lineNum">    1008 </span>            :          * translate the script/variant portion, e.g. uz-Cyrl-UZ to
<span class="lineNum">    1009 </span>            :          * uz_UZ@cyrillic.  Simply replace the hyphen with an underscore.
<span class="lineNum">    1010 </span>            :          *
<span class="lineNum">    1011 </span>            :          * Note that the locale name can be less-specific than the value we
<span class="lineNum">    1012 </span>            :          * would derive under earlier Visual Studio releases.  For example,
<span class="lineNum">    1013 </span>            :          * French_France.1252 yields just &quot;fr&quot;.  This does not affect any of
<span class="lineNum">    1014 </span>            :          * the country-specific message catalogs available as of this writing
<span class="lineNum">    1015 </span>            :          * (pt_BR, zh_CN, zh_TW).
<span class="lineNum">    1016 </span>            :          */
<span class="lineNum">    1017 </span>            :         hyphen = strchr(iso_lc_messages, '-');
<span class="lineNum">    1018 </span>            :         if (hyphen)
<span class="lineNum">    1019 </span>            :             *hyphen = '_';
<span class="lineNum">    1020 </span>            :         return iso_lc_messages;
<span class="lineNum">    1021 </span>            :     }
<span class="lineNum">    1022 </span>            : #endif                          /* _MSC_VER */
<span class="lineNum">    1023 </span>            :     return NULL;                /* Not supported on this version of msvc/mingw */
<span class="lineNum">    1024 </span>            : }
<span class="lineNum">    1025 </span>            : #endif                          /* WIN32 &amp;&amp; LC_MESSAGES */
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            : /*
<span class="lineNum">    1029 </span>            :  * Detect aging strxfrm() implementations that, in a subset of locales, write
<span class="lineNum">    1030 </span>            :  * past the specified buffer length.  Affected users must update OS packages
<span class="lineNum">    1031 </span>            :  * before using PostgreSQL 9.5 or later.
<span class="lineNum">    1032 </span>            :  *
<span class="lineNum">    1033 </span>            :  * Assume that the bug can come and go from one postmaster startup to another
<span class="lineNum">    1034 </span>            :  * due to physical replication among diverse machines.  Assume that the bug's
<span class="lineNum">    1035 </span>            :  * presence will not change during the life of a particular postmaster.  Given
<span class="lineNum">    1036 </span>            :  * those assumptions, call this no less than once per postmaster startup per
<span class="lineNum">    1037 </span>            :  * LC_COLLATE setting used.  No known-affected system offers strxfrm_l(), so
<span class="lineNum">    1038 </span>            :  * there is no need to consider pg_collation locales.
<a name="1039"><span class="lineNum">    1039 </span>            :  */</a>
<span class="lineNum">    1040 </span>            : void
<span class="lineNum">    1041 </span><span class="lineCov">       2436 : check_strxfrm_bug(void)</span>
<span class="lineNum">    1042 </span>            : {
<span class="lineNum">    1043 </span>            :     char        buf[32];
<span class="lineNum">    1044 </span><span class="lineCov">       2436 :     const int   canary = 0x7F;</span>
<span class="lineNum">    1045 </span><span class="lineCov">       2436 :     bool        ok = true;</span>
<span class="lineNum">    1046 </span>            : 
<span class="lineNum">    1047 </span>            :     /*
<span class="lineNum">    1048 </span>            :      * Given a two-byte ASCII string and length limit 7, 8 or 9, Solaris 10
<span class="lineNum">    1049 </span>            :      * 05/08 returns 18 and modifies 10 bytes.  It respects limits above or
<span class="lineNum">    1050 </span>            :      * below that range.
<span class="lineNum">    1051 </span>            :      *
<span class="lineNum">    1052 </span>            :      * The bug is present in Solaris 8 as well; it is absent in Solaris 10
<span class="lineNum">    1053 </span>            :      * 01/13 and Solaris 11.2.  Affected locales include is_IS.ISO8859-1,
<span class="lineNum">    1054 </span>            :      * en_US.UTF-8, en_US.ISO8859-1, and ru_RU.KOI8-R.  Unaffected locales
<span class="lineNum">    1055 </span>            :      * include de_DE.UTF-8, de_DE.ISO8859-1, zh_TW.UTF-8, and C.
<span class="lineNum">    1056 </span>            :      */
<span class="lineNum">    1057 </span><span class="lineCov">       2436 :     buf[7] = canary;</span>
<span class="lineNum">    1058 </span><span class="lineCov">       2436 :     (void) strxfrm(buf, &quot;ab&quot;, 7);</span>
<span class="lineNum">    1059 </span><span class="lineCov">       2436 :     if (buf[7] != canary)</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :         ok = false;</span>
<span class="lineNum">    1061 </span>            : 
<span class="lineNum">    1062 </span>            :     /*
<span class="lineNum">    1063 </span>            :      * illumos bug #1594 was present in the source tree from 2010-10-11 to
<span class="lineNum">    1064 </span>            :      * 2012-02-01.  Given an ASCII string of any length and length limit 1,
<span class="lineNum">    1065 </span>            :      * affected systems ignore the length limit and modify a number of bytes
<span class="lineNum">    1066 </span>            :      * one less than the return value.  The problem inputs for this bug do not
<span class="lineNum">    1067 </span>            :      * overlap those for the Solaris bug, hence a distinct test.
<span class="lineNum">    1068 </span>            :      *
<span class="lineNum">    1069 </span>            :      * Affected systems include smartos-20110926T021612Z.  Affected locales
<span class="lineNum">    1070 </span>            :      * include en_US.ISO8859-1 and en_US.UTF-8.  Unaffected locales include C.
<span class="lineNum">    1071 </span>            :      */
<span class="lineNum">    1072 </span><span class="lineCov">       2436 :     buf[1] = canary;</span>
<span class="lineNum">    1073 </span><span class="lineCov">       2436 :     (void) strxfrm(buf, &quot;a&quot;, 1);</span>
<span class="lineNum">    1074 </span><span class="lineCov">       2436 :     if (buf[1] != canary)</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :         ok = false;</span>
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span><span class="lineCov">       2436 :     if (!ok)</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1079 </span>            :                 (errcode(ERRCODE_SYSTEM_ERROR),
<span class="lineNum">    1080 </span>            :                  errmsg_internal(&quot;strxfrm(), in locale \&quot;%s\&quot;, writes past the specified array length&quot;,
<span class="lineNum">    1081 </span>            :                                  setlocale(LC_COLLATE, NULL)),
<span class="lineNum">    1082 </span>            :                  errhint(&quot;Apply system library package updates.&quot;)));
<span class="lineNum">    1083 </span><span class="lineCov">       2436 : }</span>
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span>            : /*
<span class="lineNum">    1087 </span>            :  * Cache mechanism for collation information.
<span class="lineNum">    1088 </span>            :  *
<span class="lineNum">    1089 </span>            :  * We cache two flags: whether the collation's LC_COLLATE or LC_CTYPE is C
<span class="lineNum">    1090 </span>            :  * (or POSIX), so we can optimize a few code paths in various places.
<span class="lineNum">    1091 </span>            :  * For the built-in C and POSIX collations, we can know that without even
<span class="lineNum">    1092 </span>            :  * doing a cache lookup, but we want to support aliases for C/POSIX too.
<span class="lineNum">    1093 </span>            :  * For the &quot;default&quot; collation, there are separate static cache variables,
<span class="lineNum">    1094 </span>            :  * since consulting the pg_collation catalog doesn't tell us what we need.
<span class="lineNum">    1095 </span>            :  *
<span class="lineNum">    1096 </span>            :  * Also, if a pg_locale_t has been requested for a collation, we cache that
<span class="lineNum">    1097 </span>            :  * for the life of a backend.
<span class="lineNum">    1098 </span>            :  *
<span class="lineNum">    1099 </span>            :  * Note that some code relies on the flags not reporting false negatives
<span class="lineNum">    1100 </span>            :  * (that is, saying it's not C when it is).  For example, char2wchar()
<span class="lineNum">    1101 </span>            :  * could fail if the locale is C, so str_tolower() shouldn't call it
<span class="lineNum">    1102 </span>            :  * in that case.
<span class="lineNum">    1103 </span>            :  *
<span class="lineNum">    1104 </span>            :  * Note that we currently lack any way to flush the cache.  Since we don't
<span class="lineNum">    1105 </span>            :  * support ALTER COLLATION, this is OK.  The worst case is that someone
<span class="lineNum">    1106 </span>            :  * drops a collation, and a useless cache entry hangs around in existing
<span class="lineNum">    1107 </span>            :  * backends.
<span class="lineNum">    1108 </span>            :  */
<a name="1109"><span class="lineNum">    1109 </span>            : </a>
<span class="lineNum">    1110 </span>            : static collation_cache_entry *
<span class="lineNum">    1111 </span><span class="lineCov">       1662 : lookup_collation_cache(Oid collation, bool set_flags)</span>
<span class="lineNum">    1112 </span>            : {
<span class="lineNum">    1113 </span>            :     collation_cache_entry *cache_entry;
<span class="lineNum">    1114 </span>            :     bool        found;
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span><span class="lineCov">       1662 :     Assert(OidIsValid(collation));</span>
<span class="lineNum">    1117 </span><span class="lineCov">       1662 :     Assert(collation != DEFAULT_COLLATION_OID);</span>
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span><span class="lineCov">       1662 :     if (collation_cache == NULL)</span>
<span class="lineNum">    1120 </span>            :     {
<span class="lineNum">    1121 </span>            :         /* First time through, initialize the hash table */
<span class="lineNum">    1122 </span>            :         HASHCTL     ctl;
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span><span class="lineCov">          4 :         memset(&amp;ctl, 0, sizeof(ctl));</span>
<span class="lineNum">    1125 </span><span class="lineCov">          4 :         ctl.keysize = sizeof(Oid);</span>
<span class="lineNum">    1126 </span><span class="lineCov">          4 :         ctl.entrysize = sizeof(collation_cache_entry);</span>
<span class="lineNum">    1127 </span><span class="lineCov">          4 :         collation_cache = hash_create(&quot;Collation cache&quot;, 100, &amp;ctl,</span>
<span class="lineNum">    1128 </span>            :                                       HASH_ELEM | HASH_BLOBS);
<span class="lineNum">    1129 </span>            :     }
<span class="lineNum">    1130 </span>            : 
<span class="lineNum">    1131 </span><span class="lineCov">       1662 :     cache_entry = hash_search(collation_cache, &amp;collation, HASH_ENTER, &amp;found);</span>
<span class="lineNum">    1132 </span><span class="lineCov">       1662 :     if (!found)</span>
<span class="lineNum">    1133 </span>            :     {
<span class="lineNum">    1134 </span>            :         /*
<span class="lineNum">    1135 </span>            :          * Make sure cache entry is marked invalid, in case we fail before
<span class="lineNum">    1136 </span>            :          * setting things.
<span class="lineNum">    1137 </span>            :          */
<span class="lineNum">    1138 </span><span class="lineCov">         22 :         cache_entry-&gt;flags_valid = false;</span>
<span class="lineNum">    1139 </span><span class="lineCov">         22 :         cache_entry-&gt;locale = 0;</span>
<span class="lineNum">    1140 </span>            :     }
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span><span class="lineCov">       1662 :     if (set_flags &amp;&amp; !cache_entry-&gt;flags_valid)</span>
<span class="lineNum">    1143 </span>            :     {
<span class="lineNum">    1144 </span>            :         /* Attempt to set the flags */
<span class="lineNum">    1145 </span>            :         HeapTuple   tp;
<span class="lineNum">    1146 </span>            :         Form_pg_collation collform;
<span class="lineNum">    1147 </span>            :         const char *collcollate;
<span class="lineNum">    1148 </span>            :         const char *collctype;
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span><span class="lineCov">         22 :         tp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collation));</span>
<span class="lineNum">    1151 </span><span class="lineCov">         22 :         if (!HeapTupleIsValid(tp))</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;cache lookup failed for collation %u&quot;, collation);</span>
<span class="lineNum">    1153 </span><span class="lineCov">         22 :         collform = (Form_pg_collation) GETSTRUCT(tp);</span>
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span><span class="lineCov">         22 :         collcollate = NameStr(collform-&gt;collcollate);</span>
<span class="lineNum">    1156 </span><span class="lineCov">         22 :         collctype = NameStr(collform-&gt;collctype);</span>
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span><span class="lineCov">         40 :         cache_entry-&gt;collate_is_c = ((strcmp(collcollate, &quot;C&quot;) == 0) ||</span>
<span class="lineNum">    1159 </span><span class="lineCov">         18 :                                      (strcmp(collcollate, &quot;POSIX&quot;) == 0));</span>
<span class="lineNum">    1160 </span><span class="lineCov">         40 :         cache_entry-&gt;ctype_is_c = ((strcmp(collctype, &quot;C&quot;) == 0) ||</span>
<span class="lineNum">    1161 </span><span class="lineCov">         18 :                                    (strcmp(collctype, &quot;POSIX&quot;) == 0));</span>
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span><span class="lineCov">         22 :         cache_entry-&gt;flags_valid = true;</span>
<span class="lineNum">    1164 </span>            : 
<span class="lineNum">    1165 </span><span class="lineCov">         22 :         ReleaseSysCache(tp);</span>
<span class="lineNum">    1166 </span>            :     }
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineCov">       1662 :     return cache_entry;</span>
<span class="lineNum">    1169 </span>            : }
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span>            : /*
<span class="lineNum">    1173 </span>            :  * Detect whether collation's LC_COLLATE property is C
<a name="1174"><span class="lineNum">    1174 </span>            :  */</a>
<span class="lineNum">    1175 </span>            : bool
<span class="lineNum">    1176 </span><span class="lineCov">    2688622 : lc_collate_is_c(Oid collation)</span>
<span class="lineNum">    1177 </span>            : {
<span class="lineNum">    1178 </span>            :     /*
<span class="lineNum">    1179 </span>            :      * If we're asked about &quot;collation 0&quot;, return false, so that the code will
<span class="lineNum">    1180 </span>            :      * go into the non-C path and report that the collation is bogus.
<span class="lineNum">    1181 </span>            :      */
<span class="lineNum">    1182 </span><span class="lineCov">    2688622 :     if (!OidIsValid(collation))</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1184 </span>            : 
<span class="lineNum">    1185 </span>            :     /*
<span class="lineNum">    1186 </span>            :      * If we're asked about the default collation, we have to inquire of the C
<span class="lineNum">    1187 </span>            :      * library.  Cache the result so we only have to compute it once.
<span class="lineNum">    1188 </span>            :      */
<span class="lineNum">    1189 </span><span class="lineCov">    2688622 :     if (collation == DEFAULT_COLLATION_OID)</span>
<span class="lineNum">    1190 </span>            :     {
<span class="lineNum">    1191 </span>            :         static int  result = -1;
<span class="lineNum">    1192 </span>            :         char       *localeptr;
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span><span class="lineCov">    2333146 :         if (result &gt;= 0)</span>
<span class="lineNum">    1195 </span><span class="lineCov">    2332924 :             return (bool) result;</span>
<span class="lineNum">    1196 </span><span class="lineCov">        222 :         localeptr = setlocale(LC_COLLATE, NULL);</span>
<span class="lineNum">    1197 </span><span class="lineCov">        222 :         if (!localeptr)</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;invalid LC_COLLATE setting&quot;);</span>
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span><span class="lineCov">        222 :         if (strcmp(localeptr, &quot;C&quot;) == 0)</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :             result = true;</span>
<span class="lineNum">    1202 </span><span class="lineCov">        222 :         else if (strcmp(localeptr, &quot;POSIX&quot;) == 0)</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :             result = true;</span>
<span class="lineNum">    1204 </span>            :         else
<span class="lineNum">    1205 </span><span class="lineCov">        222 :             result = false;</span>
<span class="lineNum">    1206 </span><span class="lineCov">        222 :         return (bool) result;</span>
<span class="lineNum">    1207 </span>            :     }
<span class="lineNum">    1208 </span>            : 
<span class="lineNum">    1209 </span>            :     /*
<span class="lineNum">    1210 </span>            :      * If we're asked about the built-in C/POSIX collations, we know that.
<span class="lineNum">    1211 </span>            :      */
<span class="lineNum">    1212 </span><span class="lineCov">     355476 :     if (collation == C_COLLATION_OID ||</span>
<span class="lineNum">    1213 </span>            :         collation == POSIX_COLLATION_OID)
<span class="lineNum">    1214 </span><span class="lineCov">     355120 :         return true;</span>
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span>            :     /*
<span class="lineNum">    1217 </span>            :      * Otherwise, we have to consult pg_collation, but we cache that.
<span class="lineNum">    1218 </span>            :      */
<span class="lineNum">    1219 </span><span class="lineCov">        356 :     return (lookup_collation_cache(collation, true))-&gt;collate_is_c;</span>
<span class="lineNum">    1220 </span>            : }
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span>            : /*
<span class="lineNum">    1223 </span>            :  * Detect whether collation's LC_CTYPE property is C
<a name="1224"><span class="lineNum">    1224 </span>            :  */</a>
<span class="lineNum">    1225 </span>            : bool
<span class="lineNum">    1226 </span><span class="lineCov">     333198 : lc_ctype_is_c(Oid collation)</span>
<span class="lineNum">    1227 </span>            : {
<span class="lineNum">    1228 </span>            :     /*
<span class="lineNum">    1229 </span>            :      * If we're asked about &quot;collation 0&quot;, return false, so that the code will
<span class="lineNum">    1230 </span>            :      * go into the non-C path and report that the collation is bogus.
<span class="lineNum">    1231 </span>            :      */
<span class="lineNum">    1232 </span><span class="lineCov">     333198 :     if (!OidIsValid(collation))</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span>            :     /*
<span class="lineNum">    1236 </span>            :      * If we're asked about the default collation, we have to inquire of the C
<span class="lineNum">    1237 </span>            :      * library.  Cache the result so we only have to compute it once.
<span class="lineNum">    1238 </span>            :      */
<span class="lineNum">    1239 </span><span class="lineCov">     333198 :     if (collation == DEFAULT_COLLATION_OID)</span>
<span class="lineNum">    1240 </span>            :     {
<span class="lineNum">    1241 </span>            :         static int  result = -1;
<span class="lineNum">    1242 </span>            :         char       *localeptr;
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span><span class="lineCov">     122084 :         if (result &gt;= 0)</span>
<span class="lineNum">    1245 </span><span class="lineCov">     121950 :             return (bool) result;</span>
<span class="lineNum">    1246 </span><span class="lineCov">        134 :         localeptr = setlocale(LC_CTYPE, NULL);</span>
<span class="lineNum">    1247 </span><span class="lineCov">        134 :         if (!localeptr)</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;invalid LC_CTYPE setting&quot;);</span>
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span><span class="lineCov">        134 :         if (strcmp(localeptr, &quot;C&quot;) == 0)</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :             result = true;</span>
<span class="lineNum">    1252 </span><span class="lineCov">        134 :         else if (strcmp(localeptr, &quot;POSIX&quot;) == 0)</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :             result = true;</span>
<span class="lineNum">    1254 </span>            :         else
<span class="lineNum">    1255 </span><span class="lineCov">        134 :             result = false;</span>
<span class="lineNum">    1256 </span><span class="lineCov">        134 :         return (bool) result;</span>
<span class="lineNum">    1257 </span>            :     }
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span>            :     /*
<span class="lineNum">    1260 </span>            :      * If we're asked about the built-in C/POSIX collations, we know that.
<span class="lineNum">    1261 </span>            :      */
<span class="lineNum">    1262 </span><span class="lineCov">     211114 :     if (collation == C_COLLATION_OID ||</span>
<span class="lineNum">    1263 </span>            :         collation == POSIX_COLLATION_OID)
<span class="lineNum">    1264 </span><span class="lineCov">     210632 :         return true;</span>
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span>            :     /*
<span class="lineNum">    1267 </span>            :      * Otherwise, we have to consult pg_collation, but we cache that.
<span class="lineNum">    1268 </span>            :      */
<span class="lineNum">    1269 </span><span class="lineCov">        482 :     return (lookup_collation_cache(collation, true))-&gt;ctype_is_c;</span>
<span class="lineNum">    1270 </span>            : }
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span>            : /* simple subroutine for reporting errors from newlocale() */
<a name="1274"><span class="lineNum">    1274 </span>            : #ifdef HAVE_LOCALE_T</a>
<span class="lineNum">    1275 </span>            : static void
<span class="lineNum">    1276 </span><span class="lineCov">          2 : report_newlocale_failure(const char *localename)</span>
<span class="lineNum">    1277 </span>            : {
<span class="lineNum">    1278 </span>            :     int         save_errno;
<span class="lineNum">    1279 </span>            : 
<span class="lineNum">    1280 </span>            :     /*
<span class="lineNum">    1281 </span>            :      * Windows doesn't provide any useful error indication from
<span class="lineNum">    1282 </span>            :      * _create_locale(), and BSD-derived platforms don't seem to feel they
<span class="lineNum">    1283 </span>            :      * need to set errno either (even though POSIX is pretty clear that
<span class="lineNum">    1284 </span>            :      * newlocale should do so).  So, if errno hasn't been set, assume ENOENT
<span class="lineNum">    1285 </span>            :      * is what to report.
<span class="lineNum">    1286 </span>            :      */
<span class="lineNum">    1287 </span><span class="lineCov">          2 :     if (errno == 0)</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :         errno = ENOENT;</span>
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span>            :     /*
<span class="lineNum">    1291 </span>            :      * ENOENT means &quot;no such locale&quot;, not &quot;no such file&quot;, so clarify that
<span class="lineNum">    1292 </span>            :      * errno with an errdetail message.
<span class="lineNum">    1293 </span>            :      */
<span class="lineNum">    1294 </span><span class="lineCov">          2 :     save_errno = errno;         /* auxiliary funcs might change errno */</span>
<span class="lineNum">    1295 </span><span class="lineCov">          2 :     ereport(ERROR,</span>
<span class="lineNum">    1296 </span>            :             (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
<span class="lineNum">    1297 </span>            :              errmsg(&quot;could not create locale \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">    1298 </span>            :                     localename),
<span class="lineNum">    1299 </span>            :              (save_errno == ENOENT ?
<span class="lineNum">    1300 </span>            :               errdetail(&quot;The operating system could not find any locale data for the locale name \&quot;%s\&quot;.&quot;,
<span class="lineNum">    1301 </span>            :                         localename) : 0)));
<span class="lineNum">    1302 </span>            : }
<span class="lineNum">    1303 </span>            : #endif                          /* HAVE_LOCALE_T */
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span>            : /*
<span class="lineNum">    1307 </span>            :  * Create a locale_t from a collation OID.  Results are cached for the
<span class="lineNum">    1308 </span>            :  * lifetime of the backend.  Thus, do not free the result with freelocale().
<span class="lineNum">    1309 </span>            :  *
<span class="lineNum">    1310 </span>            :  * As a special optimization, the default/database collation returns 0.
<span class="lineNum">    1311 </span>            :  * Callers should then revert to the non-locale_t-enabled code path.
<span class="lineNum">    1312 </span>            :  * In fact, they shouldn't call this function at all when they are dealing
<span class="lineNum">    1313 </span>            :  * with the default locale.  That can save quite a bit in hotspots.
<span class="lineNum">    1314 </span>            :  * Also, callers should avoid calling this before going down a C/POSIX
<span class="lineNum">    1315 </span>            :  * fastpath, because such a fastpath should work even on platforms without
<span class="lineNum">    1316 </span>            :  * locale_t support in the C library.
<span class="lineNum">    1317 </span>            :  *
<span class="lineNum">    1318 </span>            :  * For simplicity, we always generate COLLATE + CTYPE even though we
<span class="lineNum">    1319 </span>            :  * might only need one of them.  Since this is called only once per session,
<span class="lineNum">    1320 </span>            :  * it shouldn't cost much.
<a name="1321"><span class="lineNum">    1321 </span>            :  */</a>
<span class="lineNum">    1322 </span>            : pg_locale_t
<span class="lineNum">    1323 </span><span class="lineCov">        824 : pg_newlocale_from_collation(Oid collid)</span>
<span class="lineNum">    1324 </span>            : {
<span class="lineNum">    1325 </span>            :     collation_cache_entry *cache_entry;
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span>            :     /* Callers must pass a valid OID */
<span class="lineNum">    1328 </span><span class="lineCov">        824 :     Assert(OidIsValid(collid));</span>
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span>            :     /* Return 0 for &quot;default&quot; collation, just in case caller forgets */
<span class="lineNum">    1331 </span><span class="lineCov">        824 :     if (collid == DEFAULT_COLLATION_OID)</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :         return (pg_locale_t) 0;</span>
<span class="lineNum">    1333 </span>            : 
<span class="lineNum">    1334 </span><span class="lineCov">        824 :     cache_entry = lookup_collation_cache(collid, false);</span>
<span class="lineNum">    1335 </span>            : 
<span class="lineNum">    1336 </span><span class="lineCov">        824 :     if (cache_entry-&gt;locale == 0)</span>
<span class="lineNum">    1337 </span>            :     {
<span class="lineNum">    1338 </span>            :         /* We haven't computed this yet in this session, so do it */
<span class="lineNum">    1339 </span>            :         HeapTuple   tp;
<span class="lineNum">    1340 </span>            :         Form_pg_collation collform;
<span class="lineNum">    1341 </span>            :         const char *collcollate;
<span class="lineNum">    1342 </span>            :         const char *collctype pg_attribute_unused();
<span class="lineNum">    1343 </span>            :         struct pg_locale_struct result;
<span class="lineNum">    1344 </span>            :         pg_locale_t resultp;
<span class="lineNum">    1345 </span>            :         Datum       collversion;
<span class="lineNum">    1346 </span>            :         bool        isnull;
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span><span class="lineCov">         16 :         tp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));</span>
<span class="lineNum">    1349 </span><span class="lineCov">         16 :         if (!HeapTupleIsValid(tp))</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;cache lookup failed for collation %u&quot;, collid);</span>
<span class="lineNum">    1351 </span><span class="lineCov">         16 :         collform = (Form_pg_collation) GETSTRUCT(tp);</span>
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span><span class="lineCov">         16 :         collcollate = NameStr(collform-&gt;collcollate);</span>
<span class="lineNum">    1354 </span><span class="lineCov">         16 :         collctype = NameStr(collform-&gt;collctype);</span>
<span class="lineNum">    1355 </span>            : 
<span class="lineNum">    1356 </span>            :         /* We'll fill in the result struct locally before allocating memory */
<span class="lineNum">    1357 </span><span class="lineCov">         16 :         memset(&amp;result, 0, sizeof(result));</span>
<span class="lineNum">    1358 </span><span class="lineCov">         16 :         result.provider = collform-&gt;collprovider;</span>
<span class="lineNum">    1359 </span><span class="lineCov">         16 :         result.deterministic = collform-&gt;collisdeterministic;</span>
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span><span class="lineCov">         16 :         if (collform-&gt;collprovider == COLLPROVIDER_LIBC)</span>
<span class="lineNum">    1362 </span>            :         {
<span class="lineNum">    1363 </span>            : #ifdef HAVE_LOCALE_T
<span class="lineNum">    1364 </span>            :             locale_t    loc;
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span><span class="lineCov">         16 :             if (strcmp(collcollate, collctype) == 0)</span>
<span class="lineNum">    1367 </span>            :             {
<span class="lineNum">    1368 </span>            :                 /* Normal case where they're the same */
<span class="lineNum">    1369 </span><span class="lineCov">         16 :                 errno = 0;</span>
<span class="lineNum">    1370 </span>            : #ifndef WIN32
<span class="lineNum">    1371 </span><span class="lineCov">         16 :                 loc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,</span>
<span class="lineNum">    1372 </span>            :                                 NULL);
<span class="lineNum">    1373 </span>            : #else
<span class="lineNum">    1374 </span>            :                 loc = _create_locale(LC_ALL, collcollate);
<span class="lineNum">    1375 </span>            : #endif
<span class="lineNum">    1376 </span><span class="lineCov">         16 :                 if (!loc)</span>
<span class="lineNum">    1377 </span><span class="lineCov">          2 :                     report_newlocale_failure(collcollate);</span>
<span class="lineNum">    1378 </span>            :             }
<span class="lineNum">    1379 </span>            :             else
<span class="lineNum">    1380 </span>            :             {
<span class="lineNum">    1381 </span>            : #ifndef WIN32
<span class="lineNum">    1382 </span>            :                 /* We need two newlocale() steps */
<span class="lineNum">    1383 </span>            :                 locale_t    loc1;
<span class="lineNum">    1384 </span>            : 
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :                 errno = 0;</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :                 loc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :                 if (!loc1)</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :                     report_newlocale_failure(collcollate);</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :                 errno = 0;</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :                 loc = newlocale(LC_CTYPE_MASK, collctype, loc1);</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :                 if (!loc)</span>
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :                     report_newlocale_failure(collctype);</span>
<span class="lineNum">    1393 </span>            : #else
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span>            :                 /*
<span class="lineNum">    1396 </span>            :                  * XXX The _create_locale() API doesn't appear to support
<span class="lineNum">    1397 </span>            :                  * this. Could perhaps be worked around by changing
<span class="lineNum">    1398 </span>            :                  * pg_locale_t to contain two separate fields.
<span class="lineNum">    1399 </span>            :                  */
<span class="lineNum">    1400 </span>            :                 ereport(ERROR,
<span class="lineNum">    1401 </span>            :                         (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">    1402 </span>            :                          errmsg(&quot;collations with different collate and ctype values are not supported on this platform&quot;)));
<span class="lineNum">    1403 </span>            : #endif
<span class="lineNum">    1404 </span>            :             }
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span><span class="lineCov">         14 :             result.info.lt = loc;</span>
<span class="lineNum">    1407 </span>            : #else                           /* not HAVE_LOCALE_T */
<span class="lineNum">    1408 </span>            :             /* platform that doesn't support locale_t */
<span class="lineNum">    1409 </span>            :             ereport(ERROR,
<span class="lineNum">    1410 </span>            :                     (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">    1411 </span>            :                      errmsg(&quot;collation provider LIBC is not supported on this platform&quot;)));
<span class="lineNum">    1412 </span>            : #endif                          /* not HAVE_LOCALE_T */
<span class="lineNum">    1413 </span>            :         }
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :         else if (collform-&gt;collprovider == COLLPROVIDER_ICU)</span>
<span class="lineNum">    1415 </span>            :         {
<span class="lineNum">    1416 </span>            : #ifdef USE_ICU
<span class="lineNum">    1417 </span>            :             UCollator  *collator;
<span class="lineNum">    1418 </span>            :             UErrorCode  status;
<span class="lineNum">    1419 </span>            : 
<span class="lineNum">    1420 </span>            :             if (strcmp(collcollate, collctype) != 0)
<span class="lineNum">    1421 </span>            :                 ereport(ERROR,
<span class="lineNum">    1422 </span>            :                         (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">    1423 </span>            :                          errmsg(&quot;collations with different collate and ctype values are not supported by ICU&quot;)));
<span class="lineNum">    1424 </span>            : 
<span class="lineNum">    1425 </span>            :             status = U_ZERO_ERROR;
<span class="lineNum">    1426 </span>            :             collator = ucol_open(collcollate, &amp;status);
<span class="lineNum">    1427 </span>            :             if (U_FAILURE(status))
<span class="lineNum">    1428 </span>            :                 ereport(ERROR,
<span class="lineNum">    1429 </span>            :                         (errmsg(&quot;could not open collator for locale \&quot;%s\&quot;: %s&quot;,
<span class="lineNum">    1430 </span>            :                                 collcollate, u_errorName(status))));
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span>            :             if (U_ICU_VERSION_MAJOR_NUM &lt; 54)
<span class="lineNum">    1433 </span>            :                 icu_set_collation_attributes(collator, collcollate);
<span class="lineNum">    1434 </span>            : 
<span class="lineNum">    1435 </span>            :             /* We will leak this string if we get an error below :-( */
<span class="lineNum">    1436 </span>            :             result.info.icu.locale = MemoryContextStrdup(TopMemoryContext,
<span class="lineNum">    1437 </span>            :                                                          collcollate);
<span class="lineNum">    1438 </span>            :             result.info.icu.ucol = collator;
<span class="lineNum">    1439 </span>            : #else                           /* not USE_ICU */
<span class="lineNum">    1440 </span>            :             /* could get here if a collation was created by a build with ICU */
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">    1442 </span>            :                     (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">    1443 </span>            :                      errmsg(&quot;ICU is not supported in this build&quot;), \
<span class="lineNum">    1444 </span>            :                      errhint(&quot;You need to rebuild PostgreSQL using --with-icu.&quot;)));
<span class="lineNum">    1445 </span>            : #endif                          /* not USE_ICU */
<span class="lineNum">    1446 </span>            :         }
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span><span class="lineCov">         14 :         collversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,</span>
<span class="lineNum">    1449 </span>            :                                       &amp;isnull);
<span class="lineNum">    1450 </span><span class="lineCov">         14 :         if (!isnull)</span>
<span class="lineNum">    1451 </span>            :         {
<span class="lineNum">    1452 </span>            :             char       *actual_versionstr;
<span class="lineNum">    1453 </span>            :             char       *collversionstr;
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span><span class="lineCov">         14 :             actual_versionstr = get_collation_actual_version(collform-&gt;collprovider, collcollate);</span>
<span class="lineNum">    1456 </span><span class="lineCov">         14 :             if (!actual_versionstr)</span>
<span class="lineNum">    1457 </span>            :             {
<span class="lineNum">    1458 </span>            :                 /*
<span class="lineNum">    1459 </span>            :                  * This could happen when specifying a version in CREATE
<span class="lineNum">    1460 </span>            :                  * COLLATION for a libc locale, or manually creating a mess in
<span class="lineNum">    1461 </span>            :                  * the catalogs.
<span class="lineNum">    1462 </span>            :                  */
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :                 ereport(ERROR,</span>
<span class="lineNum">    1464 </span>            :                         (errmsg(&quot;collation \&quot;%s\&quot; has no actual version, but a version was specified&quot;,
<span class="lineNum">    1465 </span>            :                                 NameStr(collform-&gt;collname))));
<span class="lineNum">    1466 </span>            :             }
<span class="lineNum">    1467 </span><span class="lineCov">         14 :             collversionstr = TextDatumGetCString(collversion);</span>
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span><span class="lineCov">         14 :             if (strcmp(actual_versionstr, collversionstr) != 0)</span>
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :                 ereport(WARNING,</span>
<span class="lineNum">    1471 </span>            :                         (errmsg(&quot;collation \&quot;%s\&quot; has version mismatch&quot;,
<span class="lineNum">    1472 </span>            :                                 NameStr(collform-&gt;collname)),
<span class="lineNum">    1473 </span>            :                          errdetail(&quot;The collation in the database was created using version %s, &quot;
<span class="lineNum">    1474 </span>            :                                    &quot;but the operating system provides version %s.&quot;,
<span class="lineNum">    1475 </span>            :                                    collversionstr, actual_versionstr),
<span class="lineNum">    1476 </span>            :                          errhint(&quot;Rebuild all objects affected by this collation and run &quot;
<span class="lineNum">    1477 </span>            :                                  &quot;ALTER COLLATION %s REFRESH VERSION, &quot;
<span class="lineNum">    1478 </span>            :                                  &quot;or build PostgreSQL with the right library version.&quot;,
<span class="lineNum">    1479 </span>            :                                  quote_qualified_identifier(get_namespace_name(collform-&gt;collnamespace),
<span class="lineNum">    1480 </span>            :                                                             NameStr(collform-&gt;collname)))));
<span class="lineNum">    1481 </span>            :         }
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span><span class="lineCov">         14 :         ReleaseSysCache(tp);</span>
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span>            :         /* We'll keep the pg_locale_t structures in TopMemoryContext */
<span class="lineNum">    1486 </span><span class="lineCov">         14 :         resultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));</span>
<span class="lineNum">    1487 </span><span class="lineCov">         14 :         *resultp = result;</span>
<span class="lineNum">    1488 </span>            : 
<span class="lineNum">    1489 </span><span class="lineCov">         14 :         cache_entry-&gt;locale = resultp;</span>
<span class="lineNum">    1490 </span>            :     }
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span><span class="lineCov">        822 :     return cache_entry-&gt;locale;</span>
<span class="lineNum">    1493 </span>            : }
<span class="lineNum">    1494 </span>            : 
<span class="lineNum">    1495 </span>            : /*
<span class="lineNum">    1496 </span>            :  * Get provider-specific collation version string for the given collation from
<span class="lineNum">    1497 </span>            :  * the operating system/library.
<span class="lineNum">    1498 </span>            :  *
<span class="lineNum">    1499 </span>            :  * A particular provider must always either return a non-NULL string or return
<span class="lineNum">    1500 </span>            :  * NULL (if it doesn't support versions).  It must not return NULL for some
<span class="lineNum">    1501 </span>            :  * collcollate and not NULL for others.
<a name="1502"><span class="lineNum">    1502 </span>            :  */</a>
<span class="lineNum">    1503 </span>            : char *
<span class="lineNum">    1504 </span><span class="lineCov">       2460 : get_collation_actual_version(char collprovider, const char *collcollate)</span>
<span class="lineNum">    1505 </span>            : {
<span class="lineNum">    1506 </span><span class="lineCov">       2460 :     char       *collversion = NULL;</span>
<span class="lineNum">    1507 </span>            : 
<span class="lineNum">    1508 </span>            : #ifdef USE_ICU
<span class="lineNum">    1509 </span>            :     if (collprovider == COLLPROVIDER_ICU)
<span class="lineNum">    1510 </span>            :     {
<span class="lineNum">    1511 </span>            :         UCollator  *collator;
<span class="lineNum">    1512 </span>            :         UErrorCode  status;
<span class="lineNum">    1513 </span>            :         UVersionInfo versioninfo;
<span class="lineNum">    1514 </span>            :         char        buf[U_MAX_VERSION_STRING_LENGTH];
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span>            :         status = U_ZERO_ERROR;
<span class="lineNum">    1517 </span>            :         collator = ucol_open(collcollate, &amp;status);
<span class="lineNum">    1518 </span>            :         if (U_FAILURE(status))
<span class="lineNum">    1519 </span>            :             ereport(ERROR,
<span class="lineNum">    1520 </span>            :                     (errmsg(&quot;could not open collator for locale \&quot;%s\&quot;: %s&quot;,
<span class="lineNum">    1521 </span>            :                             collcollate, u_errorName(status))));
<span class="lineNum">    1522 </span>            :         ucol_getVersion(collator, versioninfo);
<span class="lineNum">    1523 </span>            :         ucol_close(collator);
<span class="lineNum">    1524 </span>            : 
<span class="lineNum">    1525 </span>            :         u_versionToString(versioninfo, buf);
<span class="lineNum">    1526 </span>            :         collversion = pstrdup(buf);
<span class="lineNum">    1527 </span>            :     }
<span class="lineNum">    1528 </span>            :     else
<span class="lineNum">    1529 </span>            : #endif
<span class="lineNum">    1530 </span><span class="lineCov">       2460 :     if (collprovider == COLLPROVIDER_LIBC)</span>
<span class="lineNum">    1531 </span>            :     {
<span class="lineNum">    1532 </span>            : #if defined(__GLIBC__)
<span class="lineNum">    1533 </span>            :         /* Use the glibc version because we don't have anything better. */
<span class="lineNum">    1534 </span><span class="lineCov">       2460 :         collversion = pstrdup(gnu_get_libc_version());</span>
<span class="lineNum">    1535 </span>            : #endif
<span class="lineNum">    1536 </span>            :     }
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span><span class="lineCov">       2460 :     return collversion;</span>
<span class="lineNum">    1539 </span>            : }
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span>            : #ifdef USE_ICU
<span class="lineNum">    1543 </span>            : /*
<span class="lineNum">    1544 </span>            :  * Converter object for converting between ICU's UChar strings and C strings
<span class="lineNum">    1545 </span>            :  * in database encoding.  Since the database encoding doesn't change, we only
<span class="lineNum">    1546 </span>            :  * need one of these per session.
<span class="lineNum">    1547 </span>            :  */
<span class="lineNum">    1548 </span>            : static UConverter *icu_converter = NULL;
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span>            : static void
<span class="lineNum">    1551 </span>            : init_icu_converter(void)
<span class="lineNum">    1552 </span>            : {
<span class="lineNum">    1553 </span>            :     const char *icu_encoding_name;
<span class="lineNum">    1554 </span>            :     UErrorCode  status;
<span class="lineNum">    1555 </span>            :     UConverter *conv;
<span class="lineNum">    1556 </span>            : 
<span class="lineNum">    1557 </span>            :     if (icu_converter)
<span class="lineNum">    1558 </span>            :         return;
<span class="lineNum">    1559 </span>            : 
<span class="lineNum">    1560 </span>            :     icu_encoding_name = get_encoding_name_for_icu(GetDatabaseEncoding());
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span>            :     status = U_ZERO_ERROR;
<span class="lineNum">    1563 </span>            :     conv = ucnv_open(icu_encoding_name, &amp;status);
<span class="lineNum">    1564 </span>            :     if (U_FAILURE(status))
<span class="lineNum">    1565 </span>            :         ereport(ERROR,
<span class="lineNum">    1566 </span>            :                 (errmsg(&quot;could not open ICU converter for encoding \&quot;%s\&quot;: %s&quot;,
<span class="lineNum">    1567 </span>            :                         icu_encoding_name, u_errorName(status))));
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span>            :     icu_converter = conv;
<span class="lineNum">    1570 </span>            : }
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span>            : /*
<span class="lineNum">    1573 </span>            :  * Convert a string in the database encoding into a string of UChars.
<span class="lineNum">    1574 </span>            :  *
<span class="lineNum">    1575 </span>            :  * The source string at buff is of length nbytes
<span class="lineNum">    1576 </span>            :  * (it needn't be nul-terminated)
<span class="lineNum">    1577 </span>            :  *
<span class="lineNum">    1578 </span>            :  * *buff_uchar receives a pointer to the palloc'd result string, and
<span class="lineNum">    1579 </span>            :  * the function's result is the number of UChars generated.
<span class="lineNum">    1580 </span>            :  *
<span class="lineNum">    1581 </span>            :  * The result string is nul-terminated, though most callers rely on the
<span class="lineNum">    1582 </span>            :  * result length instead.
<span class="lineNum">    1583 </span>            :  */
<span class="lineNum">    1584 </span>            : int32_t
<span class="lineNum">    1585 </span>            : icu_to_uchar(UChar **buff_uchar, const char *buff, size_t nbytes)
<span class="lineNum">    1586 </span>            : {
<span class="lineNum">    1587 </span>            :     UErrorCode  status;
<span class="lineNum">    1588 </span>            :     int32_t     len_uchar;
<span class="lineNum">    1589 </span>            : 
<span class="lineNum">    1590 </span>            :     init_icu_converter();
<span class="lineNum">    1591 </span>            : 
<span class="lineNum">    1592 </span>            :     status = U_ZERO_ERROR;
<span class="lineNum">    1593 </span>            :     len_uchar = ucnv_toUChars(icu_converter, NULL, 0,
<span class="lineNum">    1594 </span>            :                               buff, nbytes, &amp;status);
<span class="lineNum">    1595 </span>            :     if (U_FAILURE(status) &amp;&amp; status != U_BUFFER_OVERFLOW_ERROR)
<span class="lineNum">    1596 </span>            :         ereport(ERROR,
<span class="lineNum">    1597 </span>            :                 (errmsg(&quot;%s failed: %s&quot;, &quot;ucnv_toUChars&quot;, u_errorName(status))));
<span class="lineNum">    1598 </span>            : 
<span class="lineNum">    1599 </span>            :     *buff_uchar = palloc((len_uchar + 1) * sizeof(**buff_uchar));
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span>            :     status = U_ZERO_ERROR;
<span class="lineNum">    1602 </span>            :     len_uchar = ucnv_toUChars(icu_converter, *buff_uchar, len_uchar + 1,
<span class="lineNum">    1603 </span>            :                               buff, nbytes, &amp;status);
<span class="lineNum">    1604 </span>            :     if (U_FAILURE(status))
<span class="lineNum">    1605 </span>            :         ereport(ERROR,
<span class="lineNum">    1606 </span>            :                 (errmsg(&quot;%s failed: %s&quot;, &quot;ucnv_toUChars&quot;, u_errorName(status))));
<span class="lineNum">    1607 </span>            : 
<span class="lineNum">    1608 </span>            :     return len_uchar;
<span class="lineNum">    1609 </span>            : }
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span>            : /*
<span class="lineNum">    1612 </span>            :  * Convert a string of UChars into the database encoding.
<span class="lineNum">    1613 </span>            :  *
<span class="lineNum">    1614 </span>            :  * The source string at buff_uchar is of length len_uchar
<span class="lineNum">    1615 </span>            :  * (it needn't be nul-terminated)
<span class="lineNum">    1616 </span>            :  *
<span class="lineNum">    1617 </span>            :  * *result receives a pointer to the palloc'd result string, and the
<span class="lineNum">    1618 </span>            :  * function's result is the number of bytes generated (not counting nul).
<span class="lineNum">    1619 </span>            :  *
<span class="lineNum">    1620 </span>            :  * The result string is nul-terminated.
<span class="lineNum">    1621 </span>            :  */
<span class="lineNum">    1622 </span>            : int32_t
<span class="lineNum">    1623 </span>            : icu_from_uchar(char **result, const UChar *buff_uchar, int32_t len_uchar)
<span class="lineNum">    1624 </span>            : {
<span class="lineNum">    1625 </span>            :     UErrorCode  status;
<span class="lineNum">    1626 </span>            :     int32_t     len_result;
<span class="lineNum">    1627 </span>            : 
<span class="lineNum">    1628 </span>            :     init_icu_converter();
<span class="lineNum">    1629 </span>            : 
<span class="lineNum">    1630 </span>            :     status = U_ZERO_ERROR;
<span class="lineNum">    1631 </span>            :     len_result = ucnv_fromUChars(icu_converter, NULL, 0,
<span class="lineNum">    1632 </span>            :                                  buff_uchar, len_uchar, &amp;status);
<span class="lineNum">    1633 </span>            :     if (U_FAILURE(status) &amp;&amp; status != U_BUFFER_OVERFLOW_ERROR)
<span class="lineNum">    1634 </span>            :         ereport(ERROR,
<span class="lineNum">    1635 </span>            :                 (errmsg(&quot;%s failed: %s&quot;, &quot;ucnv_fromUChars&quot;,
<span class="lineNum">    1636 </span>            :                         u_errorName(status))));
<span class="lineNum">    1637 </span>            : 
<span class="lineNum">    1638 </span>            :     *result = palloc(len_result + 1);
<span class="lineNum">    1639 </span>            : 
<span class="lineNum">    1640 </span>            :     status = U_ZERO_ERROR;
<span class="lineNum">    1641 </span>            :     len_result = ucnv_fromUChars(icu_converter, *result, len_result + 1,
<span class="lineNum">    1642 </span>            :                                  buff_uchar, len_uchar, &amp;status);
<span class="lineNum">    1643 </span>            :     if (U_FAILURE(status))
<span class="lineNum">    1644 </span>            :         ereport(ERROR,
<span class="lineNum">    1645 </span>            :                 (errmsg(&quot;%s failed: %s&quot;, &quot;ucnv_fromUChars&quot;,
<span class="lineNum">    1646 </span>            :                         u_errorName(status))));
<span class="lineNum">    1647 </span>            : 
<span class="lineNum">    1648 </span>            :     return len_result;
<span class="lineNum">    1649 </span>            : }
<span class="lineNum">    1650 </span>            : 
<span class="lineNum">    1651 </span>            : /*
<span class="lineNum">    1652 </span>            :  * Parse collation attributes and apply them to the open collator.  This takes
<span class="lineNum">    1653 </span>            :  * a string like &quot;und@colStrength=primary;colCaseLevel=yes&quot; and parses and
<span class="lineNum">    1654 </span>            :  * applies the key-value arguments.
<span class="lineNum">    1655 </span>            :  *
<span class="lineNum">    1656 </span>            :  * Starting with ICU version 54, the attributes are processed automatically by
<span class="lineNum">    1657 </span>            :  * ucol_open(), so this is only necessary for emulating this behavior on older
<span class="lineNum">    1658 </span>            :  * versions.
<span class="lineNum">    1659 </span>            :  */
<span class="lineNum">    1660 </span>            : pg_attribute_unused()
<span class="lineNum">    1661 </span>            : static void
<span class="lineNum">    1662 </span>            : icu_set_collation_attributes(UCollator *collator, const char *loc)
<span class="lineNum">    1663 </span>            : {
<span class="lineNum">    1664 </span>            :     char       *str = asc_tolower(loc, strlen(loc));
<span class="lineNum">    1665 </span>            : 
<span class="lineNum">    1666 </span>            :     str = strchr(str, '@');
<span class="lineNum">    1667 </span>            :     if (!str)
<span class="lineNum">    1668 </span>            :         return;
<span class="lineNum">    1669 </span>            :     str++;
<span class="lineNum">    1670 </span>            : 
<span class="lineNum">    1671 </span>            :     for (char *token = strtok(str, &quot;;&quot;); token; token = strtok(NULL, &quot;;&quot;))
<span class="lineNum">    1672 </span>            :     {
<span class="lineNum">    1673 </span>            :         char       *e = strchr(token, '=');
<span class="lineNum">    1674 </span>            : 
<span class="lineNum">    1675 </span>            :         if (e)
<span class="lineNum">    1676 </span>            :         {
<span class="lineNum">    1677 </span>            :             char       *name;
<span class="lineNum">    1678 </span>            :             char       *value;
<span class="lineNum">    1679 </span>            :             UColAttribute uattr;
<span class="lineNum">    1680 </span>            :             UColAttributeValue uvalue;
<span class="lineNum">    1681 </span>            :             UErrorCode  status;
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span>            :             status = U_ZERO_ERROR;
<span class="lineNum">    1684 </span>            : 
<span class="lineNum">    1685 </span>            :             *e = '\0';
<span class="lineNum">    1686 </span>            :             name = token;
<span class="lineNum">    1687 </span>            :             value = e + 1;
<span class="lineNum">    1688 </span>            : 
<span class="lineNum">    1689 </span>            :             /*
<span class="lineNum">    1690 </span>            :              * See attribute name and value lists in ICU i18n/coll.cpp
<span class="lineNum">    1691 </span>            :              */
<span class="lineNum">    1692 </span>            :             if (strcmp(name, &quot;colstrength&quot;) == 0)
<span class="lineNum">    1693 </span>            :                 uattr = UCOL_STRENGTH;
<span class="lineNum">    1694 </span>            :             else if (strcmp(name, &quot;colbackwards&quot;) == 0)
<span class="lineNum">    1695 </span>            :                 uattr = UCOL_FRENCH_COLLATION;
<span class="lineNum">    1696 </span>            :             else if (strcmp(name, &quot;colcaselevel&quot;) == 0)
<span class="lineNum">    1697 </span>            :                 uattr = UCOL_CASE_LEVEL;
<span class="lineNum">    1698 </span>            :             else if (strcmp(name, &quot;colcasefirst&quot;) == 0)
<span class="lineNum">    1699 </span>            :                 uattr = UCOL_CASE_FIRST;
<span class="lineNum">    1700 </span>            :             else if (strcmp(name, &quot;colalternate&quot;) == 0)
<span class="lineNum">    1701 </span>            :                 uattr = UCOL_ALTERNATE_HANDLING;
<span class="lineNum">    1702 </span>            :             else if (strcmp(name, &quot;colnormalization&quot;) == 0)
<span class="lineNum">    1703 </span>            :                 uattr = UCOL_NORMALIZATION_MODE;
<span class="lineNum">    1704 </span>            :             else if (strcmp(name, &quot;colnumeric&quot;) == 0)
<span class="lineNum">    1705 </span>            :                 uattr = UCOL_NUMERIC_COLLATION;
<span class="lineNum">    1706 </span>            :             else
<span class="lineNum">    1707 </span>            :                 /* ignore if unknown */
<span class="lineNum">    1708 </span>            :                 continue;
<span class="lineNum">    1709 </span>            : 
<span class="lineNum">    1710 </span>            :             if (strcmp(value, &quot;primary&quot;) == 0)
<span class="lineNum">    1711 </span>            :                 uvalue = UCOL_PRIMARY;
<span class="lineNum">    1712 </span>            :             else if (strcmp(value, &quot;secondary&quot;) == 0)
<span class="lineNum">    1713 </span>            :                 uvalue = UCOL_SECONDARY;
<span class="lineNum">    1714 </span>            :             else if (strcmp(value, &quot;tertiary&quot;) == 0)
<span class="lineNum">    1715 </span>            :                 uvalue = UCOL_TERTIARY;
<span class="lineNum">    1716 </span>            :             else if (strcmp(value, &quot;quaternary&quot;) == 0)
<span class="lineNum">    1717 </span>            :                 uvalue = UCOL_QUATERNARY;
<span class="lineNum">    1718 </span>            :             else if (strcmp(value, &quot;identical&quot;) == 0)
<span class="lineNum">    1719 </span>            :                 uvalue = UCOL_IDENTICAL;
<span class="lineNum">    1720 </span>            :             else if (strcmp(value, &quot;no&quot;) == 0)
<span class="lineNum">    1721 </span>            :                 uvalue = UCOL_OFF;
<span class="lineNum">    1722 </span>            :             else if (strcmp(value, &quot;yes&quot;) == 0)
<span class="lineNum">    1723 </span>            :                 uvalue = UCOL_ON;
<span class="lineNum">    1724 </span>            :             else if (strcmp(value, &quot;shifted&quot;) == 0)
<span class="lineNum">    1725 </span>            :                 uvalue = UCOL_SHIFTED;
<span class="lineNum">    1726 </span>            :             else if (strcmp(value, &quot;non-ignorable&quot;) == 0)
<span class="lineNum">    1727 </span>            :                 uvalue = UCOL_NON_IGNORABLE;
<span class="lineNum">    1728 </span>            :             else if (strcmp(value, &quot;lower&quot;) == 0)
<span class="lineNum">    1729 </span>            :                 uvalue = UCOL_LOWER_FIRST;
<span class="lineNum">    1730 </span>            :             else if (strcmp(value, &quot;upper&quot;) == 0)
<span class="lineNum">    1731 </span>            :                 uvalue = UCOL_UPPER_FIRST;
<span class="lineNum">    1732 </span>            :             else
<span class="lineNum">    1733 </span>            :                 status = U_ILLEGAL_ARGUMENT_ERROR;
<span class="lineNum">    1734 </span>            : 
<span class="lineNum">    1735 </span>            :             if (status == U_ZERO_ERROR)
<span class="lineNum">    1736 </span>            :                 ucol_setAttribute(collator, uattr, uvalue, &amp;status);
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span>            :             /*
<span class="lineNum">    1739 </span>            :              * Pretend the error came from ucol_open(), for consistent error
<span class="lineNum">    1740 </span>            :              * message across ICU versions.
<span class="lineNum">    1741 </span>            :              */
<span class="lineNum">    1742 </span>            :             if (U_FAILURE(status))
<span class="lineNum">    1743 </span>            :                 ereport(ERROR,
<span class="lineNum">    1744 </span>            :                         (errmsg(&quot;could not open collator for locale \&quot;%s\&quot;: %s&quot;,
<span class="lineNum">    1745 </span>            :                                 loc, u_errorName(status))));
<span class="lineNum">    1746 </span>            :         }
<span class="lineNum">    1747 </span>            :     }
<span class="lineNum">    1748 </span>            : }
<span class="lineNum">    1749 </span>            : 
<span class="lineNum">    1750 </span>            : #endif                          /* USE_ICU */
<span class="lineNum">    1751 </span>            : 
<span class="lineNum">    1752 </span>            : /*
<span class="lineNum">    1753 </span>            :  * These functions convert from/to libc's wchar_t, *not* pg_wchar_t.
<span class="lineNum">    1754 </span>            :  * Therefore we keep them here rather than with the mbutils code.
<span class="lineNum">    1755 </span>            :  */
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span>            : /*
<span class="lineNum">    1758 </span>            :  * wchar2char --- convert wide characters to multibyte format
<span class="lineNum">    1759 </span>            :  *
<span class="lineNum">    1760 </span>            :  * This has the same API as the standard wcstombs_l() function; in particular,
<span class="lineNum">    1761 </span>            :  * tolen is the maximum number of bytes to store at *to, and *from must be
<span class="lineNum">    1762 </span>            :  * zero-terminated.  The output will be zero-terminated iff there is room.
<a name="1763"><span class="lineNum">    1763 </span>            :  */</a>
<span class="lineNum">    1764 </span>            : size_t
<span class="lineNum">    1765 </span><span class="lineCov">       8480 : wchar2char(char *to, const wchar_t *from, size_t tolen, pg_locale_t locale)</span>
<span class="lineNum">    1766 </span>            : {
<span class="lineNum">    1767 </span>            :     size_t      result;
<span class="lineNum">    1768 </span>            : 
<span class="lineNum">    1769 </span><span class="lineCov">       8480 :     Assert(!locale || locale-&gt;provider == COLLPROVIDER_LIBC);</span>
<span class="lineNum">    1770 </span>            : 
<span class="lineNum">    1771 </span><span class="lineCov">       8480 :     if (tolen == 0)</span>
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1773 </span>            : 
<span class="lineNum">    1774 </span>            : #ifdef WIN32
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span>            :     /*
<span class="lineNum">    1777 </span>            :      * On Windows, the &quot;Unicode&quot; locales assume UTF16 not UTF8 encoding, and
<span class="lineNum">    1778 </span>            :      * for some reason mbstowcs and wcstombs won't do this for us, so we use
<span class="lineNum">    1779 </span>            :      * MultiByteToWideChar().
<span class="lineNum">    1780 </span>            :      */
<span class="lineNum">    1781 </span>            :     if (GetDatabaseEncoding() == PG_UTF8)
<span class="lineNum">    1782 </span>            :     {
<span class="lineNum">    1783 </span>            :         result = WideCharToMultiByte(CP_UTF8, 0, from, -1, to, tolen,
<span class="lineNum">    1784 </span>            :                                      NULL, NULL);
<span class="lineNum">    1785 </span>            :         /* A zero return is failure */
<span class="lineNum">    1786 </span>            :         if (result &lt;= 0)
<span class="lineNum">    1787 </span>            :             result = -1;
<span class="lineNum">    1788 </span>            :         else
<span class="lineNum">    1789 </span>            :         {
<span class="lineNum">    1790 </span>            :             Assert(result &lt;= tolen);
<span class="lineNum">    1791 </span>            :             /* Microsoft counts the zero terminator in the result */
<span class="lineNum">    1792 </span>            :             result--;
<span class="lineNum">    1793 </span>            :         }
<span class="lineNum">    1794 </span>            :     }
<span class="lineNum">    1795 </span>            :     else
<span class="lineNum">    1796 </span>            : #endif                          /* WIN32 */
<span class="lineNum">    1797 </span><span class="lineCov">       8480 :     if (locale == (pg_locale_t) 0)</span>
<span class="lineNum">    1798 </span>            :     {
<span class="lineNum">    1799 </span>            :         /* Use wcstombs directly for the default locale */
<span class="lineNum">    1800 </span><span class="lineCov">       8352 :         result = wcstombs(to, from, tolen);</span>
<span class="lineNum">    1801 </span>            :     }
<span class="lineNum">    1802 </span>            :     else
<span class="lineNum">    1803 </span>            :     {
<span class="lineNum">    1804 </span>            : #ifdef HAVE_LOCALE_T
<span class="lineNum">    1805 </span>            : #ifdef HAVE_WCSTOMBS_L
<span class="lineNum">    1806 </span>            :         /* Use wcstombs_l for nondefault locales */
<span class="lineNum">    1807 </span>            :         result = wcstombs_l(to, from, tolen, locale-&gt;info.lt);
<span class="lineNum">    1808 </span>            : #else                           /* !HAVE_WCSTOMBS_L */
<span class="lineNum">    1809 </span>            :         /* We have to temporarily set the locale as current ... ugh */
<span class="lineNum">    1810 </span><span class="lineCov">        128 :         locale_t    save_locale = uselocale(locale-&gt;info.lt);</span>
<span class="lineNum">    1811 </span>            : 
<span class="lineNum">    1812 </span><span class="lineCov">        128 :         result = wcstombs(to, from, tolen);</span>
<span class="lineNum">    1813 </span>            : 
<span class="lineNum">    1814 </span><span class="lineCov">        128 :         uselocale(save_locale);</span>
<span class="lineNum">    1815 </span>            : #endif                          /* HAVE_WCSTOMBS_L */
<span class="lineNum">    1816 </span>            : #else                           /* !HAVE_LOCALE_T */
<span class="lineNum">    1817 </span>            :         /* Can't have locale != 0 without HAVE_LOCALE_T */
<span class="lineNum">    1818 </span>            :         elog(ERROR, &quot;wcstombs_l is not available&quot;);
<span class="lineNum">    1819 </span>            :         result = 0;             /* keep compiler quiet */
<span class="lineNum">    1820 </span>            : #endif                          /* HAVE_LOCALE_T */
<span class="lineNum">    1821 </span>            :     }
<span class="lineNum">    1822 </span>            : 
<span class="lineNum">    1823 </span><span class="lineCov">       8480 :     return result;</span>
<span class="lineNum">    1824 </span>            : }
<span class="lineNum">    1825 </span>            : 
<span class="lineNum">    1826 </span>            : /*
<span class="lineNum">    1827 </span>            :  * char2wchar --- convert multibyte characters to wide characters
<span class="lineNum">    1828 </span>            :  *
<span class="lineNum">    1829 </span>            :  * This has almost the API of mbstowcs_l(), except that *from need not be
<span class="lineNum">    1830 </span>            :  * null-terminated; instead, the number of input bytes is specified as
<span class="lineNum">    1831 </span>            :  * fromlen.  Also, we ereport() rather than returning -1 for invalid
<span class="lineNum">    1832 </span>            :  * input encoding.  tolen is the maximum number of wchar_t's to store at *to.
<span class="lineNum">    1833 </span>            :  * The output will be zero-terminated iff there is room.
<a name="1834"><span class="lineNum">    1834 </span>            :  */</a>
<span class="lineNum">    1835 </span>            : size_t
<span class="lineNum">    1836 </span><span class="lineCov">      10018 : char2wchar(wchar_t *to, size_t tolen, const char *from, size_t fromlen,</span>
<span class="lineNum">    1837 </span>            :            pg_locale_t locale)
<span class="lineNum">    1838 </span>            : {
<span class="lineNum">    1839 </span>            :     size_t      result;
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span><span class="lineCov">      10018 :     Assert(!locale || locale-&gt;provider == COLLPROVIDER_LIBC);</span>
<span class="lineNum">    1842 </span>            : 
<span class="lineNum">    1843 </span><span class="lineCov">      10018 :     if (tolen == 0)</span>
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1845 </span>            : 
<span class="lineNum">    1846 </span>            : #ifdef WIN32
<span class="lineNum">    1847 </span>            :     /* See WIN32 &quot;Unicode&quot; comment above */
<span class="lineNum">    1848 </span>            :     if (GetDatabaseEncoding() == PG_UTF8)
<span class="lineNum">    1849 </span>            :     {
<span class="lineNum">    1850 </span>            :         /* Win32 API does not work for zero-length input */
<span class="lineNum">    1851 </span>            :         if (fromlen == 0)
<span class="lineNum">    1852 </span>            :             result = 0;
<span class="lineNum">    1853 </span>            :         else
<span class="lineNum">    1854 </span>            :         {
<span class="lineNum">    1855 </span>            :             result = MultiByteToWideChar(CP_UTF8, 0, from, fromlen, to, tolen - 1);
<span class="lineNum">    1856 </span>            :             /* A zero return is failure */
<span class="lineNum">    1857 </span>            :             if (result == 0)
<span class="lineNum">    1858 </span>            :                 result = -1;
<span class="lineNum">    1859 </span>            :         }
<span class="lineNum">    1860 </span>            : 
<span class="lineNum">    1861 </span>            :         if (result != -1)
<span class="lineNum">    1862 </span>            :         {
<span class="lineNum">    1863 </span>            :             Assert(result &lt; tolen);
<span class="lineNum">    1864 </span>            :             /* Append trailing null wchar (MultiByteToWideChar() does not) */
<span class="lineNum">    1865 </span>            :             to[result] = 0;
<span class="lineNum">    1866 </span>            :         }
<span class="lineNum">    1867 </span>            :     }
<span class="lineNum">    1868 </span>            :     else
<span class="lineNum">    1869 </span>            : #endif                          /* WIN32 */
<span class="lineNum">    1870 </span>            :     {
<span class="lineNum">    1871 </span>            :         /* mbstowcs requires ending '\0' */
<span class="lineNum">    1872 </span><span class="lineCov">      10018 :         char       *str = pnstrdup(from, fromlen);</span>
<span class="lineNum">    1873 </span>            : 
<span class="lineNum">    1874 </span><span class="lineCov">      10018 :         if (locale == (pg_locale_t) 0)</span>
<span class="lineNum">    1875 </span>            :         {
<span class="lineNum">    1876 </span>            :             /* Use mbstowcs directly for the default locale */
<span class="lineNum">    1877 </span><span class="lineCov">       9890 :             result = mbstowcs(to, str, tolen);</span>
<span class="lineNum">    1878 </span>            :         }
<span class="lineNum">    1879 </span>            :         else
<span class="lineNum">    1880 </span>            :         {
<span class="lineNum">    1881 </span>            : #ifdef HAVE_LOCALE_T
<span class="lineNum">    1882 </span>            : #ifdef HAVE_MBSTOWCS_L
<span class="lineNum">    1883 </span>            :             /* Use mbstowcs_l for nondefault locales */
<span class="lineNum">    1884 </span>            :             result = mbstowcs_l(to, str, tolen, locale-&gt;info.lt);
<span class="lineNum">    1885 </span>            : #else                           /* !HAVE_MBSTOWCS_L */
<span class="lineNum">    1886 </span>            :             /* We have to temporarily set the locale as current ... ugh */
<span class="lineNum">    1887 </span><span class="lineCov">        128 :             locale_t    save_locale = uselocale(locale-&gt;info.lt);</span>
<span class="lineNum">    1888 </span>            : 
<span class="lineNum">    1889 </span><span class="lineCov">        128 :             result = mbstowcs(to, str, tolen);</span>
<span class="lineNum">    1890 </span>            : 
<span class="lineNum">    1891 </span><span class="lineCov">        128 :             uselocale(save_locale);</span>
<span class="lineNum">    1892 </span>            : #endif                          /* HAVE_MBSTOWCS_L */
<span class="lineNum">    1893 </span>            : #else                           /* !HAVE_LOCALE_T */
<span class="lineNum">    1894 </span>            :             /* Can't have locale != 0 without HAVE_LOCALE_T */
<span class="lineNum">    1895 </span>            :             elog(ERROR, &quot;mbstowcs_l is not available&quot;);
<span class="lineNum">    1896 </span>            :             result = 0;         /* keep compiler quiet */
<span class="lineNum">    1897 </span>            : #endif                          /* HAVE_LOCALE_T */
<span class="lineNum">    1898 </span>            :         }
<span class="lineNum">    1899 </span>            : 
<span class="lineNum">    1900 </span><span class="lineCov">      10018 :         pfree(str);</span>
<span class="lineNum">    1901 </span>            :     }
<span class="lineNum">    1902 </span>            : 
<span class="lineNum">    1903 </span><span class="lineCov">      10018 :     if (result == -1)</span>
<span class="lineNum">    1904 </span>            :     {
<span class="lineNum">    1905 </span>            :         /*
<span class="lineNum">    1906 </span>            :          * Invalid multibyte character encountered.  We try to give a useful
<span class="lineNum">    1907 </span>            :          * error message by letting pg_verifymbstr check the string.  But it's
<span class="lineNum">    1908 </span>            :          * possible that the string is OK to us, and not OK to mbstowcs ---
<span class="lineNum">    1909 </span>            :          * this suggests that the LC_CTYPE locale is different from the
<span class="lineNum">    1910 </span>            :          * database encoding.  Give a generic error message if pg_verifymbstr
<span class="lineNum">    1911 </span>            :          * can't find anything wrong.
<span class="lineNum">    1912 </span>            :          */
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :         pg_verifymbstr(from, fromlen, false);   /* might not return */</span>
<span class="lineNum">    1914 </span>            :         /* but if it does ... */
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1916 </span>            :                 (errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),
<span class="lineNum">    1917 </span>            :                  errmsg(&quot;invalid multibyte character for locale&quot;),
<span class="lineNum">    1918 </span>            :                  errhint(&quot;The server's LC_CTYPE locale is probably incompatible with the database encoding.&quot;)));
<span class="lineNum">    1919 </span>            :     }
<span class="lineNum">    1920 </span>            : 
<span class="lineNum">    1921 </span><span class="lineCov">      10018 :     return result;</span>
<span class="lineNum">    1922 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
