<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/utils/adt/tsgistidx.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/backend/utils/adt</a> - tsgistidx.c<span style="font-size: 80%;"> (source / <a href="tsgistidx.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">234</td>
            <td class="headerCovTableEntry">326</td>
            <td class="headerCovTableEntryLo">71.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntry">21</td>
            <td class="headerCovTableEntryMed">76.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * tsgistidx.c
<span class="lineNum">       4 </span>            :  *    GiST support functions for tsvector_ops
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  * IDENTIFICATION
<span class="lineNum">      10 </span>            :  *    src/backend/utils/adt/tsgistidx.c
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      13 </span>            :  */
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &quot;access/gist.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;access/heaptoast.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;lib/qunique.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;port/pg_bitutils.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;tsearch/ts_utils.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;utils/builtins.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;utils/pg_crc.h&quot;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #define SIGLENINT  31           /* &gt;121 =&gt; key will toast, so it will not work
<span class="lineNum">      27 </span>            :                                  * !!! */
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #define SIGLEN  ( sizeof(int32) * SIGLENINT )
<span class="lineNum">      30 </span>            : #define SIGLENBIT (SIGLEN * BITS_PER_BYTE)
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : typedef char BITVEC[SIGLEN];
<span class="lineNum">      33 </span>            : typedef char *BITVECP;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #define LOOPBYTE \
<span class="lineNum">      36 </span>            :             for(i=0;i&lt;SIGLEN;i++)
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : #define GETBYTE(x,i) ( *( (BITVECP)(x) + (int)( (i) / BITS_PER_BYTE ) ) )
<span class="lineNum">      39 </span>            : #define GETBITBYTE(x,i) ( ((char)(x)) &gt;&gt; (i) &amp; 0x01 )
<span class="lineNum">      40 </span>            : #define CLRBIT(x,i)   GETBYTE(x,i) &amp;= ~( 0x01 &lt;&lt; ( (i) % BITS_PER_BYTE ) )
<span class="lineNum">      41 </span>            : #define SETBIT(x,i)   GETBYTE(x,i) |=  ( 0x01 &lt;&lt; ( (i) % BITS_PER_BYTE ) )
<span class="lineNum">      42 </span>            : #define GETBIT(x,i) ( (GETBYTE(x,i) &gt;&gt; ( (i) % BITS_PER_BYTE )) &amp; 0x01 )
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : #define HASHVAL(val) (((unsigned int)(val)) % SIGLENBIT)
<span class="lineNum">      45 </span>            : #define HASH(sign, val) SETBIT((sign), HASHVAL(val))
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : #define GETENTRY(vec,pos) ((SignTSVector *) DatumGetPointer((vec)-&gt;vector[(pos)].key))
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : /*
<span class="lineNum">      50 </span>            :  * type of GiST index key
<span class="lineNum">      51 </span>            :  */
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : typedef struct
<span class="lineNum">      54 </span>            : {
<span class="lineNum">      55 </span>            :     int32       vl_len_;        /* varlena header (do not touch directly!) */
<span class="lineNum">      56 </span>            :     int32       flag;
<span class="lineNum">      57 </span>            :     char        data[FLEXIBLE_ARRAY_MEMBER];
<span class="lineNum">      58 </span>            : } SignTSVector;
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : #define ARRKEY      0x01
<span class="lineNum">      61 </span>            : #define SIGNKEY     0x02
<span class="lineNum">      62 </span>            : #define ALLISTRUE   0x04
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : #define ISARRKEY(x) ( ((SignTSVector*)(x))-&gt;flag &amp; ARRKEY )
<span class="lineNum">      65 </span>            : #define ISSIGNKEY(x)    ( ((SignTSVector*)(x))-&gt;flag &amp; SIGNKEY )
<span class="lineNum">      66 </span>            : #define ISALLTRUE(x)    ( ((SignTSVector*)(x))-&gt;flag &amp; ALLISTRUE )
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : #define GTHDRSIZE   ( VARHDRSZ + sizeof(int32) )
<span class="lineNum">      69 </span>            : #define CALCGTSIZE(flag, len) ( GTHDRSIZE + ( ( (flag) &amp; ARRKEY ) ? ((len)*sizeof(int32)) : (((flag) &amp; ALLISTRUE) ? 0 : SIGLEN) ) )
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : #define GETSIGN(x)  ( (BITVECP)( (char*)(x)+GTHDRSIZE ) )
<span class="lineNum">      72 </span>            : #define GETARR(x)   ( (int32*)( (char*)(x)+GTHDRSIZE ) )
<span class="lineNum">      73 </span>            : #define ARRNELEM(x) ( ( VARSIZE(x) - GTHDRSIZE )/sizeof(int32) )
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : static int32 sizebitvec(BITVECP sign);
<a name="76"><span class="lineNum">      76 </span>            : </a>
<span class="lineNum">      77 </span>            : Datum
<span class="lineNum">      78 </span><span class="lineNoCov">          0 : gtsvectorin(PG_FUNCTION_ARGS)</span>
<span class="lineNum">      79 </span>            : {
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :     ereport(ERROR,</span>
<span class="lineNum">      81 </span>            :             (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">      82 </span>            :              errmsg(&quot;gtsvector_in not implemented&quot;)));
<span class="lineNum">      83 </span>            :     PG_RETURN_DATUM(0);
<span class="lineNum">      84 </span>            : }
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : #define SINGOUTSTR  &quot;%d true bits, %d false bits&quot;
<span class="lineNum">      87 </span>            : #define ARROUTSTR   &quot;%d unique words&quot;
<span class="lineNum">      88 </span>            : #define EXTRALEN    ( 2*13 )
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : static int  outbuf_maxlen = 0;
<a name="91"><span class="lineNum">      91 </span>            : </a>
<span class="lineNum">      92 </span>            : Datum
<span class="lineNum">      93 </span><span class="lineNoCov">          0 : gtsvectorout(PG_FUNCTION_ARGS)</span>
<span class="lineNum">      94 </span>            : {
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :     SignTSVector *key = (SignTSVector *) PG_DETOAST_DATUM(PG_GETARG_POINTER(0));</span>
<span class="lineNum">      96 </span>            :     char       *outbuf;
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :     if (outbuf_maxlen == 0)</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :         outbuf_maxlen = 2 * EXTRALEN + Max(strlen(SINGOUTSTR), strlen(ARROUTSTR)) + 1;</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :     outbuf = palloc(outbuf_maxlen);</span>
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :     if (ISARRKEY(key))</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :         sprintf(outbuf, ARROUTSTR, (int) ARRNELEM(key));</span>
<span class="lineNum">     104 </span>            :     else
<span class="lineNum">     105 </span>            :     {
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :         int         cnttrue = (ISALLTRUE(key)) ? SIGLENBIT : sizebitvec(GETSIGN(key));</span>
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :         sprintf(outbuf, SINGOUTSTR, cnttrue, (int) SIGLENBIT - cnttrue);</span>
<span class="lineNum">     109 </span>            :     }
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :     PG_FREE_IF_COPY(key, 0);</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :     PG_RETURN_POINTER(outbuf);</span>
<span class="lineNum">     113 </span>            : }
<a name="114"><span class="lineNum">     114 </span>            : </a>
<span class="lineNum">     115 </span>            : static int
<span class="lineNum">     116 </span><span class="lineCov">     403398 : compareint(const void *va, const void *vb)</span>
<span class="lineNum">     117 </span>            : {
<span class="lineNum">     118 </span><span class="lineCov">     403398 :     int32       a = *((const int32 *) va);</span>
<span class="lineNum">     119 </span><span class="lineCov">     403398 :     int32       b = *((const int32 *) vb);</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span><span class="lineCov">     403398 :     if (a == b)</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     123 </span><span class="lineCov">     403398 :     return (a &gt; b) ? 1 : -1;</span>
<span class="lineNum">     124 </span>            : }
<a name="125"><span class="lineNum">     125 </span>            : </a>
<span class="lineNum">     126 </span>            : static void
<span class="lineNum">     127 </span><span class="lineCov">      10674 : makesign(BITVECP sign, SignTSVector *a)</span>
<span class="lineNum">     128 </span>            : {
<span class="lineNum">     129 </span>            :     int32       k,
<span class="lineNum">     130 </span><span class="lineCov">      10674 :                 len = ARRNELEM(a);</span>
<span class="lineNum">     131 </span><span class="lineCov">      10674 :     int32      *ptr = GETARR(a);</span>
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span><span class="lineCov">      10674 :     MemSet((void *) sign, 0, sizeof(BITVEC));</span>
<span class="lineNum">     134 </span><span class="lineCov">     627486 :     for (k = 0; k &lt; len; k++)</span>
<span class="lineNum">     135 </span><span class="lineCov">     616812 :         HASH(sign, ptr[k]);</span>
<span class="lineNum">     136 </span><span class="lineCov">      10674 : }</span>
<a name="137"><span class="lineNum">     137 </span>            : </a>
<span class="lineNum">     138 </span>            : Datum
<span class="lineNum">     139 </span><span class="lineCov">       2004 : gtsvector_compress(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     140 </span>            : {
<span class="lineNum">     141 </span><span class="lineCov">       2004 :     GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);</span>
<span class="lineNum">     142 </span><span class="lineCov">       2004 :     GISTENTRY  *retval = entry;</span>
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span><span class="lineCov">       2004 :     if (entry-&gt;leafkey)</span>
<span class="lineNum">     145 </span>            :     {                           /* tsvector */
<span class="lineNum">     146 </span>            :         SignTSVector *res;
<span class="lineNum">     147 </span><span class="lineCov">       1016 :         TSVector    val = DatumGetTSVector(entry-&gt;key);</span>
<span class="lineNum">     148 </span>            :         int32       len;
<span class="lineNum">     149 </span>            :         int32      *arr;
<span class="lineNum">     150 </span><span class="lineCov">       1016 :         WordEntry  *ptr = ARRPTR(val);</span>
<span class="lineNum">     151 </span><span class="lineCov">       1016 :         char       *words = STRPTR(val);</span>
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineCov">       1016 :         len = CALCGTSIZE(ARRKEY, val-&gt;size);</span>
<span class="lineNum">     154 </span><span class="lineCov">       1016 :         res = (SignTSVector *) palloc(len);</span>
<span class="lineNum">     155 </span><span class="lineCov">       1016 :         SET_VARSIZE(res, len);</span>
<span class="lineNum">     156 </span><span class="lineCov">       1016 :         res-&gt;flag = ARRKEY;</span>
<span class="lineNum">     157 </span><span class="lineCov">       1016 :         arr = GETARR(res);</span>
<span class="lineNum">     158 </span><span class="lineCov">       1016 :         len = val-&gt;size;</span>
<span class="lineNum">     159 </span><span class="lineCov">      59666 :         while (len--)</span>
<span class="lineNum">     160 </span>            :         {
<span class="lineNum">     161 </span>            :             pg_crc32    c;
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span><span class="lineCov">      57634 :             INIT_LEGACY_CRC32(c);</span>
<span class="lineNum">     164 </span><span class="lineCov">      57634 :             COMP_LEGACY_CRC32(c, words + ptr-&gt;pos, ptr-&gt;len);</span>
<span class="lineNum">     165 </span><span class="lineCov">      57634 :             FIN_LEGACY_CRC32(c);</span>
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span><span class="lineCov">      57634 :             *arr = *(int32 *) &amp;c;</span>
<span class="lineNum">     168 </span><span class="lineCov">      57634 :             arr++;</span>
<span class="lineNum">     169 </span><span class="lineCov">      57634 :             ptr++;</span>
<span class="lineNum">     170 </span>            :         }
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineCov">       1016 :         qsort(GETARR(res), val-&gt;size, sizeof(int), compareint);</span>
<span class="lineNum">     173 </span><span class="lineCov">       1016 :         len = qunique(GETARR(res), val-&gt;size, sizeof(int), compareint);</span>
<span class="lineNum">     174 </span><span class="lineCov">       1016 :         if (len != val-&gt;size)</span>
<span class="lineNum">     175 </span>            :         {
<span class="lineNum">     176 </span>            :             /*
<span class="lineNum">     177 </span>            :              * there is a collision of hash-function; len is always less than
<span class="lineNum">     178 </span>            :              * val-&gt;size
<span class="lineNum">     179 </span>            :              */
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :             len = CALCGTSIZE(ARRKEY, len);</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :             res = (SignTSVector *) repalloc((void *) res, len);</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :             SET_VARSIZE(res, len);</span>
<span class="lineNum">     183 </span>            :         }
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            :         /* make signature, if array is too long */
<span class="lineNum">     186 </span><span class="lineCov">       1016 :         if (VARSIZE(res) &gt; TOAST_INDEX_TARGET)</span>
<span class="lineNum">     187 </span>            :         {
<span class="lineNum">     188 </span>            :             SignTSVector *ressign;
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :             len = CALCGTSIZE(SIGNKEY, 0);</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :             ressign = (SignTSVector *) palloc(len);</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :             SET_VARSIZE(ressign, len);</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :             ressign-&gt;flag = SIGNKEY;</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :             makesign(GETSIGN(ressign), res);</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :             res = ressign;</span>
<span class="lineNum">     196 </span>            :         }
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span><span class="lineCov">       1016 :         retval = (GISTENTRY *) palloc(sizeof(GISTENTRY));</span>
<span class="lineNum">     199 </span><span class="lineCov">       1016 :         gistentryinit(*retval, PointerGetDatum(res),</span>
<span class="lineNum">     200 </span>            :                       entry-&gt;rel, entry-&gt;page,
<span class="lineNum">     201 </span>            :                       entry-&gt;offset, false);
<span class="lineNum">     202 </span>            :     }
<span class="lineNum">     203 </span><span class="lineCov">       1976 :     else if (ISSIGNKEY(DatumGetPointer(entry-&gt;key)) &amp;&amp;</span>
<span class="lineNum">     204 </span><span class="lineCov">        988 :              !ISALLTRUE(DatumGetPointer(entry-&gt;key)))</span>
<span class="lineNum">     205 </span>            :     {
<span class="lineNum">     206 </span>            :         int32       i,
<span class="lineNum">     207 </span>            :                     len;
<span class="lineNum">     208 </span>            :         SignTSVector *res;
<span class="lineNum">     209 </span><span class="lineCov">        988 :         BITVECP     sign = GETSIGN(DatumGetPointer(entry-&gt;key));</span>
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span><span class="lineCov">        988 :         LOOPBYTE</span>
<span class="lineNum">     212 </span>            :         {
<span class="lineNum">     213 </span><span class="lineCov">        988 :             if ((sign[i] &amp; 0xff) != 0xff)</span>
<span class="lineNum">     214 </span><span class="lineCov">        988 :                 PG_RETURN_POINTER(retval);</span>
<span class="lineNum">     215 </span>            :         }
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :         len = CALCGTSIZE(SIGNKEY | ALLISTRUE, 0);</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :         res = (SignTSVector *) palloc(len);</span>
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :         SET_VARSIZE(res, len);</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :         res-&gt;flag = SIGNKEY | ALLISTRUE;</span>
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         retval = (GISTENTRY *) palloc(sizeof(GISTENTRY));</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :         gistentryinit(*retval, PointerGetDatum(res),</span>
<span class="lineNum">     224 </span>            :                       entry-&gt;rel, entry-&gt;page,
<span class="lineNum">     225 </span>            :                       entry-&gt;offset, false);
<span class="lineNum">     226 </span>            :     }
<span class="lineNum">     227 </span><span class="lineCov">       1016 :     PG_RETURN_POINTER(retval);</span>
<span class="lineNum">     228 </span>            : }
<a name="229"><span class="lineNum">     229 </span>            : </a>
<span class="lineNum">     230 </span>            : Datum
<span class="lineNum">     231 </span><span class="lineCov">      33646 : gtsvector_decompress(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     232 </span>            : {
<span class="lineNum">     233 </span>            :     /*
<span class="lineNum">     234 </span>            :      * We need to detoast the stored value, because the other gtsvector
<span class="lineNum">     235 </span>            :      * support functions don't cope with toasted values.
<span class="lineNum">     236 </span>            :      */
<span class="lineNum">     237 </span><span class="lineCov">      33646 :     GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);</span>
<span class="lineNum">     238 </span><span class="lineCov">      33646 :     SignTSVector *key = (SignTSVector *) PG_DETOAST_DATUM(entry-&gt;key);</span>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span><span class="lineCov">      33646 :     if (key != (SignTSVector *) DatumGetPointer(entry-&gt;key))</span>
<span class="lineNum">     241 </span>            :     {
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :         GISTENTRY  *retval = (GISTENTRY *) palloc(sizeof(GISTENTRY));</span>
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :         gistentryinit(*retval, PointerGetDatum(key),</span>
<span class="lineNum">     245 </span>            :                       entry-&gt;rel, entry-&gt;page,
<span class="lineNum">     246 </span>            :                       entry-&gt;offset, false);
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         PG_RETURN_POINTER(retval);</span>
<span class="lineNum">     249 </span>            :     }
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineCov">      33646 :     PG_RETURN_POINTER(entry);</span>
<span class="lineNum">     252 </span>            : }
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            : typedef struct
<span class="lineNum">     255 </span>            : {
<span class="lineNum">     256 </span>            :     int32      *arrb;
<span class="lineNum">     257 </span>            :     int32      *arre;
<span class="lineNum">     258 </span>            : } CHKVAL;
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            : /*
<span class="lineNum">     261 </span>            :  * is there value 'val' in array or not ?
<a name="262"><span class="lineNum">     262 </span>            :  */</a>
<span class="lineNum">     263 </span>            : static bool
<span class="lineNum">     264 </span><span class="lineCov">      28516 : checkcondition_arr(void *checkval, QueryOperand *val, ExecPhraseData *data)</span>
<span class="lineNum">     265 </span>            : {
<span class="lineNum">     266 </span><span class="lineCov">      28516 :     int32      *StopLow = ((CHKVAL *) checkval)-&gt;arrb;</span>
<span class="lineNum">     267 </span><span class="lineCov">      28516 :     int32      *StopHigh = ((CHKVAL *) checkval)-&gt;arre;</span>
<span class="lineNum">     268 </span>            :     int32      *StopMiddle;
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :     /* Loop invariant: StopLow &lt;= val &lt; StopHigh */
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            :     /*
<span class="lineNum">     273 </span>            :      * we are not able to find a prefix by hash value
<span class="lineNum">     274 </span>            :      */
<span class="lineNum">     275 </span><span class="lineCov">      28516 :     if (val-&gt;prefix)</span>
<span class="lineNum">     276 </span><span class="lineCov">       2032 :         return true;</span>
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span><span class="lineCov">     197394 :     while (StopLow &lt; StopHigh)</span>
<span class="lineNum">     279 </span>            :     {
<span class="lineNum">     280 </span><span class="lineCov">     147620 :         StopMiddle = StopLow + (StopHigh - StopLow) / 2;</span>
<span class="lineNum">     281 </span><span class="lineCov">     147620 :         if (*StopMiddle == val-&gt;valcrc)</span>
<span class="lineNum">     282 </span><span class="lineCov">       3194 :             return true;</span>
<span class="lineNum">     283 </span><span class="lineCov">     144426 :         else if (*StopMiddle &lt; val-&gt;valcrc)</span>
<span class="lineNum">     284 </span><span class="lineCov">      53564 :             StopLow = StopMiddle + 1;</span>
<span class="lineNum">     285 </span>            :         else
<span class="lineNum">     286 </span><span class="lineCov">      90862 :             StopHigh = StopMiddle;</span>
<span class="lineNum">     287 </span>            :     }
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineCov">      23290 :     return false;</span>
<span class="lineNum">     290 </span>            : }
<a name="291"><span class="lineNum">     291 </span>            : </a>
<span class="lineNum">     292 </span>            : static bool
<span class="lineNum">     293 </span><span class="lineCov">        996 : checkcondition_bit(void *checkval, QueryOperand *val, ExecPhraseData *data)</span>
<span class="lineNum">     294 </span>            : {
<span class="lineNum">     295 </span>            :     /*
<span class="lineNum">     296 </span>            :      * we are not able to find a prefix in signature tree
<span class="lineNum">     297 </span>            :      */
<span class="lineNum">     298 </span><span class="lineCov">        996 :     if (val-&gt;prefix)</span>
<span class="lineNum">     299 </span><span class="lineCov">         76 :         return true;</span>
<span class="lineNum">     300 </span><span class="lineCov">        920 :     return GETBIT(checkval, HASHVAL(val-&gt;valcrc));</span>
<span class="lineNum">     301 </span>            : }
<a name="302"><span class="lineNum">     302 </span>            : </a>
<span class="lineNum">     303 </span>            : Datum
<span class="lineNum">     304 </span><span class="lineCov">      20152 : gtsvector_consistent(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     305 </span>            : {
<span class="lineNum">     306 </span><span class="lineCov">      20152 :     GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);</span>
<span class="lineNum">     307 </span><span class="lineCov">      20152 :     TSQuery     query = PG_GETARG_TSQUERY(1);</span>
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            :     /* StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2); */
<span class="lineNum">     310 </span>            :     /* Oid      subtype = PG_GETARG_OID(3); */
<span class="lineNum">     311 </span><span class="lineCov">      20152 :     bool       *recheck = (bool *) PG_GETARG_POINTER(4);</span>
<span class="lineNum">     312 </span><span class="lineCov">      20152 :     SignTSVector *key = (SignTSVector *) DatumGetPointer(entry-&gt;key);</span>
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            :     /* All cases served by this function are inexact */
<span class="lineNum">     315 </span><span class="lineCov">      20152 :     *recheck = true;</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span><span class="lineCov">      20152 :     if (!query-&gt;size)</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :         PG_RETURN_BOOL(false);</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineCov">      20152 :     if (ISSIGNKEY(key))</span>
<span class="lineNum">     321 </span>            :     {
<span class="lineNum">     322 </span><span class="lineCov">        760 :         if (ISALLTRUE(key))</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :             PG_RETURN_BOOL(true);</span>
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            :         /* since signature is lossy, cannot specify CALC_NOT here */
<span class="lineNum">     326 </span><span class="lineCov">        760 :         PG_RETURN_BOOL(TS_execute(GETQUERY(query),</span>
<span class="lineNum">     327 </span>            :                                   (void *) GETSIGN(key),
<span class="lineNum">     328 </span>            :                                   TS_EXEC_PHRASE_NO_POS,
<span class="lineNum">     329 </span>            :                                   checkcondition_bit));
<span class="lineNum">     330 </span>            :     }
<span class="lineNum">     331 </span>            :     else
<span class="lineNum">     332 </span>            :     {                           /* only leaf pages */
<span class="lineNum">     333 </span>            :         CHKVAL      chkval;
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span><span class="lineCov">      19392 :         chkval.arrb = GETARR(key);</span>
<span class="lineNum">     336 </span><span class="lineCov">      19392 :         chkval.arre = chkval.arrb + ARRNELEM(key);</span>
<span class="lineNum">     337 </span><span class="lineCov">      19392 :         PG_RETURN_BOOL(TS_execute(GETQUERY(query),</span>
<span class="lineNum">     338 </span>            :                                   (void *) &amp;chkval,
<span class="lineNum">     339 </span>            :                                   TS_EXEC_PHRASE_NO_POS | TS_EXEC_CALC_NOT,
<span class="lineNum">     340 </span>            :                                   checkcondition_arr));
<span class="lineNum">     341 </span>            :     }
<span class="lineNum">     342 </span>            : }
<a name="343"><span class="lineNum">     343 </span>            : </a>
<span class="lineNum">     344 </span>            : static int32
<span class="lineNum">     345 </span><span class="lineCov">       1880 : unionkey(BITVECP sbase, SignTSVector *add)</span>
<span class="lineNum">     346 </span>            : {
<span class="lineNum">     347 </span>            :     int32       i;
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span><span class="lineCov">       1880 :     if (ISSIGNKEY(add))</span>
<span class="lineNum">     350 </span>            :     {
<span class="lineNum">     351 </span><span class="lineCov">        940 :         BITVECP     sadd = GETSIGN(add);</span>
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span><span class="lineCov">        940 :         if (ISALLTRUE(add))</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :             return 1;</span>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span><span class="lineCov">     117500 :         LOOPBYTE</span>
<span class="lineNum">     357 </span><span class="lineCov">     116560 :             sbase[i] |= sadd[i];</span>
<span class="lineNum">     358 </span>            :     }
<span class="lineNum">     359 </span>            :     else
<span class="lineNum">     360 </span>            :     {
<span class="lineNum">     361 </span><span class="lineCov">        940 :         int32      *ptr = GETARR(add);</span>
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span><span class="lineCov">      55318 :         for (i = 0; i &lt; ARRNELEM(add); i++)</span>
<span class="lineNum">     364 </span><span class="lineCov">      54378 :             HASH(sbase, ptr[i]);</span>
<span class="lineNum">     365 </span>            :     }
<span class="lineNum">     366 </span><span class="lineCov">       1880 :     return 0;</span>
<span class="lineNum">     367 </span>            : }
<span class="lineNum">     368 </span>            : 
<a name="369"><span class="lineNum">     369 </span>            : </a>
<span class="lineNum">     370 </span>            : Datum
<span class="lineNum">     371 </span><span class="lineCov">        940 : gtsvector_union(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     372 </span>            : {
<span class="lineNum">     373 </span><span class="lineCov">        940 :     GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);</span>
<span class="lineNum">     374 </span><span class="lineCov">        940 :     int        *size = (int *) PG_GETARG_POINTER(1);</span>
<span class="lineNum">     375 </span>            :     BITVEC      base;
<span class="lineNum">     376 </span>            :     int32       i,
<span class="lineNum">     377 </span>            :                 len;
<span class="lineNum">     378 </span><span class="lineCov">        940 :     int32       flag = 0;</span>
<span class="lineNum">     379 </span>            :     SignTSVector *result;
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineCov">        940 :     MemSet((void *) base, 0, sizeof(BITVEC));</span>
<span class="lineNum">     382 </span><span class="lineCov">       2820 :     for (i = 0; i &lt; entryvec-&gt;n; i++)</span>
<span class="lineNum">     383 </span>            :     {
<span class="lineNum">     384 </span><span class="lineCov">       1880 :         if (unionkey(base, GETENTRY(entryvec, i)))</span>
<span class="lineNum">     385 </span>            :         {
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :             flag = ALLISTRUE;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     388 </span>            :         }
<span class="lineNum">     389 </span>            :     }
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span><span class="lineCov">        940 :     flag |= SIGNKEY;</span>
<span class="lineNum">     392 </span><span class="lineCov">        940 :     len = CALCGTSIZE(flag, 0);</span>
<span class="lineNum">     393 </span><span class="lineCov">        940 :     result = (SignTSVector *) palloc(len);</span>
<span class="lineNum">     394 </span><span class="lineCov">        940 :     *size = len;</span>
<span class="lineNum">     395 </span><span class="lineCov">        940 :     SET_VARSIZE(result, len);</span>
<span class="lineNum">     396 </span><span class="lineCov">        940 :     result-&gt;flag = flag;</span>
<span class="lineNum">     397 </span><span class="lineCov">        940 :     if (!ISALLTRUE(result))</span>
<span class="lineNum">     398 </span><span class="lineCov">        940 :         memcpy((void *) GETSIGN(result), (void *) base, sizeof(BITVEC));</span>
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span><span class="lineCov">        940 :     PG_RETURN_POINTER(result);</span>
<span class="lineNum">     401 </span>            : }
<a name="402"><span class="lineNum">     402 </span>            : </a>
<span class="lineNum">     403 </span>            : Datum
<span class="lineNum">     404 </span><span class="lineCov">        940 : gtsvector_same(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     405 </span>            : {
<span class="lineNum">     406 </span><span class="lineCov">        940 :     SignTSVector *a = (SignTSVector *) PG_GETARG_POINTER(0);</span>
<span class="lineNum">     407 </span><span class="lineCov">        940 :     SignTSVector *b = (SignTSVector *) PG_GETARG_POINTER(1);</span>
<span class="lineNum">     408 </span><span class="lineCov">        940 :     bool       *result = (bool *) PG_GETARG_POINTER(2);</span>
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span><span class="lineCov">        940 :     if (ISSIGNKEY(a))</span>
<span class="lineNum">     411 </span>            :     {                           /* then b also ISSIGNKEY */
<span class="lineNum">     412 </span><span class="lineCov">        940 :         if (ISALLTRUE(a) &amp;&amp; ISALLTRUE(b))</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :             *result = true;</span>
<span class="lineNum">     414 </span><span class="lineCov">        940 :         else if (ISALLTRUE(a))</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :             *result = false;</span>
<span class="lineNum">     416 </span><span class="lineCov">        940 :         else if (ISALLTRUE(b))</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :             *result = false;</span>
<span class="lineNum">     418 </span>            :         else
<span class="lineNum">     419 </span>            :         {
<span class="lineNum">     420 </span>            :             int32       i;
<span class="lineNum">     421 </span><span class="lineCov">        940 :             BITVECP     sa = GETSIGN(a),</span>
<span class="lineNum">     422 </span><span class="lineCov">        940 :                         sb = GETSIGN(b);</span>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span><span class="lineCov">        940 :             *result = true;</span>
<span class="lineNum">     425 </span><span class="lineCov">      18602 :             LOOPBYTE</span>
<span class="lineNum">     426 </span>            :             {
<span class="lineNum">     427 </span><span class="lineCov">      18578 :                 if (sa[i] != sb[i])</span>
<span class="lineNum">     428 </span>            :                 {
<span class="lineNum">     429 </span><span class="lineCov">        916 :                     *result = false;</span>
<span class="lineNum">     430 </span><span class="lineCov">        916 :                     break;</span>
<span class="lineNum">     431 </span>            :                 }
<span class="lineNum">     432 </span>            :             }
<span class="lineNum">     433 </span>            :         }
<span class="lineNum">     434 </span>            :     }
<span class="lineNum">     435 </span>            :     else
<span class="lineNum">     436 </span>            :     {                           /* a and b ISARRKEY */
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :         int32       lena = ARRNELEM(a),</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :                     lenb = ARRNELEM(b);</span>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :         if (lena != lenb)</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :             *result = false;</span>
<span class="lineNum">     442 </span>            :         else
<span class="lineNum">     443 </span>            :         {
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :             int32      *ptra = GETARR(a),</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :                        *ptrb = GETARR(b);</span>
<span class="lineNum">     446 </span>            :             int32       i;
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :             *result = true;</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :             for (i = 0; i &lt; lena; i++)</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :                 if (ptra[i] != ptrb[i])</span>
<span class="lineNum">     451 </span>            :                 {
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :                     *result = false;</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     454 </span>            :                 }
<span class="lineNum">     455 </span>            :         }
<span class="lineNum">     456 </span>            :     }
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineCov">        940 :     PG_RETURN_POINTER(result);</span>
<span class="lineNum">     459 </span>            : }
<a name="460"><span class="lineNum">     460 </span>            : </a>
<span class="lineNum">     461 </span>            : static int32
<span class="lineNum">     462 </span><span class="lineNoCov">          0 : sizebitvec(BITVECP sign)</span>
<span class="lineNum">     463 </span>            : {
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :     return pg_popcount(sign, SIGLEN);</span>
<span class="lineNum">     465 </span>            : }
<a name="466"><span class="lineNum">     466 </span>            : </a>
<span class="lineNum">     467 </span>            : static int
<span class="lineNum">     468 </span><span class="lineCov">      31232 : hemdistsign(BITVECP a, BITVECP b)</span>
<span class="lineNum">     469 </span>            : {
<span class="lineNum">     470 </span>            :     int         i,
<span class="lineNum">     471 </span>            :                 diff,
<span class="lineNum">     472 </span><span class="lineCov">      31232 :                 dist = 0;</span>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span><span class="lineCov">    3904000 :     LOOPBYTE</span>
<span class="lineNum">     475 </span>            :     {
<span class="lineNum">     476 </span><span class="lineCov">    3872768 :         diff = (unsigned char) (a[i] ^ b[i]);</span>
<span class="lineNum">     477 </span>            :         /* Using the popcount functions here isn't likely to win */
<span class="lineNum">     478 </span><span class="lineCov">    3872768 :         dist += pg_number_of_ones[diff];</span>
<span class="lineNum">     479 </span>            :     }
<span class="lineNum">     480 </span><span class="lineCov">      31232 :     return dist;</span>
<span class="lineNum">     481 </span>            : }
<a name="482"><span class="lineNum">     482 </span>            : </a>
<span class="lineNum">     483 </span>            : static int
<span class="lineNum">     484 </span><span class="lineNoCov">          0 : hemdist(SignTSVector *a, SignTSVector *b)</span>
<span class="lineNum">     485 </span>            : {
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :     if (ISALLTRUE(a))</span>
<span class="lineNum">     487 </span>            :     {
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :         if (ISALLTRUE(b))</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     490 </span>            :         else
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :             return SIGLENBIT - sizebitvec(GETSIGN(b));</span>
<span class="lineNum">     492 </span>            :     }
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     else if (ISALLTRUE(b))</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :         return SIGLENBIT - sizebitvec(GETSIGN(a));</span>
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     return hemdistsign(GETSIGN(a), GETSIGN(b));</span>
<span class="lineNum">     497 </span>            : }
<a name="498"><span class="lineNum">     498 </span>            : </a>
<span class="lineNum">     499 </span>            : Datum
<span class="lineNum">     500 </span><span class="lineCov">       9516 : gtsvector_penalty(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     501 </span>            : {
<span class="lineNum">     502 </span><span class="lineCov">       9516 :     GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0); /* always ISSIGNKEY */</span>
<span class="lineNum">     503 </span><span class="lineCov">       9516 :     GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);</span>
<span class="lineNum">     504 </span><span class="lineCov">       9516 :     float      *penalty = (float *) PG_GETARG_POINTER(2);</span>
<span class="lineNum">     505 </span><span class="lineCov">       9516 :     SignTSVector *origval = (SignTSVector *) DatumGetPointer(origentry-&gt;key);</span>
<span class="lineNum">     506 </span><span class="lineCov">       9516 :     SignTSVector *newval = (SignTSVector *) DatumGetPointer(newentry-&gt;key);</span>
<span class="lineNum">     507 </span><span class="lineCov">       9516 :     BITVECP     orig = GETSIGN(origval);</span>
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span><span class="lineCov">       9516 :     *penalty = 0.0;</span>
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span><span class="lineCov">       9516 :     if (ISARRKEY(newval))</span>
<span class="lineNum">     512 </span>            :     {
<span class="lineNum">     513 </span>            :         BITVEC      sign;
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span><span class="lineCov">       9516 :         makesign(sign, newval);</span>
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span><span class="lineCov">       9516 :         if (ISALLTRUE(origval))</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :             *penalty = ((float) (SIGLENBIT - sizebitvec(sign))) / (float) (SIGLENBIT + 1);</span>
<span class="lineNum">     519 </span>            :         else
<span class="lineNum">     520 </span><span class="lineCov">       9516 :             *penalty = hemdistsign(sign, orig);</span>
<span class="lineNum">     521 </span>            :     }
<span class="lineNum">     522 </span>            :     else
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :         *penalty = hemdist(origval, newval);</span>
<span class="lineNum">     524 </span><span class="lineCov">       9516 :     PG_RETURN_POINTER(penalty);</span>
<span class="lineNum">     525 </span>            : }
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            : typedef struct
<span class="lineNum">     528 </span>            : {
<span class="lineNum">     529 </span>            :     bool        allistrue;
<span class="lineNum">     530 </span>            :     BITVEC      sign;
<span class="lineNum">     531 </span>            : } CACHESIGN;
<a name="532"><span class="lineNum">     532 </span>            : </a>
<span class="lineNum">     533 </span>            : static void
<span class="lineNum">     534 </span><span class="lineCov">       1158 : fillcache(CACHESIGN *item, SignTSVector *key)</span>
<span class="lineNum">     535 </span>            : {
<span class="lineNum">     536 </span><span class="lineCov">       1158 :     item-&gt;allistrue = false;</span>
<span class="lineNum">     537 </span><span class="lineCov">       1158 :     if (ISARRKEY(key))</span>
<span class="lineNum">     538 </span><span class="lineCov">       1158 :         makesign(item-&gt;sign, key);</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     else if (ISALLTRUE(key))</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :         item-&gt;allistrue = true;</span>
<span class="lineNum">     541 </span>            :     else
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :         memcpy((void *) item-&gt;sign, (void *) GETSIGN(key), sizeof(BITVEC));</span>
<span class="lineNum">     543 </span><span class="lineCov">       1158 : }</span>
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            : #define WISH_F(a,b,c) (double)( -(double)(((a)-(b))*((a)-(b))*((a)-(b)))*(c) )
<span class="lineNum">     546 </span>            : typedef struct
<span class="lineNum">     547 </span>            : {
<span class="lineNum">     548 </span>            :     OffsetNumber pos;
<span class="lineNum">     549 </span>            :     int32       cost;
<span class="lineNum">     550 </span>            : } SPLITCOST;
<a name="551"><span class="lineNum">     551 </span>            : </a>
<span class="lineNum">     552 </span>            : static int
<span class="lineNum">     553 </span><span class="lineCov">       3842 : comparecost(const void *va, const void *vb)</span>
<span class="lineNum">     554 </span>            : {
<span class="lineNum">     555 </span><span class="lineCov">       3842 :     const SPLITCOST *a = (const SPLITCOST *) va;</span>
<span class="lineNum">     556 </span><span class="lineCov">       3842 :     const SPLITCOST *b = (const SPLITCOST *) vb;</span>
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span><span class="lineCov">       3842 :     if (a-&gt;cost == b-&gt;cost)</span>
<span class="lineNum">     559 </span><span class="lineCov">        926 :         return 0;</span>
<span class="lineNum">     560 </span>            :     else
<span class="lineNum">     561 </span><span class="lineCov">       2916 :         return (a-&gt;cost &gt; b-&gt;cost) ? 1 : -1;</span>
<span class="lineNum">     562 </span>            : }
<span class="lineNum">     563 </span>            : 
<a name="564"><span class="lineNum">     564 </span>            : </a>
<span class="lineNum">     565 </span>            : static int
<span class="lineNum">     566 </span><span class="lineCov">      19544 : hemdistcache(CACHESIGN *a, CACHESIGN *b)</span>
<span class="lineNum">     567 </span>            : {
<span class="lineNum">     568 </span><span class="lineCov">      19544 :     if (a-&gt;allistrue)</span>
<span class="lineNum">     569 </span>            :     {
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :         if (b-&gt;allistrue)</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     572 </span>            :         else
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :             return SIGLENBIT - sizebitvec(b-&gt;sign);</span>
<span class="lineNum">     574 </span>            :     }
<span class="lineNum">     575 </span><span class="lineCov">      19544 :     else if (b-&gt;allistrue)</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :         return SIGLENBIT - sizebitvec(a-&gt;sign);</span>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span><span class="lineCov">      19544 :     return hemdistsign(a-&gt;sign, b-&gt;sign);</span>
<span class="lineNum">     579 </span>            : }
<a name="580"><span class="lineNum">     580 </span>            : </a>
<span class="lineNum">     581 </span>            : Datum
<span class="lineNum">     582 </span><span class="lineCov">         36 : gtsvector_picksplit(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     583 </span>            : {
<span class="lineNum">     584 </span><span class="lineCov">         36 :     GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);</span>
<span class="lineNum">     585 </span><span class="lineCov">         36 :     GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);</span>
<span class="lineNum">     586 </span>            :     OffsetNumber k,
<span class="lineNum">     587 </span>            :                 j;
<span class="lineNum">     588 </span>            :     SignTSVector *datum_l,
<span class="lineNum">     589 </span>            :                *datum_r;
<span class="lineNum">     590 </span>            :     BITVECP     union_l,
<span class="lineNum">     591 </span>            :                 union_r;
<span class="lineNum">     592 </span>            :     int32       size_alpha,
<span class="lineNum">     593 </span>            :                 size_beta;
<span class="lineNum">     594 </span>            :     int32       size_waste,
<span class="lineNum">     595 </span><span class="lineCov">         36 :                 waste = -1;</span>
<span class="lineNum">     596 </span>            :     int32       nbytes;
<span class="lineNum">     597 </span><span class="lineCov">         36 :     OffsetNumber seed_1 = 0,</span>
<span class="lineNum">     598 </span><span class="lineCov">         36 :                 seed_2 = 0;</span>
<span class="lineNum">     599 </span>            :     OffsetNumber *left,
<span class="lineNum">     600 </span>            :                *right;
<span class="lineNum">     601 </span>            :     OffsetNumber maxoff;
<span class="lineNum">     602 </span>            :     BITVECP     ptr;
<span class="lineNum">     603 </span>            :     int         i;
<span class="lineNum">     604 </span>            :     CACHESIGN  *cache;
<span class="lineNum">     605 </span>            :     SPLITCOST  *costvector;
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span><span class="lineCov">         36 :     maxoff = entryvec-&gt;n - 2;</span>
<span class="lineNum">     608 </span><span class="lineCov">         36 :     nbytes = (maxoff + 2) * sizeof(OffsetNumber);</span>
<span class="lineNum">     609 </span><span class="lineCov">         36 :     v-&gt;spl_left = (OffsetNumber *) palloc(nbytes);</span>
<span class="lineNum">     610 </span><span class="lineCov">         36 :     v-&gt;spl_right = (OffsetNumber *) palloc(nbytes);</span>
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span><span class="lineCov">         36 :     cache = (CACHESIGN *) palloc(sizeof(CACHESIGN) * (maxoff + 2));</span>
<span class="lineNum">     613 </span><span class="lineCov">         36 :     fillcache(&amp;cache[FirstOffsetNumber], GETENTRY(entryvec, FirstOffsetNumber));</span>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineCov">       1122 :     for (k = FirstOffsetNumber; k &lt; maxoff; k = OffsetNumberNext(k))</span>
<span class="lineNum">     616 </span>            :     {
<span class="lineNum">     617 </span><span class="lineCov">      18314 :         for (j = OffsetNumberNext(k); j &lt;= maxoff; j = OffsetNumberNext(j))</span>
<span class="lineNum">     618 </span>            :         {
<span class="lineNum">     619 </span><span class="lineCov">      17228 :             if (k == FirstOffsetNumber)</span>
<span class="lineNum">     620 </span><span class="lineCov">       1086 :                 fillcache(&amp;cache[j], GETENTRY(entryvec, j));</span>
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span><span class="lineCov">      17228 :             size_waste = hemdistcache(&amp;(cache[j]), &amp;(cache[k]));</span>
<span class="lineNum">     623 </span><span class="lineCov">      17228 :             if (size_waste &gt; waste)</span>
<span class="lineNum">     624 </span>            :             {
<span class="lineNum">     625 </span><span class="lineCov">        336 :                 waste = size_waste;</span>
<span class="lineNum">     626 </span><span class="lineCov">        336 :                 seed_1 = k;</span>
<span class="lineNum">     627 </span><span class="lineCov">        336 :                 seed_2 = j;</span>
<span class="lineNum">     628 </span>            :             }
<span class="lineNum">     629 </span>            :         }
<span class="lineNum">     630 </span>            :     }
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span><span class="lineCov">         36 :     left = v-&gt;spl_left;</span>
<span class="lineNum">     633 </span><span class="lineCov">         36 :     v-&gt;spl_nleft = 0;</span>
<span class="lineNum">     634 </span><span class="lineCov">         36 :     right = v-&gt;spl_right;</span>
<span class="lineNum">     635 </span><span class="lineCov">         36 :     v-&gt;spl_nright = 0;</span>
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span><span class="lineCov">         36 :     if (seed_1 == 0 || seed_2 == 0)</span>
<span class="lineNum">     638 </span>            :     {
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :         seed_1 = 1;</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :         seed_2 = 2;</span>
<span class="lineNum">     641 </span>            :     }
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :     /* form initial .. */
<span class="lineNum">     644 </span><span class="lineCov">         36 :     if (cache[seed_1].allistrue)</span>
<span class="lineNum">     645 </span>            :     {
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :         datum_l = (SignTSVector *) palloc(CALCGTSIZE(SIGNKEY | ALLISTRUE, 0));</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :         SET_VARSIZE(datum_l, CALCGTSIZE(SIGNKEY | ALLISTRUE, 0));</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :         datum_l-&gt;flag = SIGNKEY | ALLISTRUE;</span>
<span class="lineNum">     649 </span>            :     }
<span class="lineNum">     650 </span>            :     else
<span class="lineNum">     651 </span>            :     {
<span class="lineNum">     652 </span><span class="lineCov">         36 :         datum_l = (SignTSVector *) palloc(CALCGTSIZE(SIGNKEY, 0));</span>
<span class="lineNum">     653 </span><span class="lineCov">         36 :         SET_VARSIZE(datum_l, CALCGTSIZE(SIGNKEY, 0));</span>
<span class="lineNum">     654 </span><span class="lineCov">         36 :         datum_l-&gt;flag = SIGNKEY;</span>
<span class="lineNum">     655 </span><span class="lineCov">         36 :         memcpy((void *) GETSIGN(datum_l), (void *) cache[seed_1].sign, sizeof(BITVEC));</span>
<span class="lineNum">     656 </span>            :     }
<span class="lineNum">     657 </span><span class="lineCov">         36 :     if (cache[seed_2].allistrue)</span>
<span class="lineNum">     658 </span>            :     {
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :         datum_r = (SignTSVector *) palloc(CALCGTSIZE(SIGNKEY | ALLISTRUE, 0));</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :         SET_VARSIZE(datum_r, CALCGTSIZE(SIGNKEY | ALLISTRUE, 0));</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :         datum_r-&gt;flag = SIGNKEY | ALLISTRUE;</span>
<span class="lineNum">     662 </span>            :     }
<span class="lineNum">     663 </span>            :     else
<span class="lineNum">     664 </span>            :     {
<span class="lineNum">     665 </span><span class="lineCov">         36 :         datum_r = (SignTSVector *) palloc(CALCGTSIZE(SIGNKEY, 0));</span>
<span class="lineNum">     666 </span><span class="lineCov">         36 :         SET_VARSIZE(datum_r, CALCGTSIZE(SIGNKEY, 0));</span>
<span class="lineNum">     667 </span><span class="lineCov">         36 :         datum_r-&gt;flag = SIGNKEY;</span>
<span class="lineNum">     668 </span><span class="lineCov">         36 :         memcpy((void *) GETSIGN(datum_r), (void *) cache[seed_2].sign, sizeof(BITVEC));</span>
<span class="lineNum">     669 </span>            :     }
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span><span class="lineCov">         36 :     union_l = GETSIGN(datum_l);</span>
<span class="lineNum">     672 </span><span class="lineCov">         36 :     union_r = GETSIGN(datum_r);</span>
<span class="lineNum">     673 </span><span class="lineCov">         36 :     maxoff = OffsetNumberNext(maxoff);</span>
<span class="lineNum">     674 </span><span class="lineCov">         36 :     fillcache(&amp;cache[maxoff], GETENTRY(entryvec, maxoff));</span>
<span class="lineNum">     675 </span>            :     /* sort before ... */
<span class="lineNum">     676 </span><span class="lineCov">         36 :     costvector = (SPLITCOST *) palloc(sizeof(SPLITCOST) * maxoff);</span>
<span class="lineNum">     677 </span><span class="lineCov">       1194 :     for (j = FirstOffsetNumber; j &lt;= maxoff; j = OffsetNumberNext(j))</span>
<span class="lineNum">     678 </span>            :     {
<span class="lineNum">     679 </span><span class="lineCov">       1158 :         costvector[j - 1].pos = j;</span>
<span class="lineNum">     680 </span><span class="lineCov">       1158 :         size_alpha = hemdistcache(&amp;(cache[seed_1]), &amp;(cache[j]));</span>
<span class="lineNum">     681 </span><span class="lineCov">       1158 :         size_beta = hemdistcache(&amp;(cache[seed_2]), &amp;(cache[j]));</span>
<span class="lineNum">     682 </span><span class="lineCov">       1158 :         costvector[j - 1].cost = Abs(size_alpha - size_beta);</span>
<span class="lineNum">     683 </span>            :     }
<span class="lineNum">     684 </span><span class="lineCov">         36 :     qsort((void *) costvector, maxoff, sizeof(SPLITCOST), comparecost);</span>
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineCov">       1194 :     for (k = 0; k &lt; maxoff; k++)</span>
<span class="lineNum">     687 </span>            :     {
<span class="lineNum">     688 </span><span class="lineCov">       1158 :         j = costvector[k].pos;</span>
<span class="lineNum">     689 </span><span class="lineCov">       1158 :         if (j == seed_1)</span>
<span class="lineNum">     690 </span>            :         {
<span class="lineNum">     691 </span><span class="lineCov">         36 :             *left++ = j;</span>
<span class="lineNum">     692 </span><span class="lineCov">         36 :             v-&gt;spl_nleft++;</span>
<span class="lineNum">     693 </span><span class="lineCov">         36 :             continue;</span>
<span class="lineNum">     694 </span>            :         }
<span class="lineNum">     695 </span><span class="lineCov">       1122 :         else if (j == seed_2)</span>
<span class="lineNum">     696 </span>            :         {
<span class="lineNum">     697 </span><span class="lineCov">         36 :             *right++ = j;</span>
<span class="lineNum">     698 </span><span class="lineCov">         36 :             v-&gt;spl_nright++;</span>
<span class="lineNum">     699 </span><span class="lineCov">         36 :             continue;</span>
<span class="lineNum">     700 </span>            :         }
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span><span class="lineCov">       1086 :         if (ISALLTRUE(datum_l) || cache[j].allistrue)</span>
<span class="lineNum">     703 </span>            :         {
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :             if (ISALLTRUE(datum_l) &amp;&amp; cache[j].allistrue)</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :                 size_alpha = 0;</span>
<span class="lineNum">     706 </span>            :             else
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :                 size_alpha = SIGLENBIT - sizebitvec(</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :                                                     (cache[j].allistrue) ? GETSIGN(datum_l) : GETSIGN(cache[j].sign)</span>
<span class="lineNum">     709 </span>            :                     );
<span class="lineNum">     710 </span>            :         }
<span class="lineNum">     711 </span>            :         else
<span class="lineNum">     712 </span><span class="lineCov">       1086 :             size_alpha = hemdistsign(cache[j].sign, GETSIGN(datum_l));</span>
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span><span class="lineCov">       1086 :         if (ISALLTRUE(datum_r) || cache[j].allistrue)</span>
<span class="lineNum">     715 </span>            :         {
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :             if (ISALLTRUE(datum_r) &amp;&amp; cache[j].allistrue)</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :                 size_beta = 0;</span>
<span class="lineNum">     718 </span>            :             else
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :                 size_beta = SIGLENBIT - sizebitvec(</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :                                                    (cache[j].allistrue) ? GETSIGN(datum_r) : GETSIGN(cache[j].sign)</span>
<span class="lineNum">     721 </span>            :                     );
<span class="lineNum">     722 </span>            :         }
<span class="lineNum">     723 </span>            :         else
<span class="lineNum">     724 </span><span class="lineCov">       1086 :             size_beta = hemdistsign(cache[j].sign, GETSIGN(datum_r));</span>
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span><span class="lineCov">       1086 :         if (size_alpha &lt; size_beta + WISH_F(v-&gt;spl_nleft, v-&gt;spl_nright, 0.1))</span>
<span class="lineNum">     727 </span>            :         {
<span class="lineNum">     728 </span><span class="lineCov">        540 :             if (ISALLTRUE(datum_l) || cache[j].allistrue)</span>
<span class="lineNum">     729 </span>            :             {
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :                 if (!ISALLTRUE(datum_l))</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :                     MemSet((void *) GETSIGN(datum_l), 0xff, sizeof(BITVEC));</span>
<span class="lineNum">     732 </span>            :             }
<span class="lineNum">     733 </span>            :             else
<span class="lineNum">     734 </span>            :             {
<span class="lineNum">     735 </span><span class="lineCov">        540 :                 ptr = cache[j].sign;</span>
<span class="lineNum">     736 </span><span class="lineCov">      67500 :                 LOOPBYTE</span>
<span class="lineNum">     737 </span><span class="lineCov">      66960 :                     union_l[i] |= ptr[i];</span>
<span class="lineNum">     738 </span>            :             }
<span class="lineNum">     739 </span><span class="lineCov">        540 :             *left++ = j;</span>
<span class="lineNum">     740 </span><span class="lineCov">        540 :             v-&gt;spl_nleft++;</span>
<span class="lineNum">     741 </span>            :         }
<span class="lineNum">     742 </span>            :         else
<span class="lineNum">     743 </span>            :         {
<span class="lineNum">     744 </span><span class="lineCov">        546 :             if (ISALLTRUE(datum_r) || cache[j].allistrue)</span>
<span class="lineNum">     745 </span>            :             {
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :                 if (!ISALLTRUE(datum_r))</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :                     MemSet((void *) GETSIGN(datum_r), 0xff, sizeof(BITVEC));</span>
<span class="lineNum">     748 </span>            :             }
<span class="lineNum">     749 </span>            :             else
<span class="lineNum">     750 </span>            :             {
<span class="lineNum">     751 </span><span class="lineCov">        546 :                 ptr = cache[j].sign;</span>
<span class="lineNum">     752 </span><span class="lineCov">      68250 :                 LOOPBYTE</span>
<span class="lineNum">     753 </span><span class="lineCov">      67704 :                     union_r[i] |= ptr[i];</span>
<span class="lineNum">     754 </span>            :             }
<span class="lineNum">     755 </span><span class="lineCov">        546 :             *right++ = j;</span>
<span class="lineNum">     756 </span><span class="lineCov">        546 :             v-&gt;spl_nright++;</span>
<span class="lineNum">     757 </span>            :         }
<span class="lineNum">     758 </span>            :     }
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span><span class="lineCov">         36 :     *right = *left = FirstOffsetNumber;</span>
<span class="lineNum">     761 </span><span class="lineCov">         36 :     v-&gt;spl_ldatum = PointerGetDatum(datum_l);</span>
<span class="lineNum">     762 </span><span class="lineCov">         36 :     v-&gt;spl_rdatum = PointerGetDatum(datum_r);</span>
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span><span class="lineCov">         36 :     PG_RETURN_POINTER(v);</span>
<span class="lineNum">     765 </span>            : }
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span>            : /*
<span class="lineNum">     768 </span>            :  * Formerly, gtsvector_consistent was declared in pg_proc.h with arguments
<span class="lineNum">     769 </span>            :  * that did not match the documented conventions for GiST support functions.
<span class="lineNum">     770 </span>            :  * We fixed that, but we still need a pg_proc entry with the old signature
<span class="lineNum">     771 </span>            :  * to support reloading pre-9.6 contrib/tsearch2 opclass declarations.
<span class="lineNum">     772 </span>            :  * This compatibility function should go away eventually.
<a name="773"><span class="lineNum">     773 </span>            :  */</a>
<span class="lineNum">     774 </span>            : Datum
<span class="lineNum">     775 </span><span class="lineNoCov">          0 : gtsvector_consistent_oldsig(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     776 </span>            : {
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :     return gtsvector_consistent(fcinfo);</span>
<span class="lineNum">     778 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
