<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/storage/lmgr/proc.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/backend/storage/lmgr</a> - proc.c<span style="font-size: 80%;"> (source / <a href="proc.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">371</td>
            <td class="headerCovTableEntry">566</td>
            <td class="headerCovTableEntryLo">65.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntryLo">63.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * proc.c
<span class="lineNum">       4 </span>            :  *    routines to manage per-process shared memory data structure
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * IDENTIFICATION
<span class="lineNum">      11 </span>            :  *    src/backend/storage/lmgr/proc.c
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      14 </span>            :  */
<span class="lineNum">      15 </span>            : /*
<span class="lineNum">      16 </span>            :  * Interface (a):
<span class="lineNum">      17 </span>            :  *      ProcSleep(), ProcWakeup(),
<span class="lineNum">      18 </span>            :  *      ProcQueueAlloc() -- create a shm queue for sleeping processes
<span class="lineNum">      19 </span>            :  *      ProcQueueInit() -- create a queue without allocing memory
<span class="lineNum">      20 </span>            :  *
<span class="lineNum">      21 </span>            :  * Waiting for a lock causes the backend to be put to sleep.  Whoever releases
<span class="lineNum">      22 </span>            :  * the lock wakes the process up again (and gives it an error code so it knows
<span class="lineNum">      23 </span>            :  * whether it was awoken on an error condition).
<span class="lineNum">      24 </span>            :  *
<span class="lineNum">      25 </span>            :  * Interface (b):
<span class="lineNum">      26 </span>            :  *
<span class="lineNum">      27 </span>            :  * ProcReleaseLocks -- frees the locks associated with current transaction
<span class="lineNum">      28 </span>            :  *
<span class="lineNum">      29 </span>            :  * ProcKill -- destroys the shared memory state (and locks)
<span class="lineNum">      30 </span>            :  * associated with the process.
<span class="lineNum">      31 </span>            :  */
<span class="lineNum">      32 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #include &lt;signal.h&gt;
<span class="lineNum">      35 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">      36 </span>            : #include &lt;sys/time.h&gt;
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : #include &quot;access/transam.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;access/twophase.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;access/xact.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;miscadmin.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;pgstat.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;postmaster/autovacuum.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;replication/slot.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;replication/syncrep.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;replication/walsender.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;storage/condition_variable.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;storage/ipc.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;storage/lmgr.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;storage/pmsignal.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;storage/proc.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;storage/procarray.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;storage/procsignal.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;storage/spin.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;storage/standby.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;utils/timeout.h&quot;
<span class="lineNum">      57 </span>            : #include &quot;utils/timestamp.h&quot;
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : /* GUC variables */
<span class="lineNum">      60 </span>            : int         DeadlockTimeout = 1000;
<span class="lineNum">      61 </span>            : int         StatementTimeout = 0;
<span class="lineNum">      62 </span>            : int         LockTimeout = 0;
<span class="lineNum">      63 </span>            : int         IdleInTransactionSessionTimeout = 0;
<span class="lineNum">      64 </span>            : bool        log_lock_waits = false;
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : /* Pointer to this process's PGPROC and PGXACT structs, if any */
<span class="lineNum">      67 </span>            : PGPROC     *MyProc = NULL;
<span class="lineNum">      68 </span>            : PGXACT     *MyPgXact = NULL;
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : /*
<span class="lineNum">      71 </span>            :  * This spinlock protects the freelist of recycled PGPROC structures.
<span class="lineNum">      72 </span>            :  * We cannot use an LWLock because the LWLock manager depends on already
<span class="lineNum">      73 </span>            :  * having a PGPROC and a wait semaphore!  But these structures are touched
<span class="lineNum">      74 </span>            :  * relatively infrequently (only at backend startup or shutdown) and not for
<span class="lineNum">      75 </span>            :  * very long, so a spinlock is okay.
<span class="lineNum">      76 </span>            :  */
<span class="lineNum">      77 </span>            : NON_EXEC_STATIC slock_t *ProcStructLock = NULL;
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : /* Pointers to shared-memory structures */
<span class="lineNum">      80 </span>            : PROC_HDR   *ProcGlobal = NULL;
<span class="lineNum">      81 </span>            : NON_EXEC_STATIC PGPROC *AuxiliaryProcs = NULL;
<span class="lineNum">      82 </span>            : PGPROC     *PreparedXactProcs = NULL;
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            : /* If we are waiting for a lock, this points to the associated LOCALLOCK */
<span class="lineNum">      85 </span>            : static LOCALLOCK *lockAwaited = NULL;
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : static DeadLockState deadlock_state = DS_NOT_YET_CHECKED;
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            : /* Is a deadlock check pending? */
<span class="lineNum">      90 </span>            : static volatile sig_atomic_t got_deadlock_timeout;
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : static void RemoveProcFromArray(int code, Datum arg);
<span class="lineNum">      93 </span>            : static void ProcKill(int code, Datum arg);
<span class="lineNum">      94 </span>            : static void AuxiliaryProcKill(int code, Datum arg);
<span class="lineNum">      95 </span>            : static void CheckDeadLock(void);
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : /*
<span class="lineNum">      99 </span>            :  * Report shared-memory space needed by InitProcGlobal.
<a name="100"><span class="lineNum">     100 </span>            :  */</a>
<span class="lineNum">     101 </span>            : Size
<span class="lineNum">     102 </span><span class="lineCov">       1228 : ProcGlobalShmemSize(void)</span>
<span class="lineNum">     103 </span>            : {
<span class="lineNum">     104 </span><span class="lineCov">       1228 :     Size        size = 0;</span>
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :     /* ProcGlobal */
<span class="lineNum">     107 </span><span class="lineCov">       1228 :     size = add_size(size, sizeof(PROC_HDR));</span>
<span class="lineNum">     108 </span>            :     /* MyProcs, including autovacuum workers and launcher */
<span class="lineNum">     109 </span><span class="lineCov">       1228 :     size = add_size(size, mul_size(MaxBackends, sizeof(PGPROC)));</span>
<span class="lineNum">     110 </span>            :     /* AuxiliaryProcs */
<span class="lineNum">     111 </span><span class="lineCov">       1228 :     size = add_size(size, mul_size(NUM_AUXILIARY_PROCS, sizeof(PGPROC)));</span>
<span class="lineNum">     112 </span>            :     /* Prepared xacts */
<span class="lineNum">     113 </span><span class="lineCov">       1228 :     size = add_size(size, mul_size(max_prepared_xacts, sizeof(PGPROC)));</span>
<span class="lineNum">     114 </span>            :     /* ProcStructLock */
<span class="lineNum">     115 </span><span class="lineCov">       1228 :     size = add_size(size, sizeof(slock_t));</span>
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span><span class="lineCov">       1228 :     size = add_size(size, mul_size(MaxBackends, sizeof(PGXACT)));</span>
<span class="lineNum">     118 </span><span class="lineCov">       1228 :     size = add_size(size, mul_size(NUM_AUXILIARY_PROCS, sizeof(PGXACT)));</span>
<span class="lineNum">     119 </span><span class="lineCov">       1228 :     size = add_size(size, mul_size(max_prepared_xacts, sizeof(PGXACT)));</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span><span class="lineCov">       1228 :     return size;</span>
<span class="lineNum">     122 </span>            : }
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : /*
<span class="lineNum">     125 </span>            :  * Report number of semaphores needed by InitProcGlobal.
<a name="126"><span class="lineNum">     126 </span>            :  */</a>
<span class="lineNum">     127 </span>            : int
<span class="lineNum">     128 </span><span class="lineCov">       1228 : ProcGlobalSemas(void)</span>
<span class="lineNum">     129 </span>            : {
<span class="lineNum">     130 </span>            :     /*
<span class="lineNum">     131 </span>            :      * We need a sema per backend (including autovacuum), plus one for each
<span class="lineNum">     132 </span>            :      * auxiliary process.
<span class="lineNum">     133 </span>            :      */
<span class="lineNum">     134 </span><span class="lineCov">       1228 :     return MaxBackends + NUM_AUXILIARY_PROCS;</span>
<span class="lineNum">     135 </span>            : }
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : /*
<span class="lineNum">     138 </span>            :  * InitProcGlobal -
<span class="lineNum">     139 </span>            :  *    Initialize the global process table during postmaster or standalone
<span class="lineNum">     140 </span>            :  *    backend startup.
<span class="lineNum">     141 </span>            :  *
<span class="lineNum">     142 </span>            :  *    We also create all the per-process semaphores we will need to support
<span class="lineNum">     143 </span>            :  *    the requested number of backends.  We used to allocate semaphores
<span class="lineNum">     144 </span>            :  *    only when backends were actually started up, but that is bad because
<span class="lineNum">     145 </span>            :  *    it lets Postgres fail under load --- a lot of Unix systems are
<span class="lineNum">     146 </span>            :  *    (mis)configured with small limits on the number of semaphores, and
<span class="lineNum">     147 </span>            :  *    running out when trying to start another backend is a common failure.
<span class="lineNum">     148 </span>            :  *    So, now we grab enough semaphores to support the desired max number
<span class="lineNum">     149 </span>            :  *    of backends immediately at initialization --- if the sysadmin has set
<span class="lineNum">     150 </span>            :  *    MaxConnections, max_worker_processes, max_wal_senders, or
<span class="lineNum">     151 </span>            :  *    autovacuum_max_workers higher than his kernel will support, he'll
<span class="lineNum">     152 </span>            :  *    find out sooner rather than later.
<span class="lineNum">     153 </span>            :  *
<span class="lineNum">     154 </span>            :  *    Another reason for creating semaphores here is that the semaphore
<span class="lineNum">     155 </span>            :  *    implementation typically requires us to create semaphores in the
<span class="lineNum">     156 </span>            :  *    postmaster, not in backends.
<span class="lineNum">     157 </span>            :  *
<span class="lineNum">     158 </span>            :  * Note: this is NOT called by individual backends under a postmaster,
<span class="lineNum">     159 </span>            :  * not even in the EXEC_BACKEND case.  The ProcGlobal and AuxiliaryProcs
<span class="lineNum">     160 </span>            :  * pointers must be propagated specially for EXEC_BACKEND operation.
<a name="161"><span class="lineNum">     161 </span>            :  */</a>
<span class="lineNum">     162 </span>            : void
<span class="lineNum">     163 </span><span class="lineCov">       1228 : InitProcGlobal(void)</span>
<span class="lineNum">     164 </span>            : {
<span class="lineNum">     165 </span>            :     PGPROC     *procs;
<span class="lineNum">     166 </span>            :     PGXACT     *pgxacts;
<span class="lineNum">     167 </span>            :     int         i,
<span class="lineNum">     168 </span>            :                 j;
<span class="lineNum">     169 </span>            :     bool        found;
<span class="lineNum">     170 </span><span class="lineCov">       1228 :     uint32      TotalProcs = MaxBackends + NUM_AUXILIARY_PROCS + max_prepared_xacts;</span>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :     /* Create the ProcGlobal shared structure */
<span class="lineNum">     173 </span><span class="lineCov">       1228 :     ProcGlobal = (PROC_HDR *)</span>
<span class="lineNum">     174 </span><span class="lineCov">       1228 :         ShmemInitStruct(&quot;Proc Header&quot;, sizeof(PROC_HDR), &amp;found);</span>
<span class="lineNum">     175 </span><span class="lineCov">       1228 :     Assert(!found);</span>
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            :     /*
<span class="lineNum">     178 </span>            :      * Initialize the data structures.
<span class="lineNum">     179 </span>            :      */
<span class="lineNum">     180 </span><span class="lineCov">       1228 :     ProcGlobal-&gt;spins_per_delay = DEFAULT_SPINS_PER_DELAY;</span>
<span class="lineNum">     181 </span><span class="lineCov">       1228 :     ProcGlobal-&gt;freeProcs = NULL;</span>
<span class="lineNum">     182 </span><span class="lineCov">       1228 :     ProcGlobal-&gt;autovacFreeProcs = NULL;</span>
<span class="lineNum">     183 </span><span class="lineCov">       1228 :     ProcGlobal-&gt;bgworkerFreeProcs = NULL;</span>
<span class="lineNum">     184 </span><span class="lineCov">       1228 :     ProcGlobal-&gt;walsenderFreeProcs = NULL;</span>
<span class="lineNum">     185 </span><span class="lineCov">       1228 :     ProcGlobal-&gt;startupProc = NULL;</span>
<span class="lineNum">     186 </span><span class="lineCov">       1228 :     ProcGlobal-&gt;startupProcPid = 0;</span>
<span class="lineNum">     187 </span><span class="lineCov">       1228 :     ProcGlobal-&gt;startupBufferPinWaitBufId = -1;</span>
<span class="lineNum">     188 </span><span class="lineCov">       1228 :     ProcGlobal-&gt;walwriterLatch = NULL;</span>
<span class="lineNum">     189 </span><span class="lineCov">       1228 :     ProcGlobal-&gt;checkpointerLatch = NULL;</span>
<span class="lineNum">     190 </span><span class="lineCov">       1228 :     pg_atomic_init_u32(&amp;ProcGlobal-&gt;procArrayGroupFirst, INVALID_PGPROCNO);</span>
<span class="lineNum">     191 </span><span class="lineCov">       1228 :     pg_atomic_init_u32(&amp;ProcGlobal-&gt;clogGroupFirst, INVALID_PGPROCNO);</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :     /*
<span class="lineNum">     194 </span>            :      * Create and initialize all the PGPROC structures we'll need.  There are
<span class="lineNum">     195 </span>            :      * five separate consumers: (1) normal backends, (2) autovacuum workers
<span class="lineNum">     196 </span>            :      * and the autovacuum launcher, (3) background workers, (4) auxiliary
<span class="lineNum">     197 </span>            :      * processes, and (5) prepared transactions.  Each PGPROC structure is
<span class="lineNum">     198 </span>            :      * dedicated to exactly one of these purposes, and they do not move
<span class="lineNum">     199 </span>            :      * between groups.
<span class="lineNum">     200 </span>            :      */
<span class="lineNum">     201 </span><span class="lineCov">       1228 :     procs = (PGPROC *) ShmemAlloc(TotalProcs * sizeof(PGPROC));</span>
<span class="lineNum">     202 </span><span class="lineCov">       1228 :     MemSet(procs, 0, TotalProcs * sizeof(PGPROC));</span>
<span class="lineNum">     203 </span><span class="lineCov">       1228 :     ProcGlobal-&gt;allProcs = procs;</span>
<span class="lineNum">     204 </span>            :     /* XXX allProcCount isn't really all of them; it excludes prepared xacts */
<span class="lineNum">     205 </span><span class="lineCov">       1228 :     ProcGlobal-&gt;allProcCount = MaxBackends + NUM_AUXILIARY_PROCS;</span>
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :     /*
<span class="lineNum">     208 </span>            :      * Also allocate a separate array of PGXACT structures.  This is separate
<span class="lineNum">     209 </span>            :      * from the main PGPROC array so that the most heavily accessed data is
<span class="lineNum">     210 </span>            :      * stored contiguously in memory in as few cache lines as possible. This
<span class="lineNum">     211 </span>            :      * provides significant performance benefits, especially on a
<span class="lineNum">     212 </span>            :      * multiprocessor system.  There is one PGXACT structure for every PGPROC
<span class="lineNum">     213 </span>            :      * structure.
<span class="lineNum">     214 </span>            :      */
<span class="lineNum">     215 </span><span class="lineCov">       1228 :     pgxacts = (PGXACT *) ShmemAlloc(TotalProcs * sizeof(PGXACT));</span>
<span class="lineNum">     216 </span><span class="lineCov">       1228 :     MemSet(pgxacts, 0, TotalProcs * sizeof(PGXACT));</span>
<span class="lineNum">     217 </span><span class="lineCov">       1228 :     ProcGlobal-&gt;allPgXact = pgxacts;</span>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span><span class="lineCov">     158396 :     for (i = 0; i &lt; TotalProcs; i++)</span>
<span class="lineNum">     220 </span>            :     {
<span class="lineNum">     221 </span>            :         /* Common initialization for all PGPROCs, regardless of type. */
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :         /*
<span class="lineNum">     224 </span>            :          * Set up per-PGPROC semaphore, latch, and backendLock. Prepared xact
<span class="lineNum">     225 </span>            :          * dummy PGPROCs don't need these though - they're never associated
<span class="lineNum">     226 </span>            :          * with a real process
<span class="lineNum">     227 </span>            :          */
<span class="lineNum">     228 </span><span class="lineCov">     157168 :         if (i &lt; MaxBackends + NUM_AUXILIARY_PROCS)</span>
<span class="lineNum">     229 </span>            :         {
<span class="lineNum">     230 </span><span class="lineCov">     154728 :             procs[i].sem = PGSemaphoreCreate();</span>
<span class="lineNum">     231 </span><span class="lineCov">     154728 :             InitSharedLatch(&amp;(procs[i].procLatch));</span>
<span class="lineNum">     232 </span><span class="lineCov">     154728 :             LWLockInitialize(&amp;(procs[i].backendLock), LWTRANCHE_PROC);</span>
<span class="lineNum">     233 </span>            :         }
<span class="lineNum">     234 </span><span class="lineCov">     157168 :         procs[i].pgprocno = i;</span>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :         /*
<span class="lineNum">     237 </span>            :          * Newly created PGPROCs for normal backends, autovacuum and bgworkers
<span class="lineNum">     238 </span>            :          * must be queued up on the appropriate free list.  Because there can
<span class="lineNum">     239 </span>            :          * only ever be a small, fixed number of auxiliary processes, no free
<span class="lineNum">     240 </span>            :          * list is used in that case; InitAuxiliaryProcess() instead uses a
<span class="lineNum">     241 </span>            :          * linear search.   PGPROCs for prepared transactions are added to a
<span class="lineNum">     242 </span>            :          * free list by TwoPhaseShmemInit().
<span class="lineNum">     243 </span>            :          */
<span class="lineNum">     244 </span><span class="lineCov">     157168 :         if (i &lt; MaxConnections)</span>
<span class="lineNum">     245 </span>            :         {
<span class="lineNum">     246 </span>            :             /* PGPROC for normal backend, add to freeProcs list */
<span class="lineNum">     247 </span><span class="lineCov">     122800 :             procs[i].links.next = (SHM_QUEUE *) ProcGlobal-&gt;freeProcs;</span>
<span class="lineNum">     248 </span><span class="lineCov">     122800 :             ProcGlobal-&gt;freeProcs = &amp;procs[i];</span>
<span class="lineNum">     249 </span><span class="lineCov">     122800 :             procs[i].procgloballist = &amp;ProcGlobal-&gt;freeProcs;</span>
<span class="lineNum">     250 </span>            :         }
<span class="lineNum">     251 </span><span class="lineCov">      34368 :         else if (i &lt; MaxConnections + autovacuum_max_workers + 1)</span>
<span class="lineNum">     252 </span>            :         {
<span class="lineNum">     253 </span>            :             /* PGPROC for AV launcher/worker, add to autovacFreeProcs list */
<span class="lineNum">     254 </span><span class="lineCov">       4912 :             procs[i].links.next = (SHM_QUEUE *) ProcGlobal-&gt;autovacFreeProcs;</span>
<span class="lineNum">     255 </span><span class="lineCov">       4912 :             ProcGlobal-&gt;autovacFreeProcs = &amp;procs[i];</span>
<span class="lineNum">     256 </span><span class="lineCov">       4912 :             procs[i].procgloballist = &amp;ProcGlobal-&gt;autovacFreeProcs;</span>
<span class="lineNum">     257 </span>            :         }
<span class="lineNum">     258 </span><span class="lineCov">      29456 :         else if (i &lt; MaxConnections + autovacuum_max_workers + 1 + max_worker_processes)</span>
<span class="lineNum">     259 </span>            :         {
<span class="lineNum">     260 </span>            :             /* PGPROC for bgworker, add to bgworkerFreeProcs list */
<span class="lineNum">     261 </span><span class="lineCov">       9824 :             procs[i].links.next = (SHM_QUEUE *) ProcGlobal-&gt;bgworkerFreeProcs;</span>
<span class="lineNum">     262 </span><span class="lineCov">       9824 :             ProcGlobal-&gt;bgworkerFreeProcs = &amp;procs[i];</span>
<span class="lineNum">     263 </span><span class="lineCov">       9824 :             procs[i].procgloballist = &amp;ProcGlobal-&gt;bgworkerFreeProcs;</span>
<span class="lineNum">     264 </span>            :         }
<span class="lineNum">     265 </span><span class="lineCov">      19632 :         else if (i &lt; MaxBackends)</span>
<span class="lineNum">     266 </span>            :         {
<span class="lineNum">     267 </span>            :             /* PGPROC for walsender, add to walsenderFreeProcs list */
<span class="lineNum">     268 </span><span class="lineCov">      12280 :             procs[i].links.next = (SHM_QUEUE *) ProcGlobal-&gt;walsenderFreeProcs;</span>
<span class="lineNum">     269 </span><span class="lineCov">      12280 :             ProcGlobal-&gt;walsenderFreeProcs = &amp;procs[i];</span>
<span class="lineNum">     270 </span><span class="lineCov">      12280 :             procs[i].procgloballist = &amp;ProcGlobal-&gt;walsenderFreeProcs;</span>
<span class="lineNum">     271 </span>            :         }
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :         /* Initialize myProcLocks[] shared memory queues. */
<span class="lineNum">     274 </span><span class="lineCov">    2671856 :         for (j = 0; j &lt; NUM_LOCK_PARTITIONS; j++)</span>
<span class="lineNum">     275 </span><span class="lineCov">    2514688 :             SHMQueueInit(&amp;(procs[i].myProcLocks[j]));</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :         /* Initialize lockGroupMembers list. */
<span class="lineNum">     278 </span><span class="lineCov">     157168 :         dlist_init(&amp;procs[i].lockGroupMembers);</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            :         /*
<span class="lineNum">     281 </span>            :          * Initialize the atomic variables, otherwise, it won't be safe to
<span class="lineNum">     282 </span>            :          * access them for backends that aren't currently in use.
<span class="lineNum">     283 </span>            :          */
<span class="lineNum">     284 </span><span class="lineCov">     157168 :         pg_atomic_init_u32(&amp;(procs[i].procArrayGroupNext), INVALID_PGPROCNO);</span>
<span class="lineNum">     285 </span><span class="lineCov">     157168 :         pg_atomic_init_u32(&amp;(procs[i].clogGroupNext), INVALID_PGPROCNO);</span>
<span class="lineNum">     286 </span>            :     }
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :     /*
<span class="lineNum">     289 </span>            :      * Save pointers to the blocks of PGPROC structures reserved for auxiliary
<span class="lineNum">     290 </span>            :      * processes and prepared transactions.
<span class="lineNum">     291 </span>            :      */
<span class="lineNum">     292 </span><span class="lineCov">       1228 :     AuxiliaryProcs = &amp;procs[MaxBackends];</span>
<span class="lineNum">     293 </span><span class="lineCov">       1228 :     PreparedXactProcs = &amp;procs[MaxBackends + NUM_AUXILIARY_PROCS];</span>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :     /* Create ProcStructLock spinlock, too */
<span class="lineNum">     296 </span><span class="lineCov">       1228 :     ProcStructLock = (slock_t *) ShmemAlloc(sizeof(slock_t));</span>
<span class="lineNum">     297 </span><span class="lineCov">       1228 :     SpinLockInit(ProcStructLock);</span>
<span class="lineNum">     298 </span><span class="lineCov">       1228 : }</span>
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            : /*
<span class="lineNum">     301 </span>            :  * InitProcess -- initialize a per-process data structure for this backend
<a name="302"><span class="lineNum">     302 </span>            :  */</a>
<span class="lineNum">     303 </span>            : void
<span class="lineNum">     304 </span><span class="lineCov">       1212 : InitProcess(void)</span>
<span class="lineNum">     305 </span>            : {
<span class="lineNum">     306 </span>            :     PGPROC     *volatile *procgloballist;
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :     /*
<span class="lineNum">     309 </span>            :      * ProcGlobal should be set up already (if we are a backend, we inherit
<span class="lineNum">     310 </span>            :      * this by fork() or EXEC_BACKEND mechanism from the postmaster).
<span class="lineNum">     311 </span>            :      */
<span class="lineNum">     312 </span><span class="lineCov">       1212 :     if (ProcGlobal == NULL)</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :         elog(PANIC, &quot;proc header uninitialized&quot;);</span>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span><span class="lineCov">       1212 :     if (MyProc != NULL)</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;you already exist&quot;);</span>
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            :     /* Decide which list should supply our PGPROC. */
<span class="lineNum">     319 </span><span class="lineCov">       1212 :     if (IsAnyAutoVacuumProcess())</span>
<span class="lineNum">     320 </span><span class="lineCov">          6 :         procgloballist = &amp;ProcGlobal-&gt;autovacFreeProcs;</span>
<span class="lineNum">     321 </span><span class="lineCov">       1206 :     else if (IsBackgroundWorker)</span>
<span class="lineNum">     322 </span><span class="lineCov">        748 :         procgloballist = &amp;ProcGlobal-&gt;bgworkerFreeProcs;</span>
<span class="lineNum">     323 </span><span class="lineCov">        458 :     else if (am_walsender)</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         procgloballist = &amp;ProcGlobal-&gt;walsenderFreeProcs;</span>
<span class="lineNum">     325 </span>            :     else
<span class="lineNum">     326 </span><span class="lineCov">        458 :         procgloballist = &amp;ProcGlobal-&gt;freeProcs;</span>
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :     /*
<span class="lineNum">     329 </span>            :      * Try to get a proc struct from the appropriate free list.  If this
<span class="lineNum">     330 </span>            :      * fails, we must be out of PGPROC structures (not to mention semaphores).
<span class="lineNum">     331 </span>            :      *
<span class="lineNum">     332 </span>            :      * While we are holding the ProcStructLock, also copy the current shared
<span class="lineNum">     333 </span>            :      * estimate of spins_per_delay to local storage.
<span class="lineNum">     334 </span>            :      */
<span class="lineNum">     335 </span><span class="lineCov">       1212 :     SpinLockAcquire(ProcStructLock);</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span><span class="lineCov">       1212 :     set_spins_per_delay(ProcGlobal-&gt;spins_per_delay);</span>
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span><span class="lineCov">       1212 :     MyProc = *procgloballist;</span>
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span><span class="lineCov">       1212 :     if (MyProc != NULL)</span>
<span class="lineNum">     342 </span>            :     {
<span class="lineNum">     343 </span><span class="lineCov">       1212 :         *procgloballist = (PGPROC *) MyProc-&gt;links.next;</span>
<span class="lineNum">     344 </span><span class="lineCov">       1212 :         SpinLockRelease(ProcStructLock);</span>
<span class="lineNum">     345 </span>            :     }
<span class="lineNum">     346 </span>            :     else
<span class="lineNum">     347 </span>            :     {
<span class="lineNum">     348 </span>            :         /*
<span class="lineNum">     349 </span>            :          * If we reach here, all the PGPROCs are in use.  This is one of the
<span class="lineNum">     350 </span>            :          * possible places to detect &quot;too many backends&quot;, so give the standard
<span class="lineNum">     351 </span>            :          * error message.  XXX do we need to give a different failure message
<span class="lineNum">     352 </span>            :          * in the autovacuum case?
<span class="lineNum">     353 </span>            :          */
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         SpinLockRelease(ProcStructLock);</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         if (am_walsender)</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :             ereport(FATAL,</span>
<span class="lineNum">     357 </span>            :                     (errcode(ERRCODE_TOO_MANY_CONNECTIONS),
<span class="lineNum">     358 </span>            :                      errmsg(&quot;number of requested standby connections exceeds max_wal_senders (currently %d)&quot;,
<span class="lineNum">     359 </span>            :                             max_wal_senders)));
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         ereport(FATAL,</span>
<span class="lineNum">     361 </span>            :                 (errcode(ERRCODE_TOO_MANY_CONNECTIONS),
<span class="lineNum">     362 </span>            :                  errmsg(&quot;sorry, too many clients already&quot;)));
<span class="lineNum">     363 </span>            :     }
<span class="lineNum">     364 </span><span class="lineCov">       1212 :     MyPgXact = &amp;ProcGlobal-&gt;allPgXact[MyProc-&gt;pgprocno];</span>
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            :     /*
<span class="lineNum">     367 </span>            :      * Cross-check that the PGPROC is of the type we expect; if this were not
<span class="lineNum">     368 </span>            :      * the case, it would get returned to the wrong list.
<span class="lineNum">     369 </span>            :      */
<span class="lineNum">     370 </span><span class="lineCov">       1212 :     Assert(MyProc-&gt;procgloballist == procgloballist);</span>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            :     /*
<span class="lineNum">     373 </span>            :      * Now that we have a PGPROC, mark ourselves as an active postmaster
<span class="lineNum">     374 </span>            :      * child; this is so that the postmaster can detect it if we exit without
<span class="lineNum">     375 </span>            :      * cleaning up.  (XXX autovac launcher currently doesn't participate in
<span class="lineNum">     376 </span>            :      * this; it probably should.)
<span class="lineNum">     377 </span>            :      */
<span class="lineNum">     378 </span><span class="lineCov">       1212 :     if (IsUnderPostmaster &amp;&amp; !IsAutoVacuumLauncherProcess())</span>
<span class="lineNum">     379 </span><span class="lineCov">       1206 :         MarkPostmasterChildActive();</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            :     /*
<span class="lineNum">     382 </span>            :      * Initialize all fields of MyProc, except for those previously
<span class="lineNum">     383 </span>            :      * initialized by InitProcGlobal.
<span class="lineNum">     384 </span>            :      */
<span class="lineNum">     385 </span><span class="lineCov">       1212 :     SHMQueueElemInit(&amp;(MyProc-&gt;links));</span>
<span class="lineNum">     386 </span><span class="lineCov">       1212 :     MyProc-&gt;waitStatus = STATUS_OK;</span>
<span class="lineNum">     387 </span><span class="lineCov">       1212 :     MyProc-&gt;lxid = InvalidLocalTransactionId;</span>
<span class="lineNum">     388 </span><span class="lineCov">       1212 :     MyProc-&gt;fpVXIDLock = false;</span>
<span class="lineNum">     389 </span><span class="lineCov">       1212 :     MyProc-&gt;fpLocalTransactionId = InvalidLocalTransactionId;</span>
<span class="lineNum">     390 </span><span class="lineCov">       1212 :     MyPgXact-&gt;xid = InvalidTransactionId;</span>
<span class="lineNum">     391 </span><span class="lineCov">       1212 :     MyPgXact-&gt;xmin = InvalidTransactionId;</span>
<span class="lineNum">     392 </span><span class="lineCov">       1212 :     MyProc-&gt;pid = MyProcPid;</span>
<span class="lineNum">     393 </span>            :     /* backendId, databaseId and roleId will be filled in later */
<span class="lineNum">     394 </span><span class="lineCov">       1212 :     MyProc-&gt;backendId = InvalidBackendId;</span>
<span class="lineNum">     395 </span><span class="lineCov">       1212 :     MyProc-&gt;databaseId = InvalidOid;</span>
<span class="lineNum">     396 </span><span class="lineCov">       1212 :     MyProc-&gt;roleId = InvalidOid;</span>
<span class="lineNum">     397 </span><span class="lineCov">       1212 :     MyProc-&gt;tempNamespaceId = InvalidOid;</span>
<span class="lineNum">     398 </span><span class="lineCov">       1212 :     MyProc-&gt;isBackgroundWorker = IsBackgroundWorker;</span>
<span class="lineNum">     399 </span><span class="lineCov">       1212 :     MyPgXact-&gt;delayChkpt = false;</span>
<span class="lineNum">     400 </span><span class="lineCov">       1212 :     MyPgXact-&gt;vacuumFlags = 0;</span>
<span class="lineNum">     401 </span>            :     /* NB -- autovac launcher intentionally does not set IS_AUTOVACUUM */
<span class="lineNum">     402 </span><span class="lineCov">       1212 :     if (IsAutoVacuumWorkerProcess())</span>
<span class="lineNum">     403 </span><span class="lineCov">          4 :         MyPgXact-&gt;vacuumFlags |= PROC_IS_AUTOVACUUM;</span>
<span class="lineNum">     404 </span><span class="lineCov">       1212 :     MyProc-&gt;lwWaiting = false;</span>
<span class="lineNum">     405 </span><span class="lineCov">       1212 :     MyProc-&gt;lwWaitMode = 0;</span>
<span class="lineNum">     406 </span><span class="lineCov">       1212 :     MyProc-&gt;waitLock = NULL;</span>
<span class="lineNum">     407 </span><span class="lineCov">       1212 :     MyProc-&gt;waitProcLock = NULL;</span>
<span class="lineNum">     408 </span>            : #ifdef USE_ASSERT_CHECKING
<span class="lineNum">     409 </span>            :     {
<span class="lineNum">     410 </span>            :         int         i;
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            :         /* Last process should have released all locks. */
<span class="lineNum">     413 </span><span class="lineCov">      20604 :         for (i = 0; i &lt; NUM_LOCK_PARTITIONS; i++)</span>
<span class="lineNum">     414 </span><span class="lineCov">      19392 :             Assert(SHMQueueEmpty(&amp;(MyProc-&gt;myProcLocks[i])));</span>
<span class="lineNum">     415 </span>            :     }
<span class="lineNum">     416 </span>            : #endif
<span class="lineNum">     417 </span><span class="lineCov">       1212 :     MyProc-&gt;recoveryConflictPending = false;</span>
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            :     /* Initialize fields for sync rep */
<span class="lineNum">     420 </span><span class="lineCov">       1212 :     MyProc-&gt;waitLSN = 0;</span>
<span class="lineNum">     421 </span><span class="lineCov">       1212 :     MyProc-&gt;syncRepState = SYNC_REP_NOT_WAITING;</span>
<span class="lineNum">     422 </span><span class="lineCov">       1212 :     SHMQueueElemInit(&amp;(MyProc-&gt;syncRepLinks));</span>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            :     /* Initialize fields for group XID clearing. */
<span class="lineNum">     425 </span><span class="lineCov">       1212 :     MyProc-&gt;procArrayGroupMember = false;</span>
<span class="lineNum">     426 </span><span class="lineCov">       1212 :     MyProc-&gt;procArrayGroupMemberXid = InvalidTransactionId;</span>
<span class="lineNum">     427 </span><span class="lineCov">       1212 :     Assert(pg_atomic_read_u32(&amp;MyProc-&gt;procArrayGroupNext) == INVALID_PGPROCNO);</span>
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            :     /* Check that group locking fields are in a proper initial state. */
<span class="lineNum">     430 </span><span class="lineCov">       1212 :     Assert(MyProc-&gt;lockGroupLeader == NULL);</span>
<span class="lineNum">     431 </span><span class="lineCov">       1212 :     Assert(dlist_is_empty(&amp;MyProc-&gt;lockGroupMembers));</span>
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            :     /* Initialize wait event information. */
<span class="lineNum">     434 </span><span class="lineCov">       1212 :     MyProc-&gt;wait_event_info = 0;</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            :     /* Initialize fields for group transaction status update. */
<span class="lineNum">     437 </span><span class="lineCov">       1212 :     MyProc-&gt;clogGroupMember = false;</span>
<span class="lineNum">     438 </span><span class="lineCov">       1212 :     MyProc-&gt;clogGroupMemberXid = InvalidTransactionId;</span>
<span class="lineNum">     439 </span><span class="lineCov">       1212 :     MyProc-&gt;clogGroupMemberXidStatus = TRANSACTION_STATUS_IN_PROGRESS;</span>
<span class="lineNum">     440 </span><span class="lineCov">       1212 :     MyProc-&gt;clogGroupMemberPage = -1;</span>
<span class="lineNum">     441 </span><span class="lineCov">       1212 :     MyProc-&gt;clogGroupMemberLsn = InvalidXLogRecPtr;</span>
<span class="lineNum">     442 </span><span class="lineCov">       1212 :     Assert(pg_atomic_read_u32(&amp;MyProc-&gt;clogGroupNext) == INVALID_PGPROCNO);</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :     /*
<span class="lineNum">     445 </span>            :      * Acquire ownership of the PGPROC's latch, so that we can use WaitLatch
<span class="lineNum">     446 </span>            :      * on it.  That allows us to repoint the process latch, which so far
<span class="lineNum">     447 </span>            :      * points to process local one, to the shared one.
<span class="lineNum">     448 </span>            :      */
<span class="lineNum">     449 </span><span class="lineCov">       1212 :     OwnLatch(&amp;MyProc-&gt;procLatch);</span>
<span class="lineNum">     450 </span><span class="lineCov">       1212 :     SwitchToSharedLatch();</span>
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :     /*
<span class="lineNum">     453 </span>            :      * We might be reusing a semaphore that belonged to a failed process. So
<span class="lineNum">     454 </span>            :      * be careful and reinitialize its value here.  (This is not strictly
<span class="lineNum">     455 </span>            :      * necessary anymore, but seems like a good idea for cleanliness.)
<span class="lineNum">     456 </span>            :      */
<span class="lineNum">     457 </span><span class="lineCov">       1212 :     PGSemaphoreReset(MyProc-&gt;sem);</span>
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :     /*
<span class="lineNum">     460 </span>            :      * Arrange to clean up at backend exit.
<span class="lineNum">     461 </span>            :      */
<span class="lineNum">     462 </span><span class="lineCov">       1212 :     on_shmem_exit(ProcKill, 0);</span>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            :     /*
<span class="lineNum">     465 </span>            :      * Now that we have a PGPROC, we could try to acquire locks, so initialize
<span class="lineNum">     466 </span>            :      * local state needed for LWLocks, and the deadlock checker.
<span class="lineNum">     467 </span>            :      */
<span class="lineNum">     468 </span><span class="lineCov">       1212 :     InitLWLockAccess();</span>
<span class="lineNum">     469 </span><span class="lineCov">       1212 :     InitDeadLockChecking();</span>
<span class="lineNum">     470 </span><span class="lineCov">       1212 : }</span>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            : /*
<span class="lineNum">     473 </span>            :  * InitProcessPhase2 -- make MyProc visible in the shared ProcArray.
<span class="lineNum">     474 </span>            :  *
<span class="lineNum">     475 </span>            :  * This is separate from InitProcess because we can't acquire LWLocks until
<span class="lineNum">     476 </span>            :  * we've created a PGPROC, but in the EXEC_BACKEND case ProcArrayAdd won't
<span class="lineNum">     477 </span>            :  * work until after we've done CreateSharedMemoryAndSemaphores.
<a name="478"><span class="lineNum">     478 </span>            :  */</a>
<span class="lineNum">     479 </span>            : void
<span class="lineNum">     480 </span><span class="lineCov">       1212 : InitProcessPhase2(void)</span>
<span class="lineNum">     481 </span>            : {
<span class="lineNum">     482 </span><span class="lineCov">       1212 :     Assert(MyProc != NULL);</span>
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :     /*
<span class="lineNum">     485 </span>            :      * Add our PGPROC to the PGPROC array in shared memory.
<span class="lineNum">     486 </span>            :      */
<span class="lineNum">     487 </span><span class="lineCov">       1212 :     ProcArrayAdd(MyProc);</span>
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            :     /*
<span class="lineNum">     490 </span>            :      * Arrange to clean that up at backend exit.
<span class="lineNum">     491 </span>            :      */
<span class="lineNum">     492 </span><span class="lineCov">       1212 :     on_shmem_exit(RemoveProcFromArray, 0);</span>
<span class="lineNum">     493 </span><span class="lineCov">       1212 : }</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            : /*
<span class="lineNum">     496 </span>            :  * InitAuxiliaryProcess -- create a per-auxiliary-process data structure
<span class="lineNum">     497 </span>            :  *
<span class="lineNum">     498 </span>            :  * This is called by bgwriter and similar processes so that they will have a
<span class="lineNum">     499 </span>            :  * MyProc value that's real enough to let them wait for LWLocks.  The PGPROC
<span class="lineNum">     500 </span>            :  * and sema that are assigned are one of the extra ones created during
<span class="lineNum">     501 </span>            :  * InitProcGlobal.
<span class="lineNum">     502 </span>            :  *
<span class="lineNum">     503 </span>            :  * Auxiliary processes are presently not expected to wait for real (lockmgr)
<span class="lineNum">     504 </span>            :  * locks, so we need not set up the deadlock checker.  They are never added
<span class="lineNum">     505 </span>            :  * to the ProcArray or the sinval messaging mechanism, either.  They also
<span class="lineNum">     506 </span>            :  * don't get a VXID assigned, since this is only useful when we actually
<span class="lineNum">     507 </span>            :  * hold lockmgr locks.
<span class="lineNum">     508 </span>            :  *
<span class="lineNum">     509 </span>            :  * Startup process however uses locks but never waits for them in the
<span class="lineNum">     510 </span>            :  * normal backend sense. Startup process also takes part in sinval messaging
<span class="lineNum">     511 </span>            :  * as a sendOnly process, so never reads messages from sinval queue. So
<span class="lineNum">     512 </span>            :  * Startup process does have a VXID and does show up in pg_locks.
<a name="513"><span class="lineNum">     513 </span>            :  */</a>
<span class="lineNum">     514 </span>            : void
<span class="lineNum">     515 </span><span class="lineCov">          8 : InitAuxiliaryProcess(void)</span>
<span class="lineNum">     516 </span>            : {
<span class="lineNum">     517 </span>            :     PGPROC     *auxproc;
<span class="lineNum">     518 </span>            :     int         proctype;
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            :     /*
<span class="lineNum">     521 </span>            :      * ProcGlobal should be set up already (if we are a backend, we inherit
<span class="lineNum">     522 </span>            :      * this by fork() or EXEC_BACKEND mechanism from the postmaster).
<span class="lineNum">     523 </span>            :      */
<span class="lineNum">     524 </span><span class="lineCov">          8 :     if (ProcGlobal == NULL || AuxiliaryProcs == NULL)</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :         elog(PANIC, &quot;proc header uninitialized&quot;);</span>
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineCov">          8 :     if (MyProc != NULL)</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;you already exist&quot;);</span>
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            :     /*
<span class="lineNum">     531 </span>            :      * We use the ProcStructLock to protect assignment and releasing of
<span class="lineNum">     532 </span>            :      * AuxiliaryProcs entries.
<span class="lineNum">     533 </span>            :      *
<span class="lineNum">     534 </span>            :      * While we are holding the ProcStructLock, also copy the current shared
<span class="lineNum">     535 </span>            :      * estimate of spins_per_delay to local storage.
<span class="lineNum">     536 </span>            :      */
<span class="lineNum">     537 </span><span class="lineCov">          8 :     SpinLockAcquire(ProcStructLock);</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span><span class="lineCov">          8 :     set_spins_per_delay(ProcGlobal-&gt;spins_per_delay);</span>
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span>            :     /*
<span class="lineNum">     542 </span>            :      * Find a free auxproc ... *big* trouble if there isn't one ...
<span class="lineNum">     543 </span>            :      */
<span class="lineNum">     544 </span><span class="lineCov">         14 :     for (proctype = 0; proctype &lt; NUM_AUXILIARY_PROCS; proctype++)</span>
<span class="lineNum">     545 </span>            :     {
<span class="lineNum">     546 </span><span class="lineCov">         14 :         auxproc = &amp;AuxiliaryProcs[proctype];</span>
<span class="lineNum">     547 </span><span class="lineCov">         14 :         if (auxproc-&gt;pid == 0)</span>
<span class="lineNum">     548 </span><span class="lineCov">          8 :             break;</span>
<span class="lineNum">     549 </span>            :     }
<span class="lineNum">     550 </span><span class="lineCov">          8 :     if (proctype &gt;= NUM_AUXILIARY_PROCS)</span>
<span class="lineNum">     551 </span>            :     {
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :         SpinLockRelease(ProcStructLock);</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         elog(FATAL, &quot;all AuxiliaryProcs are in use&quot;);</span>
<span class="lineNum">     554 </span>            :     }
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            :     /* Mark auxiliary proc as in use by me */
<span class="lineNum">     557 </span>            :     /* use volatile pointer to prevent code rearrangement */
<span class="lineNum">     558 </span><span class="lineCov">          8 :     ((volatile PGPROC *) auxproc)-&gt;pid = MyProcPid;</span>
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span><span class="lineCov">          8 :     MyProc = auxproc;</span>
<span class="lineNum">     561 </span><span class="lineCov">          8 :     MyPgXact = &amp;ProcGlobal-&gt;allPgXact[auxproc-&gt;pgprocno];</span>
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span><span class="lineCov">          8 :     SpinLockRelease(ProcStructLock);</span>
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            :     /*
<span class="lineNum">     566 </span>            :      * Initialize all fields of MyProc, except for those previously
<span class="lineNum">     567 </span>            :      * initialized by InitProcGlobal.
<span class="lineNum">     568 </span>            :      */
<span class="lineNum">     569 </span><span class="lineCov">          8 :     SHMQueueElemInit(&amp;(MyProc-&gt;links));</span>
<span class="lineNum">     570 </span><span class="lineCov">          8 :     MyProc-&gt;waitStatus = STATUS_OK;</span>
<span class="lineNum">     571 </span><span class="lineCov">          8 :     MyProc-&gt;lxid = InvalidLocalTransactionId;</span>
<span class="lineNum">     572 </span><span class="lineCov">          8 :     MyProc-&gt;fpVXIDLock = false;</span>
<span class="lineNum">     573 </span><span class="lineCov">          8 :     MyProc-&gt;fpLocalTransactionId = InvalidLocalTransactionId;</span>
<span class="lineNum">     574 </span><span class="lineCov">          8 :     MyPgXact-&gt;xid = InvalidTransactionId;</span>
<span class="lineNum">     575 </span><span class="lineCov">          8 :     MyPgXact-&gt;xmin = InvalidTransactionId;</span>
<span class="lineNum">     576 </span><span class="lineCov">          8 :     MyProc-&gt;backendId = InvalidBackendId;</span>
<span class="lineNum">     577 </span><span class="lineCov">          8 :     MyProc-&gt;databaseId = InvalidOid;</span>
<span class="lineNum">     578 </span><span class="lineCov">          8 :     MyProc-&gt;roleId = InvalidOid;</span>
<span class="lineNum">     579 </span><span class="lineCov">          8 :     MyProc-&gt;tempNamespaceId = InvalidOid;</span>
<span class="lineNum">     580 </span><span class="lineCov">          8 :     MyProc-&gt;isBackgroundWorker = IsBackgroundWorker;</span>
<span class="lineNum">     581 </span><span class="lineCov">          8 :     MyPgXact-&gt;delayChkpt = false;</span>
<span class="lineNum">     582 </span><span class="lineCov">          8 :     MyPgXact-&gt;vacuumFlags = 0;</span>
<span class="lineNum">     583 </span><span class="lineCov">          8 :     MyProc-&gt;lwWaiting = false;</span>
<span class="lineNum">     584 </span><span class="lineCov">          8 :     MyProc-&gt;lwWaitMode = 0;</span>
<span class="lineNum">     585 </span><span class="lineCov">          8 :     MyProc-&gt;waitLock = NULL;</span>
<span class="lineNum">     586 </span><span class="lineCov">          8 :     MyProc-&gt;waitProcLock = NULL;</span>
<span class="lineNum">     587 </span>            : #ifdef USE_ASSERT_CHECKING
<span class="lineNum">     588 </span>            :     {
<span class="lineNum">     589 </span>            :         int         i;
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            :         /* Last process should have released all locks. */
<span class="lineNum">     592 </span><span class="lineCov">        136 :         for (i = 0; i &lt; NUM_LOCK_PARTITIONS; i++)</span>
<span class="lineNum">     593 </span><span class="lineCov">        128 :             Assert(SHMQueueEmpty(&amp;(MyProc-&gt;myProcLocks[i])));</span>
<span class="lineNum">     594 </span>            :     }
<span class="lineNum">     595 </span>            : #endif
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span>            :     /*
<span class="lineNum">     598 </span>            :      * Acquire ownership of the PGPROC's latch, so that we can use WaitLatch
<span class="lineNum">     599 </span>            :      * on it.  That allows us to repoint the process latch, which so far
<span class="lineNum">     600 </span>            :      * points to process local one, to the shared one.
<span class="lineNum">     601 </span>            :      */
<span class="lineNum">     602 </span><span class="lineCov">          8 :     OwnLatch(&amp;MyProc-&gt;procLatch);</span>
<span class="lineNum">     603 </span><span class="lineCov">          8 :     SwitchToSharedLatch();</span>
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            :     /* Check that group locking fields are in a proper initial state. */
<span class="lineNum">     606 </span><span class="lineCov">          8 :     Assert(MyProc-&gt;lockGroupLeader == NULL);</span>
<span class="lineNum">     607 </span><span class="lineCov">          8 :     Assert(dlist_is_empty(&amp;MyProc-&gt;lockGroupMembers));</span>
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            :     /*
<span class="lineNum">     610 </span>            :      * We might be reusing a semaphore that belonged to a failed process. So
<span class="lineNum">     611 </span>            :      * be careful and reinitialize its value here.  (This is not strictly
<span class="lineNum">     612 </span>            :      * necessary anymore, but seems like a good idea for cleanliness.)
<span class="lineNum">     613 </span>            :      */
<span class="lineNum">     614 </span><span class="lineCov">          8 :     PGSemaphoreReset(MyProc-&gt;sem);</span>
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            :     /*
<span class="lineNum">     617 </span>            :      * Arrange to clean up at process exit.
<span class="lineNum">     618 </span>            :      */
<span class="lineNum">     619 </span><span class="lineCov">          8 :     on_shmem_exit(AuxiliaryProcKill, Int32GetDatum(proctype));</span>
<span class="lineNum">     620 </span><span class="lineCov">          8 : }</span>
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            : /*
<span class="lineNum">     623 </span>            :  * Record the PID and PGPROC structures for the Startup process, for use in
<span class="lineNum">     624 </span>            :  * ProcSendSignal().  See comments there for further explanation.
<a name="625"><span class="lineNum">     625 </span>            :  */</a>
<span class="lineNum">     626 </span>            : void
<span class="lineNum">     627 </span><span class="lineNoCov">          0 : PublishStartupProcessInformation(void)</span>
<span class="lineNum">     628 </span>            : {
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :     SpinLockAcquire(ProcStructLock);</span>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :     ProcGlobal-&gt;startupProc = MyProc;</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :     ProcGlobal-&gt;startupProcPid = MyProcPid;</span>
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     SpinLockRelease(ProcStructLock);</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            : /*
<span class="lineNum">     638 </span>            :  * Used from bufmgr to share the value of the buffer that Startup waits on,
<span class="lineNum">     639 </span>            :  * or to reset the value to &quot;not waiting&quot; (-1). This allows processing
<span class="lineNum">     640 </span>            :  * of recovery conflicts for buffer pins. Set is made before backends look
<span class="lineNum">     641 </span>            :  * at this value, so locking not required, especially since the set is
<span class="lineNum">     642 </span>            :  * an atomic integer set operation.
<a name="643"><span class="lineNum">     643 </span>            :  */</a>
<span class="lineNum">     644 </span>            : void
<span class="lineNum">     645 </span><span class="lineNoCov">          0 : SetStartupBufferPinWaitBufId(int bufid)</span>
<span class="lineNum">     646 </span>            : {
<span class="lineNum">     647 </span>            :     /* use volatile pointer to prevent code rearrangement */
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     volatile PROC_HDR *procglobal = ProcGlobal;</span>
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :     procglobal-&gt;startupBufferPinWaitBufId = bufid;</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span>            : /*
<span class="lineNum">     654 </span>            :  * Used by backends when they receive a request to check for buffer pin waits.
<a name="655"><span class="lineNum">     655 </span>            :  */</a>
<span class="lineNum">     656 </span>            : int
<span class="lineNum">     657 </span><span class="lineNoCov">          0 : GetStartupBufferPinWaitBufId(void)</span>
<span class="lineNum">     658 </span>            : {
<span class="lineNum">     659 </span>            :     /* use volatile pointer to prevent code rearrangement */
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :     volatile PROC_HDR *procglobal = ProcGlobal;</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :     return procglobal-&gt;startupBufferPinWaitBufId;</span>
<span class="lineNum">     663 </span>            : }
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            : /*
<span class="lineNum">     666 </span>            :  * Check whether there are at least N free PGPROC objects.
<span class="lineNum">     667 </span>            :  *
<span class="lineNum">     668 </span>            :  * Note: this is designed on the assumption that N will generally be small.
<a name="669"><span class="lineNum">     669 </span>            :  */</a>
<span class="lineNum">     670 </span>            : bool
<span class="lineNum">     671 </span><span class="lineNoCov">          0 : HaveNFreeProcs(int n)</span>
<span class="lineNum">     672 </span>            : {
<span class="lineNum">     673 </span>            :     PGPROC     *proc;
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :     SpinLockAcquire(ProcStructLock);</span>
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :     proc = ProcGlobal-&gt;freeProcs;</span>
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :     while (n &gt; 0 &amp;&amp; proc != NULL)</span>
<span class="lineNum">     680 </span>            :     {
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :         proc = (PGPROC *) proc-&gt;links.next;</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :         n--;</span>
<span class="lineNum">     683 </span>            :     }
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :     SpinLockRelease(ProcStructLock);</span>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     return (n &lt;= 0);</span>
<span class="lineNum">     688 </span>            : }
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            : /*
<span class="lineNum">     691 </span>            :  * Check if the current process is awaiting a lock.
<a name="692"><span class="lineNum">     692 </span>            :  */</a>
<span class="lineNum">     693 </span>            : bool
<span class="lineNum">     694 </span><span class="lineNoCov">          0 : IsWaitingForLock(void)</span>
<span class="lineNum">     695 </span>            : {
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :     if (lockAwaited == NULL)</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     700 </span>            : }
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            : /*
<span class="lineNum">     703 </span>            :  * Cancel any pending wait for lock, when aborting a transaction, and revert
<span class="lineNum">     704 </span>            :  * any strong lock count acquisition for a lock being acquired.
<span class="lineNum">     705 </span>            :  *
<span class="lineNum">     706 </span>            :  * (Normally, this would only happen if we accept a cancel/die
<span class="lineNum">     707 </span>            :  * interrupt while waiting; but an ereport(ERROR) before or during the lock
<span class="lineNum">     708 </span>            :  * wait is within the realm of possibility, too.)
<a name="709"><span class="lineNum">     709 </span>            :  */</a>
<span class="lineNum">     710 </span>            : void
<span class="lineNum">     711 </span><span class="lineCov">      80566 : LockErrorCleanup(void)</span>
<span class="lineNum">     712 </span>            : {
<span class="lineNum">     713 </span>            :     LWLock     *partitionLock;
<span class="lineNum">     714 </span>            :     DisableTimeoutParams timeouts[2];
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span><span class="lineCov">      80566 :     HOLD_INTERRUPTS();</span>
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span><span class="lineCov">      80566 :     AbortStrongLockAcquire();</span>
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span>            :     /* Nothing to do if we weren't waiting for a lock */
<span class="lineNum">     721 </span><span class="lineCov">      80566 :     if (lockAwaited == NULL)</span>
<span class="lineNum">     722 </span>            :     {
<span class="lineNum">     723 </span><span class="lineCov">      80566 :         RESUME_INTERRUPTS();</span>
<span class="lineNum">     724 </span><span class="lineCov">     161132 :         return;</span>
<span class="lineNum">     725 </span>            :     }
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            :     /*
<span class="lineNum">     728 </span>            :      * Turn off the deadlock and lock timeout timers, if they are still
<span class="lineNum">     729 </span>            :      * running (see ProcSleep).  Note we must preserve the LOCK_TIMEOUT
<span class="lineNum">     730 </span>            :      * indicator flag, since this function is executed before
<span class="lineNum">     731 </span>            :      * ProcessInterrupts when responding to SIGINT; else we'd lose the
<span class="lineNum">     732 </span>            :      * knowledge that the SIGINT came from a lock timeout and not an external
<span class="lineNum">     733 </span>            :      * source.
<span class="lineNum">     734 </span>            :      */
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :     timeouts[0].id = DEADLOCK_TIMEOUT;</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :     timeouts[0].keep_indicator = false;</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :     timeouts[1].id = LOCK_TIMEOUT;</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :     timeouts[1].keep_indicator = true;</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     disable_timeouts(timeouts, 2);</span>
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            :     /* Unlink myself from the wait queue, if on it (might not be anymore!) */
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :     partitionLock = LockHashPartitionLock(lockAwaited-&gt;hashcode);</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :     LWLockAcquire(partitionLock, LW_EXCLUSIVE);</span>
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     if (MyProc-&gt;links.next != NULL)</span>
<span class="lineNum">     746 </span>            :     {
<span class="lineNum">     747 </span>            :         /* We could not have been granted the lock yet */
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :         RemoveFromWaitQueue(MyProc, lockAwaited-&gt;hashcode);</span>
<span class="lineNum">     749 </span>            :     }
<span class="lineNum">     750 </span>            :     else
<span class="lineNum">     751 </span>            :     {
<span class="lineNum">     752 </span>            :         /*
<span class="lineNum">     753 </span>            :          * Somebody kicked us off the lock queue already.  Perhaps they
<span class="lineNum">     754 </span>            :          * granted us the lock, or perhaps they detected a deadlock. If they
<span class="lineNum">     755 </span>            :          * did grant us the lock, we'd better remember it in our local lock
<span class="lineNum">     756 </span>            :          * table.
<span class="lineNum">     757 </span>            :          */
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :         if (MyProc-&gt;waitStatus == STATUS_OK)</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :             GrantAwaitedLock();</span>
<span class="lineNum">     760 </span>            :     }
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :     lockAwaited = NULL;</span>
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :     LWLockRelease(partitionLock);</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :     RESUME_INTERRUPTS();</span>
<span class="lineNum">     767 </span>            : }
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            : /*
<span class="lineNum">     771 </span>            :  * ProcReleaseLocks() -- release locks associated with current transaction
<span class="lineNum">     772 </span>            :  *          at main transaction commit or abort
<span class="lineNum">     773 </span>            :  *
<span class="lineNum">     774 </span>            :  * At main transaction commit, we release standard locks except session locks.
<span class="lineNum">     775 </span>            :  * At main transaction abort, we release all locks including session locks.
<span class="lineNum">     776 </span>            :  *
<span class="lineNum">     777 </span>            :  * Advisory locks are released only if they are transaction-level;
<span class="lineNum">     778 </span>            :  * session-level holds remain, whether this is a commit or not.
<span class="lineNum">     779 </span>            :  *
<span class="lineNum">     780 </span>            :  * At subtransaction commit, we don't release any locks (so this func is not
<span class="lineNum">     781 </span>            :  * needed at all); we will defer the releasing to the parent transaction.
<span class="lineNum">     782 </span>            :  * At subtransaction abort, we release all locks held by the subtransaction;
<span class="lineNum">     783 </span>            :  * this is implemented by retail releasing of the locks under control of
<span class="lineNum">     784 </span>            :  * the ResourceOwner mechanism.
<a name="785"><span class="lineNum">     785 </span>            :  */</a>
<span class="lineNum">     786 </span>            : void
<span class="lineNum">     787 </span><span class="lineCov">      71316 : ProcReleaseLocks(bool isCommit)</span>
<span class="lineNum">     788 </span>            : {
<span class="lineNum">     789 </span><span class="lineCov">      71316 :     if (!MyProc)</span>
<span class="lineNum">     790 </span><span class="lineCov">      71316 :         return;</span>
<span class="lineNum">     791 </span>            :     /* If waiting, get off wait queue (should only be needed after error) */
<span class="lineNum">     792 </span><span class="lineCov">      71316 :     LockErrorCleanup();</span>
<span class="lineNum">     793 </span>            :     /* Release standard locks, including session-level if aborting */
<span class="lineNum">     794 </span><span class="lineCov">      71316 :     LockReleaseAll(DEFAULT_LOCKMETHOD, !isCommit);</span>
<span class="lineNum">     795 </span>            :     /* Release transaction-level advisory locks */
<span class="lineNum">     796 </span><span class="lineCov">      71316 :     LockReleaseAll(USER_LOCKMETHOD, false);</span>
<span class="lineNum">     797 </span>            : }
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span>            : /*
<span class="lineNum">     801 </span>            :  * RemoveProcFromArray() -- Remove this process from the shared ProcArray.
<a name="802"><span class="lineNum">     802 </span>            :  */</a>
<span class="lineNum">     803 </span>            : static void
<span class="lineNum">     804 </span><span class="lineCov">       1212 : RemoveProcFromArray(int code, Datum arg)</span>
<span class="lineNum">     805 </span>            : {
<span class="lineNum">     806 </span><span class="lineCov">       1212 :     Assert(MyProc != NULL);</span>
<span class="lineNum">     807 </span><span class="lineCov">       1212 :     ProcArrayRemove(MyProc, InvalidTransactionId);</span>
<span class="lineNum">     808 </span><span class="lineCov">       1212 : }</span>
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            : /*
<span class="lineNum">     811 </span>            :  * ProcKill() -- Destroy the per-proc data structure for
<span class="lineNum">     812 </span>            :  *      this process. Release any of its held LW locks.
<a name="813"><span class="lineNum">     813 </span>            :  */</a>
<span class="lineNum">     814 </span>            : static void
<span class="lineNum">     815 </span><span class="lineCov">       1212 : ProcKill(int code, Datum arg)</span>
<span class="lineNum">     816 </span>            : {
<span class="lineNum">     817 </span>            :     PGPROC     *proc;
<span class="lineNum">     818 </span>            :     PGPROC     *volatile *procgloballist;
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineCov">       1212 :     Assert(MyProc != NULL);</span>
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            :     /* Make sure we're out of the sync rep lists */
<span class="lineNum">     823 </span><span class="lineCov">       1212 :     SyncRepCleanupAtProcExit();</span>
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            : #ifdef USE_ASSERT_CHECKING
<span class="lineNum">     826 </span>            :     {
<span class="lineNum">     827 </span>            :         int         i;
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            :         /* Last process should have released all locks. */
<span class="lineNum">     830 </span><span class="lineCov">      20604 :         for (i = 0; i &lt; NUM_LOCK_PARTITIONS; i++)</span>
<span class="lineNum">     831 </span><span class="lineCov">      19392 :             Assert(SHMQueueEmpty(&amp;(MyProc-&gt;myProcLocks[i])));</span>
<span class="lineNum">     832 </span>            :     }
<span class="lineNum">     833 </span>            : #endif
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            :     /*
<span class="lineNum">     836 </span>            :      * Release any LW locks I am holding.  There really shouldn't be any, but
<span class="lineNum">     837 </span>            :      * it's cheap to check again before we cut the knees off the LWLock
<span class="lineNum">     838 </span>            :      * facility by releasing our PGPROC ...
<span class="lineNum">     839 </span>            :      */
<span class="lineNum">     840 </span><span class="lineCov">       1212 :     LWLockReleaseAll();</span>
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            :     /* Cancel any pending condition variable sleep, too */
<span class="lineNum">     843 </span><span class="lineCov">       1212 :     ConditionVariableCancelSleep();</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            :     /* Make sure active replication slots are released */
<span class="lineNum">     846 </span><span class="lineCov">       1212 :     if (MyReplicationSlot != NULL)</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :         ReplicationSlotRelease();</span>
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            :     /* Also cleanup all the temporary slots. */
<span class="lineNum">     850 </span><span class="lineCov">       1212 :     ReplicationSlotCleanup();</span>
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span>            :     /*
<span class="lineNum">     853 </span>            :      * Detach from any lock group of which we are a member.  If the leader
<span class="lineNum">     854 </span>            :      * exist before all other group members, it's PGPROC will remain allocated
<span class="lineNum">     855 </span>            :      * until the last group process exits; that process must return the
<span class="lineNum">     856 </span>            :      * leader's PGPROC to the appropriate list.
<span class="lineNum">     857 </span>            :      */
<span class="lineNum">     858 </span><span class="lineCov">       1212 :     if (MyProc-&gt;lockGroupLeader != NULL)</span>
<span class="lineNum">     859 </span>            :     {
<span class="lineNum">     860 </span><span class="lineCov">        760 :         PGPROC     *leader = MyProc-&gt;lockGroupLeader;</span>
<span class="lineNum">     861 </span><span class="lineCov">        760 :         LWLock     *leader_lwlock = LockHashPartitionLockByProc(leader);</span>
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span><span class="lineCov">        760 :         LWLockAcquire(leader_lwlock, LW_EXCLUSIVE);</span>
<span class="lineNum">     864 </span><span class="lineCov">        760 :         Assert(!dlist_is_empty(&amp;leader-&gt;lockGroupMembers));</span>
<span class="lineNum">     865 </span><span class="lineCov">        760 :         dlist_delete(&amp;MyProc-&gt;lockGroupLink);</span>
<span class="lineNum">     866 </span><span class="lineCov">        760 :         if (dlist_is_empty(&amp;leader-&gt;lockGroupMembers))</span>
<span class="lineNum">     867 </span>            :         {
<span class="lineNum">     868 </span><span class="lineCov">         14 :             leader-&gt;lockGroupLeader = NULL;</span>
<span class="lineNum">     869 </span><span class="lineCov">         14 :             if (leader != MyProc)</span>
<span class="lineNum">     870 </span>            :             {
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :                 procgloballist = leader-&gt;procgloballist;</span>
<span class="lineNum">     872 </span>            : 
<span class="lineNum">     873 </span>            :                 /* Leader exited first; return its PGPROC. */
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :                 SpinLockAcquire(ProcStructLock);</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :                 leader-&gt;links.next = (SHM_QUEUE *) *procgloballist;</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :                 *procgloballist = leader;</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :                 SpinLockRelease(ProcStructLock);</span>
<span class="lineNum">     878 </span>            :             }
<span class="lineNum">     879 </span>            :         }
<span class="lineNum">     880 </span><span class="lineCov">        746 :         else if (leader != MyProc)</span>
<span class="lineNum">     881 </span><span class="lineCov">        746 :             MyProc-&gt;lockGroupLeader = NULL;</span>
<span class="lineNum">     882 </span><span class="lineCov">        760 :         LWLockRelease(leader_lwlock);</span>
<span class="lineNum">     883 </span>            :     }
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            :     /*
<span class="lineNum">     886 </span>            :      * Reset MyLatch to the process local one.  This is so that signal
<span class="lineNum">     887 </span>            :      * handlers et al can continue using the latch after the shared latch
<span class="lineNum">     888 </span>            :      * isn't ours anymore. After that clear MyProc and disown the shared
<span class="lineNum">     889 </span>            :      * latch.
<span class="lineNum">     890 </span>            :      */
<span class="lineNum">     891 </span><span class="lineCov">       1212 :     SwitchBackToLocalLatch();</span>
<span class="lineNum">     892 </span><span class="lineCov">       1212 :     proc = MyProc;</span>
<span class="lineNum">     893 </span><span class="lineCov">       1212 :     MyProc = NULL;</span>
<span class="lineNum">     894 </span><span class="lineCov">       1212 :     DisownLatch(&amp;proc-&gt;procLatch);</span>
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span><span class="lineCov">       1212 :     procgloballist = proc-&gt;procgloballist;</span>
<span class="lineNum">     897 </span><span class="lineCov">       1212 :     SpinLockAcquire(ProcStructLock);</span>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            :     /*
<span class="lineNum">     900 </span>            :      * If we're still a member of a locking group, that means we're a leader
<span class="lineNum">     901 </span>            :      * which has somehow exited before its children.  The last remaining child
<span class="lineNum">     902 </span>            :      * will release our PGPROC.  Otherwise, release it now.
<span class="lineNum">     903 </span>            :      */
<span class="lineNum">     904 </span><span class="lineCov">       1212 :     if (proc-&gt;lockGroupLeader == NULL)</span>
<span class="lineNum">     905 </span>            :     {
<span class="lineNum">     906 </span>            :         /* Since lockGroupLeader is NULL, lockGroupMembers should be empty. */
<span class="lineNum">     907 </span><span class="lineCov">       1212 :         Assert(dlist_is_empty(&amp;proc-&gt;lockGroupMembers));</span>
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            :         /* Return PGPROC structure (and semaphore) to appropriate freelist */
<span class="lineNum">     910 </span><span class="lineCov">       1212 :         proc-&gt;links.next = (SHM_QUEUE *) *procgloballist;</span>
<span class="lineNum">     911 </span><span class="lineCov">       1212 :         *procgloballist = proc;</span>
<span class="lineNum">     912 </span>            :     }
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span>            :     /* Update shared estimate of spins_per_delay */
<span class="lineNum">     915 </span><span class="lineCov">       1212 :     ProcGlobal-&gt;spins_per_delay = update_spins_per_delay(ProcGlobal-&gt;spins_per_delay);</span>
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span><span class="lineCov">       1212 :     SpinLockRelease(ProcStructLock);</span>
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span>            :     /*
<span class="lineNum">     920 </span>            :      * This process is no longer present in shared memory in any meaningful
<span class="lineNum">     921 </span>            :      * way, so tell the postmaster we've cleaned up acceptably well. (XXX
<span class="lineNum">     922 </span>            :      * autovac launcher should be included here someday)
<span class="lineNum">     923 </span>            :      */
<span class="lineNum">     924 </span><span class="lineCov">       1212 :     if (IsUnderPostmaster &amp;&amp; !IsAutoVacuumLauncherProcess())</span>
<span class="lineNum">     925 </span><span class="lineCov">       1206 :         MarkPostmasterChildInactive();</span>
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span>            :     /* wake autovac launcher if needed -- see comments in FreeWorkerInfo */
<span class="lineNum">     928 </span><span class="lineCov">       1212 :     if (AutovacuumLauncherPid != 0)</span>
<span class="lineNum">     929 </span><span class="lineCov">          4 :         kill(AutovacuumLauncherPid, SIGUSR2);</span>
<span class="lineNum">     930 </span><span class="lineCov">       1212 : }</span>
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span>            : /*
<span class="lineNum">     933 </span>            :  * AuxiliaryProcKill() -- Cut-down version of ProcKill for auxiliary
<span class="lineNum">     934 </span>            :  *      processes (bgwriter, etc).  The PGPROC and sema are not released, only
<span class="lineNum">     935 </span>            :  *      marked as not-in-use.
<a name="936"><span class="lineNum">     936 </span>            :  */</a>
<span class="lineNum">     937 </span>            : static void
<span class="lineNum">     938 </span><span class="lineCov">          8 : AuxiliaryProcKill(int code, Datum arg)</span>
<span class="lineNum">     939 </span>            : {
<span class="lineNum">     940 </span><span class="lineCov">          8 :     int         proctype = DatumGetInt32(arg);</span>
<span class="lineNum">     941 </span>            :     PGPROC     *auxproc PG_USED_FOR_ASSERTS_ONLY;
<span class="lineNum">     942 </span>            :     PGPROC     *proc;
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span><span class="lineCov">          8 :     Assert(proctype &gt;= 0 &amp;&amp; proctype &lt; NUM_AUXILIARY_PROCS);</span>
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineCov">          8 :     auxproc = &amp;AuxiliaryProcs[proctype];</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineCov">          8 :     Assert(MyProc == auxproc);</span>
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            :     /* Release any LW locks I am holding (see notes above) */
<span class="lineNum">     951 </span><span class="lineCov">          8 :     LWLockReleaseAll();</span>
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span>            :     /* Cancel any pending condition variable sleep, too */
<span class="lineNum">     954 </span><span class="lineCov">          8 :     ConditionVariableCancelSleep();</span>
<span class="lineNum">     955 </span>            : 
<span class="lineNum">     956 </span>            :     /*
<span class="lineNum">     957 </span>            :      * Reset MyLatch to the process local one.  This is so that signal
<span class="lineNum">     958 </span>            :      * handlers et al can continue using the latch after the shared latch
<span class="lineNum">     959 </span>            :      * isn't ours anymore. After that clear MyProc and disown the shared
<span class="lineNum">     960 </span>            :      * latch.
<span class="lineNum">     961 </span>            :      */
<span class="lineNum">     962 </span><span class="lineCov">          8 :     SwitchBackToLocalLatch();</span>
<span class="lineNum">     963 </span><span class="lineCov">          8 :     proc = MyProc;</span>
<span class="lineNum">     964 </span><span class="lineCov">          8 :     MyProc = NULL;</span>
<span class="lineNum">     965 </span><span class="lineCov">          8 :     DisownLatch(&amp;proc-&gt;procLatch);</span>
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span><span class="lineCov">          8 :     SpinLockAcquire(ProcStructLock);</span>
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            :     /* Mark auxiliary proc no longer in use */
<span class="lineNum">     970 </span><span class="lineCov">          8 :     proc-&gt;pid = 0;</span>
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span>            :     /* Update shared estimate of spins_per_delay */
<span class="lineNum">     973 </span><span class="lineCov">          8 :     ProcGlobal-&gt;spins_per_delay = update_spins_per_delay(ProcGlobal-&gt;spins_per_delay);</span>
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span><span class="lineCov">          8 :     SpinLockRelease(ProcStructLock);</span>
<span class="lineNum">     976 </span><span class="lineCov">          8 : }</span>
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            : /*
<span class="lineNum">     979 </span>            :  * AuxiliaryPidGetProc -- get PGPROC for an auxiliary process
<span class="lineNum">     980 </span>            :  * given its PID
<span class="lineNum">     981 </span>            :  *
<span class="lineNum">     982 </span>            :  * Returns NULL if not found.
<a name="983"><span class="lineNum">     983 </span>            :  */</a>
<span class="lineNum">     984 </span>            : PGPROC *
<span class="lineNum">     985 </span><span class="lineNoCov">          0 : AuxiliaryPidGetProc(int pid)</span>
<span class="lineNum">     986 </span>            : {
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :     PGPROC     *result = NULL;</span>
<span class="lineNum">     988 </span>            :     int         index;
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :     if (pid == 0)               /* never match dummy PGPROCs */</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :     for (index = 0; index &lt; NUM_AUXILIARY_PROCS; index++)</span>
<span class="lineNum">     994 </span>            :     {
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :         PGPROC     *proc = &amp;AuxiliaryProcs[index];</span>
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :         if (proc-&gt;pid == pid)</span>
<span class="lineNum">     998 </span>            :         {
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :             result = proc;</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1001 </span>            :         }
<span class="lineNum">    1002 </span>            :     }
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">    1004 </span>            : }
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span>            : /*
<span class="lineNum">    1007 </span>            :  * ProcQueue package: routines for putting processes to sleep
<span class="lineNum">    1008 </span>            :  *      and  waking them up
<span class="lineNum">    1009 </span>            :  */
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            : /*
<span class="lineNum">    1012 </span>            :  * ProcQueueAlloc -- alloc/attach to a shared memory process queue
<span class="lineNum">    1013 </span>            :  *
<span class="lineNum">    1014 </span>            :  * Returns: a pointer to the queue
<span class="lineNum">    1015 </span>            :  * Side Effects: Initializes the queue if it wasn't there before
<span class="lineNum">    1016 </span>            :  */
<span class="lineNum">    1017 </span>            : #ifdef NOT_USED
<span class="lineNum">    1018 </span>            : PROC_QUEUE *
<span class="lineNum">    1019 </span>            : ProcQueueAlloc(const char *name)
<span class="lineNum">    1020 </span>            : {
<span class="lineNum">    1021 </span>            :     PROC_QUEUE *queue;
<span class="lineNum">    1022 </span>            :     bool        found;
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span>            :     queue = (PROC_QUEUE *)
<span class="lineNum">    1025 </span>            :         ShmemInitStruct(name, sizeof(PROC_QUEUE), &amp;found);
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span>            :     if (!found)
<span class="lineNum">    1028 </span>            :         ProcQueueInit(queue);
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span>            :     return queue;
<span class="lineNum">    1031 </span>            : }
<span class="lineNum">    1032 </span>            : #endif
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            : /*
<span class="lineNum">    1035 </span>            :  * ProcQueueInit -- initialize a shared memory process queue
<a name="1036"><span class="lineNum">    1036 </span>            :  */</a>
<span class="lineNum">    1037 </span>            : void
<span class="lineNum">    1038 </span><span class="lineCov">     290498 : ProcQueueInit(PROC_QUEUE *queue)</span>
<span class="lineNum">    1039 </span>            : {
<span class="lineNum">    1040 </span><span class="lineCov">     290498 :     SHMQueueInit(&amp;(queue-&gt;links));</span>
<span class="lineNum">    1041 </span><span class="lineCov">     290498 :     queue-&gt;size = 0;</span>
<span class="lineNum">    1042 </span><span class="lineCov">     290498 : }</span>
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            : /*
<span class="lineNum">    1046 </span>            :  * ProcSleep -- put a process to sleep on the specified lock
<span class="lineNum">    1047 </span>            :  *
<span class="lineNum">    1048 </span>            :  * Caller must have set MyProc-&gt;heldLocks to reflect locks already held
<span class="lineNum">    1049 </span>            :  * on the lockable object by this process (under all XIDs).
<span class="lineNum">    1050 </span>            :  *
<span class="lineNum">    1051 </span>            :  * The lock table's partition lock must be held at entry, and will be held
<span class="lineNum">    1052 </span>            :  * at exit.
<span class="lineNum">    1053 </span>            :  *
<span class="lineNum">    1054 </span>            :  * Result: STATUS_OK if we acquired the lock, STATUS_ERROR if not (deadlock).
<span class="lineNum">    1055 </span>            :  *
<span class="lineNum">    1056 </span>            :  * ASSUME: that no one will fiddle with the queue until after
<span class="lineNum">    1057 </span>            :  *      we release the partition lock.
<span class="lineNum">    1058 </span>            :  *
<span class="lineNum">    1059 </span>            :  * NOTES: The process queue is now a priority queue for locking.
<a name="1060"><span class="lineNum">    1060 </span>            :  */</a>
<span class="lineNum">    1061 </span>            : int
<span class="lineNum">    1062 </span><span class="lineCov">         28 : ProcSleep(LOCALLOCK *locallock, LockMethod lockMethodTable)</span>
<span class="lineNum">    1063 </span>            : {
<span class="lineNum">    1064 </span><span class="lineCov">         28 :     LOCKMODE    lockmode = locallock-&gt;tag.mode;</span>
<span class="lineNum">    1065 </span><span class="lineCov">         28 :     LOCK       *lock = locallock-&gt;lock;</span>
<span class="lineNum">    1066 </span><span class="lineCov">         28 :     PROCLOCK   *proclock = locallock-&gt;proclock;</span>
<span class="lineNum">    1067 </span><span class="lineCov">         28 :     uint32      hashcode = locallock-&gt;hashcode;</span>
<span class="lineNum">    1068 </span><span class="lineCov">         28 :     LWLock     *partitionLock = LockHashPartitionLock(hashcode);</span>
<span class="lineNum">    1069 </span><span class="lineCov">         28 :     PROC_QUEUE *waitQueue = &amp;(lock-&gt;waitProcs);</span>
<span class="lineNum">    1070 </span><span class="lineCov">         28 :     LOCKMASK    myHeldLocks = MyProc-&gt;heldLocks;</span>
<span class="lineNum">    1071 </span><span class="lineCov">         28 :     bool        early_deadlock = false;</span>
<span class="lineNum">    1072 </span><span class="lineCov">         28 :     bool        allow_autovacuum_cancel = true;</span>
<span class="lineNum">    1073 </span>            :     int         myWaitStatus;
<span class="lineNum">    1074 </span>            :     PGPROC     *proc;
<span class="lineNum">    1075 </span><span class="lineCov">         28 :     PGPROC     *leader = MyProc-&gt;lockGroupLeader;</span>
<span class="lineNum">    1076 </span>            :     int         i;
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span>            :     /*
<span class="lineNum">    1079 </span>            :      * If group locking is in use, locks held by members of my locking group
<span class="lineNum">    1080 </span>            :      * need to be included in myHeldLocks.
<span class="lineNum">    1081 </span>            :      */
<span class="lineNum">    1082 </span><span class="lineCov">         28 :     if (leader != NULL)</span>
<span class="lineNum">    1083 </span>            :     {
<span class="lineNum">    1084 </span><span class="lineCov">          4 :         SHM_QUEUE  *procLocks = &amp;(lock-&gt;procLocks);</span>
<span class="lineNum">    1085 </span>            :         PROCLOCK   *otherproclock;
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span><span class="lineCov">          4 :         otherproclock = (PROCLOCK *)</span>
<span class="lineNum">    1088 </span>            :             SHMQueueNext(procLocks, procLocks, offsetof(PROCLOCK, lockLink));
<span class="lineNum">    1089 </span><span class="lineCov">         16 :         while (otherproclock != NULL)</span>
<span class="lineNum">    1090 </span>            :         {
<span class="lineNum">    1091 </span><span class="lineCov">          8 :             if (otherproclock-&gt;groupLeader == leader)</span>
<span class="lineNum">    1092 </span><span class="lineCov">          4 :                 myHeldLocks |= otherproclock-&gt;holdMask;</span>
<span class="lineNum">    1093 </span><span class="lineCov">          8 :             otherproclock = (PROCLOCK *)</span>
<span class="lineNum">    1094 </span><span class="lineCov">          8 :                 SHMQueueNext(procLocks, &amp;otherproclock-&gt;lockLink,</span>
<span class="lineNum">    1095 </span>            :                              offsetof(PROCLOCK, lockLink));
<span class="lineNum">    1096 </span>            :         }
<span class="lineNum">    1097 </span>            :     }
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            :     /*
<span class="lineNum">    1100 </span>            :      * Determine where to add myself in the wait queue.
<span class="lineNum">    1101 </span>            :      *
<span class="lineNum">    1102 </span>            :      * Normally I should go at the end of the queue.  However, if I already
<span class="lineNum">    1103 </span>            :      * hold locks that conflict with the request of any previous waiter, put
<span class="lineNum">    1104 </span>            :      * myself in the queue just in front of the first such waiter. This is not
<span class="lineNum">    1105 </span>            :      * a necessary step, since deadlock detection would move me to before that
<span class="lineNum">    1106 </span>            :      * waiter anyway; but it's relatively cheap to detect such a conflict
<span class="lineNum">    1107 </span>            :      * immediately, and avoid delaying till deadlock timeout.
<span class="lineNum">    1108 </span>            :      *
<span class="lineNum">    1109 </span>            :      * Special case: if I find I should go in front of some waiter, check to
<span class="lineNum">    1110 </span>            :      * see if I conflict with already-held locks or the requests before that
<span class="lineNum">    1111 </span>            :      * waiter.  If not, then just grant myself the requested lock immediately.
<span class="lineNum">    1112 </span>            :      * This is the same as the test for immediate grant in LockAcquire, except
<span class="lineNum">    1113 </span>            :      * we are only considering the part of the wait queue before my insertion
<span class="lineNum">    1114 </span>            :      * point.
<span class="lineNum">    1115 </span>            :      */
<span class="lineNum">    1116 </span><span class="lineCov">         28 :     if (myHeldLocks != 0)</span>
<span class="lineNum">    1117 </span>            :     {
<span class="lineNum">    1118 </span><span class="lineCov">          2 :         LOCKMASK    aheadRequests = 0;</span>
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span><span class="lineCov">          2 :         proc = (PGPROC *) waitQueue-&gt;links.next;</span>
<span class="lineNum">    1121 </span><span class="lineCov">          2 :         for (i = 0; i &lt; waitQueue-&gt;size; i++)</span>
<span class="lineNum">    1122 </span>            :         {
<span class="lineNum">    1123 </span>            :             /*
<span class="lineNum">    1124 </span>            :              * If we're part of the same locking group as this waiter, its
<span class="lineNum">    1125 </span>            :              * locks neither conflict with ours nor contribute to
<span class="lineNum">    1126 </span>            :              * aheadRequests.
<span class="lineNum">    1127 </span>            :              */
<span class="lineNum">    1128 </span><span class="lineCov">          2 :             if (leader != NULL &amp;&amp; leader == proc-&gt;lockGroupLeader)</span>
<span class="lineNum">    1129 </span>            :             {
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :                 proc = (PGPROC *) proc-&gt;links.next;</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1132 </span>            :             }
<span class="lineNum">    1133 </span>            :             /* Must he wait for me? */
<span class="lineNum">    1134 </span><span class="lineCov">          2 :             if (lockMethodTable-&gt;conflictTab[proc-&gt;waitLockMode] &amp; myHeldLocks)</span>
<span class="lineNum">    1135 </span>            :             {
<span class="lineNum">    1136 </span>            :                 /* Must I wait for him ? */
<span class="lineNum">    1137 </span><span class="lineCov">          2 :                 if (lockMethodTable-&gt;conflictTab[lockmode] &amp; proc-&gt;heldLocks)</span>
<span class="lineNum">    1138 </span>            :                 {
<span class="lineNum">    1139 </span>            :                     /*
<span class="lineNum">    1140 </span>            :                      * Yes, so we have a deadlock.  Easiest way to clean up
<span class="lineNum">    1141 </span>            :                      * correctly is to call RemoveFromWaitQueue(), but we
<span class="lineNum">    1142 </span>            :                      * can't do that until we are *on* the wait queue. So, set
<span class="lineNum">    1143 </span>            :                      * a flag to check below, and break out of loop.  Also,
<span class="lineNum">    1144 </span>            :                      * record deadlock info for later message.
<span class="lineNum">    1145 </span>            :                      */
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :                     RememberSimpleDeadLock(MyProc, lockmode, lock, proc);</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :                     early_deadlock = true;</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1149 </span>            :                 }
<span class="lineNum">    1150 </span>            :                 /* I must go before this waiter.  Check special case. */
<span class="lineNum">    1151 </span><span class="lineCov">          4 :                 if ((lockMethodTable-&gt;conflictTab[lockmode] &amp; aheadRequests) == 0 &amp;&amp;</span>
<span class="lineNum">    1152 </span><span class="lineCov">          2 :                     LockCheckConflicts(lockMethodTable,</span>
<span class="lineNum">    1153 </span>            :                                        lockmode,
<span class="lineNum">    1154 </span>            :                                        lock,
<span class="lineNum">    1155 </span>            :                                        proclock) == STATUS_OK)
<span class="lineNum">    1156 </span>            :                 {
<span class="lineNum">    1157 </span>            :                     /* Skip the wait and just grant myself the lock. */
<span class="lineNum">    1158 </span><span class="lineCov">          2 :                     GrantLock(lock, proclock, lockmode);</span>
<span class="lineNum">    1159 </span><span class="lineCov">          2 :                     GrantAwaitedLock();</span>
<span class="lineNum">    1160 </span><span class="lineCov">          2 :                     return STATUS_OK;</span>
<span class="lineNum">    1161 </span>            :                 }
<span class="lineNum">    1162 </span>            :                 /* Break out of loop to put myself before him */
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1164 </span>            :             }
<span class="lineNum">    1165 </span>            :             /* Nope, so advance to next waiter */
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :             aheadRequests |= LOCKBIT_ON(proc-&gt;waitLockMode);</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :             proc = (PGPROC *) proc-&gt;links.next;</span>
<span class="lineNum">    1168 </span>            :         }
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span>            :         /*
<span class="lineNum">    1171 </span>            :          * If we fall out of loop normally, proc points to waitQueue head, so
<span class="lineNum">    1172 </span>            :          * we will insert at tail of queue as desired.
<span class="lineNum">    1173 </span>            :          */
<span class="lineNum">    1174 </span>            :     }
<span class="lineNum">    1175 </span>            :     else
<span class="lineNum">    1176 </span>            :     {
<span class="lineNum">    1177 </span>            :         /* I hold no locks, so I can't push in front of anyone. */
<span class="lineNum">    1178 </span><span class="lineCov">         26 :         proc = (PGPROC *) &amp;(waitQueue-&gt;links);</span>
<span class="lineNum">    1179 </span>            :     }
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span>            :     /*
<span class="lineNum">    1182 </span>            :      * Insert self into queue, ahead of the given proc (or at tail of queue).
<span class="lineNum">    1183 </span>            :      */
<span class="lineNum">    1184 </span><span class="lineCov">         26 :     SHMQueueInsertBefore(&amp;(proc-&gt;links), &amp;(MyProc-&gt;links));</span>
<span class="lineNum">    1185 </span><span class="lineCov">         26 :     waitQueue-&gt;size++;</span>
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span><span class="lineCov">         26 :     lock-&gt;waitMask |= LOCKBIT_ON(lockmode);</span>
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span>            :     /* Set up wait information in PGPROC object, too */
<span class="lineNum">    1190 </span><span class="lineCov">         26 :     MyProc-&gt;waitLock = lock;</span>
<span class="lineNum">    1191 </span><span class="lineCov">         26 :     MyProc-&gt;waitProcLock = proclock;</span>
<span class="lineNum">    1192 </span><span class="lineCov">         26 :     MyProc-&gt;waitLockMode = lockmode;</span>
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span><span class="lineCov">         26 :     MyProc-&gt;waitStatus = STATUS_WAITING;</span>
<span class="lineNum">    1195 </span>            : 
<span class="lineNum">    1196 </span>            :     /*
<span class="lineNum">    1197 </span>            :      * If we detected deadlock, give up without waiting.  This must agree with
<span class="lineNum">    1198 </span>            :      * CheckDeadLock's recovery code.
<span class="lineNum">    1199 </span>            :      */
<span class="lineNum">    1200 </span><span class="lineCov">         26 :     if (early_deadlock)</span>
<span class="lineNum">    1201 </span>            :     {
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :         RemoveFromWaitQueue(MyProc, hashcode);</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :         return STATUS_ERROR;</span>
<span class="lineNum">    1204 </span>            :     }
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span>            :     /* mark that we are waiting for a lock */
<span class="lineNum">    1207 </span><span class="lineCov">         26 :     lockAwaited = locallock;</span>
<span class="lineNum">    1208 </span>            : 
<span class="lineNum">    1209 </span>            :     /*
<span class="lineNum">    1210 </span>            :      * Release the lock table's partition lock.
<span class="lineNum">    1211 </span>            :      *
<span class="lineNum">    1212 </span>            :      * NOTE: this may also cause us to exit critical-section state, possibly
<span class="lineNum">    1213 </span>            :      * allowing a cancel/die interrupt to be accepted. This is OK because we
<span class="lineNum">    1214 </span>            :      * have recorded the fact that we are waiting for a lock, and so
<span class="lineNum">    1215 </span>            :      * LockErrorCleanup will clean up if cancel/die happens.
<span class="lineNum">    1216 </span>            :      */
<span class="lineNum">    1217 </span><span class="lineCov">         26 :     LWLockRelease(partitionLock);</span>
<span class="lineNum">    1218 </span>            : 
<span class="lineNum">    1219 </span>            :     /*
<span class="lineNum">    1220 </span>            :      * Also, now that we will successfully clean up after an ereport, it's
<span class="lineNum">    1221 </span>            :      * safe to check to see if there's a buffer pin deadlock against the
<span class="lineNum">    1222 </span>            :      * Startup process.  Of course, that's only necessary if we're doing Hot
<span class="lineNum">    1223 </span>            :      * Standby and are not the Startup process ourselves.
<span class="lineNum">    1224 </span>            :      */
<span class="lineNum">    1225 </span><span class="lineCov">         26 :     if (RecoveryInProgress() &amp;&amp; !InRecovery)</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :         CheckRecoveryConflictDeadlock();</span>
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span>            :     /* Reset deadlock_state before enabling the timeout handler */
<span class="lineNum">    1229 </span><span class="lineCov">         26 :     deadlock_state = DS_NOT_YET_CHECKED;</span>
<span class="lineNum">    1230 </span><span class="lineCov">         26 :     got_deadlock_timeout = false;</span>
<span class="lineNum">    1231 </span>            : 
<span class="lineNum">    1232 </span>            :     /*
<span class="lineNum">    1233 </span>            :      * Set timer so we can wake up after awhile and check for a deadlock. If a
<span class="lineNum">    1234 </span>            :      * deadlock is detected, the handler sets MyProc-&gt;waitStatus =
<span class="lineNum">    1235 </span>            :      * STATUS_ERROR, allowing us to know that we must report failure rather
<span class="lineNum">    1236 </span>            :      * than success.
<span class="lineNum">    1237 </span>            :      *
<span class="lineNum">    1238 </span>            :      * By delaying the check until we've waited for a bit, we can avoid
<span class="lineNum">    1239 </span>            :      * running the rather expensive deadlock-check code in most cases.
<span class="lineNum">    1240 </span>            :      *
<span class="lineNum">    1241 </span>            :      * If LockTimeout is set, also enable the timeout for that.  We can save a
<span class="lineNum">    1242 </span>            :      * few cycles by enabling both timeout sources in one call.
<span class="lineNum">    1243 </span>            :      *
<span class="lineNum">    1244 </span>            :      * If InHotStandby we set lock waits slightly later for clarity with other
<span class="lineNum">    1245 </span>            :      * code.
<span class="lineNum">    1246 </span>            :      */
<span class="lineNum">    1247 </span><span class="lineCov">         26 :     if (!InHotStandby)</span>
<span class="lineNum">    1248 </span>            :     {
<span class="lineNum">    1249 </span><span class="lineCov">         26 :         if (LockTimeout &gt; 0)</span>
<span class="lineNum">    1250 </span>            :         {
<span class="lineNum">    1251 </span>            :             EnableTimeoutParams timeouts[2];
<span class="lineNum">    1252 </span>            : 
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :             timeouts[0].id = DEADLOCK_TIMEOUT;</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :             timeouts[0].type = TMPARAM_AFTER;</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :             timeouts[0].delay_ms = DeadlockTimeout;</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :             timeouts[1].id = LOCK_TIMEOUT;</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :             timeouts[1].type = TMPARAM_AFTER;</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :             timeouts[1].delay_ms = LockTimeout;</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :             enable_timeouts(timeouts, 2);</span>
<span class="lineNum">    1260 </span>            :         }
<span class="lineNum">    1261 </span>            :         else
<span class="lineNum">    1262 </span><span class="lineCov">         26 :             enable_timeout_after(DEADLOCK_TIMEOUT, DeadlockTimeout);</span>
<span class="lineNum">    1263 </span>            :     }
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span>            :     /*
<span class="lineNum">    1266 </span>            :      * If somebody wakes us between LWLockRelease and WaitLatch, the latch
<span class="lineNum">    1267 </span>            :      * will not wait. But a set latch does not necessarily mean that the lock
<span class="lineNum">    1268 </span>            :      * is free now, as there are many other sources for latch sets than
<span class="lineNum">    1269 </span>            :      * somebody releasing the lock.
<span class="lineNum">    1270 </span>            :      *
<span class="lineNum">    1271 </span>            :      * We process interrupts whenever the latch has been set, so cancel/die
<span class="lineNum">    1272 </span>            :      * interrupts are processed quickly. This means we must not mind losing
<span class="lineNum">    1273 </span>            :      * control to a cancel/die interrupt here.  We don't, because we have no
<span class="lineNum">    1274 </span>            :      * shared-state-change work to do after being granted the lock (the
<span class="lineNum">    1275 </span>            :      * grantor did it all).  We do have to worry about canceling the deadlock
<span class="lineNum">    1276 </span>            :      * timeout and updating the locallock table, but if we lose control to an
<span class="lineNum">    1277 </span>            :      * error, LockErrorCleanup will fix that up.
<span class="lineNum">    1278 </span>            :      */
<span class="lineNum">    1279 </span>            :     do
<span class="lineNum">    1280 </span>            :     {
<span class="lineNum">    1281 </span><span class="lineCov">         28 :         if (InHotStandby)</span>
<span class="lineNum">    1282 </span>            :         {
<span class="lineNum">    1283 </span>            :             /* Set a timer and wait for that or for the Lock to be granted */
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :             ResolveRecoveryConflictWithLock(locallock-&gt;tag.lock);</span>
<span class="lineNum">    1285 </span>            :         }
<span class="lineNum">    1286 </span>            :         else
<span class="lineNum">    1287 </span>            :         {
<span class="lineNum">    1288 </span><span class="lineCov">         28 :             (void) WaitLatch(MyLatch, WL_LATCH_SET | WL_EXIT_ON_PM_DEATH, 0,</span>
<span class="lineNum">    1289 </span><span class="lineCov">         28 :                              PG_WAIT_LOCK | locallock-&gt;tag.lock.locktag_type);</span>
<span class="lineNum">    1290 </span><span class="lineCov">         28 :             ResetLatch(MyLatch);</span>
<span class="lineNum">    1291 </span>            :             /* check for deadlocks first, as that's probably log-worthy */
<span class="lineNum">    1292 </span><span class="lineCov">         28 :             if (got_deadlock_timeout)</span>
<span class="lineNum">    1293 </span>            :             {
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :                 CheckDeadLock();</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :                 got_deadlock_timeout = false;</span>
<span class="lineNum">    1296 </span>            :             }
<span class="lineNum">    1297 </span><span class="lineCov">         28 :             CHECK_FOR_INTERRUPTS();</span>
<span class="lineNum">    1298 </span>            :         }
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span>            :         /*
<span class="lineNum">    1301 </span>            :          * waitStatus could change from STATUS_WAITING to something else
<span class="lineNum">    1302 </span>            :          * asynchronously.  Read it just once per loop to prevent surprising
<span class="lineNum">    1303 </span>            :          * behavior (such as missing log messages).
<span class="lineNum">    1304 </span>            :          */
<span class="lineNum">    1305 </span><span class="lineCov">         28 :         myWaitStatus = *((volatile int *) &amp;MyProc-&gt;waitStatus);</span>
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span>            :         /*
<span class="lineNum">    1308 </span>            :          * If we are not deadlocked, but are waiting on an autovacuum-induced
<span class="lineNum">    1309 </span>            :          * task, send a signal to interrupt it.
<span class="lineNum">    1310 </span>            :          */
<span class="lineNum">    1311 </span><span class="lineCov">         28 :         if (deadlock_state == DS_BLOCKED_BY_AUTOVACUUM &amp;&amp; allow_autovacuum_cancel)</span>
<span class="lineNum">    1312 </span>            :         {
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :             PGPROC     *autovac = GetBlockingAutoVacuumPgproc();</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :             PGXACT     *autovac_pgxact = &amp;ProcGlobal-&gt;allPgXact[autovac-&gt;pgprocno];</span>
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :             LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);</span>
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span>            :             /*
<span class="lineNum">    1319 </span>            :              * Only do it if the worker is not working to protect against Xid
<span class="lineNum">    1320 </span>            :              * wraparound.
<span class="lineNum">    1321 </span>            :              */
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :             if ((autovac_pgxact-&gt;vacuumFlags &amp; PROC_IS_AUTOVACUUM) &amp;&amp;</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :                 !(autovac_pgxact-&gt;vacuumFlags &amp; PROC_VACUUM_FOR_WRAPAROUND))</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :                 int         pid = autovac-&gt;pid;</span>
<span class="lineNum">    1326 </span>            :                 StringInfoData locktagbuf;
<span class="lineNum">    1327 </span>            :                 StringInfoData logbuf;  /* errdetail for server log */
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :                 initStringInfo(&amp;locktagbuf);</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :                 initStringInfo(&amp;logbuf);</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :                 DescribeLockTag(&amp;locktagbuf, &amp;lock-&gt;tag);</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :                 appendStringInfo(&amp;logbuf,</span>
<span class="lineNum">    1333 </span>            :                                  _(&quot;Process %d waits for %s on %s.&quot;),
<span class="lineNum">    1334 </span>            :                                  MyProcPid,
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :                                  GetLockmodeName(lock-&gt;tag.locktag_lockmethodid,</span>
<span class="lineNum">    1336 </span>            :                                                  lockmode),
<span class="lineNum">    1337 </span>            :                                  locktagbuf.data);
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span>            :                 /* release lock as quickly as possible */
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :                 LWLockRelease(ProcArrayLock);</span>
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span>            :                 /* send the autovacuum worker Back to Old Kent Road */
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :                 ereport(DEBUG1,</span>
<span class="lineNum">    1344 </span>            :                         (errmsg(&quot;sending cancel to blocking autovacuum PID %d&quot;,
<span class="lineNum">    1345 </span>            :                                 pid),
<span class="lineNum">    1346 </span>            :                          errdetail_log(&quot;%s&quot;, logbuf.data)));
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :                 if (kill(pid, SIGINT) &lt; 0)</span>
<span class="lineNum">    1349 </span>            :                 {
<span class="lineNum">    1350 </span>            :                     /*
<span class="lineNum">    1351 </span>            :                      * There's a race condition here: once we release the
<span class="lineNum">    1352 </span>            :                      * ProcArrayLock, it's possible for the autovac worker to
<span class="lineNum">    1353 </span>            :                      * close up shop and exit before we can do the kill().
<span class="lineNum">    1354 </span>            :                      * Therefore, we do not whinge about no-such-process.
<span class="lineNum">    1355 </span>            :                      * Other errors such as EPERM could conceivably happen if
<span class="lineNum">    1356 </span>            :                      * the kernel recycles the PID fast enough, but such cases
<span class="lineNum">    1357 </span>            :                      * seem improbable enough that it's probably best to issue
<span class="lineNum">    1358 </span>            :                      * a warning if we see some other errno.
<span class="lineNum">    1359 </span>            :                      */
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :                     if (errno != ESRCH)</span>
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :                         ereport(WARNING,</span>
<span class="lineNum">    1362 </span>            :                                 (errmsg(&quot;could not send signal to process %d: %m&quot;,
<span class="lineNum">    1363 </span>            :                                         pid)));
<span class="lineNum">    1364 </span>            :                 }
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :                 pfree(logbuf.data);</span>
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :                 pfree(locktagbuf.data);</span>
<span class="lineNum">    1368 </span>            :             }
<span class="lineNum">    1369 </span>            :             else
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :                 LWLockRelease(ProcArrayLock);</span>
<span class="lineNum">    1371 </span>            : 
<span class="lineNum">    1372 </span>            :             /* prevent signal from being resent more than once */
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :             allow_autovacuum_cancel = false;</span>
<span class="lineNum">    1374 </span>            :         }
<span class="lineNum">    1375 </span>            : 
<span class="lineNum">    1376 </span>            :         /*
<span class="lineNum">    1377 </span>            :          * If awoken after the deadlock check interrupt has run, and
<span class="lineNum">    1378 </span>            :          * log_lock_waits is on, then report about the wait.
<span class="lineNum">    1379 </span>            :          */
<span class="lineNum">    1380 </span><span class="lineCov">         28 :         if (log_lock_waits &amp;&amp; deadlock_state != DS_NOT_YET_CHECKED)</span>
<span class="lineNum">    1381 </span>            :         {
<span class="lineNum">    1382 </span>            :             StringInfoData buf,
<span class="lineNum">    1383 </span>            :                         lock_waiters_sbuf,
<span class="lineNum">    1384 </span>            :                         lock_holders_sbuf;
<span class="lineNum">    1385 </span>            :             const char *modename;
<span class="lineNum">    1386 </span>            :             long        secs;
<span class="lineNum">    1387 </span>            :             int         usecs;
<span class="lineNum">    1388 </span>            :             long        msecs;
<span class="lineNum">    1389 </span>            :             SHM_QUEUE  *procLocks;
<span class="lineNum">    1390 </span>            :             PROCLOCK   *proclock;
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :             bool        first_holder = true,</span>
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :                         first_waiter = true;</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :             int         lockHoldersNum = 0;</span>
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :             initStringInfo(&amp;buf);</span>
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :             initStringInfo(&amp;lock_waiters_sbuf);</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :             initStringInfo(&amp;lock_holders_sbuf);</span>
<span class="lineNum">    1398 </span>            : 
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :             DescribeLockTag(&amp;buf, &amp;locallock-&gt;tag.lock);</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :             modename = GetLockmodeName(locallock-&gt;tag.lock.locktag_lockmethodid,</span>
<span class="lineNum">    1401 </span>            :                                        lockmode);
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :             TimestampDifference(get_timeout_start_time(DEADLOCK_TIMEOUT),</span>
<span class="lineNum">    1403 </span>            :                                 GetCurrentTimestamp(),
<span class="lineNum">    1404 </span>            :                                 &amp;secs, &amp;usecs);
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :             msecs = secs * 1000 + usecs / 1000;</span>
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :             usecs = usecs % 1000;</span>
<span class="lineNum">    1407 </span>            : 
<span class="lineNum">    1408 </span>            :             /*
<span class="lineNum">    1409 </span>            :              * we loop over the lock's procLocks to gather a list of all
<span class="lineNum">    1410 </span>            :              * holders and waiters. Thus we will be able to provide more
<span class="lineNum">    1411 </span>            :              * detailed information for lock debugging purposes.
<span class="lineNum">    1412 </span>            :              *
<span class="lineNum">    1413 </span>            :              * lock-&gt;procLocks contains all processes which hold or wait for
<span class="lineNum">    1414 </span>            :              * this lock.
<span class="lineNum">    1415 </span>            :              */
<span class="lineNum">    1416 </span>            : 
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :             LWLockAcquire(partitionLock, LW_SHARED);</span>
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :             procLocks = &amp;(lock-&gt;procLocks);</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :             proclock = (PROCLOCK *) SHMQueueNext(procLocks, procLocks,</span>
<span class="lineNum">    1421 </span>            :                                                  offsetof(PROCLOCK, lockLink));
<span class="lineNum">    1422 </span>            : 
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :             while (proclock)</span>
<span class="lineNum">    1424 </span>            :             {
<span class="lineNum">    1425 </span>            :                 /*
<span class="lineNum">    1426 </span>            :                  * we are a waiter if myProc-&gt;waitProcLock == proclock; we are
<span class="lineNum">    1427 </span>            :                  * a holder if it is NULL or something different
<span class="lineNum">    1428 </span>            :                  */
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :                 if (proclock-&gt;tag.myProc-&gt;waitProcLock == proclock)</span>
<span class="lineNum">    1430 </span>            :                 {
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :                     if (first_waiter)</span>
<span class="lineNum">    1432 </span>            :                     {
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :                         appendStringInfo(&amp;lock_waiters_sbuf, &quot;%d&quot;,</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :                                          proclock-&gt;tag.myProc-&gt;pid);</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :                         first_waiter = false;</span>
<span class="lineNum">    1436 </span>            :                     }
<span class="lineNum">    1437 </span>            :                     else
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :                         appendStringInfo(&amp;lock_waiters_sbuf, &quot;, %d&quot;,</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :                                          proclock-&gt;tag.myProc-&gt;pid);</span>
<span class="lineNum">    1440 </span>            :                 }
<span class="lineNum">    1441 </span>            :                 else
<span class="lineNum">    1442 </span>            :                 {
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :                     if (first_holder)</span>
<span class="lineNum">    1444 </span>            :                     {
<span class="lineNum">    1445 </span><span class="lineNoCov">          0 :                         appendStringInfo(&amp;lock_holders_sbuf, &quot;%d&quot;,</span>
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :                                          proclock-&gt;tag.myProc-&gt;pid);</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :                         first_holder = false;</span>
<span class="lineNum">    1448 </span>            :                     }
<span class="lineNum">    1449 </span>            :                     else
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :                         appendStringInfo(&amp;lock_holders_sbuf, &quot;, %d&quot;,</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :                                          proclock-&gt;tag.myProc-&gt;pid);</span>
<span class="lineNum">    1452 </span>            : 
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :                     lockHoldersNum++;</span>
<span class="lineNum">    1454 </span>            :                 }
<span class="lineNum">    1455 </span>            : 
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :                 proclock = (PROCLOCK *) SHMQueueNext(procLocks, &amp;proclock-&gt;lockLink,</span>
<span class="lineNum">    1457 </span>            :                                                      offsetof(PROCLOCK, lockLink));
<span class="lineNum">    1458 </span>            :             }
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :             LWLockRelease(partitionLock);</span>
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :             if (deadlock_state == DS_SOFT_DEADLOCK)</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :                 ereport(LOG,</span>
<span class="lineNum">    1464 </span>            :                         (errmsg(&quot;process %d avoided deadlock for %s on %s by rearranging queue order after %ld.%03d ms&quot;,
<span class="lineNum">    1465 </span>            :                                 MyProcPid, modename, buf.data, msecs, usecs),
<span class="lineNum">    1466 </span>            :                          (errdetail_log_plural(&quot;Process holding the lock: %s. Wait queue: %s.&quot;,
<span class="lineNum">    1467 </span>            :                                                &quot;Processes holding the lock: %s. Wait queue: %s.&quot;,
<span class="lineNum">    1468 </span>            :                                                lockHoldersNum, lock_holders_sbuf.data, lock_waiters_sbuf.data))));
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :             else if (deadlock_state == DS_HARD_DEADLOCK)</span>
<span class="lineNum">    1470 </span>            :             {
<span class="lineNum">    1471 </span>            :                 /*
<span class="lineNum">    1472 </span>            :                  * This message is a bit redundant with the error that will be
<span class="lineNum">    1473 </span>            :                  * reported subsequently, but in some cases the error report
<span class="lineNum">    1474 </span>            :                  * might not make it to the log (eg, if it's caught by an
<span class="lineNum">    1475 </span>            :                  * exception handler), and we want to ensure all long-wait
<span class="lineNum">    1476 </span>            :                  * events get logged.
<span class="lineNum">    1477 </span>            :                  */
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :                 ereport(LOG,</span>
<span class="lineNum">    1479 </span>            :                         (errmsg(&quot;process %d detected deadlock while waiting for %s on %s after %ld.%03d ms&quot;,
<span class="lineNum">    1480 </span>            :                                 MyProcPid, modename, buf.data, msecs, usecs),
<span class="lineNum">    1481 </span>            :                          (errdetail_log_plural(&quot;Process holding the lock: %s. Wait queue: %s.&quot;,
<span class="lineNum">    1482 </span>            :                                                &quot;Processes holding the lock: %s. Wait queue: %s.&quot;,
<span class="lineNum">    1483 </span>            :                                                lockHoldersNum, lock_holders_sbuf.data, lock_waiters_sbuf.data))));
<span class="lineNum">    1484 </span>            :             }
<span class="lineNum">    1485 </span>            : 
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :             if (myWaitStatus == STATUS_WAITING)</span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :                 ereport(LOG,</span>
<span class="lineNum">    1488 </span>            :                         (errmsg(&quot;process %d still waiting for %s on %s after %ld.%03d ms&quot;,
<span class="lineNum">    1489 </span>            :                                 MyProcPid, modename, buf.data, msecs, usecs),
<span class="lineNum">    1490 </span>            :                          (errdetail_log_plural(&quot;Process holding the lock: %s. Wait queue: %s.&quot;,
<span class="lineNum">    1491 </span>            :                                                &quot;Processes holding the lock: %s. Wait queue: %s.&quot;,
<span class="lineNum">    1492 </span>            :                                                lockHoldersNum, lock_holders_sbuf.data, lock_waiters_sbuf.data))));
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :             else if (myWaitStatus == STATUS_OK)</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :                 ereport(LOG,</span>
<span class="lineNum">    1495 </span>            :                         (errmsg(&quot;process %d acquired %s on %s after %ld.%03d ms&quot;,
<span class="lineNum">    1496 </span>            :                                 MyProcPid, modename, buf.data, msecs, usecs)));
<span class="lineNum">    1497 </span>            :             else
<span class="lineNum">    1498 </span>            :             {
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :                 Assert(myWaitStatus == STATUS_ERROR);</span>
<span class="lineNum">    1500 </span>            : 
<span class="lineNum">    1501 </span>            :                 /*
<span class="lineNum">    1502 </span>            :                  * Currently, the deadlock checker always kicks its own
<span class="lineNum">    1503 </span>            :                  * process, which means that we'll only see STATUS_ERROR when
<span class="lineNum">    1504 </span>            :                  * deadlock_state == DS_HARD_DEADLOCK, and there's no need to
<span class="lineNum">    1505 </span>            :                  * print redundant messages.  But for completeness and
<span class="lineNum">    1506 </span>            :                  * future-proofing, print a message if it looks like someone
<span class="lineNum">    1507 </span>            :                  * else kicked us off the lock.
<span class="lineNum">    1508 </span>            :                  */
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :                 if (deadlock_state != DS_HARD_DEADLOCK)</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :                     ereport(LOG,</span>
<span class="lineNum">    1511 </span>            :                             (errmsg(&quot;process %d failed to acquire %s on %s after %ld.%03d ms&quot;,
<span class="lineNum">    1512 </span>            :                                     MyProcPid, modename, buf.data, msecs, usecs),
<span class="lineNum">    1513 </span>            :                              (errdetail_log_plural(&quot;Process holding the lock: %s. Wait queue: %s.&quot;,
<span class="lineNum">    1514 </span>            :                                                    &quot;Processes holding the lock: %s. Wait queue: %s.&quot;,
<span class="lineNum">    1515 </span>            :                                                    lockHoldersNum, lock_holders_sbuf.data, lock_waiters_sbuf.data))));
<span class="lineNum">    1516 </span>            :             }
<span class="lineNum">    1517 </span>            : 
<span class="lineNum">    1518 </span>            :             /*
<span class="lineNum">    1519 </span>            :              * At this point we might still need to wait for the lock. Reset
<span class="lineNum">    1520 </span>            :              * state so we don't print the above messages again.
<span class="lineNum">    1521 </span>            :              */
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :             deadlock_state = DS_NO_DEADLOCK;</span>
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :             pfree(buf.data);</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :             pfree(lock_holders_sbuf.data);</span>
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :             pfree(lock_waiters_sbuf.data);</span>
<span class="lineNum">    1527 </span>            :         }
<span class="lineNum">    1528 </span><span class="lineCov">         28 :     } while (myWaitStatus == STATUS_WAITING);</span>
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span>            :     /*
<span class="lineNum">    1531 </span>            :      * Disable the timers, if they are still running.  As in LockErrorCleanup,
<span class="lineNum">    1532 </span>            :      * we must preserve the LOCK_TIMEOUT indicator flag: if a lock timeout has
<span class="lineNum">    1533 </span>            :      * already caused QueryCancelPending to become set, we want the cancel to
<span class="lineNum">    1534 </span>            :      * be reported as a lock timeout, not a user cancel.
<span class="lineNum">    1535 </span>            :      */
<span class="lineNum">    1536 </span><span class="lineCov">         26 :     if (!InHotStandby)</span>
<span class="lineNum">    1537 </span>            :     {
<span class="lineNum">    1538 </span><span class="lineCov">         26 :         if (LockTimeout &gt; 0)</span>
<span class="lineNum">    1539 </span>            :         {
<span class="lineNum">    1540 </span>            :             DisableTimeoutParams timeouts[2];
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :             timeouts[0].id = DEADLOCK_TIMEOUT;</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :             timeouts[0].keep_indicator = false;</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :             timeouts[1].id = LOCK_TIMEOUT;</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :             timeouts[1].keep_indicator = true;</span>
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :             disable_timeouts(timeouts, 2);</span>
<span class="lineNum">    1547 </span>            :         }
<span class="lineNum">    1548 </span>            :         else
<span class="lineNum">    1549 </span><span class="lineCov">         26 :             disable_timeout(DEADLOCK_TIMEOUT, false);</span>
<span class="lineNum">    1550 </span>            :     }
<span class="lineNum">    1551 </span>            : 
<span class="lineNum">    1552 </span>            :     /*
<span class="lineNum">    1553 </span>            :      * Re-acquire the lock table's partition lock.  We have to do this to hold
<span class="lineNum">    1554 </span>            :      * off cancel/die interrupts before we can mess with lockAwaited (else we
<span class="lineNum">    1555 </span>            :      * might have a missed or duplicated locallock update).
<span class="lineNum">    1556 </span>            :      */
<span class="lineNum">    1557 </span><span class="lineCov">         26 :     LWLockAcquire(partitionLock, LW_EXCLUSIVE);</span>
<span class="lineNum">    1558 </span>            : 
<span class="lineNum">    1559 </span>            :     /*
<span class="lineNum">    1560 </span>            :      * We no longer want LockErrorCleanup to do anything.
<span class="lineNum">    1561 </span>            :      */
<span class="lineNum">    1562 </span><span class="lineCov">         26 :     lockAwaited = NULL;</span>
<span class="lineNum">    1563 </span>            : 
<span class="lineNum">    1564 </span>            :     /*
<span class="lineNum">    1565 </span>            :      * If we got the lock, be sure to remember it in the locallock table.
<span class="lineNum">    1566 </span>            :      */
<span class="lineNum">    1567 </span><span class="lineCov">         26 :     if (MyProc-&gt;waitStatus == STATUS_OK)</span>
<span class="lineNum">    1568 </span><span class="lineCov">         26 :         GrantAwaitedLock();</span>
<span class="lineNum">    1569 </span>            : 
<span class="lineNum">    1570 </span>            :     /*
<span class="lineNum">    1571 </span>            :      * We don't have to do anything else, because the awaker did all the
<span class="lineNum">    1572 </span>            :      * necessary update of the lock table and MyProc.
<span class="lineNum">    1573 </span>            :      */
<span class="lineNum">    1574 </span><span class="lineCov">         26 :     return MyProc-&gt;waitStatus;</span>
<span class="lineNum">    1575 </span>            : }
<span class="lineNum">    1576 </span>            : 
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span>            : /*
<span class="lineNum">    1579 </span>            :  * ProcWakeup -- wake up a process by setting its latch.
<span class="lineNum">    1580 </span>            :  *
<span class="lineNum">    1581 </span>            :  *   Also remove the process from the wait queue and set its links invalid.
<span class="lineNum">    1582 </span>            :  *   RETURN: the next process in the wait queue.
<span class="lineNum">    1583 </span>            :  *
<span class="lineNum">    1584 </span>            :  * The appropriate lock partition lock must be held by caller.
<span class="lineNum">    1585 </span>            :  *
<span class="lineNum">    1586 </span>            :  * XXX: presently, this code is only used for the &quot;success&quot; case, and only
<span class="lineNum">    1587 </span>            :  * works correctly for that case.  To clean up in failure case, would need
<span class="lineNum">    1588 </span>            :  * to twiddle the lock's request counts too --- see RemoveFromWaitQueue.
<span class="lineNum">    1589 </span>            :  * Hence, in practice the waitStatus parameter must be STATUS_OK.
<a name="1590"><span class="lineNum">    1590 </span>            :  */</a>
<span class="lineNum">    1591 </span>            : PGPROC *
<span class="lineNum">    1592 </span><span class="lineCov">         26 : ProcWakeup(PGPROC *proc, int waitStatus)</span>
<span class="lineNum">    1593 </span>            : {
<span class="lineNum">    1594 </span>            :     PGPROC     *retProc;
<span class="lineNum">    1595 </span>            : 
<span class="lineNum">    1596 </span>            :     /* Proc should be sleeping ... */
<span class="lineNum">    1597 </span><span class="lineCov">         52 :     if (proc-&gt;links.prev == NULL ||</span>
<span class="lineNum">    1598 </span><span class="lineCov">         26 :         proc-&gt;links.next == NULL)</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    1600 </span><span class="lineCov">         26 :     Assert(proc-&gt;waitStatus == STATUS_WAITING);</span>
<span class="lineNum">    1601 </span>            : 
<span class="lineNum">    1602 </span>            :     /* Save next process before we zap the list link */
<span class="lineNum">    1603 </span><span class="lineCov">         26 :     retProc = (PGPROC *) proc-&gt;links.next;</span>
<span class="lineNum">    1604 </span>            : 
<span class="lineNum">    1605 </span>            :     /* Remove process from wait queue */
<span class="lineNum">    1606 </span><span class="lineCov">         26 :     SHMQueueDelete(&amp;(proc-&gt;links));</span>
<span class="lineNum">    1607 </span><span class="lineCov">         26 :     (proc-&gt;waitLock-&gt;waitProcs.size)--;</span>
<span class="lineNum">    1608 </span>            : 
<span class="lineNum">    1609 </span>            :     /* Clean up process' state and pass it the ok/fail signal */
<span class="lineNum">    1610 </span><span class="lineCov">         26 :     proc-&gt;waitLock = NULL;</span>
<span class="lineNum">    1611 </span><span class="lineCov">         26 :     proc-&gt;waitProcLock = NULL;</span>
<span class="lineNum">    1612 </span><span class="lineCov">         26 :     proc-&gt;waitStatus = waitStatus;</span>
<span class="lineNum">    1613 </span>            : 
<span class="lineNum">    1614 </span>            :     /* And awaken it */
<span class="lineNum">    1615 </span><span class="lineCov">         26 :     SetLatch(&amp;proc-&gt;procLatch);</span>
<span class="lineNum">    1616 </span>            : 
<span class="lineNum">    1617 </span><span class="lineCov">         26 :     return retProc;</span>
<span class="lineNum">    1618 </span>            : }
<span class="lineNum">    1619 </span>            : 
<span class="lineNum">    1620 </span>            : /*
<span class="lineNum">    1621 </span>            :  * ProcLockWakeup -- routine for waking up processes when a lock is
<span class="lineNum">    1622 </span>            :  *      released (or a prior waiter is aborted).  Scan all waiters
<span class="lineNum">    1623 </span>            :  *      for lock, waken any that are no longer blocked.
<span class="lineNum">    1624 </span>            :  *
<span class="lineNum">    1625 </span>            :  * The appropriate lock partition lock must be held by caller.
<a name="1626"><span class="lineNum">    1626 </span>            :  */</a>
<span class="lineNum">    1627 </span>            : void
<span class="lineNum">    1628 </span><span class="lineCov">         16 : ProcLockWakeup(LockMethod lockMethodTable, LOCK *lock)</span>
<span class="lineNum">    1629 </span>            : {
<span class="lineNum">    1630 </span><span class="lineCov">         16 :     PROC_QUEUE *waitQueue = &amp;(lock-&gt;waitProcs);</span>
<span class="lineNum">    1631 </span><span class="lineCov">         16 :     int         queue_size = waitQueue-&gt;size;</span>
<span class="lineNum">    1632 </span>            :     PGPROC     *proc;
<span class="lineNum">    1633 </span><span class="lineCov">         16 :     LOCKMASK    aheadRequests = 0;</span>
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span><span class="lineCov">         16 :     Assert(queue_size &gt;= 0);</span>
<span class="lineNum">    1636 </span>            : 
<span class="lineNum">    1637 </span><span class="lineCov">         16 :     if (queue_size == 0)</span>
<span class="lineNum">    1638 </span><span class="lineCov">         16 :         return;</span>
<span class="lineNum">    1639 </span>            : 
<span class="lineNum">    1640 </span><span class="lineCov">         16 :     proc = (PGPROC *) waitQueue-&gt;links.next;</span>
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span><span class="lineCov">         72 :     while (queue_size-- &gt; 0)</span>
<span class="lineNum">    1643 </span>            :     {
<span class="lineNum">    1644 </span><span class="lineCov">         40 :         LOCKMODE    lockmode = proc-&gt;waitLockMode;</span>
<span class="lineNum">    1645 </span>            : 
<span class="lineNum">    1646 </span>            :         /*
<span class="lineNum">    1647 </span>            :          * Waken if (a) doesn't conflict with requests of earlier waiters, and
<span class="lineNum">    1648 </span>            :          * (b) doesn't conflict with already-held locks.
<span class="lineNum">    1649 </span>            :          */
<span class="lineNum">    1650 </span><span class="lineCov">         80 :         if ((lockMethodTable-&gt;conflictTab[lockmode] &amp; aheadRequests) == 0 &amp;&amp;</span>
<span class="lineNum">    1651 </span><span class="lineCov">         40 :             LockCheckConflicts(lockMethodTable,</span>
<span class="lineNum">    1652 </span>            :                                lockmode,
<span class="lineNum">    1653 </span>            :                                lock,
<span class="lineNum">    1654 </span>            :                                proc-&gt;waitProcLock) == STATUS_OK)
<span class="lineNum">    1655 </span>            :         {
<span class="lineNum">    1656 </span>            :             /* OK to waken */
<span class="lineNum">    1657 </span><span class="lineCov">         26 :             GrantLock(lock, proc-&gt;waitProcLock, lockmode);</span>
<span class="lineNum">    1658 </span><span class="lineCov">         26 :             proc = ProcWakeup(proc, STATUS_OK);</span>
<span class="lineNum">    1659 </span>            : 
<span class="lineNum">    1660 </span>            :             /*
<span class="lineNum">    1661 </span>            :              * ProcWakeup removes proc from the lock's waiting process queue
<span class="lineNum">    1662 </span>            :              * and returns the next proc in chain; don't use proc's next-link,
<span class="lineNum">    1663 </span>            :              * because it's been cleared.
<span class="lineNum">    1664 </span>            :              */
<span class="lineNum">    1665 </span>            :         }
<span class="lineNum">    1666 </span>            :         else
<span class="lineNum">    1667 </span>            :         {
<span class="lineNum">    1668 </span>            :             /*
<span class="lineNum">    1669 </span>            :              * Cannot wake this guy. Remember his request for later checks.
<span class="lineNum">    1670 </span>            :              */
<span class="lineNum">    1671 </span><span class="lineCov">         14 :             aheadRequests |= LOCKBIT_ON(lockmode);</span>
<span class="lineNum">    1672 </span><span class="lineCov">         14 :             proc = (PGPROC *) proc-&gt;links.next;</span>
<span class="lineNum">    1673 </span>            :         }
<span class="lineNum">    1674 </span>            :     }
<span class="lineNum">    1675 </span>            : 
<span class="lineNum">    1676 </span><span class="lineCov">         16 :     Assert(waitQueue-&gt;size &gt;= 0);</span>
<span class="lineNum">    1677 </span>            : }
<span class="lineNum">    1678 </span>            : 
<span class="lineNum">    1679 </span>            : /*
<span class="lineNum">    1680 </span>            :  * CheckDeadLock
<span class="lineNum">    1681 </span>            :  *
<span class="lineNum">    1682 </span>            :  * We only get to this routine, if DEADLOCK_TIMEOUT fired while waiting for a
<span class="lineNum">    1683 </span>            :  * lock to be released by some other process.  Check if there's a deadlock; if
<span class="lineNum">    1684 </span>            :  * not, just return.  (But signal ProcSleep to log a message, if
<span class="lineNum">    1685 </span>            :  * log_lock_waits is true.)  If we have a real deadlock, remove ourselves from
<span class="lineNum">    1686 </span>            :  * the lock's wait queue and signal an error to ProcSleep.
<a name="1687"><span class="lineNum">    1687 </span>            :  */</a>
<span class="lineNum">    1688 </span>            : static void
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 : CheckDeadLock(void)</span>
<span class="lineNum">    1690 </span>            : {
<span class="lineNum">    1691 </span>            :     int         i;
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span>            :     /*
<span class="lineNum">    1694 </span>            :      * Acquire exclusive lock on the entire shared lock data structures. Must
<span class="lineNum">    1695 </span>            :      * grab LWLocks in partition-number order to avoid LWLock deadlock.
<span class="lineNum">    1696 </span>            :      *
<span class="lineNum">    1697 </span>            :      * Note that the deadlock check interrupt had better not be enabled
<span class="lineNum">    1698 </span>            :      * anywhere that this process itself holds lock partition locks, else this
<span class="lineNum">    1699 </span>            :      * will wait forever.  Also note that LWLockAcquire creates a critical
<span class="lineNum">    1700 </span>            :      * section, so that this routine cannot be interrupted by cancel/die
<span class="lineNum">    1701 </span>            :      * interrupts.
<span class="lineNum">    1702 </span>            :      */
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; NUM_LOCK_PARTITIONS; i++)</span>
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :         LWLockAcquire(LockHashPartitionLockByIndex(i), LW_EXCLUSIVE);</span>
<span class="lineNum">    1705 </span>            : 
<span class="lineNum">    1706 </span>            :     /*
<span class="lineNum">    1707 </span>            :      * Check to see if we've been awoken by anyone in the interim.
<span class="lineNum">    1708 </span>            :      *
<span class="lineNum">    1709 </span>            :      * If we have, we can return and resume our transaction -- happy day.
<span class="lineNum">    1710 </span>            :      * Before we are awoken the process releasing the lock grants it to us so
<span class="lineNum">    1711 </span>            :      * we know that we don't have to wait anymore.
<span class="lineNum">    1712 </span>            :      *
<span class="lineNum">    1713 </span>            :      * We check by looking to see if we've been unlinked from the wait queue.
<span class="lineNum">    1714 </span>            :      * This is safe because we hold the lock partition lock.
<span class="lineNum">    1715 </span>            :      */
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :     if (MyProc-&gt;links.prev == NULL ||</span>
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :         MyProc-&gt;links.next == NULL)</span>
<span class="lineNum">    1718 </span>            :         goto check_done;
<span class="lineNum">    1719 </span>            : 
<span class="lineNum">    1720 </span>            : #ifdef LOCK_DEBUG
<span class="lineNum">    1721 </span>            :     if (Debug_deadlocks)
<span class="lineNum">    1722 </span>            :         DumpAllLocks();
<span class="lineNum">    1723 </span>            : #endif
<span class="lineNum">    1724 </span>            : 
<span class="lineNum">    1725 </span>            :     /* Run the deadlock check, and set deadlock_state for use by ProcSleep */
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :     deadlock_state = DeadLockCheck(MyProc);</span>
<span class="lineNum">    1727 </span>            : 
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :     if (deadlock_state == DS_HARD_DEADLOCK)</span>
<span class="lineNum">    1729 </span>            :     {
<span class="lineNum">    1730 </span>            :         /*
<span class="lineNum">    1731 </span>            :          * Oops.  We have a deadlock.
<span class="lineNum">    1732 </span>            :          *
<span class="lineNum">    1733 </span>            :          * Get this process out of wait state. (Note: we could do this more
<span class="lineNum">    1734 </span>            :          * efficiently by relying on lockAwaited, but use this coding to
<span class="lineNum">    1735 </span>            :          * preserve the flexibility to kill some other transaction than the
<span class="lineNum">    1736 </span>            :          * one detecting the deadlock.)
<span class="lineNum">    1737 </span>            :          *
<span class="lineNum">    1738 </span>            :          * RemoveFromWaitQueue sets MyProc-&gt;waitStatus to STATUS_ERROR, so
<span class="lineNum">    1739 </span>            :          * ProcSleep will report an error after we return from the signal
<span class="lineNum">    1740 </span>            :          * handler.
<span class="lineNum">    1741 </span>            :          */
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :         Assert(MyProc-&gt;waitLock != NULL);</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :         RemoveFromWaitQueue(MyProc, LockTagHashCode(&amp;(MyProc-&gt;waitLock-&gt;tag)));</span>
<span class="lineNum">    1744 </span>            : 
<span class="lineNum">    1745 </span>            :         /*
<span class="lineNum">    1746 </span>            :          * We're done here.  Transaction abort caused by the error that
<span class="lineNum">    1747 </span>            :          * ProcSleep will raise will cause any other locks we hold to be
<span class="lineNum">    1748 </span>            :          * released, thus allowing other processes to wake up; we don't need
<span class="lineNum">    1749 </span>            :          * to do that here.  NOTE: an exception is that releasing locks we
<span class="lineNum">    1750 </span>            :          * hold doesn't consider the possibility of waiters that were blocked
<span class="lineNum">    1751 </span>            :          * behind us on the lock we just failed to get, and might now be
<span class="lineNum">    1752 </span>            :          * wakable because we're not in front of them anymore.  However,
<span class="lineNum">    1753 </span>            :          * RemoveFromWaitQueue took care of waking up any such processes.
<span class="lineNum">    1754 </span>            :          */
<span class="lineNum">    1755 </span>            :     }
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span>            :     /*
<span class="lineNum">    1758 </span>            :      * And release locks.  We do this in reverse order for two reasons: (1)
<span class="lineNum">    1759 </span>            :      * Anyone else who needs more than one of the locks will be trying to lock
<span class="lineNum">    1760 </span>            :      * them in increasing order; we don't want to release the other process
<span class="lineNum">    1761 </span>            :      * until it can get all the locks it needs. (2) This avoids O(N^2)
<span class="lineNum">    1762 </span>            :      * behavior inside LWLockRelease.
<span class="lineNum">    1763 </span>            :      */
<span class="lineNum">    1764 </span>            : check_done:
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :     for (i = NUM_LOCK_PARTITIONS; --i &gt;= 0;)</span>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :         LWLockRelease(LockHashPartitionLockByIndex(i));</span>
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1768 </span>            : 
<span class="lineNum">    1769 </span>            : /*
<span class="lineNum">    1770 </span>            :  * CheckDeadLockAlert - Handle the expiry of deadlock_timeout.
<span class="lineNum">    1771 </span>            :  *
<span class="lineNum">    1772 </span>            :  * NB: Runs inside a signal handler, be careful.
<a name="1773"><span class="lineNum">    1773 </span>            :  */</a>
<span class="lineNum">    1774 </span>            : void
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 : CheckDeadLockAlert(void)</span>
<span class="lineNum">    1776 </span>            : {
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :     int         save_errno = errno;</span>
<span class="lineNum">    1778 </span>            : 
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :     got_deadlock_timeout = true;</span>
<span class="lineNum">    1780 </span>            : 
<span class="lineNum">    1781 </span>            :     /*
<span class="lineNum">    1782 </span>            :      * Have to set the latch again, even if handle_sig_alarm already did. Back
<span class="lineNum">    1783 </span>            :      * then got_deadlock_timeout wasn't yet set... It's unlikely that this
<span class="lineNum">    1784 </span>            :      * ever would be a problem, but setting a set latch again is cheap.
<span class="lineNum">    1785 </span>            :      */
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :     SetLatch(MyLatch);</span>
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :     errno = save_errno;</span>
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1789 </span>            : 
<span class="lineNum">    1790 </span>            : /*
<span class="lineNum">    1791 </span>            :  * ProcWaitForSignal - wait for a signal from another backend.
<span class="lineNum">    1792 </span>            :  *
<span class="lineNum">    1793 </span>            :  * As this uses the generic process latch the caller has to be robust against
<span class="lineNum">    1794 </span>            :  * unrelated wakeups: Always check that the desired state has occurred, and
<span class="lineNum">    1795 </span>            :  * wait again if not.
<a name="1796"><span class="lineNum">    1796 </span>            :  */</a>
<span class="lineNum">    1797 </span>            : void
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 : ProcWaitForSignal(uint32 wait_event_info)</span>
<span class="lineNum">    1799 </span>            : {
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :     (void) WaitLatch(MyLatch, WL_LATCH_SET | WL_EXIT_ON_PM_DEATH, 0,</span>
<span class="lineNum">    1801 </span>            :                      wait_event_info);
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :     ResetLatch(MyLatch);</span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :     CHECK_FOR_INTERRUPTS();</span>
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1805 </span>            : 
<span class="lineNum">    1806 </span>            : /*
<span class="lineNum">    1807 </span>            :  * ProcSendSignal - send a signal to a backend identified by PID
<a name="1808"><span class="lineNum">    1808 </span>            :  */</a>
<span class="lineNum">    1809 </span>            : void
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 : ProcSendSignal(int pid)</span>
<span class="lineNum">    1811 </span>            : {
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :     PGPROC     *proc = NULL;</span>
<span class="lineNum">    1813 </span>            : 
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :     if (RecoveryInProgress())</span>
<span class="lineNum">    1815 </span>            :     {
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :         SpinLockAcquire(ProcStructLock);</span>
<span class="lineNum">    1817 </span>            : 
<span class="lineNum">    1818 </span>            :         /*
<span class="lineNum">    1819 </span>            :          * Check to see whether it is the Startup process we wish to signal.
<span class="lineNum">    1820 </span>            :          * This call is made by the buffer manager when it wishes to wake up a
<span class="lineNum">    1821 </span>            :          * process that has been waiting for a pin in so it can obtain a
<span class="lineNum">    1822 </span>            :          * cleanup lock using LockBufferForCleanup(). Startup is not a normal
<span class="lineNum">    1823 </span>            :          * backend, so BackendPidGetProc() will not return any pid at all. So
<span class="lineNum">    1824 </span>            :          * we remember the information for this special case.
<span class="lineNum">    1825 </span>            :          */
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :         if (pid == ProcGlobal-&gt;startupProcPid)</span>
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :             proc = ProcGlobal-&gt;startupProc;</span>
<span class="lineNum">    1828 </span>            : 
<span class="lineNum">    1829 </span><span class="lineNoCov">          0 :         SpinLockRelease(ProcStructLock);</span>
<span class="lineNum">    1830 </span>            :     }
<span class="lineNum">    1831 </span>            : 
<span class="lineNum">    1832 </span><span class="lineNoCov">          0 :     if (proc == NULL)</span>
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :         proc = BackendPidGetProc(pid);</span>
<span class="lineNum">    1834 </span>            : 
<span class="lineNum">    1835 </span><span class="lineNoCov">          0 :     if (proc != NULL)</span>
<span class="lineNum">    1836 </span>            :     {
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :         SetLatch(&amp;proc-&gt;procLatch);</span>
<span class="lineNum">    1838 </span>            :     }
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span>            : /*
<span class="lineNum">    1842 </span>            :  * BecomeLockGroupLeader - designate process as lock group leader
<span class="lineNum">    1843 </span>            :  *
<span class="lineNum">    1844 </span>            :  * Once this function has returned, other processes can join the lock group
<span class="lineNum">    1845 </span>            :  * by calling BecomeLockGroupMember.
<a name="1846"><span class="lineNum">    1846 </span>            :  */</a>
<span class="lineNum">    1847 </span>            : void
<span class="lineNum">    1848 </span><span class="lineCov">        298 : BecomeLockGroupLeader(void)</span>
<span class="lineNum">    1849 </span>            : {
<span class="lineNum">    1850 </span>            :     LWLock     *leader_lwlock;
<span class="lineNum">    1851 </span>            : 
<span class="lineNum">    1852 </span>            :     /* If we already did it, we don't need to do it again. */
<span class="lineNum">    1853 </span><span class="lineCov">        298 :     if (MyProc-&gt;lockGroupLeader == MyProc)</span>
<span class="lineNum">    1854 </span><span class="lineCov">        582 :         return;</span>
<span class="lineNum">    1855 </span>            : 
<span class="lineNum">    1856 </span>            :     /* We had better not be a follower. */
<span class="lineNum">    1857 </span><span class="lineCov">         14 :     Assert(MyProc-&gt;lockGroupLeader == NULL);</span>
<span class="lineNum">    1858 </span>            : 
<span class="lineNum">    1859 </span>            :     /* Create single-member group, containing only ourselves. */
<span class="lineNum">    1860 </span><span class="lineCov">         14 :     leader_lwlock = LockHashPartitionLockByProc(MyProc);</span>
<span class="lineNum">    1861 </span><span class="lineCov">         14 :     LWLockAcquire(leader_lwlock, LW_EXCLUSIVE);</span>
<span class="lineNum">    1862 </span><span class="lineCov">         14 :     MyProc-&gt;lockGroupLeader = MyProc;</span>
<span class="lineNum">    1863 </span><span class="lineCov">         14 :     dlist_push_head(&amp;MyProc-&gt;lockGroupMembers, &amp;MyProc-&gt;lockGroupLink);</span>
<span class="lineNum">    1864 </span><span class="lineCov">         14 :     LWLockRelease(leader_lwlock);</span>
<span class="lineNum">    1865 </span>            : }
<span class="lineNum">    1866 </span>            : 
<span class="lineNum">    1867 </span>            : /*
<span class="lineNum">    1868 </span>            :  * BecomeLockGroupMember - designate process as lock group member
<span class="lineNum">    1869 </span>            :  *
<span class="lineNum">    1870 </span>            :  * This is pretty straightforward except for the possibility that the leader
<span class="lineNum">    1871 </span>            :  * whose group we're trying to join might exit before we manage to do so;
<span class="lineNum">    1872 </span>            :  * and the PGPROC might get recycled for an unrelated process.  To avoid
<span class="lineNum">    1873 </span>            :  * that, we require the caller to pass the PID of the intended PGPROC as
<span class="lineNum">    1874 </span>            :  * an interlock.  Returns true if we successfully join the intended lock
<span class="lineNum">    1875 </span>            :  * group, and false if not.
<a name="1876"><span class="lineNum">    1876 </span>            :  */</a>
<span class="lineNum">    1877 </span>            : bool
<span class="lineNum">    1878 </span><span class="lineCov">        746 : BecomeLockGroupMember(PGPROC *leader, int pid)</span>
<span class="lineNum">    1879 </span>            : {
<span class="lineNum">    1880 </span>            :     LWLock     *leader_lwlock;
<span class="lineNum">    1881 </span><span class="lineCov">        746 :     bool        ok = false;</span>
<span class="lineNum">    1882 </span>            : 
<span class="lineNum">    1883 </span>            :     /* Group leader can't become member of group */
<span class="lineNum">    1884 </span><span class="lineCov">        746 :     Assert(MyProc != leader);</span>
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span>            :     /* Can't already be a member of a group */
<span class="lineNum">    1887 </span><span class="lineCov">        746 :     Assert(MyProc-&gt;lockGroupLeader == NULL);</span>
<span class="lineNum">    1888 </span>            : 
<span class="lineNum">    1889 </span>            :     /* PID must be valid. */
<span class="lineNum">    1890 </span><span class="lineCov">        746 :     Assert(pid != 0);</span>
<span class="lineNum">    1891 </span>            : 
<span class="lineNum">    1892 </span>            :     /*
<span class="lineNum">    1893 </span>            :      * Get lock protecting the group fields.  Note LockHashPartitionLockByProc
<span class="lineNum">    1894 </span>            :      * accesses leader-&gt;pgprocno in a PGPROC that might be free.  This is safe
<span class="lineNum">    1895 </span>            :      * because all PGPROCs' pgprocno fields are set during shared memory
<span class="lineNum">    1896 </span>            :      * initialization and never change thereafter; so we will acquire the
<span class="lineNum">    1897 </span>            :      * correct lock even if the leader PGPROC is in process of being recycled.
<span class="lineNum">    1898 </span>            :      */
<span class="lineNum">    1899 </span><span class="lineCov">        746 :     leader_lwlock = LockHashPartitionLockByProc(leader);</span>
<span class="lineNum">    1900 </span><span class="lineCov">        746 :     LWLockAcquire(leader_lwlock, LW_EXCLUSIVE);</span>
<span class="lineNum">    1901 </span>            : 
<span class="lineNum">    1902 </span>            :     /* Is this the leader we're looking for? */
<span class="lineNum">    1903 </span><span class="lineCov">        746 :     if (leader-&gt;pid == pid &amp;&amp; leader-&gt;lockGroupLeader == leader)</span>
<span class="lineNum">    1904 </span>            :     {
<span class="lineNum">    1905 </span>            :         /* OK, join the group */
<span class="lineNum">    1906 </span><span class="lineCov">        746 :         ok = true;</span>
<span class="lineNum">    1907 </span><span class="lineCov">        746 :         MyProc-&gt;lockGroupLeader = leader;</span>
<span class="lineNum">    1908 </span><span class="lineCov">        746 :         dlist_push_tail(&amp;leader-&gt;lockGroupMembers, &amp;MyProc-&gt;lockGroupLink);</span>
<span class="lineNum">    1909 </span>            :     }
<span class="lineNum">    1910 </span><span class="lineCov">        746 :     LWLockRelease(leader_lwlock);</span>
<span class="lineNum">    1911 </span>            : 
<span class="lineNum">    1912 </span><span class="lineCov">        746 :     return ok;</span>
<span class="lineNum">    1913 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
