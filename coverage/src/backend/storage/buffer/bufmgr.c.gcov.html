<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/storage/buffer/bufmgr.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/backend/storage/buffer</a> - bufmgr.c<span style="font-size: 80%;"> (source / <a href="bufmgr.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">879</td>
            <td class="headerCovTableEntry">1180</td>
            <td class="headerCovTableEntryLo">74.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">57</td>
            <td class="headerCovTableEntry">68</td>
            <td class="headerCovTableEntryMed">83.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * bufmgr.c
<span class="lineNum">       4 </span>            :  *    buffer manager interface routines
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * IDENTIFICATION
<span class="lineNum">      11 </span>            :  *    src/backend/storage/buffer/bufmgr.c
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      14 </span>            :  */
<span class="lineNum">      15 </span>            : /*
<span class="lineNum">      16 </span>            :  * Principal entry points:
<span class="lineNum">      17 </span>            :  *
<span class="lineNum">      18 </span>            :  * ReadBuffer() -- find or create a buffer holding the requested page,
<span class="lineNum">      19 </span>            :  *      and pin it so that no one can destroy it while this process
<span class="lineNum">      20 </span>            :  *      is using it.
<span class="lineNum">      21 </span>            :  *
<span class="lineNum">      22 </span>            :  * ReleaseBuffer() -- unpin a buffer
<span class="lineNum">      23 </span>            :  *
<span class="lineNum">      24 </span>            :  * MarkBufferDirty() -- mark a pinned buffer's contents as &quot;dirty&quot;.
<span class="lineNum">      25 </span>            :  *      The disk write is delayed until buffer replacement or checkpoint.
<span class="lineNum">      26 </span>            :  *
<span class="lineNum">      27 </span>            :  * See also these files:
<span class="lineNum">      28 </span>            :  *      freelist.c -- chooses victim for buffer replacement
<span class="lineNum">      29 </span>            :  *      buf_table.c -- manages the buffer lookup table
<span class="lineNum">      30 </span>            :  */
<span class="lineNum">      31 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : #include &lt;sys/file.h&gt;
<span class="lineNum">      34 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : #include &quot;access/tableam.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;access/xlog.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;catalog/catalog.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;catalog/storage.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;executor/instrument.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;lib/binaryheap.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;miscadmin.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;pg_trace.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;pgstat.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;postmaster/bgwriter.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;storage/buf_internals.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;storage/bufmgr.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;storage/ipc.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;storage/proc.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;storage/smgr.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;storage/standby.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;utils/rel.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;utils/resowner_private.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;utils/timestamp.h&quot;
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : /* Note: these two macros only work on shared buffers, not local ones! */
<span class="lineNum">      58 </span>            : #define BufHdrGetBlock(bufHdr)  ((Block) (BufferBlocks + ((Size) (bufHdr)-&gt;buf_id) * BLCKSZ))
<span class="lineNum">      59 </span>            : #define BufferGetLSN(bufHdr)    (PageGetLSN(BufHdrGetBlock(bufHdr)))
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : /* Note: this macro only works on local buffers, not shared ones! */
<span class="lineNum">      62 </span>            : #define LocalBufHdrGetBlock(bufHdr) \
<span class="lineNum">      63 </span>            :     LocalBufferBlockPointers[-((bufHdr)-&gt;buf_id + 2)]
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : /* Bits in SyncOneBuffer's return value */
<span class="lineNum">      66 </span>            : #define BUF_WRITTEN             0x01
<span class="lineNum">      67 </span>            : #define BUF_REUSABLE            0x02
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : #define DROP_RELS_BSEARCH_THRESHOLD     20
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : typedef struct PrivateRefCountEntry
<span class="lineNum">      72 </span>            : {
<span class="lineNum">      73 </span>            :     Buffer      buffer;
<span class="lineNum">      74 </span>            :     int32       refcount;
<span class="lineNum">      75 </span>            : } PrivateRefCountEntry;
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : /* 64 bytes, about the size of a cache line on common systems */
<span class="lineNum">      78 </span>            : #define REFCOUNT_ARRAY_ENTRIES 8
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : /*
<span class="lineNum">      81 </span>            :  * Status of buffers to checkpoint for a particular tablespace, used
<span class="lineNum">      82 </span>            :  * internally in BufferSync.
<span class="lineNum">      83 </span>            :  */
<span class="lineNum">      84 </span>            : typedef struct CkptTsStatus
<span class="lineNum">      85 </span>            : {
<span class="lineNum">      86 </span>            :     /* oid of the tablespace */
<span class="lineNum">      87 </span>            :     Oid         tsId;
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            :     /*
<span class="lineNum">      90 </span>            :      * Checkpoint progress for this tablespace. To make progress comparable
<span class="lineNum">      91 </span>            :      * between tablespaces the progress is, for each tablespace, measured as a
<span class="lineNum">      92 </span>            :      * number between 0 and the total number of to-be-checkpointed pages. Each
<span class="lineNum">      93 </span>            :      * page checkpointed in this tablespace increments this space's progress
<span class="lineNum">      94 </span>            :      * by progress_slice.
<span class="lineNum">      95 </span>            :      */
<span class="lineNum">      96 </span>            :     float8      progress;
<span class="lineNum">      97 </span>            :     float8      progress_slice;
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            :     /* number of to-be checkpointed pages in this tablespace */
<span class="lineNum">     100 </span>            :     int         num_to_scan;
<span class="lineNum">     101 </span>            :     /* already processed pages in this tablespace */
<span class="lineNum">     102 </span>            :     int         num_scanned;
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :     /* current offset in CkptBufferIds for this tablespace */
<span class="lineNum">     105 </span>            :     int         index;
<span class="lineNum">     106 </span>            : } CkptTsStatus;
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            : /* GUC variables */
<span class="lineNum">     109 </span>            : bool        zero_damaged_pages = false;
<span class="lineNum">     110 </span>            : int         bgwriter_lru_maxpages = 100;
<span class="lineNum">     111 </span>            : double      bgwriter_lru_multiplier = 2.0;
<span class="lineNum">     112 </span>            : bool        track_io_timing = false;
<span class="lineNum">     113 </span>            : int         effective_io_concurrency = 0;
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : /*
<span class="lineNum">     116 </span>            :  * GUC variables about triggering kernel writeback for buffers written; OS
<span class="lineNum">     117 </span>            :  * dependent defaults are set via the GUC mechanism.
<span class="lineNum">     118 </span>            :  */
<span class="lineNum">     119 </span>            : int         checkpoint_flush_after = 0;
<span class="lineNum">     120 </span>            : int         bgwriter_flush_after = 0;
<span class="lineNum">     121 </span>            : int         backend_flush_after = 0;
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : /*
<span class="lineNum">     124 </span>            :  * How many buffers PrefetchBuffer callers should try to stay ahead of their
<span class="lineNum">     125 </span>            :  * ReadBuffer calls by.  This is maintained by the assign hook for
<span class="lineNum">     126 </span>            :  * effective_io_concurrency.  Zero means &quot;never prefetch&quot;.  This value is
<span class="lineNum">     127 </span>            :  * only used for buffers not belonging to tablespaces that have their
<span class="lineNum">     128 </span>            :  * effective_io_concurrency parameter set.
<span class="lineNum">     129 </span>            :  */
<span class="lineNum">     130 </span>            : int         target_prefetch_pages = 0;
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            : /* local state for StartBufferIO and related functions */
<span class="lineNum">     133 </span>            : static BufferDesc *InProgressBuf = NULL;
<span class="lineNum">     134 </span>            : static bool IsForInput;
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : /* local state for LockBufferForCleanup */
<span class="lineNum">     137 </span>            : static BufferDesc *PinCountWaitBuf = NULL;
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            : /*
<span class="lineNum">     140 </span>            :  * Backend-Private refcount management:
<span class="lineNum">     141 </span>            :  *
<span class="lineNum">     142 </span>            :  * Each buffer also has a private refcount that keeps track of the number of
<span class="lineNum">     143 </span>            :  * times the buffer is pinned in the current process.  This is so that the
<span class="lineNum">     144 </span>            :  * shared refcount needs to be modified only once if a buffer is pinned more
<span class="lineNum">     145 </span>            :  * than once by an individual backend.  It's also used to check that no buffers
<span class="lineNum">     146 </span>            :  * are still pinned at the end of transactions and when exiting.
<span class="lineNum">     147 </span>            :  *
<span class="lineNum">     148 </span>            :  *
<span class="lineNum">     149 </span>            :  * To avoid - as we used to - requiring an array with NBuffers entries to keep
<span class="lineNum">     150 </span>            :  * track of local buffers, we use a small sequentially searched array
<span class="lineNum">     151 </span>            :  * (PrivateRefCountArray) and an overflow hash table (PrivateRefCountHash) to
<span class="lineNum">     152 </span>            :  * keep track of backend local pins.
<span class="lineNum">     153 </span>            :  *
<span class="lineNum">     154 </span>            :  * Until no more than REFCOUNT_ARRAY_ENTRIES buffers are pinned at once, all
<span class="lineNum">     155 </span>            :  * refcounts are kept track of in the array; after that, new array entries
<span class="lineNum">     156 </span>            :  * displace old ones into the hash table. That way a frequently used entry
<span class="lineNum">     157 </span>            :  * can't get &quot;stuck&quot; in the hashtable while infrequent ones clog the array.
<span class="lineNum">     158 </span>            :  *
<span class="lineNum">     159 </span>            :  * Note that in most scenarios the number of pinned buffers will not exceed
<span class="lineNum">     160 </span>            :  * REFCOUNT_ARRAY_ENTRIES.
<span class="lineNum">     161 </span>            :  *
<span class="lineNum">     162 </span>            :  *
<span class="lineNum">     163 </span>            :  * To enter a buffer into the refcount tracking mechanism first reserve a free
<span class="lineNum">     164 </span>            :  * entry using ReservePrivateRefCountEntry() and then later, if necessary,
<span class="lineNum">     165 </span>            :  * fill it with NewPrivateRefCountEntry(). That split lets us avoid doing
<span class="lineNum">     166 </span>            :  * memory allocations in NewPrivateRefCountEntry() which can be important
<span class="lineNum">     167 </span>            :  * because in some scenarios it's called with a spinlock held...
<span class="lineNum">     168 </span>            :  */
<span class="lineNum">     169 </span>            : static struct PrivateRefCountEntry PrivateRefCountArray[REFCOUNT_ARRAY_ENTRIES];
<span class="lineNum">     170 </span>            : static HTAB *PrivateRefCountHash = NULL;
<span class="lineNum">     171 </span>            : static int32 PrivateRefCountOverflowed = 0;
<span class="lineNum">     172 </span>            : static uint32 PrivateRefCountClock = 0;
<span class="lineNum">     173 </span>            : static PrivateRefCountEntry *ReservedRefCountEntry = NULL;
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            : static void ReservePrivateRefCountEntry(void);
<span class="lineNum">     176 </span>            : static PrivateRefCountEntry *NewPrivateRefCountEntry(Buffer buffer);
<span class="lineNum">     177 </span>            : static PrivateRefCountEntry *GetPrivateRefCountEntry(Buffer buffer, bool do_move);
<span class="lineNum">     178 </span>            : static inline int32 GetPrivateRefCount(Buffer buffer);
<span class="lineNum">     179 </span>            : static void ForgetPrivateRefCountEntry(PrivateRefCountEntry *ref);
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            : /*
<span class="lineNum">     182 </span>            :  * Ensure that the PrivateRefCountArray has sufficient space to store one more
<span class="lineNum">     183 </span>            :  * entry. This has to be called before using NewPrivateRefCountEntry() to fill
<span class="lineNum">     184 </span>            :  * a new entry - but it's perfectly fine to not use a reserved entry.
<a name="185"><span class="lineNum">     185 </span>            :  */</a>
<span class="lineNum">     186 </span>            : static void
<span class="lineNum">     187 </span><span class="lineCov">    9605358 : ReservePrivateRefCountEntry(void)</span>
<span class="lineNum">     188 </span>            : {
<span class="lineNum">     189 </span>            :     /* Already reserved (or freed), nothing to do */
<span class="lineNum">     190 </span><span class="lineCov">    9605358 :     if (ReservedRefCountEntry != NULL)</span>
<span class="lineNum">     191 </span><span class="lineCov">    8601630 :         return;</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :     /*
<span class="lineNum">     194 </span>            :      * First search for a free entry the array, that'll be sufficient in the
<span class="lineNum">     195 </span>            :      * majority of cases.
<span class="lineNum">     196 </span>            :      */
<span class="lineNum">     197 </span>            :     {
<span class="lineNum">     198 </span>            :         int         i;
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span><span class="lineCov">    2178436 :         for (i = 0; i &lt; REFCOUNT_ARRAY_ENTRIES; i++)</span>
<span class="lineNum">     201 </span>            :         {
<span class="lineNum">     202 </span>            :             PrivateRefCountEntry *res;
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span><span class="lineCov">    2175224 :             res = &amp;PrivateRefCountArray[i];</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineCov">    2175224 :             if (res-&gt;buffer == InvalidBuffer)</span>
<span class="lineNum">     207 </span>            :             {
<span class="lineNum">     208 </span><span class="lineCov">    1000516 :                 ReservedRefCountEntry = res;</span>
<span class="lineNum">     209 </span><span class="lineCov">    1000516 :                 return;</span>
<span class="lineNum">     210 </span>            :             }
<span class="lineNum">     211 </span>            :         }
<span class="lineNum">     212 </span>            :     }
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :     /*
<span class="lineNum">     215 </span>            :      * No luck. All array entries are full. Move one array entry into the hash
<span class="lineNum">     216 </span>            :      * table.
<span class="lineNum">     217 </span>            :      */
<span class="lineNum">     218 </span>            :     {
<span class="lineNum">     219 </span>            :         /*
<span class="lineNum">     220 </span>            :          * Move entry from the current clock position in the array into the
<span class="lineNum">     221 </span>            :          * hashtable. Use that slot.
<span class="lineNum">     222 </span>            :          */
<span class="lineNum">     223 </span>            :         PrivateRefCountEntry *hashent;
<span class="lineNum">     224 </span>            :         bool        found;
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :         /* select victim slot */
<span class="lineNum">     227 </span><span class="lineCov">       3212 :         ReservedRefCountEntry =</span>
<span class="lineNum">     228 </span><span class="lineCov">       3212 :             &amp;PrivateRefCountArray[PrivateRefCountClock++ % REFCOUNT_ARRAY_ENTRIES];</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            :         /* Better be used, otherwise we shouldn't get here. */
<span class="lineNum">     231 </span><span class="lineCov">       3212 :         Assert(ReservedRefCountEntry-&gt;buffer != InvalidBuffer);</span>
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            :         /* enter victim array entry into hashtable */
<span class="lineNum">     234 </span><span class="lineCov">       3212 :         hashent = hash_search(PrivateRefCountHash,</span>
<span class="lineNum">     235 </span><span class="lineCov">       3212 :                               (void *) &amp;(ReservedRefCountEntry-&gt;buffer),</span>
<span class="lineNum">     236 </span>            :                               HASH_ENTER,
<span class="lineNum">     237 </span>            :                               &amp;found);
<span class="lineNum">     238 </span><span class="lineCov">       3212 :         Assert(!found);</span>
<span class="lineNum">     239 </span><span class="lineCov">       3212 :         hashent-&gt;refcount = ReservedRefCountEntry-&gt;refcount;</span>
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            :         /* clear the now free array slot */
<span class="lineNum">     242 </span><span class="lineCov">       3212 :         ReservedRefCountEntry-&gt;buffer = InvalidBuffer;</span>
<span class="lineNum">     243 </span><span class="lineCov">       3212 :         ReservedRefCountEntry-&gt;refcount = 0;</span>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span><span class="lineCov">       3212 :         PrivateRefCountOverflowed++;</span>
<span class="lineNum">     246 </span>            :     }
<span class="lineNum">     247 </span>            : }
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            : /*
<span class="lineNum">     250 </span>            :  * Fill a previously reserved refcount entry.
<a name="251"><span class="lineNum">     251 </span>            :  */</a>
<span class="lineNum">     252 </span>            : static PrivateRefCountEntry *
<span class="lineNum">     253 </span><span class="lineCov">    9578304 : NewPrivateRefCountEntry(Buffer buffer)</span>
<span class="lineNum">     254 </span>            : {
<span class="lineNum">     255 </span>            :     PrivateRefCountEntry *res;
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            :     /* only allowed to be called when a reservation has been made */
<span class="lineNum">     258 </span><span class="lineCov">    9578304 :     Assert(ReservedRefCountEntry != NULL);</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            :     /* use up the reserved entry */
<span class="lineNum">     261 </span><span class="lineCov">    9578304 :     res = ReservedRefCountEntry;</span>
<span class="lineNum">     262 </span><span class="lineCov">    9578304 :     ReservedRefCountEntry = NULL;</span>
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            :     /* and fill it */
<span class="lineNum">     265 </span><span class="lineCov">    9578304 :     res-&gt;buffer = buffer;</span>
<span class="lineNum">     266 </span><span class="lineCov">    9578304 :     res-&gt;refcount = 0;</span>
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span><span class="lineCov">    9578304 :     return res;</span>
<span class="lineNum">     269 </span>            : }
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : /*
<span class="lineNum">     272 </span>            :  * Return the PrivateRefCount entry for the passed buffer.
<span class="lineNum">     273 </span>            :  *
<span class="lineNum">     274 </span>            :  * Returns NULL if a buffer doesn't have a refcount entry. Otherwise, if
<span class="lineNum">     275 </span>            :  * do_move is true, and the entry resides in the hashtable the entry is
<span class="lineNum">     276 </span>            :  * optimized for frequent access by moving it to the array.
<a name="277"><span class="lineNum">     277 </span>            :  */</a>
<span class="lineNum">     278 </span>            : static PrivateRefCountEntry *
<span class="lineNum">     279 </span><span class="lineCov">   67041250 : GetPrivateRefCountEntry(Buffer buffer, bool do_move)</span>
<span class="lineNum">     280 </span>            : {
<span class="lineNum">     281 </span>            :     PrivateRefCountEntry *res;
<span class="lineNum">     282 </span>            :     int         i;
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span><span class="lineCov">   67041250 :     Assert(BufferIsValid(buffer));</span>
<span class="lineNum">     285 </span><span class="lineCov">   67041250 :     Assert(!BufferIsLocal(buffer));</span>
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :     /*
<span class="lineNum">     288 </span>            :      * First search for references in the array, that'll be sufficient in the
<span class="lineNum">     289 </span>            :      * majority of cases.
<span class="lineNum">     290 </span>            :      */
<span class="lineNum">     291 </span><span class="lineCov">  187820816 :     for (i = 0; i &lt; REFCOUNT_ARRAY_ENTRIES; i++)</span>
<span class="lineNum">     292 </span>            :     {
<span class="lineNum">     293 </span><span class="lineCov">  178232838 :         res = &amp;PrivateRefCountArray[i];</span>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span><span class="lineCov">  178232838 :         if (res-&gt;buffer == buffer)</span>
<span class="lineNum">     296 </span><span class="lineCov">   57453272 :             return res;</span>
<span class="lineNum">     297 </span>            :     }
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :     /*
<span class="lineNum">     300 </span>            :      * By here we know that the buffer, if already pinned, isn't residing in
<span class="lineNum">     301 </span>            :      * the array.
<span class="lineNum">     302 </span>            :      *
<span class="lineNum">     303 </span>            :      * Only look up the buffer in the hashtable if we've previously overflowed
<span class="lineNum">     304 </span>            :      * into it.
<span class="lineNum">     305 </span>            :      */
<span class="lineNum">     306 </span><span class="lineCov">    9587978 :     if (PrivateRefCountOverflowed == 0)</span>
<span class="lineNum">     307 </span><span class="lineCov">    9574634 :         return NULL;</span>
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span><span class="lineCov">      13344 :     res = hash_search(PrivateRefCountHash,</span>
<span class="lineNum">     310 </span>            :                       (void *) &amp;buffer,
<span class="lineNum">     311 </span>            :                       HASH_FIND,
<span class="lineNum">     312 </span>            :                       NULL);
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span><span class="lineCov">      13344 :     if (res == NULL)</span>
<span class="lineNum">     315 </span><span class="lineCov">       3670 :         return NULL;</span>
<span class="lineNum">     316 </span><span class="lineCov">       9674 :     else if (!do_move)</span>
<span class="lineNum">     317 </span>            :     {
<span class="lineNum">     318 </span>            :         /* caller doesn't want us to move the hash entry into the array */
<span class="lineNum">     319 </span><span class="lineCov">       9672 :         return res;</span>
<span class="lineNum">     320 </span>            :     }
<span class="lineNum">     321 </span>            :     else
<span class="lineNum">     322 </span>            :     {
<span class="lineNum">     323 </span>            :         /* move buffer from hashtable into the free array slot */
<span class="lineNum">     324 </span>            :         bool        found;
<span class="lineNum">     325 </span>            :         PrivateRefCountEntry *free;
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :         /* Ensure there's a free array slot */
<span class="lineNum">     328 </span><span class="lineCov">          2 :         ReservePrivateRefCountEntry();</span>
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            :         /* Use up the reserved slot */
<span class="lineNum">     331 </span><span class="lineCov">          2 :         Assert(ReservedRefCountEntry != NULL);</span>
<span class="lineNum">     332 </span><span class="lineCov">          2 :         free = ReservedRefCountEntry;</span>
<span class="lineNum">     333 </span><span class="lineCov">          2 :         ReservedRefCountEntry = NULL;</span>
<span class="lineNum">     334 </span><span class="lineCov">          2 :         Assert(free-&gt;buffer == InvalidBuffer);</span>
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :         /* and fill it */
<span class="lineNum">     337 </span><span class="lineCov">          2 :         free-&gt;buffer = buffer;</span>
<span class="lineNum">     338 </span><span class="lineCov">          2 :         free-&gt;refcount = res-&gt;refcount;</span>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            :         /* delete from hashtable */
<span class="lineNum">     341 </span><span class="lineCov">          2 :         hash_search(PrivateRefCountHash,</span>
<span class="lineNum">     342 </span>            :                     (void *) &amp;buffer,
<span class="lineNum">     343 </span>            :                     HASH_REMOVE,
<span class="lineNum">     344 </span>            :                     &amp;found);
<span class="lineNum">     345 </span><span class="lineCov">          2 :         Assert(found);</span>
<span class="lineNum">     346 </span><span class="lineCov">          2 :         Assert(PrivateRefCountOverflowed &gt; 0);</span>
<span class="lineNum">     347 </span><span class="lineCov">          2 :         PrivateRefCountOverflowed--;</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span><span class="lineCov">          2 :         return free;</span>
<span class="lineNum">     350 </span>            :     }
<span class="lineNum">     351 </span>            : }
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            : /*
<span class="lineNum">     354 </span>            :  * Returns how many times the passed buffer is pinned by this backend.
<span class="lineNum">     355 </span>            :  *
<span class="lineNum">     356 </span>            :  * Only works for shared memory buffers!
<a name="357"><span class="lineNum">     357 </span>            :  */</a>
<span class="lineNum">     358 </span>            : static inline int32
<span class="lineNum">     359 </span><span class="lineCov">   41895562 : GetPrivateRefCount(Buffer buffer)</span>
<span class="lineNum">     360 </span>            : {
<span class="lineNum">     361 </span>            :     PrivateRefCountEntry *ref;
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span><span class="lineCov">   41895562 :     Assert(BufferIsValid(buffer));</span>
<span class="lineNum">     364 </span><span class="lineCov">   41895562 :     Assert(!BufferIsLocal(buffer));</span>
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            :     /*
<span class="lineNum">     367 </span>            :      * Not moving the entry - that's ok for the current users, but we might
<span class="lineNum">     368 </span>            :      * want to change this one day.
<span class="lineNum">     369 </span>            :      */
<span class="lineNum">     370 </span><span class="lineCov">   41895562 :     ref = GetPrivateRefCountEntry(buffer, false);</span>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span><span class="lineCov">   41895562 :     if (ref == NULL)</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     374 </span><span class="lineCov">   41895562 :     return ref-&gt;refcount;</span>
<span class="lineNum">     375 </span>            : }
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            : /*
<span class="lineNum">     378 </span>            :  * Release resources used to track the reference count of a buffer which we no
<span class="lineNum">     379 </span>            :  * longer have pinned and don't want to pin again immediately.
<a name="380"><span class="lineNum">     380 </span>            :  */</a>
<span class="lineNum">     381 </span>            : static void
<span class="lineNum">     382 </span><span class="lineCov">    9578304 : ForgetPrivateRefCountEntry(PrivateRefCountEntry *ref)</span>
<span class="lineNum">     383 </span>            : {
<span class="lineNum">     384 </span><span class="lineCov">    9578304 :     Assert(ref-&gt;refcount == 0);</span>
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span><span class="lineCov">    9578304 :     if (ref &gt;= &amp;PrivateRefCountArray[0] &amp;&amp;</span>
<span class="lineNum">     387 </span>            :         ref &lt; &amp;PrivateRefCountArray[REFCOUNT_ARRAY_ENTRIES])
<span class="lineNum">     388 </span>            :     {
<span class="lineNum">     389 </span><span class="lineCov">    9575094 :         ref-&gt;buffer = InvalidBuffer;</span>
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            :         /*
<span class="lineNum">     392 </span>            :          * Mark the just used entry as reserved - in many scenarios that
<span class="lineNum">     393 </span>            :          * allows us to avoid ever having to search the array/hash for free
<span class="lineNum">     394 </span>            :          * entries.
<span class="lineNum">     395 </span>            :          */
<span class="lineNum">     396 </span><span class="lineCov">    9575094 :         ReservedRefCountEntry = ref;</span>
<span class="lineNum">     397 </span>            :     }
<span class="lineNum">     398 </span>            :     else
<span class="lineNum">     399 </span>            :     {
<span class="lineNum">     400 </span>            :         bool        found;
<span class="lineNum">     401 </span><span class="lineCov">       3210 :         Buffer      buffer = ref-&gt;buffer;</span>
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span><span class="lineCov">       3210 :         hash_search(PrivateRefCountHash,</span>
<span class="lineNum">     404 </span>            :                     (void *) &amp;buffer,
<span class="lineNum">     405 </span>            :                     HASH_REMOVE,
<span class="lineNum">     406 </span>            :                     &amp;found);
<span class="lineNum">     407 </span><span class="lineCov">       3210 :         Assert(found);</span>
<span class="lineNum">     408 </span><span class="lineCov">       3210 :         Assert(PrivateRefCountOverflowed &gt; 0);</span>
<span class="lineNum">     409 </span><span class="lineCov">       3210 :         PrivateRefCountOverflowed--;</span>
<span class="lineNum">     410 </span>            :     }
<span class="lineNum">     411 </span><span class="lineCov">    9578304 : }</span>
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            : /*
<span class="lineNum">     414 </span>            :  * BufferIsPinned
<span class="lineNum">     415 </span>            :  *      True iff the buffer is pinned (also checks for valid buffer number).
<span class="lineNum">     416 </span>            :  *
<span class="lineNum">     417 </span>            :  *      NOTE: what we check here is that *this* backend holds a pin on
<span class="lineNum">     418 </span>            :  *      the buffer.  We do not care whether some other backend does.
<span class="lineNum">     419 </span>            :  */
<span class="lineNum">     420 </span>            : #define BufferIsPinned(bufnum) \
<span class="lineNum">     421 </span>            : ( \
<span class="lineNum">     422 </span>            :     !BufferIsValid(bufnum) ? \
<span class="lineNum">     423 </span>            :         false \
<span class="lineNum">     424 </span>            :     : \
<span class="lineNum">     425 </span>            :         BufferIsLocal(bufnum) ? \
<span class="lineNum">     426 </span>            :             (LocalRefCount[-(bufnum) - 1] &gt; 0) \
<span class="lineNum">     427 </span>            :         : \
<span class="lineNum">     428 </span>            :     (GetPrivateRefCount(bufnum) &gt; 0) \
<span class="lineNum">     429 </span>            : )
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            : static Buffer ReadBuffer_common(SMgrRelation reln, char relpersistence,
<span class="lineNum">     433 </span>            :                                 ForkNumber forkNum, BlockNumber blockNum,
<span class="lineNum">     434 </span>            :                                 ReadBufferMode mode, BufferAccessStrategy strategy,
<span class="lineNum">     435 </span>            :                                 bool *hit);
<span class="lineNum">     436 </span>            : static bool PinBuffer(BufferDesc *buf, BufferAccessStrategy strategy);
<span class="lineNum">     437 </span>            : static void PinBuffer_Locked(BufferDesc *buf);
<span class="lineNum">     438 </span>            : static void UnpinBuffer(BufferDesc *buf, bool fixOwner);
<span class="lineNum">     439 </span>            : static void BufferSync(int flags);
<span class="lineNum">     440 </span>            : static uint32 WaitBufHdrUnlocked(BufferDesc *buf);
<span class="lineNum">     441 </span>            : static int  SyncOneBuffer(int buf_id, bool skip_recently_used,
<span class="lineNum">     442 </span>            :                           WritebackContext *wb_context);
<span class="lineNum">     443 </span>            : static void WaitIO(BufferDesc *buf);
<span class="lineNum">     444 </span>            : static bool StartBufferIO(BufferDesc *buf, bool forInput);
<span class="lineNum">     445 </span>            : static void TerminateBufferIO(BufferDesc *buf, bool clear_dirty,
<span class="lineNum">     446 </span>            :                               uint32 set_flag_bits);
<span class="lineNum">     447 </span>            : static void shared_buffer_write_error_callback(void *arg);
<span class="lineNum">     448 </span>            : static void local_buffer_write_error_callback(void *arg);
<span class="lineNum">     449 </span>            : static BufferDesc *BufferAlloc(SMgrRelation smgr,
<span class="lineNum">     450 </span>            :                                char relpersistence,
<span class="lineNum">     451 </span>            :                                ForkNumber forkNum,
<span class="lineNum">     452 </span>            :                                BlockNumber blockNum,
<span class="lineNum">     453 </span>            :                                BufferAccessStrategy strategy,
<span class="lineNum">     454 </span>            :                                bool *foundPtr);
<span class="lineNum">     455 </span>            : static void FlushBuffer(BufferDesc *buf, SMgrRelation reln);
<span class="lineNum">     456 </span>            : static void AtProcExit_Buffers(int code, Datum arg);
<span class="lineNum">     457 </span>            : static void CheckForBufferLeaks(void);
<span class="lineNum">     458 </span>            : static int  rnode_comparator(const void *p1, const void *p2);
<span class="lineNum">     459 </span>            : static int  buffertag_comparator(const void *p1, const void *p2);
<span class="lineNum">     460 </span>            : static int  ckpt_buforder_comparator(const void *pa, const void *pb);
<span class="lineNum">     461 </span>            : static int  ts_ckpt_progress_comparator(Datum a, Datum b, void *arg);
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            : /*
<span class="lineNum">     465 </span>            :  * ComputeIoConcurrency -- get the number of pages to prefetch for a given
<span class="lineNum">     466 </span>            :  *      number of spindles.
<a name="467"><span class="lineNum">     467 </span>            :  */</a>
<span class="lineNum">     468 </span>            : bool
<span class="lineNum">     469 </span><span class="lineCov">       1426 : ComputeIoConcurrency(int io_concurrency, double *target)</span>
<span class="lineNum">     470 </span>            : {
<span class="lineNum">     471 </span><span class="lineCov">       1426 :     double      new_prefetch_pages = 0.0;</span>
<span class="lineNum">     472 </span>            :     int         i;
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :     /*
<span class="lineNum">     475 </span>            :      * Make sure the io_concurrency value is within valid range; it may have
<span class="lineNum">     476 </span>            :      * been forced with a manual pg_tablespace update.
<span class="lineNum">     477 </span>            :      */
<span class="lineNum">     478 </span><span class="lineCov">       1426 :     io_concurrency = Min(Max(io_concurrency, 0), MAX_IO_CONCURRENCY);</span>
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :     /*----------
<span class="lineNum">     481 </span>            :      * The user-visible GUC parameter is the number of drives (spindles),
<span class="lineNum">     482 </span>            :      * which we need to translate to a number-of-pages-to-prefetch target.
<span class="lineNum">     483 </span>            :      * The target value is stashed in *extra and then assigned to the actual
<span class="lineNum">     484 </span>            :      * variable by assign_effective_io_concurrency.
<span class="lineNum">     485 </span>            :      *
<span class="lineNum">     486 </span>            :      * The expected number of prefetch pages needed to keep N drives busy is:
<span class="lineNum">     487 </span>            :      *
<span class="lineNum">     488 </span>            :      * drives |   I/O requests
<span class="lineNum">     489 </span>            :      * -------+----------------
<span class="lineNum">     490 </span>            :      *      1 |   1
<span class="lineNum">     491 </span>            :      *      2 |   2/1 + 2/2 = 3
<span class="lineNum">     492 </span>            :      *      3 |   3/1 + 3/2 + 3/3 = 5 1/2
<span class="lineNum">     493 </span>            :      *      4 |   4/1 + 4/2 + 4/3 + 4/4 = 8 1/3
<span class="lineNum">     494 </span>            :      *      n |   n * H(n)
<span class="lineNum">     495 </span>            :      *
<span class="lineNum">     496 </span>            :      * This is called the &quot;coupon collector problem&quot; and H(n) is called the
<span class="lineNum">     497 </span>            :      * harmonic series.  This could be approximated by n * ln(n), but for
<span class="lineNum">     498 </span>            :      * reasonable numbers of drives we might as well just compute the series.
<span class="lineNum">     499 </span>            :      *
<span class="lineNum">     500 </span>            :      * Alternatively we could set the target to the number of pages necessary
<span class="lineNum">     501 </span>            :      * so that the expected number of active spindles is some arbitrary
<span class="lineNum">     502 </span>            :      * percentage of the total.  This sounds the same but is actually slightly
<span class="lineNum">     503 </span>            :      * different.  The result ends up being ln(1-P)/ln((n-1)/n) where P is
<span class="lineNum">     504 </span>            :      * that desired fraction.
<span class="lineNum">     505 </span>            :      *
<span class="lineNum">     506 </span>            :      * Experimental results show that both of these formulas aren't aggressive
<span class="lineNum">     507 </span>            :      * enough, but we don't really have any better proposals.
<span class="lineNum">     508 </span>            :      *
<span class="lineNum">     509 </span>            :      * Note that if io_concurrency = 0 (disabled), we must set target = 0.
<span class="lineNum">     510 </span>            :      *----------
<span class="lineNum">     511 </span>            :      */
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span><span class="lineCov">      12554 :     for (i = 1; i &lt;= io_concurrency; i++)</span>
<span class="lineNum">     514 </span><span class="lineCov">      11128 :         new_prefetch_pages += (double) io_concurrency / (double) i;</span>
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span><span class="lineCov">       1426 :     *target = new_prefetch_pages;</span>
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            :     /* This range check shouldn't fail, but let's be paranoid */
<span class="lineNum">     519 </span><span class="lineCov">       1426 :     return (new_prefetch_pages &gt;= 0.0 &amp;&amp; new_prefetch_pages &lt; (double) INT_MAX);</span>
<span class="lineNum">     520 </span>            : }
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            : /*
<span class="lineNum">     523 </span>            :  * PrefetchBuffer -- initiate asynchronous read of a block of a relation
<span class="lineNum">     524 </span>            :  *
<span class="lineNum">     525 </span>            :  * This is named by analogy to ReadBuffer but doesn't actually allocate a
<span class="lineNum">     526 </span>            :  * buffer.  Instead it tries to ensure that a future ReadBuffer for the given
<span class="lineNum">     527 </span>            :  * block will not be delayed by the I/O.  Prefetching is optional.
<span class="lineNum">     528 </span>            :  * No-op if prefetching isn't compiled in.
<a name="529"><span class="lineNum">     529 </span>            :  */</a>
<span class="lineNum">     530 </span>            : void
<span class="lineNum">     531 </span><span class="lineCov">      55522 : PrefetchBuffer(Relation reln, ForkNumber forkNum, BlockNumber blockNum)</span>
<span class="lineNum">     532 </span>            : {
<span class="lineNum">     533 </span>            : #ifdef USE_PREFETCH
<span class="lineNum">     534 </span><span class="lineCov">      55522 :     Assert(RelationIsValid(reln));</span>
<span class="lineNum">     535 </span><span class="lineCov">      55522 :     Assert(BlockNumberIsValid(blockNum));</span>
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            :     /* Open it at the smgr level if not already done */
<span class="lineNum">     538 </span><span class="lineCov">      55522 :     RelationOpenSmgr(reln);</span>
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span><span class="lineCov">      55522 :     if (RelationUsesLocalBuffers(reln))</span>
<span class="lineNum">     541 </span>            :     {
<span class="lineNum">     542 </span>            :         /* see comments in ReadBufferExtended */
<span class="lineNum">     543 </span><span class="lineCov">         10 :         if (RELATION_IS_OTHER_TEMP(reln))</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">     545 </span>            :                     (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">     546 </span>            :                      errmsg(&quot;cannot access temporary tables of other sessions&quot;)));
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            :         /* pass it off to localbuf.c */
<span class="lineNum">     549 </span><span class="lineCov">         10 :         LocalPrefetchBuffer(reln-&gt;rd_smgr, forkNum, blockNum);</span>
<span class="lineNum">     550 </span>            :     }
<span class="lineNum">     551 </span>            :     else
<span class="lineNum">     552 </span>            :     {
<span class="lineNum">     553 </span>            :         BufferTag   newTag;     /* identity of requested block */
<span class="lineNum">     554 </span>            :         uint32      newHash;    /* hash value for newTag */
<span class="lineNum">     555 </span>            :         LWLock     *newPartitionLock;   /* buffer partition lock for it */
<span class="lineNum">     556 </span>            :         int         buf_id;
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            :         /* create a tag so we can lookup the buffer */
<span class="lineNum">     559 </span><span class="lineCov">      55512 :         INIT_BUFFERTAG(newTag, reln-&gt;rd_smgr-&gt;smgr_rnode.node,</span>
<span class="lineNum">     560 </span>            :                        forkNum, blockNum);
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span>            :         /* determine its hash code and partition lock ID */
<span class="lineNum">     563 </span><span class="lineCov">      55512 :         newHash = BufTableHashCode(&amp;newTag);</span>
<span class="lineNum">     564 </span><span class="lineCov">      55512 :         newPartitionLock = BufMappingPartitionLock(newHash);</span>
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span>            :         /* see if the block is in the buffer pool already */
<span class="lineNum">     567 </span><span class="lineCov">      55512 :         LWLockAcquire(newPartitionLock, LW_SHARED);</span>
<span class="lineNum">     568 </span><span class="lineCov">      55512 :         buf_id = BufTableLookup(&amp;newTag, newHash);</span>
<span class="lineNum">     569 </span><span class="lineCov">      55512 :         LWLockRelease(newPartitionLock);</span>
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            :         /* If not in buffers, initiate prefetch */
<span class="lineNum">     572 </span><span class="lineCov">      55512 :         if (buf_id &lt; 0)</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :             smgrprefetch(reln-&gt;rd_smgr, forkNum, blockNum);</span>
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span>            :         /*
<span class="lineNum">     576 </span>            :          * If the block *is* in buffers, we do nothing.  This is not really
<span class="lineNum">     577 </span>            :          * ideal: the block might be just about to be evicted, which would be
<span class="lineNum">     578 </span>            :          * stupid since we know we are going to need it soon.  But the only
<span class="lineNum">     579 </span>            :          * easy answer is to bump the usage_count, which does not seem like a
<span class="lineNum">     580 </span>            :          * great solution: when the caller does ultimately touch the block,
<span class="lineNum">     581 </span>            :          * usage_count would get bumped again, resulting in too much
<span class="lineNum">     582 </span>            :          * favoritism for blocks that are involved in a prefetch sequence. A
<span class="lineNum">     583 </span>            :          * real fix would involve some additional per-buffer state, and it's
<span class="lineNum">     584 </span>            :          * not clear that there's enough of a problem to justify that.
<span class="lineNum">     585 </span>            :          */
<span class="lineNum">     586 </span>            :     }
<span class="lineNum">     587 </span>            : #endif                          /* USE_PREFETCH */
<span class="lineNum">     588 </span><span class="lineCov">      55522 : }</span>
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            : /*
<span class="lineNum">     592 </span>            :  * ReadBuffer -- a shorthand for ReadBufferExtended, for reading from main
<span class="lineNum">     593 </span>            :  *      fork with RBM_NORMAL mode and default strategy.
<a name="594"><span class="lineNum">     594 </span>            :  */</a>
<span class="lineNum">     595 </span>            : Buffer
<span class="lineNum">     596 </span><span class="lineCov">    7950488 : ReadBuffer(Relation reln, BlockNumber blockNum)</span>
<span class="lineNum">     597 </span>            : {
<span class="lineNum">     598 </span><span class="lineCov">    7950488 :     return ReadBufferExtended(reln, MAIN_FORKNUM, blockNum, RBM_NORMAL, NULL);</span>
<span class="lineNum">     599 </span>            : }
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            : /*
<span class="lineNum">     602 </span>            :  * ReadBufferExtended -- returns a buffer containing the requested
<span class="lineNum">     603 </span>            :  *      block of the requested relation.  If the blknum
<span class="lineNum">     604 </span>            :  *      requested is P_NEW, extend the relation file and
<span class="lineNum">     605 </span>            :  *      allocate a new block.  (Caller is responsible for
<span class="lineNum">     606 </span>            :  *      ensuring that only one backend tries to extend a
<span class="lineNum">     607 </span>            :  *      relation at the same time!)
<span class="lineNum">     608 </span>            :  *
<span class="lineNum">     609 </span>            :  * Returns: the buffer number for the buffer containing
<span class="lineNum">     610 </span>            :  *      the block read.  The returned buffer has been pinned.
<span class="lineNum">     611 </span>            :  *      Does not return on error --- elog's instead.
<span class="lineNum">     612 </span>            :  *
<span class="lineNum">     613 </span>            :  * Assume when this function is called, that reln has been opened already.
<span class="lineNum">     614 </span>            :  *
<span class="lineNum">     615 </span>            :  * In RBM_NORMAL mode, the page is read from disk, and the page header is
<span class="lineNum">     616 </span>            :  * validated.  An error is thrown if the page header is not valid.  (But
<span class="lineNum">     617 </span>            :  * note that an all-zero page is considered &quot;valid&quot;; see PageIsVerified().)
<span class="lineNum">     618 </span>            :  *
<span class="lineNum">     619 </span>            :  * RBM_ZERO_ON_ERROR is like the normal mode, but if the page header is not
<span class="lineNum">     620 </span>            :  * valid, the page is zeroed instead of throwing an error. This is intended
<span class="lineNum">     621 </span>            :  * for non-critical data, where the caller is prepared to repair errors.
<span class="lineNum">     622 </span>            :  *
<span class="lineNum">     623 </span>            :  * In RBM_ZERO_AND_LOCK mode, if the page isn't in buffer cache already, it's
<span class="lineNum">     624 </span>            :  * filled with zeros instead of reading it from disk.  Useful when the caller
<span class="lineNum">     625 </span>            :  * is going to fill the page from scratch, since this saves I/O and avoids
<span class="lineNum">     626 </span>            :  * unnecessary failure if the page-on-disk has corrupt page headers.
<span class="lineNum">     627 </span>            :  * The page is returned locked to ensure that the caller has a chance to
<span class="lineNum">     628 </span>            :  * initialize the page before it's made visible to others.
<span class="lineNum">     629 </span>            :  * Caution: do not use this mode to read a page that is beyond the relation's
<span class="lineNum">     630 </span>            :  * current physical EOF; that is likely to cause problems in md.c when
<span class="lineNum">     631 </span>            :  * the page is modified and written out. P_NEW is OK, though.
<span class="lineNum">     632 </span>            :  *
<span class="lineNum">     633 </span>            :  * RBM_ZERO_AND_CLEANUP_LOCK is the same as RBM_ZERO_AND_LOCK, but acquires
<span class="lineNum">     634 </span>            :  * a cleanup-strength lock on the page.
<span class="lineNum">     635 </span>            :  *
<span class="lineNum">     636 </span>            :  * RBM_NORMAL_NO_LOG mode is treated the same as RBM_NORMAL here.
<span class="lineNum">     637 </span>            :  *
<span class="lineNum">     638 </span>            :  * If strategy is not NULL, a nondefault buffer access strategy is used.
<span class="lineNum">     639 </span>            :  * See buffer/README for details.
<a name="640"><span class="lineNum">     640 </span>            :  */</a>
<span class="lineNum">     641 </span>            : Buffer
<span class="lineNum">     642 </span><span class="lineCov">   10140910 : ReadBufferExtended(Relation reln, ForkNumber forkNum, BlockNumber blockNum,</span>
<span class="lineNum">     643 </span>            :                    ReadBufferMode mode, BufferAccessStrategy strategy)
<span class="lineNum">     644 </span>            : {
<span class="lineNum">     645 </span>            :     bool        hit;
<span class="lineNum">     646 </span>            :     Buffer      buf;
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            :     /* Open it at the smgr level if not already done */
<span class="lineNum">     649 </span><span class="lineCov">   10140910 :     RelationOpenSmgr(reln);</span>
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            :     /*
<span class="lineNum">     652 </span>            :      * Reject attempts to read non-local temporary relations; we would be
<span class="lineNum">     653 </span>            :      * likely to get wrong data since we have no visibility into the owning
<span class="lineNum">     654 </span>            :      * session's local buffers.
<span class="lineNum">     655 </span>            :      */
<span class="lineNum">     656 </span><span class="lineCov">   10140910 :     if (RELATION_IS_OTHER_TEMP(reln))</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">     658 </span>            :                 (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">     659 </span>            :                  errmsg(&quot;cannot access temporary tables of other sessions&quot;)));
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            :     /*
<span class="lineNum">     662 </span>            :      * Read the buffer, and update pgstat counters to reflect a cache hit or
<span class="lineNum">     663 </span>            :      * miss.
<span class="lineNum">     664 </span>            :      */
<span class="lineNum">     665 </span><span class="lineCov">   10140910 :     pgstat_count_buffer_read(reln);</span>
<span class="lineNum">     666 </span><span class="lineCov">   10140910 :     buf = ReadBuffer_common(reln-&gt;rd_smgr, reln-&gt;rd_rel-&gt;relpersistence,</span>
<span class="lineNum">     667 </span>            :                             forkNum, blockNum, mode, strategy, &amp;hit);
<span class="lineNum">     668 </span><span class="lineCov">   10140910 :     if (hit)</span>
<span class="lineNum">     669 </span><span class="lineCov">   10086674 :         pgstat_count_buffer_hit(reln);</span>
<span class="lineNum">     670 </span><span class="lineCov">   10140910 :     return buf;</span>
<span class="lineNum">     671 </span>            : }
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            : /*
<span class="lineNum">     675 </span>            :  * ReadBufferWithoutRelcache -- like ReadBufferExtended, but doesn't require
<span class="lineNum">     676 </span>            :  *      a relcache entry for the relation.
<span class="lineNum">     677 </span>            :  *
<span class="lineNum">     678 </span>            :  * NB: At present, this function may only be used on permanent relations, which
<span class="lineNum">     679 </span>            :  * is OK, because we only use it during XLOG replay.  If in the future we
<span class="lineNum">     680 </span>            :  * want to use it on temporary or unlogged relations, we could pass additional
<span class="lineNum">     681 </span>            :  * parameters.
<a name="682"><span class="lineNum">     682 </span>            :  */</a>
<span class="lineNum">     683 </span>            : Buffer
<span class="lineNum">     684 </span><span class="lineNoCov">          0 : ReadBufferWithoutRelcache(RelFileNode rnode, ForkNumber forkNum,</span>
<span class="lineNum">     685 </span>            :                           BlockNumber blockNum, ReadBufferMode mode,
<span class="lineNum">     686 </span>            :                           BufferAccessStrategy strategy)
<span class="lineNum">     687 </span>            : {
<span class="lineNum">     688 </span>            :     bool        hit;
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     SMgrRelation smgr = smgropen(rnode, InvalidBackendId);</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     Assert(InRecovery);</span>
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     return ReadBuffer_common(smgr, RELPERSISTENCE_PERMANENT, forkNum, blockNum,</span>
<span class="lineNum">     695 </span>            :                              mode, strategy, &amp;hit);
<span class="lineNum">     696 </span>            : }
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            : /*
<span class="lineNum">     700 </span>            :  * ReadBuffer_common -- common logic for all ReadBuffer variants
<span class="lineNum">     701 </span>            :  *
<span class="lineNum">     702 </span>            :  * *hit is set to true if the request was satisfied from shared buffer cache.
<a name="703"><span class="lineNum">     703 </span>            :  */</a>
<span class="lineNum">     704 </span>            : static Buffer
<span class="lineNum">     705 </span><span class="lineCov">   10140910 : ReadBuffer_common(SMgrRelation smgr, char relpersistence, ForkNumber forkNum,</span>
<span class="lineNum">     706 </span>            :                   BlockNumber blockNum, ReadBufferMode mode,
<span class="lineNum">     707 </span>            :                   BufferAccessStrategy strategy, bool *hit)
<span class="lineNum">     708 </span>            : {
<span class="lineNum">     709 </span>            :     BufferDesc *bufHdr;
<span class="lineNum">     710 </span>            :     Block       bufBlock;
<span class="lineNum">     711 </span>            :     bool        found;
<span class="lineNum">     712 </span>            :     bool        isExtend;
<span class="lineNum">     713 </span><span class="lineCov">   10140910 :     bool        isLocalBuf = SmgrIsTemp(smgr);</span>
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span><span class="lineCov">   10140910 :     *hit = false;</span>
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            :     /* Make sure we will have room to remember the buffer pin */
<span class="lineNum">     718 </span><span class="lineCov">   10140910 :     ResourceOwnerEnlargeBuffers(CurrentResourceOwner);</span>
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span><span class="lineCov">   10140910 :     isExtend = (blockNum == P_NEW);</span>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :     TRACE_POSTGRESQL_BUFFER_READ_START(forkNum, blockNum,
<span class="lineNum">     723 </span>            :                                        smgr-&gt;smgr_rnode.node.spcNode,
<span class="lineNum">     724 </span>            :                                        smgr-&gt;smgr_rnode.node.dbNode,
<span class="lineNum">     725 </span>            :                                        smgr-&gt;smgr_rnode.node.relNode,
<span class="lineNum">     726 </span>            :                                        smgr-&gt;smgr_rnode.backend,
<span class="lineNum">     727 </span>            :                                        isExtend);
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            :     /* Substitute proper block number if caller asked for P_NEW */
<span class="lineNum">     730 </span><span class="lineCov">   10140910 :     if (isExtend)</span>
<span class="lineNum">     731 </span><span class="lineCov">      40838 :         blockNum = smgrnblocks(smgr, forkNum);</span>
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span><span class="lineCov">   10140910 :     if (isLocalBuf)</span>
<span class="lineNum">     734 </span>            :     {
<span class="lineNum">     735 </span><span class="lineCov">      80486 :         bufHdr = LocalBufferAlloc(smgr, forkNum, blockNum, &amp;found);</span>
<span class="lineNum">     736 </span><span class="lineCov">      80486 :         if (found)</span>
<span class="lineNum">     737 </span><span class="lineCov">      75934 :             pgBufferUsage.local_blks_hit++;</span>
<span class="lineNum">     738 </span><span class="lineCov">       4552 :         else if (isExtend)</span>
<span class="lineNum">     739 </span><span class="lineCov">       4284 :             pgBufferUsage.local_blks_written++;</span>
<span class="lineNum">     740 </span><span class="lineCov">        268 :         else if (mode == RBM_NORMAL || mode == RBM_NORMAL_NO_LOG ||</span>
<span class="lineNum">     741 </span>            :                  mode == RBM_ZERO_ON_ERROR)
<span class="lineNum">     742 </span><span class="lineCov">        268 :             pgBufferUsage.local_blks_read++;</span>
<span class="lineNum">     743 </span>            :     }
<span class="lineNum">     744 </span>            :     else
<span class="lineNum">     745 </span>            :     {
<span class="lineNum">     746 </span>            :         /*
<span class="lineNum">     747 </span>            :          * lookup the buffer.  IO_IN_PROGRESS is set if the requested block is
<span class="lineNum">     748 </span>            :          * not currently in memory.
<span class="lineNum">     749 </span>            :          */
<span class="lineNum">     750 </span><span class="lineCov">   10060424 :         bufHdr = BufferAlloc(smgr, relpersistence, forkNum, blockNum,</span>
<span class="lineNum">     751 </span>            :                              strategy, &amp;found);
<span class="lineNum">     752 </span><span class="lineCov">   10060424 :         if (found)</span>
<span class="lineNum">     753 </span><span class="lineCov">   10010740 :             pgBufferUsage.shared_blks_hit++;</span>
<span class="lineNum">     754 </span><span class="lineCov">      49684 :         else if (isExtend)</span>
<span class="lineNum">     755 </span><span class="lineCov">      36554 :             pgBufferUsage.shared_blks_written++;</span>
<span class="lineNum">     756 </span><span class="lineCov">      13130 :         else if (mode == RBM_NORMAL || mode == RBM_NORMAL_NO_LOG ||</span>
<span class="lineNum">     757 </span>            :                  mode == RBM_ZERO_ON_ERROR)
<span class="lineNum">     758 </span><span class="lineCov">      12694 :             pgBufferUsage.shared_blks_read++;</span>
<span class="lineNum">     759 </span>            :     }
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            :     /* At this point we do NOT hold any locks. */
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span>            :     /* if it was already in the buffer pool, we're done */
<span class="lineNum">     764 </span><span class="lineCov">   10140910 :     if (found)</span>
<span class="lineNum">     765 </span>            :     {
<span class="lineNum">     766 </span><span class="lineCov">   10086674 :         if (!isExtend)</span>
<span class="lineNum">     767 </span>            :         {
<span class="lineNum">     768 </span>            :             /* Just need to update stats before we exit */
<span class="lineNum">     769 </span><span class="lineCov">   10086674 :             *hit = true;</span>
<span class="lineNum">     770 </span><span class="lineCov">   10086674 :             VacuumPageHit++;</span>
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span><span class="lineCov">   10086674 :             if (VacuumCostActive)</span>
<span class="lineNum">     773 </span><span class="lineCov">      41354 :                 VacuumCostBalance += VacuumCostPageHit;</span>
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            :             TRACE_POSTGRESQL_BUFFER_READ_DONE(forkNum, blockNum,
<span class="lineNum">     776 </span>            :                                               smgr-&gt;smgr_rnode.node.spcNode,
<span class="lineNum">     777 </span>            :                                               smgr-&gt;smgr_rnode.node.dbNode,
<span class="lineNum">     778 </span>            :                                               smgr-&gt;smgr_rnode.node.relNode,
<span class="lineNum">     779 </span>            :                                               smgr-&gt;smgr_rnode.backend,
<span class="lineNum">     780 </span>            :                                               isExtend,
<span class="lineNum">     781 </span>            :                                               found);
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            :             /*
<span class="lineNum">     784 </span>            :              * In RBM_ZERO_AND_LOCK mode the caller expects the page to be
<span class="lineNum">     785 </span>            :              * locked on return.
<span class="lineNum">     786 </span>            :              */
<span class="lineNum">     787 </span><span class="lineCov">   10086674 :             if (!isLocalBuf)</span>
<span class="lineNum">     788 </span>            :             {
<span class="lineNum">     789 </span><span class="lineCov">   10010740 :                 if (mode == RBM_ZERO_AND_LOCK)</span>
<span class="lineNum">     790 </span><span class="lineCov">         22 :                     LWLockAcquire(BufferDescriptorGetContentLock(bufHdr),</span>
<span class="lineNum">     791 </span>            :                                   LW_EXCLUSIVE);
<span class="lineNum">     792 </span><span class="lineCov">   10010718 :                 else if (mode == RBM_ZERO_AND_CLEANUP_LOCK)</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :                     LockBufferForCleanup(BufferDescriptorGetBuffer(bufHdr));</span>
<span class="lineNum">     794 </span>            :             }
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span><span class="lineCov">   10086674 :             return BufferDescriptorGetBuffer(bufHdr);</span>
<span class="lineNum">     797 </span>            :         }
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            :         /*
<span class="lineNum">     800 </span>            :          * We get here only in the corner case where we are trying to extend
<span class="lineNum">     801 </span>            :          * the relation but we found a pre-existing buffer marked BM_VALID.
<span class="lineNum">     802 </span>            :          * This can happen because mdread doesn't complain about reads beyond
<span class="lineNum">     803 </span>            :          * EOF (when zero_damaged_pages is ON) and so a previous attempt to
<span class="lineNum">     804 </span>            :          * read a block beyond EOF could have left a &quot;valid&quot; zero-filled
<span class="lineNum">     805 </span>            :          * buffer.  Unfortunately, we have also seen this case occurring
<span class="lineNum">     806 </span>            :          * because of buggy Linux kernels that sometimes return an
<span class="lineNum">     807 </span>            :          * lseek(SEEK_END) result that doesn't account for a recent write. In
<span class="lineNum">     808 </span>            :          * that situation, the pre-existing buffer would contain valid data
<span class="lineNum">     809 </span>            :          * that we don't want to overwrite.  Since the legitimate case should
<span class="lineNum">     810 </span>            :          * always have left a zero-filled buffer, complain if not PageIsNew.
<span class="lineNum">     811 </span>            :          */
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :         bufBlock = isLocalBuf ? LocalBufHdrGetBlock(bufHdr) : BufHdrGetBlock(bufHdr);</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         if (!PageIsNew((Page) bufBlock))</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">     815 </span>            :                     (errmsg(&quot;unexpected data beyond EOF in block %u of relation %s&quot;,
<span class="lineNum">     816 </span>            :                             blockNum, relpath(smgr-&gt;smgr_rnode, forkNum)),
<span class="lineNum">     817 </span>            :                      errhint(&quot;This has been seen to occur with buggy kernels; consider updating your system.&quot;)));
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            :         /*
<span class="lineNum">     820 </span>            :          * We *must* do smgrextend before succeeding, else the page will not
<span class="lineNum">     821 </span>            :          * be reserved by the kernel, and the next P_NEW call will decide to
<span class="lineNum">     822 </span>            :          * return the same page.  Clear the BM_VALID bit, do the StartBufferIO
<span class="lineNum">     823 </span>            :          * call that BufferAlloc didn't, and proceed.
<span class="lineNum">     824 </span>            :          */
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :         if (isLocalBuf)</span>
<span class="lineNum">     826 </span>            :         {
<span class="lineNum">     827 </span>            :             /* Only need to adjust flags */
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :             uint32      buf_state = pg_atomic_read_u32(&amp;bufHdr-&gt;state);</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :             Assert(buf_state &amp; BM_VALID);</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :             buf_state &amp;= ~BM_VALID;</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :             pg_atomic_unlocked_write_u32(&amp;bufHdr-&gt;state, buf_state);</span>
<span class="lineNum">     833 </span>            :         }
<span class="lineNum">     834 </span>            :         else
<span class="lineNum">     835 </span>            :         {
<span class="lineNum">     836 </span>            :             /*
<span class="lineNum">     837 </span>            :              * Loop to handle the very small possibility that someone re-sets
<span class="lineNum">     838 </span>            :              * BM_VALID between our clearing it and StartBufferIO inspecting
<span class="lineNum">     839 </span>            :              * it.
<span class="lineNum">     840 </span>            :              */
<span class="lineNum">     841 </span>            :             do
<span class="lineNum">     842 </span>            :             {
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :                 uint32      buf_state = LockBufHdr(bufHdr);</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :                 Assert(buf_state &amp; BM_VALID);</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :                 buf_state &amp;= ~BM_VALID;</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :                 UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :             } while (!StartBufferIO(bufHdr, true));</span>
<span class="lineNum">     849 </span>            :         }
<span class="lineNum">     850 </span>            :     }
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span>            :     /*
<span class="lineNum">     853 </span>            :      * if we have gotten to this point, we have allocated a buffer for the
<span class="lineNum">     854 </span>            :      * page but its contents are not yet valid.  IO_IN_PROGRESS is set for it,
<span class="lineNum">     855 </span>            :      * if it's a shared buffer.
<span class="lineNum">     856 </span>            :      *
<span class="lineNum">     857 </span>            :      * Note: if smgrextend fails, we will end up with a buffer that is
<span class="lineNum">     858 </span>            :      * allocated but not marked BM_VALID.  P_NEW will still select the same
<span class="lineNum">     859 </span>            :      * block number (because the relation didn't get any longer on disk) and
<span class="lineNum">     860 </span>            :      * so future attempts to extend the relation will find the same buffer (if
<span class="lineNum">     861 </span>            :      * it's not been recycled) but come right back here to try smgrextend
<span class="lineNum">     862 </span>            :      * again.
<span class="lineNum">     863 </span>            :      */
<span class="lineNum">     864 </span><span class="lineCov">      54236 :     Assert(!(pg_atomic_read_u32(&amp;bufHdr-&gt;state) &amp; BM_VALID));    /* spinlock not needed */</span>
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span><span class="lineCov">      54236 :     bufBlock = isLocalBuf ? LocalBufHdrGetBlock(bufHdr) : BufHdrGetBlock(bufHdr);</span>
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span><span class="lineCov">      54236 :     if (isExtend)</span>
<span class="lineNum">     869 </span>            :     {
<span class="lineNum">     870 </span>            :         /* new buffers are zero-filled */
<span class="lineNum">     871 </span><span class="lineCov">      40838 :         MemSet((char *) bufBlock, 0, BLCKSZ);</span>
<span class="lineNum">     872 </span>            :         /* don't set checksum for all-zero page */
<span class="lineNum">     873 </span><span class="lineCov">      40838 :         smgrextend(smgr, forkNum, blockNum, (char *) bufBlock, false);</span>
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span>            :         /*
<span class="lineNum">     876 </span>            :          * NB: we're *not* doing a ScheduleBufferTagForWriteback here;
<span class="lineNum">     877 </span>            :          * although we're essentially performing a write. At least on linux
<span class="lineNum">     878 </span>            :          * doing so defeats the 'delayed allocation' mechanism, leading to
<span class="lineNum">     879 </span>            :          * increased file fragmentation.
<span class="lineNum">     880 </span>            :          */
<span class="lineNum">     881 </span>            :     }
<span class="lineNum">     882 </span>            :     else
<span class="lineNum">     883 </span>            :     {
<span class="lineNum">     884 </span>            :         /*
<span class="lineNum">     885 </span>            :          * Read in the page, unless the caller intends to overwrite it and
<span class="lineNum">     886 </span>            :          * just wants us to allocate a buffer.
<span class="lineNum">     887 </span>            :          */
<span class="lineNum">     888 </span><span class="lineCov">      13398 :         if (mode == RBM_ZERO_AND_LOCK || mode == RBM_ZERO_AND_CLEANUP_LOCK)</span>
<span class="lineNum">     889 </span><span class="lineCov">        436 :             MemSet((char *) bufBlock, 0, BLCKSZ);</span>
<span class="lineNum">     890 </span>            :         else
<span class="lineNum">     891 </span>            :         {
<span class="lineNum">     892 </span>            :             instr_time  io_start,
<span class="lineNum">     893 </span>            :                         io_time;
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span><span class="lineCov">      12962 :             if (track_io_timing)</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :                 INSTR_TIME_SET_CURRENT(io_start);</span>
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span><span class="lineCov">      12962 :             smgrread(smgr, forkNum, blockNum, (char *) bufBlock);</span>
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span><span class="lineCov">      12962 :             if (track_io_timing)</span>
<span class="lineNum">     901 </span>            :             {
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :                 INSTR_TIME_SET_CURRENT(io_time);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :                 INSTR_TIME_SUBTRACT(io_time, io_start);</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :                 pgstat_count_buffer_read_time(INSTR_TIME_GET_MICROSEC(io_time));</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :                 INSTR_TIME_ADD(pgBufferUsage.blk_read_time, io_time);</span>
<span class="lineNum">     906 </span>            :             }
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            :             /* check for garbage data */
<span class="lineNum">     909 </span><span class="lineCov">      12962 :             if (!PageIsVerified((Page) bufBlock, blockNum))</span>
<span class="lineNum">     910 </span>            :             {
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :                 if (mode == RBM_ZERO_ON_ERROR || zero_damaged_pages)</span>
<span class="lineNum">     912 </span>            :                 {
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :                     ereport(WARNING,</span>
<span class="lineNum">     914 </span>            :                             (errcode(ERRCODE_DATA_CORRUPTED),
<span class="lineNum">     915 </span>            :                              errmsg(&quot;invalid page in block %u of relation %s; zeroing out page&quot;,
<span class="lineNum">     916 </span>            :                                     blockNum,
<span class="lineNum">     917 </span>            :                                     relpath(smgr-&gt;smgr_rnode, forkNum))));
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :                     MemSet((char *) bufBlock, 0, BLCKSZ);</span>
<span class="lineNum">     919 </span>            :                 }
<span class="lineNum">     920 </span>            :                 else
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :                     ereport(ERROR,</span>
<span class="lineNum">     922 </span>            :                             (errcode(ERRCODE_DATA_CORRUPTED),
<span class="lineNum">     923 </span>            :                              errmsg(&quot;invalid page in block %u of relation %s&quot;,
<span class="lineNum">     924 </span>            :                                     blockNum,
<span class="lineNum">     925 </span>            :                                     relpath(smgr-&gt;smgr_rnode, forkNum))));
<span class="lineNum">     926 </span>            :             }
<span class="lineNum">     927 </span>            :         }
<span class="lineNum">     928 </span>            :     }
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span>            :     /*
<span class="lineNum">     931 </span>            :      * In RBM_ZERO_AND_LOCK mode, grab the buffer content lock before marking
<span class="lineNum">     932 </span>            :      * the page as valid, to make sure that no other backend sees the zeroed
<span class="lineNum">     933 </span>            :      * page before the caller has had a chance to initialize it.
<span class="lineNum">     934 </span>            :      *
<span class="lineNum">     935 </span>            :      * Since no-one else can be looking at the page contents yet, there is no
<span class="lineNum">     936 </span>            :      * difference between an exclusive lock and a cleanup-strength lock. (Note
<span class="lineNum">     937 </span>            :      * that we cannot use LockBuffer() or LockBufferForCleanup() here, because
<span class="lineNum">     938 </span>            :      * they assert that the buffer is already valid.)
<span class="lineNum">     939 </span>            :      */
<span class="lineNum">     940 </span><span class="lineCov">      83108 :     if ((mode == RBM_ZERO_AND_LOCK || mode == RBM_ZERO_AND_CLEANUP_LOCK) &amp;&amp;</span>
<span class="lineNum">     941 </span><span class="lineCov">      28872 :         !isLocalBuf)</span>
<span class="lineNum">     942 </span>            :     {
<span class="lineNum">     943 </span><span class="lineCov">      24896 :         LWLockAcquire(BufferDescriptorGetContentLock(bufHdr), LW_EXCLUSIVE);</span>
<span class="lineNum">     944 </span>            :     }
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineCov">      54236 :     if (isLocalBuf)</span>
<span class="lineNum">     947 </span>            :     {
<span class="lineNum">     948 </span>            :         /* Only need to adjust flags */
<span class="lineNum">     949 </span><span class="lineCov">       4552 :         uint32      buf_state = pg_atomic_read_u32(&amp;bufHdr-&gt;state);</span>
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span><span class="lineCov">       4552 :         buf_state |= BM_VALID;</span>
<span class="lineNum">     952 </span><span class="lineCov">       4552 :         pg_atomic_unlocked_write_u32(&amp;bufHdr-&gt;state, buf_state);</span>
<span class="lineNum">     953 </span>            :     }
<span class="lineNum">     954 </span>            :     else
<span class="lineNum">     955 </span>            :     {
<span class="lineNum">     956 </span>            :         /* Set BM_VALID, terminate IO, and wake up any waiters */
<span class="lineNum">     957 </span><span class="lineCov">      49684 :         TerminateBufferIO(bufHdr, false, BM_VALID);</span>
<span class="lineNum">     958 </span>            :     }
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span><span class="lineCov">      54236 :     VacuumPageMiss++;</span>
<span class="lineNum">     961 </span><span class="lineCov">      54236 :     if (VacuumCostActive)</span>
<span class="lineNum">     962 </span><span class="lineCov">        152 :         VacuumCostBalance += VacuumCostPageMiss;</span>
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            :     TRACE_POSTGRESQL_BUFFER_READ_DONE(forkNum, blockNum,
<span class="lineNum">     965 </span>            :                                       smgr-&gt;smgr_rnode.node.spcNode,
<span class="lineNum">     966 </span>            :                                       smgr-&gt;smgr_rnode.node.dbNode,
<span class="lineNum">     967 </span>            :                                       smgr-&gt;smgr_rnode.node.relNode,
<span class="lineNum">     968 </span>            :                                       smgr-&gt;smgr_rnode.backend,
<span class="lineNum">     969 </span>            :                                       isExtend,
<span class="lineNum">     970 </span>            :                                       found);
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span><span class="lineCov">      54236 :     return BufferDescriptorGetBuffer(bufHdr);</span>
<span class="lineNum">     973 </span>            : }
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span>            : /*
<span class="lineNum">     976 </span>            :  * BufferAlloc -- subroutine for ReadBuffer.  Handles lookup of a shared
<span class="lineNum">     977 </span>            :  *      buffer.  If no buffer exists already, selects a replacement
<span class="lineNum">     978 </span>            :  *      victim and evicts the old page, but does NOT read in new page.
<span class="lineNum">     979 </span>            :  *
<span class="lineNum">     980 </span>            :  * &quot;strategy&quot; can be a buffer replacement strategy object, or NULL for
<span class="lineNum">     981 </span>            :  * the default strategy.  The selected buffer's usage_count is advanced when
<span class="lineNum">     982 </span>            :  * using the default strategy, but otherwise possibly not (see PinBuffer).
<span class="lineNum">     983 </span>            :  *
<span class="lineNum">     984 </span>            :  * The returned buffer is pinned and is already marked as holding the
<span class="lineNum">     985 </span>            :  * desired page.  If it already did have the desired page, *foundPtr is
<span class="lineNum">     986 </span>            :  * set true.  Otherwise, *foundPtr is set false and the buffer is marked
<span class="lineNum">     987 </span>            :  * as IO_IN_PROGRESS; ReadBuffer will now need to do I/O to fill it.
<span class="lineNum">     988 </span>            :  *
<span class="lineNum">     989 </span>            :  * *foundPtr is actually redundant with the buffer's BM_VALID flag, but
<span class="lineNum">     990 </span>            :  * we keep it for simplicity in ReadBuffer.
<span class="lineNum">     991 </span>            :  *
<span class="lineNum">     992 </span>            :  * No locks are held either at entry or exit.
<a name="993"><span class="lineNum">     993 </span>            :  */</a>
<span class="lineNum">     994 </span>            : static BufferDesc *
<span class="lineNum">     995 </span><span class="lineCov">   10060424 : BufferAlloc(SMgrRelation smgr, char relpersistence, ForkNumber forkNum,</span>
<span class="lineNum">     996 </span>            :             BlockNumber blockNum,
<span class="lineNum">     997 </span>            :             BufferAccessStrategy strategy,
<span class="lineNum">     998 </span>            :             bool *foundPtr)
<span class="lineNum">     999 </span>            : {
<span class="lineNum">    1000 </span>            :     BufferTag   newTag;         /* identity of requested block */
<span class="lineNum">    1001 </span>            :     uint32      newHash;        /* hash value for newTag */
<span class="lineNum">    1002 </span>            :     LWLock     *newPartitionLock;   /* buffer partition lock for it */
<span class="lineNum">    1003 </span>            :     BufferTag   oldTag;         /* previous identity of selected buffer */
<span class="lineNum">    1004 </span>            :     uint32      oldHash;        /* hash value for oldTag */
<span class="lineNum">    1005 </span>            :     LWLock     *oldPartitionLock;   /* buffer partition lock for it */
<span class="lineNum">    1006 </span>            :     uint32      oldFlags;
<span class="lineNum">    1007 </span>            :     int         buf_id;
<span class="lineNum">    1008 </span>            :     BufferDesc *buf;
<span class="lineNum">    1009 </span>            :     bool        valid;
<span class="lineNum">    1010 </span>            :     uint32      buf_state;
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span>            :     /* create a tag so we can lookup the buffer */
<span class="lineNum">    1013 </span><span class="lineCov">   10060424 :     INIT_BUFFERTAG(newTag, smgr-&gt;smgr_rnode.node, forkNum, blockNum);</span>
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            :     /* determine its hash code and partition lock ID */
<span class="lineNum">    1016 </span><span class="lineCov">   10060424 :     newHash = BufTableHashCode(&amp;newTag);</span>
<span class="lineNum">    1017 </span><span class="lineCov">   10060424 :     newPartitionLock = BufMappingPartitionLock(newHash);</span>
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            :     /* see if the block is in the buffer pool already */
<span class="lineNum">    1020 </span><span class="lineCov">   10060424 :     LWLockAcquire(newPartitionLock, LW_SHARED);</span>
<span class="lineNum">    1021 </span><span class="lineCov">   10060424 :     buf_id = BufTableLookup(&amp;newTag, newHash);</span>
<span class="lineNum">    1022 </span><span class="lineCov">   10060424 :     if (buf_id &gt;= 0)</span>
<span class="lineNum">    1023 </span>            :     {
<span class="lineNum">    1024 </span>            :         /*
<span class="lineNum">    1025 </span>            :          * Found it.  Now, pin the buffer so no one can steal it from the
<span class="lineNum">    1026 </span>            :          * buffer pool, and check to see if the correct data has been loaded
<span class="lineNum">    1027 </span>            :          * into the buffer.
<span class="lineNum">    1028 </span>            :          */
<span class="lineNum">    1029 </span><span class="lineCov">   10010740 :         buf = GetBufferDescriptor(buf_id);</span>
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span><span class="lineCov">   10010740 :         valid = PinBuffer(buf, strategy);</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            :         /* Can release the mapping lock as soon as we've pinned it */
<span class="lineNum">    1034 </span><span class="lineCov">   10010740 :         LWLockRelease(newPartitionLock);</span>
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span><span class="lineCov">   10010740 :         *foundPtr = true;</span>
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span><span class="lineCov">   10010740 :         if (!valid)</span>
<span class="lineNum">    1039 </span>            :         {
<span class="lineNum">    1040 </span>            :             /*
<span class="lineNum">    1041 </span>            :              * We can only get here if (a) someone else is still reading in
<span class="lineNum">    1042 </span>            :              * the page, or (b) a previous read attempt failed.  We have to
<span class="lineNum">    1043 </span>            :              * wait for any active read attempt to finish, and then set up our
<span class="lineNum">    1044 </span>            :              * own read attempt if the page is still not BM_VALID.
<span class="lineNum">    1045 </span>            :              * StartBufferIO does it all.
<span class="lineNum">    1046 </span>            :              */
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :             if (StartBufferIO(buf, true))</span>
<span class="lineNum">    1048 </span>            :             {
<span class="lineNum">    1049 </span>            :                 /*
<span class="lineNum">    1050 </span>            :                  * If we get here, previous attempts to read the buffer must
<span class="lineNum">    1051 </span>            :                  * have failed ... but we shall bravely try again.
<span class="lineNum">    1052 </span>            :                  */
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :                 *foundPtr = false;</span>
<span class="lineNum">    1054 </span>            :             }
<span class="lineNum">    1055 </span>            :         }
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span><span class="lineCov">   10010740 :         return buf;</span>
<span class="lineNum">    1058 </span>            :     }
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span>            :     /*
<span class="lineNum">    1061 </span>            :      * Didn't find it in the buffer pool.  We'll have to initialize a new
<span class="lineNum">    1062 </span>            :      * buffer.  Remember to unlock the mapping lock while doing the work.
<span class="lineNum">    1063 </span>            :      */
<span class="lineNum">    1064 </span><span class="lineCov">      49684 :     LWLockRelease(newPartitionLock);</span>
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span>            :     /* Loop here in case we have to try another victim buffer */
<span class="lineNum">    1067 </span>            :     for (;;)
<span class="lineNum">    1068 </span>            :     {
<span class="lineNum">    1069 </span>            :         /*
<span class="lineNum">    1070 </span>            :          * Ensure, while the spinlock's not yet held, that there's a free
<span class="lineNum">    1071 </span>            :          * refcount entry.
<span class="lineNum">    1072 </span>            :          */
<span class="lineNum">    1073 </span><span class="lineCov">      49684 :         ReservePrivateRefCountEntry();</span>
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            :         /*
<span class="lineNum">    1076 </span>            :          * Select a victim buffer.  The buffer is returned with its header
<span class="lineNum">    1077 </span>            :          * spinlock still held!
<span class="lineNum">    1078 </span>            :          */
<span class="lineNum">    1079 </span><span class="lineCov">      49684 :         buf = StrategyGetBuffer(strategy, &amp;buf_state);</span>
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span><span class="lineCov">      49684 :         Assert(BUF_STATE_GET_REFCOUNT(buf_state) == 0);</span>
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span>            :         /* Must copy buffer flags while we still hold the spinlock */
<span class="lineNum">    1084 </span><span class="lineCov">      49684 :         oldFlags = buf_state &amp; BUF_FLAG_MASK;</span>
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span>            :         /* Pin the buffer and then release the buffer spinlock */
<span class="lineNum">    1087 </span><span class="lineCov">      49684 :         PinBuffer_Locked(buf);</span>
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span>            :         /*
<span class="lineNum">    1090 </span>            :          * If the buffer was dirty, try to write it out.  There is a race
<span class="lineNum">    1091 </span>            :          * condition here, in that someone might dirty it after we released it
<span class="lineNum">    1092 </span>            :          * above, or even while we are writing it out (since our share-lock
<span class="lineNum">    1093 </span>            :          * won't prevent hint-bit updates).  We will recheck the dirty bit
<span class="lineNum">    1094 </span>            :          * after re-locking the buffer header.
<span class="lineNum">    1095 </span>            :          */
<span class="lineNum">    1096 </span><span class="lineCov">      49684 :         if (oldFlags &amp; BM_DIRTY)</span>
<span class="lineNum">    1097 </span>            :         {
<span class="lineNum">    1098 </span>            :             /*
<span class="lineNum">    1099 </span>            :              * We need a share-lock on the buffer contents to write it out
<span class="lineNum">    1100 </span>            :              * (else we might write invalid data, eg because someone else is
<span class="lineNum">    1101 </span>            :              * compacting the page contents while we write).  We must use a
<span class="lineNum">    1102 </span>            :              * conditional lock acquisition here to avoid deadlock.  Even
<span class="lineNum">    1103 </span>            :              * though the buffer was not pinned (and therefore surely not
<span class="lineNum">    1104 </span>            :              * locked) when StrategyGetBuffer returned it, someone else could
<span class="lineNum">    1105 </span>            :              * have pinned and exclusive-locked it by the time we get here. If
<span class="lineNum">    1106 </span>            :              * we try to get the lock unconditionally, we'd block waiting for
<span class="lineNum">    1107 </span>            :              * them; if they later block waiting for us, deadlock ensues.
<span class="lineNum">    1108 </span>            :              * (This has been observed to happen when two backends are both
<span class="lineNum">    1109 </span>            :              * trying to split btree index pages, and the second one just
<span class="lineNum">    1110 </span>            :              * happens to be trying to split the page the first one got from
<span class="lineNum">    1111 </span>            :              * StrategyGetBuffer.)
<span class="lineNum">    1112 </span>            :              */
<span class="lineNum">    1113 </span><span class="lineCov">         48 :             if (LWLockConditionalAcquire(BufferDescriptorGetContentLock(buf),</span>
<span class="lineNum">    1114 </span>            :                                          LW_SHARED))
<span class="lineNum">    1115 </span>            :             {
<span class="lineNum">    1116 </span>            :                 /*
<span class="lineNum">    1117 </span>            :                  * If using a nondefault strategy, and writing the buffer
<span class="lineNum">    1118 </span>            :                  * would require a WAL flush, let the strategy decide whether
<span class="lineNum">    1119 </span>            :                  * to go ahead and write/reuse the buffer or to choose another
<span class="lineNum">    1120 </span>            :                  * victim.  We need lock to inspect the page LSN, so this
<span class="lineNum">    1121 </span>            :                  * can't be done inside StrategyGetBuffer.
<span class="lineNum">    1122 </span>            :                  */
<span class="lineNum">    1123 </span><span class="lineCov">         48 :                 if (strategy != NULL)</span>
<span class="lineNum">    1124 </span>            :                 {
<span class="lineNum">    1125 </span>            :                     XLogRecPtr  lsn;
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span>            :                     /* Read the LSN while holding buffer header lock */
<span class="lineNum">    1128 </span><span class="lineCov">         48 :                     buf_state = LockBufHdr(buf);</span>
<span class="lineNum">    1129 </span><span class="lineCov">         48 :                     lsn = BufferGetLSN(buf);</span>
<span class="lineNum">    1130 </span><span class="lineCov">         48 :                     UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span><span class="lineCov">         64 :                     if (XLogNeedsFlush(lsn) &amp;&amp;</span>
<span class="lineNum">    1133 </span><span class="lineCov">         16 :                         StrategyRejectBuffer(strategy, buf))</span>
<span class="lineNum">    1134 </span>            :                     {
<span class="lineNum">    1135 </span>            :                         /* Drop lock/pin and loop around for another buffer */
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :                         LWLockRelease(BufferDescriptorGetContentLock(buf));</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :                         UnpinBuffer(buf, true);</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1139 </span>            :                     }
<span class="lineNum">    1140 </span>            :                 }
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            :                 /* OK, do the I/O */
<span class="lineNum">    1143 </span>            :                 TRACE_POSTGRESQL_BUFFER_WRITE_DIRTY_START(forkNum, blockNum,
<span class="lineNum">    1144 </span>            :                                                           smgr-&gt;smgr_rnode.node.spcNode,
<span class="lineNum">    1145 </span>            :                                                           smgr-&gt;smgr_rnode.node.dbNode,
<span class="lineNum">    1146 </span>            :                                                           smgr-&gt;smgr_rnode.node.relNode);
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span><span class="lineCov">         48 :                 FlushBuffer(buf, NULL);</span>
<span class="lineNum">    1149 </span><span class="lineCov">         48 :                 LWLockRelease(BufferDescriptorGetContentLock(buf));</span>
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span><span class="lineCov">         48 :                 ScheduleBufferTagForWriteback(&amp;BackendWritebackContext,</span>
<span class="lineNum">    1152 </span>            :                                               &amp;buf-&gt;tag);
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span>            :                 TRACE_POSTGRESQL_BUFFER_WRITE_DIRTY_DONE(forkNum, blockNum,
<span class="lineNum">    1155 </span>            :                                                          smgr-&gt;smgr_rnode.node.spcNode,
<span class="lineNum">    1156 </span>            :                                                          smgr-&gt;smgr_rnode.node.dbNode,
<span class="lineNum">    1157 </span>            :                                                          smgr-&gt;smgr_rnode.node.relNode);
<span class="lineNum">    1158 </span>            :             }
<span class="lineNum">    1159 </span>            :             else
<span class="lineNum">    1160 </span>            :             {
<span class="lineNum">    1161 </span>            :                 /*
<span class="lineNum">    1162 </span>            :                  * Someone else has locked the buffer, so give it up and loop
<span class="lineNum">    1163 </span>            :                  * back to get another one.
<span class="lineNum">    1164 </span>            :                  */
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :                 UnpinBuffer(buf, true);</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1167 </span>            :             }
<span class="lineNum">    1168 </span>            :         }
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span>            :         /*
<span class="lineNum">    1171 </span>            :          * To change the association of a valid buffer, we'll need to have
<span class="lineNum">    1172 </span>            :          * exclusive lock on both the old and new mapping partitions.
<span class="lineNum">    1173 </span>            :          */
<span class="lineNum">    1174 </span><span class="lineCov">      49684 :         if (oldFlags &amp; BM_TAG_VALID)</span>
<span class="lineNum">    1175 </span>            :         {
<span class="lineNum">    1176 </span>            :             /*
<span class="lineNum">    1177 </span>            :              * Need to compute the old tag's hashcode and partition lock ID.
<span class="lineNum">    1178 </span>            :              * XXX is it worth storing the hashcode in BufferDesc so we need
<span class="lineNum">    1179 </span>            :              * not recompute it here?  Probably not.
<span class="lineNum">    1180 </span>            :              */
<span class="lineNum">    1181 </span><span class="lineCov">       1084 :             oldTag = buf-&gt;tag;</span>
<span class="lineNum">    1182 </span><span class="lineCov">       1084 :             oldHash = BufTableHashCode(&amp;oldTag);</span>
<span class="lineNum">    1183 </span><span class="lineCov">       1084 :             oldPartitionLock = BufMappingPartitionLock(oldHash);</span>
<span class="lineNum">    1184 </span>            : 
<span class="lineNum">    1185 </span>            :             /*
<span class="lineNum">    1186 </span>            :              * Must lock the lower-numbered partition first to avoid
<span class="lineNum">    1187 </span>            :              * deadlocks.
<span class="lineNum">    1188 </span>            :              */
<span class="lineNum">    1189 </span><span class="lineCov">       1084 :             if (oldPartitionLock &lt; newPartitionLock)</span>
<span class="lineNum">    1190 </span>            :             {
<span class="lineNum">    1191 </span><span class="lineCov">        530 :                 LWLockAcquire(oldPartitionLock, LW_EXCLUSIVE);</span>
<span class="lineNum">    1192 </span><span class="lineCov">        530 :                 LWLockAcquire(newPartitionLock, LW_EXCLUSIVE);</span>
<span class="lineNum">    1193 </span>            :             }
<span class="lineNum">    1194 </span><span class="lineCov">        554 :             else if (oldPartitionLock &gt; newPartitionLock)</span>
<span class="lineNum">    1195 </span>            :             {
<span class="lineNum">    1196 </span><span class="lineCov">        548 :                 LWLockAcquire(newPartitionLock, LW_EXCLUSIVE);</span>
<span class="lineNum">    1197 </span><span class="lineCov">        548 :                 LWLockAcquire(oldPartitionLock, LW_EXCLUSIVE);</span>
<span class="lineNum">    1198 </span>            :             }
<span class="lineNum">    1199 </span>            :             else
<span class="lineNum">    1200 </span>            :             {
<span class="lineNum">    1201 </span>            :                 /* only one partition, only one lock */
<span class="lineNum">    1202 </span><span class="lineCov">          6 :                 LWLockAcquire(newPartitionLock, LW_EXCLUSIVE);</span>
<span class="lineNum">    1203 </span>            :             }
<span class="lineNum">    1204 </span>            :         }
<span class="lineNum">    1205 </span>            :         else
<span class="lineNum">    1206 </span>            :         {
<span class="lineNum">    1207 </span>            :             /* if it wasn't valid, we need only the new partition */
<span class="lineNum">    1208 </span><span class="lineCov">      48600 :             LWLockAcquire(newPartitionLock, LW_EXCLUSIVE);</span>
<span class="lineNum">    1209 </span>            :             /* remember we have no old-partition lock or tag */
<span class="lineNum">    1210 </span><span class="lineCov">      48600 :             oldPartitionLock = NULL;</span>
<span class="lineNum">    1211 </span>            :             /* keep the compiler quiet about uninitialized variables */
<span class="lineNum">    1212 </span><span class="lineCov">      48600 :             oldHash = 0;</span>
<span class="lineNum">    1213 </span>            :         }
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span>            :         /*
<span class="lineNum">    1216 </span>            :          * Try to make a hashtable entry for the buffer under its new tag.
<span class="lineNum">    1217 </span>            :          * This could fail because while we were writing someone else
<span class="lineNum">    1218 </span>            :          * allocated another buffer for the same block we want to read in.
<span class="lineNum">    1219 </span>            :          * Note that we have not yet removed the hashtable entry for the old
<span class="lineNum">    1220 </span>            :          * tag.
<span class="lineNum">    1221 </span>            :          */
<span class="lineNum">    1222 </span><span class="lineCov">      49684 :         buf_id = BufTableInsert(&amp;newTag, newHash, buf-&gt;buf_id);</span>
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span><span class="lineCov">      49684 :         if (buf_id &gt;= 0)</span>
<span class="lineNum">    1225 </span>            :         {
<span class="lineNum">    1226 </span>            :             /*
<span class="lineNum">    1227 </span>            :              * Got a collision. Someone has already done what we were about to
<span class="lineNum">    1228 </span>            :              * do. We'll just handle this as if it were found in the buffer
<span class="lineNum">    1229 </span>            :              * pool in the first place.  First, give up the buffer we were
<span class="lineNum">    1230 </span>            :              * planning to use.
<span class="lineNum">    1231 </span>            :              */
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :             UnpinBuffer(buf, true);</span>
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span>            :             /* Can give up that buffer's mapping partition lock now */
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :             if (oldPartitionLock != NULL &amp;&amp;</span>
<span class="lineNum">    1236 </span>            :                 oldPartitionLock != newPartitionLock)
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :                 LWLockRelease(oldPartitionLock);</span>
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span>            :             /* remaining code should match code at top of routine */
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :             buf = GetBufferDescriptor(buf_id);</span>
<span class="lineNum">    1242 </span>            : 
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :             valid = PinBuffer(buf, strategy);</span>
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            :             /* Can release the mapping lock as soon as we've pinned it */
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :             LWLockRelease(newPartitionLock);</span>
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :             *foundPtr = true;</span>
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :             if (!valid)</span>
<span class="lineNum">    1251 </span>            :             {
<span class="lineNum">    1252 </span>            :                 /*
<span class="lineNum">    1253 </span>            :                  * We can only get here if (a) someone else is still reading
<span class="lineNum">    1254 </span>            :                  * in the page, or (b) a previous read attempt failed.  We
<span class="lineNum">    1255 </span>            :                  * have to wait for any active read attempt to finish, and
<span class="lineNum">    1256 </span>            :                  * then set up our own read attempt if the page is still not
<span class="lineNum">    1257 </span>            :                  * BM_VALID.  StartBufferIO does it all.
<span class="lineNum">    1258 </span>            :                  */
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :                 if (StartBufferIO(buf, true))</span>
<span class="lineNum">    1260 </span>            :                 {
<span class="lineNum">    1261 </span>            :                     /*
<span class="lineNum">    1262 </span>            :                      * If we get here, previous attempts to read the buffer
<span class="lineNum">    1263 </span>            :                      * must have failed ... but we shall bravely try again.
<span class="lineNum">    1264 </span>            :                      */
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :                     *foundPtr = false;</span>
<span class="lineNum">    1266 </span>            :                 }
<span class="lineNum">    1267 </span>            :             }
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :             return buf;</span>
<span class="lineNum">    1270 </span>            :         }
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span>            :         /*
<span class="lineNum">    1273 </span>            :          * Need to lock the buffer header too in order to change its tag.
<span class="lineNum">    1274 </span>            :          */
<span class="lineNum">    1275 </span><span class="lineCov">      49684 :         buf_state = LockBufHdr(buf);</span>
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span>            :         /*
<span class="lineNum">    1278 </span>            :          * Somebody could have pinned or re-dirtied the buffer while we were
<span class="lineNum">    1279 </span>            :          * doing the I/O and making the new hashtable entry.  If so, we can't
<span class="lineNum">    1280 </span>            :          * recycle this buffer; we must undo everything we've done and start
<span class="lineNum">    1281 </span>            :          * over with a new victim buffer.
<span class="lineNum">    1282 </span>            :          */
<span class="lineNum">    1283 </span><span class="lineCov">      49684 :         oldFlags = buf_state &amp; BUF_FLAG_MASK;</span>
<span class="lineNum">    1284 </span><span class="lineCov">      49684 :         if (BUF_STATE_GET_REFCOUNT(buf_state) == 1 &amp;&amp; !(oldFlags &amp; BM_DIRTY))</span>
<span class="lineNum">    1285 </span><span class="lineCov">      49684 :             break;</span>
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :         UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :         BufTableDelete(&amp;newTag, newHash);</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :         if (oldPartitionLock != NULL &amp;&amp;</span>
<span class="lineNum">    1290 </span>            :             oldPartitionLock != newPartitionLock)
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :             LWLockRelease(oldPartitionLock);</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :         LWLockRelease(newPartitionLock);</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :         UnpinBuffer(buf, true);</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span>            :     /*
<span class="lineNum">    1297 </span>            :      * Okay, it's finally safe to rename the buffer.
<span class="lineNum">    1298 </span>            :      *
<span class="lineNum">    1299 </span>            :      * Clearing BM_VALID here is necessary, clearing the dirtybits is just
<span class="lineNum">    1300 </span>            :      * paranoia.  We also reset the usage_count since any recency of use of
<span class="lineNum">    1301 </span>            :      * the old content is no longer relevant.  (The usage_count starts out at
<span class="lineNum">    1302 </span>            :      * 1 so that the buffer can survive one clock-sweep pass.)
<span class="lineNum">    1303 </span>            :      *
<span class="lineNum">    1304 </span>            :      * Make sure BM_PERMANENT is set for buffers that must be written at every
<span class="lineNum">    1305 </span>            :      * checkpoint.  Unlogged buffers only need to be written at shutdown
<span class="lineNum">    1306 </span>            :      * checkpoints, except for their &quot;init&quot; forks, which need to be treated
<span class="lineNum">    1307 </span>            :      * just like permanent relations.
<span class="lineNum">    1308 </span>            :      */
<span class="lineNum">    1309 </span><span class="lineCov">      49684 :     buf-&gt;tag = newTag;</span>
<span class="lineNum">    1310 </span><span class="lineCov">      49684 :     buf_state &amp;= ~(BM_VALID | BM_DIRTY | BM_JUST_DIRTIED |</span>
<span class="lineNum">    1311 </span>            :                    BM_CHECKPOINT_NEEDED | BM_IO_ERROR | BM_PERMANENT |
<span class="lineNum">    1312 </span>            :                    BUF_USAGECOUNT_MASK);
<span class="lineNum">    1313 </span><span class="lineCov">      49684 :     if (relpersistence == RELPERSISTENCE_PERMANENT || forkNum == INIT_FORKNUM)</span>
<span class="lineNum">    1314 </span><span class="lineCov">      49658 :         buf_state |= BM_TAG_VALID | BM_PERMANENT | BUF_USAGECOUNT_ONE;</span>
<span class="lineNum">    1315 </span>            :     else
<span class="lineNum">    1316 </span><span class="lineCov">         26 :         buf_state |= BM_TAG_VALID | BUF_USAGECOUNT_ONE;</span>
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span><span class="lineCov">      49684 :     UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    1319 </span>            : 
<span class="lineNum">    1320 </span><span class="lineCov">      49684 :     if (oldPartitionLock != NULL)</span>
<span class="lineNum">    1321 </span>            :     {
<span class="lineNum">    1322 </span><span class="lineCov">       1084 :         BufTableDelete(&amp;oldTag, oldHash);</span>
<span class="lineNum">    1323 </span><span class="lineCov">       1084 :         if (oldPartitionLock != newPartitionLock)</span>
<span class="lineNum">    1324 </span><span class="lineCov">       1078 :             LWLockRelease(oldPartitionLock);</span>
<span class="lineNum">    1325 </span>            :     }
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span><span class="lineCov">      49684 :     LWLockRelease(newPartitionLock);</span>
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span>            :     /*
<span class="lineNum">    1330 </span>            :      * Buffer contents are currently invalid.  Try to get the io_in_progress
<span class="lineNum">    1331 </span>            :      * lock.  If StartBufferIO returns false, then someone else managed to
<span class="lineNum">    1332 </span>            :      * read it before we did, so there's nothing left for BufferAlloc() to do.
<span class="lineNum">    1333 </span>            :      */
<span class="lineNum">    1334 </span><span class="lineCov">      49684 :     if (StartBufferIO(buf, true))</span>
<span class="lineNum">    1335 </span><span class="lineCov">      49684 :         *foundPtr = false;</span>
<span class="lineNum">    1336 </span>            :     else
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :         *foundPtr = true;</span>
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span><span class="lineCov">      49684 :     return buf;</span>
<span class="lineNum">    1340 </span>            : }
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span>            : /*
<span class="lineNum">    1343 </span>            :  * InvalidateBuffer -- mark a shared buffer invalid and return it to the
<span class="lineNum">    1344 </span>            :  * freelist.
<span class="lineNum">    1345 </span>            :  *
<span class="lineNum">    1346 </span>            :  * The buffer header spinlock must be held at entry.  We drop it before
<span class="lineNum">    1347 </span>            :  * returning.  (This is sane because the caller must have locked the
<span class="lineNum">    1348 </span>            :  * buffer in order to be sure it should be dropped.)
<span class="lineNum">    1349 </span>            :  *
<span class="lineNum">    1350 </span>            :  * This is used only in contexts such as dropping a relation.  We assume
<span class="lineNum">    1351 </span>            :  * that no other backend could possibly be interested in using the page,
<span class="lineNum">    1352 </span>            :  * so the only reason the buffer might be pinned is if someone else is
<span class="lineNum">    1353 </span>            :  * trying to write it out.  We have to let them finish before we can
<span class="lineNum">    1354 </span>            :  * reclaim the buffer.
<span class="lineNum">    1355 </span>            :  *
<span class="lineNum">    1356 </span>            :  * The buffer could get reclaimed by someone else while we are waiting
<span class="lineNum">    1357 </span>            :  * to acquire the necessary locks; if so, don't mess it up.
<a name="1358"><span class="lineNum">    1358 </span>            :  */</a>
<span class="lineNum">    1359 </span>            : static void
<span class="lineNum">    1360 </span><span class="lineCov">      23398 : InvalidateBuffer(BufferDesc *buf)</span>
<span class="lineNum">    1361 </span>            : {
<span class="lineNum">    1362 </span>            :     BufferTag   oldTag;
<span class="lineNum">    1363 </span>            :     uint32      oldHash;        /* hash value for oldTag */
<span class="lineNum">    1364 </span>            :     LWLock     *oldPartitionLock;   /* buffer partition lock for it */
<span class="lineNum">    1365 </span>            :     uint32      oldFlags;
<span class="lineNum">    1366 </span>            :     uint32      buf_state;
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span>            :     /* Save the original buffer tag before dropping the spinlock */
<span class="lineNum">    1369 </span><span class="lineCov">      23398 :     oldTag = buf-&gt;tag;</span>
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span><span class="lineCov">      23398 :     buf_state = pg_atomic_read_u32(&amp;buf-&gt;state);</span>
<span class="lineNum">    1372 </span><span class="lineCov">      23398 :     Assert(buf_state &amp; BM_LOCKED);</span>
<span class="lineNum">    1373 </span><span class="lineCov">      23398 :     UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    1374 </span>            : 
<span class="lineNum">    1375 </span>            :     /*
<span class="lineNum">    1376 </span>            :      * Need to compute the old tag's hashcode and partition lock ID. XXX is it
<span class="lineNum">    1377 </span>            :      * worth storing the hashcode in BufferDesc so we need not recompute it
<span class="lineNum">    1378 </span>            :      * here?  Probably not.
<span class="lineNum">    1379 </span>            :      */
<span class="lineNum">    1380 </span><span class="lineCov">      23398 :     oldHash = BufTableHashCode(&amp;oldTag);</span>
<span class="lineNum">    1381 </span><span class="lineCov">      23398 :     oldPartitionLock = BufMappingPartitionLock(oldHash);</span>
<span class="lineNum">    1382 </span>            : 
<span class="lineNum">    1383 </span>            : retry:
<span class="lineNum">    1384 </span>            : 
<span class="lineNum">    1385 </span>            :     /*
<span class="lineNum">    1386 </span>            :      * Acquire exclusive mapping lock in preparation for changing the buffer's
<span class="lineNum">    1387 </span>            :      * association.
<span class="lineNum">    1388 </span>            :      */
<span class="lineNum">    1389 </span><span class="lineCov">      23398 :     LWLockAcquire(oldPartitionLock, LW_EXCLUSIVE);</span>
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span>            :     /* Re-lock the buffer header */
<span class="lineNum">    1392 </span><span class="lineCov">      23398 :     buf_state = LockBufHdr(buf);</span>
<span class="lineNum">    1393 </span>            : 
<span class="lineNum">    1394 </span>            :     /* If it's changed while we were waiting for lock, do nothing */
<span class="lineNum">    1395 </span><span class="lineCov">      23398 :     if (!BUFFERTAGS_EQUAL(buf-&gt;tag, oldTag))</span>
<span class="lineNum">    1396 </span>            :     {
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :         UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :         LWLockRelease(oldPartitionLock);</span>
<span class="lineNum">    1399 </span><span class="lineCov">      23398 :         return;</span>
<span class="lineNum">    1400 </span>            :     }
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span>            :     /*
<span class="lineNum">    1403 </span>            :      * We assume the only reason for it to be pinned is that someone else is
<span class="lineNum">    1404 </span>            :      * flushing the page out.  Wait for them to finish.  (This could be an
<span class="lineNum">    1405 </span>            :      * infinite loop if the refcount is messed up... it would be nice to time
<span class="lineNum">    1406 </span>            :      * out after awhile, but there seems no way to be sure how many loops may
<span class="lineNum">    1407 </span>            :      * be needed.  Note that if the other guy has pinned the buffer but not
<span class="lineNum">    1408 </span>            :      * yet done StartBufferIO, WaitIO will fall through and we'll effectively
<span class="lineNum">    1409 </span>            :      * be busy-looping here.)
<span class="lineNum">    1410 </span>            :      */
<span class="lineNum">    1411 </span><span class="lineCov">      23398 :     if (BUF_STATE_GET_REFCOUNT(buf_state) != 0)</span>
<span class="lineNum">    1412 </span>            :     {
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :         UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :         LWLockRelease(oldPartitionLock);</span>
<span class="lineNum">    1415 </span>            :         /* safety check: should definitely not be our *own* pin */
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :         if (GetPrivateRefCount(BufferDescriptorGetBuffer(buf)) &gt; 0)</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;buffer is pinned in InvalidateBuffer&quot;);</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :         WaitIO(buf);</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :         goto retry;</span>
<span class="lineNum">    1420 </span>            :     }
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span>            :     /*
<span class="lineNum">    1423 </span>            :      * Clear out the buffer's tag and flags.  We must do this to ensure that
<span class="lineNum">    1424 </span>            :      * linear scans of the buffer array don't think the buffer is valid.
<span class="lineNum">    1425 </span>            :      */
<span class="lineNum">    1426 </span><span class="lineCov">      23398 :     oldFlags = buf_state &amp; BUF_FLAG_MASK;</span>
<span class="lineNum">    1427 </span><span class="lineCov">      23398 :     CLEAR_BUFFERTAG(buf-&gt;tag);</span>
<span class="lineNum">    1428 </span><span class="lineCov">      23398 :     buf_state &amp;= ~(BUF_FLAG_MASK | BUF_USAGECOUNT_MASK);</span>
<span class="lineNum">    1429 </span><span class="lineCov">      23398 :     UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    1430 </span>            : 
<span class="lineNum">    1431 </span>            :     /*
<span class="lineNum">    1432 </span>            :      * Remove the buffer from the lookup hashtable, if it was in there.
<span class="lineNum">    1433 </span>            :      */
<span class="lineNum">    1434 </span><span class="lineCov">      23398 :     if (oldFlags &amp; BM_TAG_VALID)</span>
<span class="lineNum">    1435 </span><span class="lineCov">      23398 :         BufTableDelete(&amp;oldTag, oldHash);</span>
<span class="lineNum">    1436 </span>            : 
<span class="lineNum">    1437 </span>            :     /*
<span class="lineNum">    1438 </span>            :      * Done with mapping lock.
<span class="lineNum">    1439 </span>            :      */
<span class="lineNum">    1440 </span><span class="lineCov">      23398 :     LWLockRelease(oldPartitionLock);</span>
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span>            :     /*
<span class="lineNum">    1443 </span>            :      * Insert the buffer at the head of the list of free buffers.
<span class="lineNum">    1444 </span>            :      */
<span class="lineNum">    1445 </span><span class="lineCov">      23398 :     StrategyFreeBuffer(buf);</span>
<span class="lineNum">    1446 </span>            : }
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span>            : /*
<span class="lineNum">    1449 </span>            :  * MarkBufferDirty
<span class="lineNum">    1450 </span>            :  *
<span class="lineNum">    1451 </span>            :  *      Marks buffer contents as dirty (actual write happens later).
<span class="lineNum">    1452 </span>            :  *
<span class="lineNum">    1453 </span>            :  * Buffer must be pinned and exclusive-locked.  (If caller does not hold
<span class="lineNum">    1454 </span>            :  * exclusive lock, then somebody could be in process of writing the buffer,
<span class="lineNum">    1455 </span>            :  * leading to risk of bad data written to disk.)
<a name="1456"><span class="lineNum">    1456 </span>            :  */</a>
<span class="lineNum">    1457 </span>            : void
<span class="lineNum">    1458 </span><span class="lineCov">    4735976 : MarkBufferDirty(Buffer buffer)</span>
<span class="lineNum">    1459 </span>            : {
<span class="lineNum">    1460 </span>            :     BufferDesc *bufHdr;
<span class="lineNum">    1461 </span>            :     uint32      buf_state;
<span class="lineNum">    1462 </span>            :     uint32      old_buf_state;
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span><span class="lineCov">    4735976 :     if (!BufferIsValid(buffer))</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;bad buffer ID: %d&quot;, buffer);</span>
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span><span class="lineCov">    4735976 :     if (BufferIsLocal(buffer))</span>
<span class="lineNum">    1468 </span>            :     {
<span class="lineNum">    1469 </span><span class="lineCov">     241326 :         MarkLocalBufferDirty(buffer);</span>
<span class="lineNum">    1470 </span><span class="lineCov">    4977302 :         return;</span>
<span class="lineNum">    1471 </span>            :     }
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span><span class="lineCov">    4494650 :     bufHdr = GetBufferDescriptor(buffer - 1);</span>
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span><span class="lineCov">    4494650 :     Assert(BufferIsPinned(buffer));</span>
<span class="lineNum">    1476 </span><span class="lineCov">    4494650 :     Assert(LWLockHeldByMeInMode(BufferDescriptorGetContentLock(bufHdr),</span>
<span class="lineNum">    1477 </span>            :                                 LW_EXCLUSIVE));
<span class="lineNum">    1478 </span>            : 
<span class="lineNum">    1479 </span><span class="lineCov">    4494650 :     old_buf_state = pg_atomic_read_u32(&amp;bufHdr-&gt;state);</span>
<span class="lineNum">    1480 </span>            :     for (;;)
<span class="lineNum">    1481 </span>            :     {
<span class="lineNum">    1482 </span><span class="lineCov">    4494654 :         if (old_buf_state &amp; BM_LOCKED)</span>
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :             old_buf_state = WaitBufHdrUnlocked(bufHdr);</span>
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span><span class="lineCov">    4494654 :         buf_state = old_buf_state;</span>
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span><span class="lineCov">    4494654 :         Assert(BUF_STATE_GET_REFCOUNT(buf_state) &gt; 0);</span>
<span class="lineNum">    1488 </span><span class="lineCov">    4494654 :         buf_state |= BM_DIRTY | BM_JUST_DIRTIED;</span>
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span><span class="lineCov">    4494654 :         if (pg_atomic_compare_exchange_u32(&amp;bufHdr-&gt;state, &amp;old_buf_state,</span>
<span class="lineNum">    1491 </span>            :                                            buf_state))
<span class="lineNum">    1492 </span><span class="lineCov">    4494650 :             break;</span>
<span class="lineNum">    1493 </span><span class="lineCov">          4 :     }</span>
<span class="lineNum">    1494 </span>            : 
<span class="lineNum">    1495 </span>            :     /*
<span class="lineNum">    1496 </span>            :      * If the buffer was not dirty already, do vacuum accounting.
<span class="lineNum">    1497 </span>            :      */
<span class="lineNum">    1498 </span><span class="lineCov">    4494650 :     if (!(old_buf_state &amp; BM_DIRTY))</span>
<span class="lineNum">    1499 </span>            :     {
<span class="lineNum">    1500 </span><span class="lineCov">      41256 :         VacuumPageDirty++;</span>
<span class="lineNum">    1501 </span><span class="lineCov">      41256 :         pgBufferUsage.shared_blks_dirtied++;</span>
<span class="lineNum">    1502 </span><span class="lineCov">      41256 :         if (VacuumCostActive)</span>
<span class="lineNum">    1503 </span><span class="lineCov">         56 :             VacuumCostBalance += VacuumCostPageDirty;</span>
<span class="lineNum">    1504 </span>            :     }
<span class="lineNum">    1505 </span>            : }
<span class="lineNum">    1506 </span>            : 
<span class="lineNum">    1507 </span>            : /*
<span class="lineNum">    1508 </span>            :  * ReleaseAndReadBuffer -- combine ReleaseBuffer() and ReadBuffer()
<span class="lineNum">    1509 </span>            :  *
<span class="lineNum">    1510 </span>            :  * Formerly, this saved one cycle of acquiring/releasing the BufMgrLock
<span class="lineNum">    1511 </span>            :  * compared to calling the two routines separately.  Now it's mainly just
<span class="lineNum">    1512 </span>            :  * a convenience function.  However, if the passed buffer is valid and
<span class="lineNum">    1513 </span>            :  * already contains the desired block, we just return it as-is; and that
<span class="lineNum">    1514 </span>            :  * does save considerable work compared to a full release and reacquire.
<span class="lineNum">    1515 </span>            :  *
<span class="lineNum">    1516 </span>            :  * Note: it is OK to pass buffer == InvalidBuffer, indicating that no old
<span class="lineNum">    1517 </span>            :  * buffer actually needs to be released.  This case is the same as ReadBuffer,
<span class="lineNum">    1518 </span>            :  * but can save some tests in the caller.
<a name="1519"><span class="lineNum">    1519 </span>            :  */</a>
<span class="lineNum">    1520 </span>            : Buffer
<span class="lineNum">    1521 </span><span class="lineCov">    4191078 : ReleaseAndReadBuffer(Buffer buffer,</span>
<span class="lineNum">    1522 </span>            :                      Relation relation,
<span class="lineNum">    1523 </span>            :                      BlockNumber blockNum)
<span class="lineNum">    1524 </span>            : {
<span class="lineNum">    1525 </span><span class="lineCov">    4191078 :     ForkNumber  forkNum = MAIN_FORKNUM;</span>
<span class="lineNum">    1526 </span>            :     BufferDesc *bufHdr;
<span class="lineNum">    1527 </span>            : 
<span class="lineNum">    1528 </span><span class="lineCov">    4191078 :     if (BufferIsValid(buffer))</span>
<span class="lineNum">    1529 </span>            :     {
<span class="lineNum">    1530 </span><span class="lineCov">    3208536 :         Assert(BufferIsPinned(buffer));</span>
<span class="lineNum">    1531 </span><span class="lineCov">    3208536 :         if (BufferIsLocal(buffer))</span>
<span class="lineNum">    1532 </span>            :         {
<span class="lineNum">    1533 </span><span class="lineCov">       1584 :             bufHdr = GetLocalBufferDescriptor(-buffer - 1);</span>
<span class="lineNum">    1534 </span><span class="lineCov">       2764 :             if (bufHdr-&gt;tag.blockNum == blockNum &amp;&amp;</span>
<span class="lineNum">    1535 </span><span class="lineCov">       3540 :                 RelFileNodeEquals(bufHdr-&gt;tag.rnode, relation-&gt;rd_node) &amp;&amp;</span>
<span class="lineNum">    1536 </span><span class="lineCov">       1180 :                 bufHdr-&gt;tag.forkNum == forkNum)</span>
<span class="lineNum">    1537 </span><span class="lineCov">       1180 :                 return buffer;</span>
<span class="lineNum">    1538 </span><span class="lineCov">        404 :             ResourceOwnerForgetBuffer(CurrentResourceOwner, buffer);</span>
<span class="lineNum">    1539 </span><span class="lineCov">        404 :             LocalRefCount[-buffer - 1]--;</span>
<span class="lineNum">    1540 </span>            :         }
<span class="lineNum">    1541 </span>            :         else
<span class="lineNum">    1542 </span>            :         {
<span class="lineNum">    1543 </span><span class="lineCov">    3206952 :             bufHdr = GetBufferDescriptor(buffer - 1);</span>
<span class="lineNum">    1544 </span>            :             /* we have pin, so it's ok to examine tag without spinlock */
<span class="lineNum">    1545 </span><span class="lineCov">    4282532 :             if (bufHdr-&gt;tag.blockNum == blockNum &amp;&amp;</span>
<span class="lineNum">    1546 </span><span class="lineCov">    3226740 :                 RelFileNodeEquals(bufHdr-&gt;tag.rnode, relation-&gt;rd_node) &amp;&amp;</span>
<span class="lineNum">    1547 </span><span class="lineCov">    1075580 :                 bufHdr-&gt;tag.forkNum == forkNum)</span>
<span class="lineNum">    1548 </span><span class="lineCov">    1075580 :                 return buffer;</span>
<span class="lineNum">    1549 </span><span class="lineCov">    2131372 :             UnpinBuffer(bufHdr, true);</span>
<span class="lineNum">    1550 </span>            :         }
<span class="lineNum">    1551 </span>            :     }
<span class="lineNum">    1552 </span>            : 
<span class="lineNum">    1553 </span><span class="lineCov">    3114318 :     return ReadBuffer(relation, blockNum);</span>
<span class="lineNum">    1554 </span>            : }
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span>            : /*
<span class="lineNum">    1557 </span>            :  * PinBuffer -- make buffer unavailable for replacement.
<span class="lineNum">    1558 </span>            :  *
<span class="lineNum">    1559 </span>            :  * For the default access strategy, the buffer's usage_count is incremented
<span class="lineNum">    1560 </span>            :  * when we first pin it; for other strategies we just make sure the usage_count
<span class="lineNum">    1561 </span>            :  * isn't zero.  (The idea of the latter is that we don't want synchronized
<span class="lineNum">    1562 </span>            :  * heap scans to inflate the count, but we need it to not be zero to discourage
<span class="lineNum">    1563 </span>            :  * other backends from stealing buffers from our ring.  As long as we cycle
<span class="lineNum">    1564 </span>            :  * through the ring faster than the global clock-sweep cycles, buffers in
<span class="lineNum">    1565 </span>            :  * our ring won't be chosen as victims for replacement by other backends.)
<span class="lineNum">    1566 </span>            :  *
<span class="lineNum">    1567 </span>            :  * This should be applied only to shared buffers, never local ones.
<span class="lineNum">    1568 </span>            :  *
<span class="lineNum">    1569 </span>            :  * Since buffers are pinned/unpinned very frequently, pin buffers without
<span class="lineNum">    1570 </span>            :  * taking the buffer header lock; instead update the state variable in loop of
<span class="lineNum">    1571 </span>            :  * CAS operations. Hopefully it's just a single CAS.
<span class="lineNum">    1572 </span>            :  *
<span class="lineNum">    1573 </span>            :  * Note that ResourceOwnerEnlargeBuffers must have been done already.
<span class="lineNum">    1574 </span>            :  *
<span class="lineNum">    1575 </span>            :  * Returns true if buffer is BM_VALID, else false.  This provision allows
<span class="lineNum">    1576 </span>            :  * some callers to avoid an extra spinlock cycle.
<a name="1577"><span class="lineNum">    1577 </span>            :  */</a>
<span class="lineNum">    1578 </span>            : static bool
<span class="lineNum">    1579 </span><span class="lineCov">   10010740 : PinBuffer(BufferDesc *buf, BufferAccessStrategy strategy)</span>
<span class="lineNum">    1580 </span>            : {
<span class="lineNum">    1581 </span><span class="lineCov">   10010740 :     Buffer      b = BufferDescriptorGetBuffer(buf);</span>
<span class="lineNum">    1582 </span>            :     bool        result;
<span class="lineNum">    1583 </span>            :     PrivateRefCountEntry *ref;
<span class="lineNum">    1584 </span>            : 
<span class="lineNum">    1585 </span><span class="lineCov">   10010740 :     ref = GetPrivateRefCountEntry(b, true);</span>
<span class="lineNum">    1586 </span>            : 
<span class="lineNum">    1587 </span><span class="lineCov">   10010740 :     if (ref == NULL)</span>
<span class="lineNum">    1588 </span>            :     {
<span class="lineNum">    1589 </span>            :         uint32      buf_state;
<span class="lineNum">    1590 </span>            :         uint32      old_buf_state;
<span class="lineNum">    1591 </span>            : 
<span class="lineNum">    1592 </span><span class="lineCov">    9505070 :         ReservePrivateRefCountEntry();</span>
<span class="lineNum">    1593 </span><span class="lineCov">    9505070 :         ref = NewPrivateRefCountEntry(b);</span>
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span><span class="lineCov">    9505070 :         old_buf_state = pg_atomic_read_u32(&amp;buf-&gt;state);</span>
<span class="lineNum">    1596 </span>            :         for (;;)
<span class="lineNum">    1597 </span>            :         {
<span class="lineNum">    1598 </span><span class="lineCov">    9505874 :             if (old_buf_state &amp; BM_LOCKED)</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :                 old_buf_state = WaitBufHdrUnlocked(buf);</span>
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span><span class="lineCov">    9505874 :             buf_state = old_buf_state;</span>
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span>            :             /* increase refcount */
<span class="lineNum">    1604 </span><span class="lineCov">    9505874 :             buf_state += BUF_REFCOUNT_ONE;</span>
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span><span class="lineCov">    9505874 :             if (strategy == NULL)</span>
<span class="lineNum">    1607 </span>            :             {
<span class="lineNum">    1608 </span>            :                 /* Default case: increase usagecount unless already max. */
<span class="lineNum">    1609 </span><span class="lineCov">    9459866 :                 if (BUF_STATE_GET_USAGECOUNT(buf_state) &lt; BM_MAX_USAGE_COUNT)</span>
<span class="lineNum">    1610 </span><span class="lineCov">     161212 :                     buf_state += BUF_USAGECOUNT_ONE;</span>
<span class="lineNum">    1611 </span>            :             }
<span class="lineNum">    1612 </span>            :             else
<span class="lineNum">    1613 </span>            :             {
<span class="lineNum">    1614 </span>            :                 /*
<span class="lineNum">    1615 </span>            :                  * Ring buffers shouldn't evict others from pool.  Thus we
<span class="lineNum">    1616 </span>            :                  * don't make usagecount more than 1.
<span class="lineNum">    1617 </span>            :                  */
<span class="lineNum">    1618 </span><span class="lineCov">      46008 :                 if (BUF_STATE_GET_USAGECOUNT(buf_state) == 0)</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :                     buf_state += BUF_USAGECOUNT_ONE;</span>
<span class="lineNum">    1620 </span>            :             }
<span class="lineNum">    1621 </span>            : 
<span class="lineNum">    1622 </span><span class="lineCov">    9505874 :             if (pg_atomic_compare_exchange_u32(&amp;buf-&gt;state, &amp;old_buf_state,</span>
<span class="lineNum">    1623 </span>            :                                                buf_state))
<span class="lineNum">    1624 </span>            :             {
<span class="lineNum">    1625 </span><span class="lineCov">    9505070 :                 result = (buf_state &amp; BM_VALID) != 0;</span>
<span class="lineNum">    1626 </span><span class="lineCov">    9505070 :                 break;</span>
<span class="lineNum">    1627 </span>            :             }
<span class="lineNum">    1628 </span><span class="lineCov">        804 :         }</span>
<span class="lineNum">    1629 </span>            :     }
<span class="lineNum">    1630 </span>            :     else
<span class="lineNum">    1631 </span>            :     {
<span class="lineNum">    1632 </span>            :         /* If we previously pinned the buffer, it must surely be valid */
<span class="lineNum">    1633 </span><span class="lineCov">     505670 :         result = true;</span>
<span class="lineNum">    1634 </span>            :     }
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span><span class="lineCov">   10010740 :     ref-&gt;refcount++;</span>
<span class="lineNum">    1637 </span><span class="lineCov">   10010740 :     Assert(ref-&gt;refcount &gt; 0);</span>
<span class="lineNum">    1638 </span><span class="lineCov">   10010740 :     ResourceOwnerRememberBuffer(CurrentResourceOwner, b);</span>
<span class="lineNum">    1639 </span><span class="lineCov">   10010740 :     return result;</span>
<span class="lineNum">    1640 </span>            : }
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span>            : /*
<span class="lineNum">    1643 </span>            :  * PinBuffer_Locked -- as above, but caller already locked the buffer header.
<span class="lineNum">    1644 </span>            :  * The spinlock is released before return.
<span class="lineNum">    1645 </span>            :  *
<span class="lineNum">    1646 </span>            :  * As this function is called with the spinlock held, the caller has to
<span class="lineNum">    1647 </span>            :  * previously call ReservePrivateRefCountEntry().
<span class="lineNum">    1648 </span>            :  *
<span class="lineNum">    1649 </span>            :  * Currently, no callers of this function want to modify the buffer's
<span class="lineNum">    1650 </span>            :  * usage_count at all, so there's no need for a strategy parameter.
<span class="lineNum">    1651 </span>            :  * Also we don't bother with a BM_VALID test (the caller could check that for
<span class="lineNum">    1652 </span>            :  * itself).
<span class="lineNum">    1653 </span>            :  *
<span class="lineNum">    1654 </span>            :  * Also all callers only ever use this function when it's known that the
<span class="lineNum">    1655 </span>            :  * buffer can't have a preexisting pin by this backend. That allows us to skip
<span class="lineNum">    1656 </span>            :  * searching the private refcount array &amp; hash, which is a boon, because the
<span class="lineNum">    1657 </span>            :  * spinlock is still held.
<span class="lineNum">    1658 </span>            :  *
<span class="lineNum">    1659 </span>            :  * Note: use of this routine is frequently mandatory, not just an optimization
<span class="lineNum">    1660 </span>            :  * to save a spin lock/unlock cycle, because we need to pin a buffer before
<span class="lineNum">    1661 </span>            :  * its state can change under us.
<a name="1662"><span class="lineNum">    1662 </span>            :  */</a>
<span class="lineNum">    1663 </span>            : static void
<span class="lineNum">    1664 </span><span class="lineCov">      73234 : PinBuffer_Locked(BufferDesc *buf)</span>
<span class="lineNum">    1665 </span>            : {
<span class="lineNum">    1666 </span>            :     Buffer      b;
<span class="lineNum">    1667 </span>            :     PrivateRefCountEntry *ref;
<span class="lineNum">    1668 </span>            :     uint32      buf_state;
<span class="lineNum">    1669 </span>            : 
<span class="lineNum">    1670 </span>            :     /*
<span class="lineNum">    1671 </span>            :      * As explained, We don't expect any preexisting pins. That allows us to
<span class="lineNum">    1672 </span>            :      * manipulate the PrivateRefCount after releasing the spinlock
<span class="lineNum">    1673 </span>            :      */
<span class="lineNum">    1674 </span><span class="lineCov">      73234 :     Assert(GetPrivateRefCountEntry(BufferDescriptorGetBuffer(buf), false) == NULL);</span>
<span class="lineNum">    1675 </span>            : 
<span class="lineNum">    1676 </span>            :     /*
<span class="lineNum">    1677 </span>            :      * Since we hold the buffer spinlock, we can update the buffer state and
<span class="lineNum">    1678 </span>            :      * release the lock in one operation.
<span class="lineNum">    1679 </span>            :      */
<span class="lineNum">    1680 </span><span class="lineCov">      73234 :     buf_state = pg_atomic_read_u32(&amp;buf-&gt;state);</span>
<span class="lineNum">    1681 </span><span class="lineCov">      73234 :     Assert(buf_state &amp; BM_LOCKED);</span>
<span class="lineNum">    1682 </span><span class="lineCov">      73234 :     buf_state += BUF_REFCOUNT_ONE;</span>
<span class="lineNum">    1683 </span><span class="lineCov">      73234 :     UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    1684 </span>            : 
<span class="lineNum">    1685 </span><span class="lineCov">      73234 :     b = BufferDescriptorGetBuffer(buf);</span>
<span class="lineNum">    1686 </span>            : 
<span class="lineNum">    1687 </span><span class="lineCov">      73234 :     ref = NewPrivateRefCountEntry(b);</span>
<span class="lineNum">    1688 </span><span class="lineCov">      73234 :     ref-&gt;refcount++;</span>
<span class="lineNum">    1689 </span>            : 
<span class="lineNum">    1690 </span><span class="lineCov">      73234 :     ResourceOwnerRememberBuffer(CurrentResourceOwner, b);</span>
<span class="lineNum">    1691 </span><span class="lineCov">      73234 : }</span>
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span>            : /*
<span class="lineNum">    1694 </span>            :  * UnpinBuffer -- make buffer available for replacement.
<span class="lineNum">    1695 </span>            :  *
<span class="lineNum">    1696 </span>            :  * This should be applied only to shared buffers, never local ones.
<span class="lineNum">    1697 </span>            :  *
<span class="lineNum">    1698 </span>            :  * Most but not all callers want CurrentResourceOwner to be adjusted.
<span class="lineNum">    1699 </span>            :  * Those that don't should pass fixOwner = false.
<a name="1700"><span class="lineNum">    1700 </span>            :  */</a>
<span class="lineNum">    1701 </span>            : static void
<span class="lineNum">    1702 </span><span class="lineCov">   12572844 : UnpinBuffer(BufferDesc *buf, bool fixOwner)</span>
<span class="lineNum">    1703 </span>            : {
<span class="lineNum">    1704 </span>            :     PrivateRefCountEntry *ref;
<span class="lineNum">    1705 </span><span class="lineCov">   12572844 :     Buffer      b = BufferDescriptorGetBuffer(buf);</span>
<span class="lineNum">    1706 </span>            : 
<span class="lineNum">    1707 </span>            :     /* not moving as we're likely deleting it soon anyway */
<span class="lineNum">    1708 </span><span class="lineCov">   12572844 :     ref = GetPrivateRefCountEntry(b, false);</span>
<span class="lineNum">    1709 </span><span class="lineCov">   12572844 :     Assert(ref != NULL);</span>
<span class="lineNum">    1710 </span>            : 
<span class="lineNum">    1711 </span><span class="lineCov">   12572844 :     if (fixOwner)</span>
<span class="lineNum">    1712 </span><span class="lineCov">   12572844 :         ResourceOwnerForgetBuffer(CurrentResourceOwner, b);</span>
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span><span class="lineCov">   12572844 :     Assert(ref-&gt;refcount &gt; 0);</span>
<span class="lineNum">    1715 </span><span class="lineCov">   12572844 :     ref-&gt;refcount--;</span>
<span class="lineNum">    1716 </span><span class="lineCov">   12572844 :     if (ref-&gt;refcount == 0)</span>
<span class="lineNum">    1717 </span>            :     {
<span class="lineNum">    1718 </span>            :         uint32      buf_state;
<span class="lineNum">    1719 </span>            :         uint32      old_buf_state;
<span class="lineNum">    1720 </span>            : 
<span class="lineNum">    1721 </span>            :         /* I'd better not still hold any locks on the buffer */
<span class="lineNum">    1722 </span><span class="lineCov">    9578304 :         Assert(!LWLockHeldByMe(BufferDescriptorGetContentLock(buf)));</span>
<span class="lineNum">    1723 </span><span class="lineCov">    9578304 :         Assert(!LWLockHeldByMe(BufferDescriptorGetIOLock(buf)));</span>
<span class="lineNum">    1724 </span>            : 
<span class="lineNum">    1725 </span>            :         /*
<span class="lineNum">    1726 </span>            :          * Decrement the shared reference count.
<span class="lineNum">    1727 </span>            :          *
<span class="lineNum">    1728 </span>            :          * Since buffer spinlock holder can update status using just write,
<span class="lineNum">    1729 </span>            :          * it's not safe to use atomic decrement here; thus use a CAS loop.
<span class="lineNum">    1730 </span>            :          */
<span class="lineNum">    1731 </span><span class="lineCov">    9578304 :         old_buf_state = pg_atomic_read_u32(&amp;buf-&gt;state);</span>
<span class="lineNum">    1732 </span>            :         for (;;)
<span class="lineNum">    1733 </span>            :         {
<span class="lineNum">    1734 </span><span class="lineCov">    9579244 :             if (old_buf_state &amp; BM_LOCKED)</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :                 old_buf_state = WaitBufHdrUnlocked(buf);</span>
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span><span class="lineCov">    9579244 :             buf_state = old_buf_state;</span>
<span class="lineNum">    1738 </span>            : 
<span class="lineNum">    1739 </span><span class="lineCov">    9579244 :             buf_state -= BUF_REFCOUNT_ONE;</span>
<span class="lineNum">    1740 </span>            : 
<span class="lineNum">    1741 </span><span class="lineCov">    9579244 :             if (pg_atomic_compare_exchange_u32(&amp;buf-&gt;state, &amp;old_buf_state,</span>
<span class="lineNum">    1742 </span>            :                                                buf_state))
<span class="lineNum">    1743 </span><span class="lineCov">    9578304 :                 break;</span>
<span class="lineNum">    1744 </span><span class="lineCov">        940 :         }</span>
<span class="lineNum">    1745 </span>            : 
<span class="lineNum">    1746 </span>            :         /* Support LockBufferForCleanup() */
<span class="lineNum">    1747 </span><span class="lineCov">    9578304 :         if (buf_state &amp; BM_PIN_COUNT_WAITER)</span>
<span class="lineNum">    1748 </span>            :         {
<span class="lineNum">    1749 </span>            :             /*
<span class="lineNum">    1750 </span>            :              * Acquire the buffer header lock, re-check that there's a waiter.
<span class="lineNum">    1751 </span>            :              * Another backend could have unpinned this buffer, and already
<span class="lineNum">    1752 </span>            :              * woken up the waiter.  There's no danger of the buffer being
<span class="lineNum">    1753 </span>            :              * replaced after we unpinned it above, as it's pinned by the
<span class="lineNum">    1754 </span>            :              * waiter.
<span class="lineNum">    1755 </span>            :              */
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :             buf_state = LockBufHdr(buf);</span>
<span class="lineNum">    1757 </span>            : 
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :             if ((buf_state &amp; BM_PIN_COUNT_WAITER) &amp;&amp;</span>
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :                 BUF_STATE_GET_REFCOUNT(buf_state) == 1)</span>
<span class="lineNum">    1760 </span><span class="lineNoCov">          0 :             {</span>
<span class="lineNum">    1761 </span>            :                 /* we just released the last pin other than the waiter's */
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :                 int         wait_backend_pid = buf-&gt;wait_backend_pid;</span>
<span class="lineNum">    1763 </span>            : 
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :                 buf_state &amp;= ~BM_PIN_COUNT_WAITER;</span>
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :                 UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :                 ProcSendSignal(wait_backend_pid);</span>
<span class="lineNum">    1767 </span>            :             }
<span class="lineNum">    1768 </span>            :             else
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :                 UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    1770 </span>            :         }
<span class="lineNum">    1771 </span><span class="lineCov">    9578304 :         ForgetPrivateRefCountEntry(ref);</span>
<span class="lineNum">    1772 </span>            :     }
<span class="lineNum">    1773 </span><span class="lineCov">   12572844 : }</span>
<span class="lineNum">    1774 </span>            : 
<span class="lineNum">    1775 </span>            : /*
<span class="lineNum">    1776 </span>            :  * BufferSync -- Write out all dirty buffers in the pool.
<span class="lineNum">    1777 </span>            :  *
<span class="lineNum">    1778 </span>            :  * This is called at checkpoint time to write out all dirty shared buffers.
<span class="lineNum">    1779 </span>            :  * The checkpoint request flags should be passed in.  If CHECKPOINT_IMMEDIATE
<span class="lineNum">    1780 </span>            :  * is set, we disable delays between writes; if CHECKPOINT_IS_SHUTDOWN,
<span class="lineNum">    1781 </span>            :  * CHECKPOINT_END_OF_RECOVERY or CHECKPOINT_FLUSH_ALL is set, we write even
<span class="lineNum">    1782 </span>            :  * unlogged buffers, which are otherwise skipped.  The remaining flags
<span class="lineNum">    1783 </span>            :  * currently have no effect here.
<a name="1784"><span class="lineNum">    1784 </span>            :  */</a>
<span class="lineNum">    1785 </span>            : static void
<span class="lineNum">    1786 </span><span class="lineCov">         22 : BufferSync(int flags)</span>
<span class="lineNum">    1787 </span>            : {
<span class="lineNum">    1788 </span>            :     uint32      buf_state;
<span class="lineNum">    1789 </span>            :     int         buf_id;
<span class="lineNum">    1790 </span>            :     int         num_to_scan;
<span class="lineNum">    1791 </span>            :     int         num_spaces;
<span class="lineNum">    1792 </span>            :     int         num_processed;
<span class="lineNum">    1793 </span>            :     int         num_written;
<span class="lineNum">    1794 </span><span class="lineCov">         22 :     CkptTsStatus *per_ts_stat = NULL;</span>
<span class="lineNum">    1795 </span>            :     Oid         last_tsid;
<span class="lineNum">    1796 </span>            :     binaryheap *ts_heap;
<span class="lineNum">    1797 </span>            :     int         i;
<span class="lineNum">    1798 </span><span class="lineCov">         22 :     int         mask = BM_DIRTY;</span>
<span class="lineNum">    1799 </span>            :     WritebackContext wb_context;
<span class="lineNum">    1800 </span>            : 
<span class="lineNum">    1801 </span>            :     /* Make sure we can handle the pin inside SyncOneBuffer */
<span class="lineNum">    1802 </span><span class="lineCov">         22 :     ResourceOwnerEnlargeBuffers(CurrentResourceOwner);</span>
<span class="lineNum">    1803 </span>            : 
<span class="lineNum">    1804 </span>            :     /*
<span class="lineNum">    1805 </span>            :      * Unless this is a shutdown checkpoint or we have been explicitly told,
<span class="lineNum">    1806 </span>            :      * we write only permanent, dirty buffers.  But at shutdown or end of
<span class="lineNum">    1807 </span>            :      * recovery, we write all dirty buffers.
<span class="lineNum">    1808 </span>            :      */
<span class="lineNum">    1809 </span><span class="lineCov">         22 :     if (!((flags &amp; (CHECKPOINT_IS_SHUTDOWN | CHECKPOINT_END_OF_RECOVERY |</span>
<span class="lineNum">    1810 </span>            :                     CHECKPOINT_FLUSH_ALL))))
<span class="lineNum">    1811 </span><span class="lineCov">         10 :         mask |= BM_PERMANENT;</span>
<span class="lineNum">    1812 </span>            : 
<span class="lineNum">    1813 </span>            :     /*
<span class="lineNum">    1814 </span>            :      * Loop over all buffers, and mark the ones that need to be written with
<span class="lineNum">    1815 </span>            :      * BM_CHECKPOINT_NEEDED.  Count them as we go (num_to_scan), so that we
<span class="lineNum">    1816 </span>            :      * can estimate how much work needs to be done.
<span class="lineNum">    1817 </span>            :      *
<span class="lineNum">    1818 </span>            :      * This allows us to write only those pages that were dirty when the
<span class="lineNum">    1819 </span>            :      * checkpoint began, and not those that get dirtied while it proceeds.
<span class="lineNum">    1820 </span>            :      * Whenever a page with BM_CHECKPOINT_NEEDED is written out, either by us
<span class="lineNum">    1821 </span>            :      * later in this function, or by normal backends or the bgwriter cleaning
<span class="lineNum">    1822 </span>            :      * scan, the flag is cleared.  Any buffer dirtied after this point won't
<span class="lineNum">    1823 </span>            :      * have the flag set.
<span class="lineNum">    1824 </span>            :      *
<span class="lineNum">    1825 </span>            :      * Note that if we fail to write some buffer, we may leave buffers with
<span class="lineNum">    1826 </span>            :      * BM_CHECKPOINT_NEEDED still set.  This is OK since any such buffer would
<span class="lineNum">    1827 </span>            :      * certainly need to be written for the next checkpoint attempt, too.
<span class="lineNum">    1828 </span>            :      */
<span class="lineNum">    1829 </span><span class="lineCov">         22 :     num_to_scan = 0;</span>
<span class="lineNum">    1830 </span><span class="lineCov">     360470 :     for (buf_id = 0; buf_id &lt; NBuffers; buf_id++)</span>
<span class="lineNum">    1831 </span>            :     {
<span class="lineNum">    1832 </span><span class="lineCov">     360448 :         BufferDesc *bufHdr = GetBufferDescriptor(buf_id);</span>
<span class="lineNum">    1833 </span>            : 
<span class="lineNum">    1834 </span>            :         /*
<span class="lineNum">    1835 </span>            :          * Header spinlock is enough to examine BM_DIRTY, see comment in
<span class="lineNum">    1836 </span>            :          * SyncOneBuffer.
<span class="lineNum">    1837 </span>            :          */
<span class="lineNum">    1838 </span><span class="lineCov">     360448 :         buf_state = LockBufHdr(bufHdr);</span>
<span class="lineNum">    1839 </span>            : 
<span class="lineNum">    1840 </span><span class="lineCov">     360448 :         if ((buf_state &amp; mask) == mask)</span>
<span class="lineNum">    1841 </span>            :         {
<span class="lineNum">    1842 </span>            :             CkptSortItem *item;
<span class="lineNum">    1843 </span>            : 
<span class="lineNum">    1844 </span><span class="lineCov">      23486 :             buf_state |= BM_CHECKPOINT_NEEDED;</span>
<span class="lineNum">    1845 </span>            : 
<span class="lineNum">    1846 </span><span class="lineCov">      23486 :             item = &amp;CkptBufferIds[num_to_scan++];</span>
<span class="lineNum">    1847 </span><span class="lineCov">      23486 :             item-&gt;buf_id = buf_id;</span>
<span class="lineNum">    1848 </span><span class="lineCov">      23486 :             item-&gt;tsId = bufHdr-&gt;tag.rnode.spcNode;</span>
<span class="lineNum">    1849 </span><span class="lineCov">      23486 :             item-&gt;relNode = bufHdr-&gt;tag.rnode.relNode;</span>
<span class="lineNum">    1850 </span><span class="lineCov">      23486 :             item-&gt;forkNum = bufHdr-&gt;tag.forkNum;</span>
<span class="lineNum">    1851 </span><span class="lineCov">      23486 :             item-&gt;blockNum = bufHdr-&gt;tag.blockNum;</span>
<span class="lineNum">    1852 </span>            :         }
<span class="lineNum">    1853 </span>            : 
<span class="lineNum">    1854 </span><span class="lineCov">     360448 :         UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    1855 </span>            :     }
<span class="lineNum">    1856 </span>            : 
<span class="lineNum">    1857 </span><span class="lineCov">         22 :     if (num_to_scan == 0)</span>
<span class="lineNum">    1858 </span><span class="lineCov">         28 :         return;                 /* nothing to do */</span>
<span class="lineNum">    1859 </span>            : 
<span class="lineNum">    1860 </span><span class="lineCov">         16 :     WritebackContextInit(&amp;wb_context, &amp;checkpoint_flush_after);</span>
<span class="lineNum">    1861 </span>            : 
<span class="lineNum">    1862 </span>            :     TRACE_POSTGRESQL_BUFFER_SYNC_START(NBuffers, num_to_scan);
<span class="lineNum">    1863 </span>            : 
<span class="lineNum">    1864 </span>            :     /*
<span class="lineNum">    1865 </span>            :      * Sort buffers that need to be written to reduce the likelihood of random
<span class="lineNum">    1866 </span>            :      * IO. The sorting is also important for the implementation of balancing
<span class="lineNum">    1867 </span>            :      * writes between tablespaces. Without balancing writes we'd potentially
<span class="lineNum">    1868 </span>            :      * end up writing to the tablespaces one-by-one; possibly overloading the
<span class="lineNum">    1869 </span>            :      * underlying system.
<span class="lineNum">    1870 </span>            :      */
<span class="lineNum">    1871 </span><span class="lineCov">         16 :     qsort(CkptBufferIds, num_to_scan, sizeof(CkptSortItem),</span>
<span class="lineNum">    1872 </span>            :           ckpt_buforder_comparator);
<span class="lineNum">    1873 </span>            : 
<span class="lineNum">    1874 </span><span class="lineCov">         16 :     num_spaces = 0;</span>
<span class="lineNum">    1875 </span>            : 
<span class="lineNum">    1876 </span>            :     /*
<span class="lineNum">    1877 </span>            :      * Allocate progress status for each tablespace with buffers that need to
<span class="lineNum">    1878 </span>            :      * be flushed. This requires the to-be-flushed array to be sorted.
<span class="lineNum">    1879 </span>            :      */
<span class="lineNum">    1880 </span><span class="lineCov">         16 :     last_tsid = InvalidOid;</span>
<span class="lineNum">    1881 </span><span class="lineCov">      23502 :     for (i = 0; i &lt; num_to_scan; i++)</span>
<span class="lineNum">    1882 </span>            :     {
<span class="lineNum">    1883 </span>            :         CkptTsStatus *s;
<span class="lineNum">    1884 </span>            :         Oid         cur_tsid;
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span><span class="lineCov">      23486 :         cur_tsid = CkptBufferIds[i].tsId;</span>
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span>            :         /*
<span class="lineNum">    1889 </span>            :          * Grow array of per-tablespace status structs, every time a new
<span class="lineNum">    1890 </span>            :          * tablespace is found.
<span class="lineNum">    1891 </span>            :          */
<span class="lineNum">    1892 </span><span class="lineCov">      23486 :         if (last_tsid == InvalidOid || last_tsid != cur_tsid)</span>
<span class="lineNum">    1893 </span><span class="lineCov">         30 :         {</span>
<span class="lineNum">    1894 </span>            :             Size        sz;
<span class="lineNum">    1895 </span>            : 
<span class="lineNum">    1896 </span><span class="lineCov">         30 :             num_spaces++;</span>
<span class="lineNum">    1897 </span>            : 
<span class="lineNum">    1898 </span>            :             /*
<span class="lineNum">    1899 </span>            :              * Not worth adding grow-by-power-of-2 logic here - even with a
<span class="lineNum">    1900 </span>            :              * few hundred tablespaces this should be fine.
<span class="lineNum">    1901 </span>            :              */
<span class="lineNum">    1902 </span><span class="lineCov">         30 :             sz = sizeof(CkptTsStatus) * num_spaces;</span>
<span class="lineNum">    1903 </span>            : 
<span class="lineNum">    1904 </span><span class="lineCov">         30 :             if (per_ts_stat == NULL)</span>
<span class="lineNum">    1905 </span><span class="lineCov">         16 :                 per_ts_stat = (CkptTsStatus *) palloc(sz);</span>
<span class="lineNum">    1906 </span>            :             else
<span class="lineNum">    1907 </span><span class="lineCov">         14 :                 per_ts_stat = (CkptTsStatus *) repalloc(per_ts_stat, sz);</span>
<span class="lineNum">    1908 </span>            : 
<span class="lineNum">    1909 </span><span class="lineCov">         30 :             s = &amp;per_ts_stat[num_spaces - 1];</span>
<span class="lineNum">    1910 </span><span class="lineCov">         30 :             memset(s, 0, sizeof(*s));</span>
<span class="lineNum">    1911 </span><span class="lineCov">         30 :             s-&gt;tsId = cur_tsid;</span>
<span class="lineNum">    1912 </span>            : 
<span class="lineNum">    1913 </span>            :             /*
<span class="lineNum">    1914 </span>            :              * The first buffer in this tablespace. As CkptBufferIds is sorted
<span class="lineNum">    1915 </span>            :              * by tablespace all (s-&gt;num_to_scan) buffers in this tablespace
<span class="lineNum">    1916 </span>            :              * will follow afterwards.
<span class="lineNum">    1917 </span>            :              */
<span class="lineNum">    1918 </span><span class="lineCov">         30 :             s-&gt;index = i;</span>
<span class="lineNum">    1919 </span>            : 
<span class="lineNum">    1920 </span>            :             /*
<span class="lineNum">    1921 </span>            :              * progress_slice will be determined once we know how many buffers
<span class="lineNum">    1922 </span>            :              * are in each tablespace, i.e. after this loop.
<span class="lineNum">    1923 </span>            :              */
<span class="lineNum">    1924 </span>            : 
<span class="lineNum">    1925 </span><span class="lineCov">         30 :             last_tsid = cur_tsid;</span>
<span class="lineNum">    1926 </span>            :         }
<span class="lineNum">    1927 </span>            :         else
<span class="lineNum">    1928 </span>            :         {
<span class="lineNum">    1929 </span><span class="lineCov">      23456 :             s = &amp;per_ts_stat[num_spaces - 1];</span>
<span class="lineNum">    1930 </span>            :         }
<span class="lineNum">    1931 </span>            : 
<span class="lineNum">    1932 </span><span class="lineCov">      23486 :         s-&gt;num_to_scan++;</span>
<span class="lineNum">    1933 </span>            :     }
<span class="lineNum">    1934 </span>            : 
<span class="lineNum">    1935 </span><span class="lineCov">         16 :     Assert(num_spaces &gt; 0);</span>
<span class="lineNum">    1936 </span>            : 
<span class="lineNum">    1937 </span>            :     /*
<span class="lineNum">    1938 </span>            :      * Build a min-heap over the write-progress in the individual tablespaces,
<span class="lineNum">    1939 </span>            :      * and compute how large a portion of the total progress a single
<span class="lineNum">    1940 </span>            :      * processed buffer is.
<span class="lineNum">    1941 </span>            :      */
<span class="lineNum">    1942 </span><span class="lineCov">         16 :     ts_heap = binaryheap_allocate(num_spaces,</span>
<span class="lineNum">    1943 </span>            :                                   ts_ckpt_progress_comparator,
<span class="lineNum">    1944 </span>            :                                   NULL);
<span class="lineNum">    1945 </span>            : 
<span class="lineNum">    1946 </span><span class="lineCov">         46 :     for (i = 0; i &lt; num_spaces; i++)</span>
<span class="lineNum">    1947 </span>            :     {
<span class="lineNum">    1948 </span><span class="lineCov">         30 :         CkptTsStatus *ts_stat = &amp;per_ts_stat[i];</span>
<span class="lineNum">    1949 </span>            : 
<span class="lineNum">    1950 </span><span class="lineCov">         30 :         ts_stat-&gt;progress_slice = (float8) num_to_scan / ts_stat-&gt;num_to_scan;</span>
<span class="lineNum">    1951 </span>            : 
<span class="lineNum">    1952 </span><span class="lineCov">         30 :         binaryheap_add_unordered(ts_heap, PointerGetDatum(ts_stat));</span>
<span class="lineNum">    1953 </span>            :     }
<span class="lineNum">    1954 </span>            : 
<span class="lineNum">    1955 </span><span class="lineCov">         16 :     binaryheap_build(ts_heap);</span>
<span class="lineNum">    1956 </span>            : 
<span class="lineNum">    1957 </span>            :     /*
<span class="lineNum">    1958 </span>            :      * Iterate through to-be-checkpointed buffers and write the ones (still)
<span class="lineNum">    1959 </span>            :      * marked with BM_CHECKPOINT_NEEDED. The writes are balanced between
<span class="lineNum">    1960 </span>            :      * tablespaces; otherwise the sorting would lead to only one tablespace
<span class="lineNum">    1961 </span>            :      * receiving writes at a time, making inefficient use of the hardware.
<span class="lineNum">    1962 </span>            :      */
<span class="lineNum">    1963 </span><span class="lineCov">         16 :     num_processed = 0;</span>
<span class="lineNum">    1964 </span><span class="lineCov">         16 :     num_written = 0;</span>
<span class="lineNum">    1965 </span><span class="lineCov">      23518 :     while (!binaryheap_empty(ts_heap))</span>
<span class="lineNum">    1966 </span>            :     {
<span class="lineNum">    1967 </span><span class="lineCov">      23486 :         BufferDesc *bufHdr = NULL;</span>
<span class="lineNum">    1968 </span><span class="lineCov">      23486 :         CkptTsStatus *ts_stat = (CkptTsStatus *)</span>
<span class="lineNum">    1969 </span><span class="lineCov">      23486 :         DatumGetPointer(binaryheap_first(ts_heap));</span>
<span class="lineNum">    1970 </span>            : 
<span class="lineNum">    1971 </span><span class="lineCov">      23486 :         buf_id = CkptBufferIds[ts_stat-&gt;index].buf_id;</span>
<span class="lineNum">    1972 </span><span class="lineCov">      23486 :         Assert(buf_id != -1);</span>
<span class="lineNum">    1973 </span>            : 
<span class="lineNum">    1974 </span><span class="lineCov">      23486 :         bufHdr = GetBufferDescriptor(buf_id);</span>
<span class="lineNum">    1975 </span>            : 
<span class="lineNum">    1976 </span><span class="lineCov">      23486 :         num_processed++;</span>
<span class="lineNum">    1977 </span>            : 
<span class="lineNum">    1978 </span>            :         /*
<span class="lineNum">    1979 </span>            :          * We don't need to acquire the lock here, because we're only looking
<span class="lineNum">    1980 </span>            :          * at a single bit. It's possible that someone else writes the buffer
<span class="lineNum">    1981 </span>            :          * and clears the flag right after we check, but that doesn't matter
<span class="lineNum">    1982 </span>            :          * since SyncOneBuffer will then do nothing.  However, there is a
<span class="lineNum">    1983 </span>            :          * further race condition: it's conceivable that between the time we
<span class="lineNum">    1984 </span>            :          * examine the bit here and the time SyncOneBuffer acquires the lock,
<span class="lineNum">    1985 </span>            :          * someone else not only wrote the buffer but replaced it with another
<span class="lineNum">    1986 </span>            :          * page and dirtied it.  In that improbable case, SyncOneBuffer will
<span class="lineNum">    1987 </span>            :          * write the buffer though we didn't need to.  It doesn't seem worth
<span class="lineNum">    1988 </span>            :          * guarding against this, though.
<span class="lineNum">    1989 </span>            :          */
<span class="lineNum">    1990 </span><span class="lineCov">      23486 :         if (pg_atomic_read_u32(&amp;bufHdr-&gt;state) &amp; BM_CHECKPOINT_NEEDED)</span>
<span class="lineNum">    1991 </span>            :         {
<span class="lineNum">    1992 </span><span class="lineCov">      23486 :             if (SyncOneBuffer(buf_id, false, &amp;wb_context) &amp; BUF_WRITTEN)</span>
<span class="lineNum">    1993 </span>            :             {
<span class="lineNum">    1994 </span>            :                 TRACE_POSTGRESQL_BUFFER_SYNC_WRITTEN(buf_id);
<span class="lineNum">    1995 </span><span class="lineCov">      23486 :                 BgWriterStats.m_buf_written_checkpoints++;</span>
<span class="lineNum">    1996 </span><span class="lineCov">      23486 :                 num_written++;</span>
<span class="lineNum">    1997 </span>            :             }
<span class="lineNum">    1998 </span>            :         }
<span class="lineNum">    1999 </span>            : 
<span class="lineNum">    2000 </span>            :         /*
<span class="lineNum">    2001 </span>            :          * Measure progress independent of actually having to flush the buffer
<span class="lineNum">    2002 </span>            :          * - otherwise writing become unbalanced.
<span class="lineNum">    2003 </span>            :          */
<span class="lineNum">    2004 </span><span class="lineCov">      23486 :         ts_stat-&gt;progress += ts_stat-&gt;progress_slice;</span>
<span class="lineNum">    2005 </span><span class="lineCov">      23486 :         ts_stat-&gt;num_scanned++;</span>
<span class="lineNum">    2006 </span><span class="lineCov">      23486 :         ts_stat-&gt;index++;</span>
<span class="lineNum">    2007 </span>            : 
<span class="lineNum">    2008 </span>            :         /* Have all the buffers from the tablespace been processed? */
<span class="lineNum">    2009 </span><span class="lineCov">      23486 :         if (ts_stat-&gt;num_scanned == ts_stat-&gt;num_to_scan)</span>
<span class="lineNum">    2010 </span>            :         {
<span class="lineNum">    2011 </span><span class="lineCov">         30 :             binaryheap_remove_first(ts_heap);</span>
<span class="lineNum">    2012 </span>            :         }
<span class="lineNum">    2013 </span>            :         else
<span class="lineNum">    2014 </span>            :         {
<span class="lineNum">    2015 </span>            :             /* update heap with the new progress */
<span class="lineNum">    2016 </span><span class="lineCov">      23456 :             binaryheap_replace_first(ts_heap, PointerGetDatum(ts_stat));</span>
<span class="lineNum">    2017 </span>            :         }
<span class="lineNum">    2018 </span>            : 
<span class="lineNum">    2019 </span>            :         /*
<span class="lineNum">    2020 </span>            :          * Sleep to throttle our I/O rate.
<span class="lineNum">    2021 </span>            :          */
<span class="lineNum">    2022 </span><span class="lineCov">      23486 :         CheckpointWriteDelay(flags, (double) num_processed / num_to_scan);</span>
<span class="lineNum">    2023 </span>            :     }
<span class="lineNum">    2024 </span>            : 
<span class="lineNum">    2025 </span>            :     /* issue all pending flushes */
<span class="lineNum">    2026 </span><span class="lineCov">         16 :     IssuePendingWritebacks(&amp;wb_context);</span>
<span class="lineNum">    2027 </span>            : 
<span class="lineNum">    2028 </span><span class="lineCov">         16 :     pfree(per_ts_stat);</span>
<span class="lineNum">    2029 </span><span class="lineCov">         16 :     per_ts_stat = NULL;</span>
<span class="lineNum">    2030 </span><span class="lineCov">         16 :     binaryheap_free(ts_heap);</span>
<span class="lineNum">    2031 </span>            : 
<span class="lineNum">    2032 </span>            :     /*
<span class="lineNum">    2033 </span>            :      * Update checkpoint statistics. As noted above, this doesn't include
<span class="lineNum">    2034 </span>            :      * buffers written by other backends or bgwriter scan.
<span class="lineNum">    2035 </span>            :      */
<span class="lineNum">    2036 </span><span class="lineCov">         16 :     CheckpointStats.ckpt_bufs_written += num_written;</span>
<span class="lineNum">    2037 </span>            : 
<span class="lineNum">    2038 </span>            :     TRACE_POSTGRESQL_BUFFER_SYNC_DONE(NBuffers, num_written, num_to_scan);
<span class="lineNum">    2039 </span>            : }
<span class="lineNum">    2040 </span>            : 
<span class="lineNum">    2041 </span>            : /*
<span class="lineNum">    2042 </span>            :  * BgBufferSync -- Write out some dirty buffers in the pool.
<span class="lineNum">    2043 </span>            :  *
<span class="lineNum">    2044 </span>            :  * This is called periodically by the background writer process.
<span class="lineNum">    2045 </span>            :  *
<span class="lineNum">    2046 </span>            :  * Returns true if it's appropriate for the bgwriter process to go into
<span class="lineNum">    2047 </span>            :  * low-power hibernation mode.  (This happens if the strategy clock sweep
<span class="lineNum">    2048 </span>            :  * has been &quot;lapped&quot; and no buffer allocations have occurred recently,
<span class="lineNum">    2049 </span>            :  * or if the bgwriter has been effectively disabled by setting
<span class="lineNum">    2050 </span>            :  * bgwriter_lru_maxpages to 0.)
<a name="2051"><span class="lineNum">    2051 </span>            :  */</a>
<span class="lineNum">    2052 </span>            : bool
<span class="lineNum">    2053 </span><span class="lineCov">        490 : BgBufferSync(WritebackContext *wb_context)</span>
<span class="lineNum">    2054 </span>            : {
<span class="lineNum">    2055 </span>            :     /* info obtained from freelist.c */
<span class="lineNum">    2056 </span>            :     int         strategy_buf_id;
<span class="lineNum">    2057 </span>            :     uint32      strategy_passes;
<span class="lineNum">    2058 </span>            :     uint32      recent_alloc;
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span>            :     /*
<span class="lineNum">    2061 </span>            :      * Information saved between calls so we can determine the strategy
<span class="lineNum">    2062 </span>            :      * point's advance rate and avoid scanning already-cleaned buffers.
<span class="lineNum">    2063 </span>            :      */
<span class="lineNum">    2064 </span>            :     static bool saved_info_valid = false;
<span class="lineNum">    2065 </span>            :     static int  prev_strategy_buf_id;
<span class="lineNum">    2066 </span>            :     static uint32 prev_strategy_passes;
<span class="lineNum">    2067 </span>            :     static int  next_to_clean;
<span class="lineNum">    2068 </span>            :     static uint32 next_passes;
<span class="lineNum">    2069 </span>            : 
<span class="lineNum">    2070 </span>            :     /* Moving averages of allocation rate and clean-buffer density */
<span class="lineNum">    2071 </span>            :     static float smoothed_alloc = 0;
<span class="lineNum">    2072 </span>            :     static float smoothed_density = 10.0;
<span class="lineNum">    2073 </span>            : 
<span class="lineNum">    2074 </span>            :     /* Potentially these could be tunables, but for now, not */
<span class="lineNum">    2075 </span><span class="lineCov">        490 :     float       smoothing_samples = 16;</span>
<span class="lineNum">    2076 </span><span class="lineCov">        490 :     float       scan_whole_pool_milliseconds = 120000.0;</span>
<span class="lineNum">    2077 </span>            : 
<span class="lineNum">    2078 </span>            :     /* Used to compute how far we scan ahead */
<span class="lineNum">    2079 </span>            :     long        strategy_delta;
<span class="lineNum">    2080 </span>            :     int         bufs_to_lap;
<span class="lineNum">    2081 </span>            :     int         bufs_ahead;
<span class="lineNum">    2082 </span>            :     float       scans_per_alloc;
<span class="lineNum">    2083 </span>            :     int         reusable_buffers_est;
<span class="lineNum">    2084 </span>            :     int         upcoming_alloc_est;
<span class="lineNum">    2085 </span>            :     int         min_scan_buffers;
<span class="lineNum">    2086 </span>            : 
<span class="lineNum">    2087 </span>            :     /* Variables for the scanning loop proper */
<span class="lineNum">    2088 </span>            :     int         num_to_scan;
<span class="lineNum">    2089 </span>            :     int         num_written;
<span class="lineNum">    2090 </span>            :     int         reusable_buffers;
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span>            :     /* Variables for final smoothed_density update */
<span class="lineNum">    2093 </span>            :     long        new_strategy_delta;
<span class="lineNum">    2094 </span>            :     uint32      new_recent_alloc;
<span class="lineNum">    2095 </span>            : 
<span class="lineNum">    2096 </span>            :     /*
<span class="lineNum">    2097 </span>            :      * Find out where the freelist clock sweep currently is, and how many
<span class="lineNum">    2098 </span>            :      * buffer allocations have happened since our last call.
<span class="lineNum">    2099 </span>            :      */
<span class="lineNum">    2100 </span><span class="lineCov">        490 :     strategy_buf_id = StrategySyncStart(&amp;strategy_passes, &amp;recent_alloc);</span>
<span class="lineNum">    2101 </span>            : 
<span class="lineNum">    2102 </span>            :     /* Report buffer alloc counts to pgstat */
<span class="lineNum">    2103 </span><span class="lineCov">        490 :     BgWriterStats.m_buf_alloc += recent_alloc;</span>
<span class="lineNum">    2104 </span>            : 
<span class="lineNum">    2105 </span>            :     /*
<span class="lineNum">    2106 </span>            :      * If we're not running the LRU scan, just stop after doing the stats
<span class="lineNum">    2107 </span>            :      * stuff.  We mark the saved state invalid so that we can recover sanely
<span class="lineNum">    2108 </span>            :      * if LRU scan is turned back on later.
<span class="lineNum">    2109 </span>            :      */
<span class="lineNum">    2110 </span><span class="lineCov">        490 :     if (bgwriter_lru_maxpages &lt;= 0)</span>
<span class="lineNum">    2111 </span>            :     {
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :         saved_info_valid = false;</span>
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    2114 </span>            :     }
<span class="lineNum">    2115 </span>            : 
<span class="lineNum">    2116 </span>            :     /*
<span class="lineNum">    2117 </span>            :      * Compute strategy_delta = how many buffers have been scanned by the
<span class="lineNum">    2118 </span>            :      * clock sweep since last time.  If first time through, assume none. Then
<span class="lineNum">    2119 </span>            :      * see if we are still ahead of the clock sweep, and if so, how many
<span class="lineNum">    2120 </span>            :      * buffers we could scan before we'd catch up with it and &quot;lap&quot; it. Note:
<span class="lineNum">    2121 </span>            :      * weird-looking coding of xxx_passes comparisons are to avoid bogus
<span class="lineNum">    2122 </span>            :      * behavior when the passes counts wrap around.
<span class="lineNum">    2123 </span>            :      */
<span class="lineNum">    2124 </span><span class="lineCov">        490 :     if (saved_info_valid)</span>
<span class="lineNum">    2125 </span>            :     {
<span class="lineNum">    2126 </span><span class="lineCov">        488 :         int32       passes_delta = strategy_passes - prev_strategy_passes;</span>
<span class="lineNum">    2127 </span>            : 
<span class="lineNum">    2128 </span><span class="lineCov">        488 :         strategy_delta = strategy_buf_id - prev_strategy_buf_id;</span>
<span class="lineNum">    2129 </span><span class="lineCov">        488 :         strategy_delta += (long) passes_delta * NBuffers;</span>
<span class="lineNum">    2130 </span>            : 
<span class="lineNum">    2131 </span><span class="lineCov">        488 :         Assert(strategy_delta &gt;= 0);</span>
<span class="lineNum">    2132 </span>            : 
<span class="lineNum">    2133 </span><span class="lineCov">        488 :         if ((int32) (next_passes - strategy_passes) &gt; 0)</span>
<span class="lineNum">    2134 </span>            :         {
<span class="lineNum">    2135 </span>            :             /* we're one pass ahead of the strategy point */
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 :             bufs_to_lap = strategy_buf_id - next_to_clean;</span>
<span class="lineNum">    2137 </span>            : #ifdef BGW_DEBUG
<span class="lineNum">    2138 </span>            :             elog(DEBUG2, &quot;bgwriter ahead: bgw %u-%u strategy %u-%u delta=%ld lap=%d&quot;,
<span class="lineNum">    2139 </span>            :                  next_passes, next_to_clean,
<span class="lineNum">    2140 </span>            :                  strategy_passes, strategy_buf_id,
<span class="lineNum">    2141 </span>            :                  strategy_delta, bufs_to_lap);
<span class="lineNum">    2142 </span>            : #endif
<span class="lineNum">    2143 </span>            :         }
<span class="lineNum">    2144 </span><span class="lineCov">        976 :         else if (next_passes == strategy_passes &amp;&amp;</span>
<span class="lineNum">    2145 </span><span class="lineCov">        488 :                  next_to_clean &gt;= strategy_buf_id)</span>
<span class="lineNum">    2146 </span>            :         {
<span class="lineNum">    2147 </span>            :             /* on same pass, but ahead or at least not behind */
<span class="lineNum">    2148 </span><span class="lineCov">        488 :             bufs_to_lap = NBuffers - (next_to_clean - strategy_buf_id);</span>
<span class="lineNum">    2149 </span>            : #ifdef BGW_DEBUG
<span class="lineNum">    2150 </span>            :             elog(DEBUG2, &quot;bgwriter ahead: bgw %u-%u strategy %u-%u delta=%ld lap=%d&quot;,
<span class="lineNum">    2151 </span>            :                  next_passes, next_to_clean,
<span class="lineNum">    2152 </span>            :                  strategy_passes, strategy_buf_id,
<span class="lineNum">    2153 </span>            :                  strategy_delta, bufs_to_lap);
<span class="lineNum">    2154 </span>            : #endif
<span class="lineNum">    2155 </span>            :         }
<span class="lineNum">    2156 </span>            :         else
<span class="lineNum">    2157 </span>            :         {
<span class="lineNum">    2158 </span>            :             /*
<span class="lineNum">    2159 </span>            :              * We're behind, so skip forward to the strategy point and start
<span class="lineNum">    2160 </span>            :              * cleaning from there.
<span class="lineNum">    2161 </span>            :              */
<span class="lineNum">    2162 </span>            : #ifdef BGW_DEBUG
<span class="lineNum">    2163 </span>            :             elog(DEBUG2, &quot;bgwriter behind: bgw %u-%u strategy %u-%u delta=%ld&quot;,
<span class="lineNum">    2164 </span>            :                  next_passes, next_to_clean,
<span class="lineNum">    2165 </span>            :                  strategy_passes, strategy_buf_id,
<span class="lineNum">    2166 </span>            :                  strategy_delta);
<span class="lineNum">    2167 </span>            : #endif
<span class="lineNum">    2168 </span><span class="lineNoCov">          0 :             next_to_clean = strategy_buf_id;</span>
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :             next_passes = strategy_passes;</span>
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :             bufs_to_lap = NBuffers;</span>
<span class="lineNum">    2171 </span>            :         }
<span class="lineNum">    2172 </span>            :     }
<span class="lineNum">    2173 </span>            :     else
<span class="lineNum">    2174 </span>            :     {
<span class="lineNum">    2175 </span>            :         /*
<span class="lineNum">    2176 </span>            :          * Initializing at startup or after LRU scanning had been off. Always
<span class="lineNum">    2177 </span>            :          * start at the strategy point.
<span class="lineNum">    2178 </span>            :          */
<span class="lineNum">    2179 </span>            : #ifdef BGW_DEBUG
<span class="lineNum">    2180 </span>            :         elog(DEBUG2, &quot;bgwriter initializing: strategy %u-%u&quot;,
<span class="lineNum">    2181 </span>            :              strategy_passes, strategy_buf_id);
<span class="lineNum">    2182 </span>            : #endif
<span class="lineNum">    2183 </span><span class="lineCov">          2 :         strategy_delta = 0;</span>
<span class="lineNum">    2184 </span><span class="lineCov">          2 :         next_to_clean = strategy_buf_id;</span>
<span class="lineNum">    2185 </span><span class="lineCov">          2 :         next_passes = strategy_passes;</span>
<span class="lineNum">    2186 </span><span class="lineCov">          2 :         bufs_to_lap = NBuffers;</span>
<span class="lineNum">    2187 </span>            :     }
<span class="lineNum">    2188 </span>            : 
<span class="lineNum">    2189 </span>            :     /* Update saved info for next time */
<span class="lineNum">    2190 </span><span class="lineCov">        490 :     prev_strategy_buf_id = strategy_buf_id;</span>
<span class="lineNum">    2191 </span><span class="lineCov">        490 :     prev_strategy_passes = strategy_passes;</span>
<span class="lineNum">    2192 </span><span class="lineCov">        490 :     saved_info_valid = true;</span>
<span class="lineNum">    2193 </span>            : 
<span class="lineNum">    2194 </span>            :     /*
<span class="lineNum">    2195 </span>            :      * Compute how many buffers had to be scanned for each new allocation, ie,
<span class="lineNum">    2196 </span>            :      * 1/density of reusable buffers, and track a moving average of that.
<span class="lineNum">    2197 </span>            :      *
<span class="lineNum">    2198 </span>            :      * If the strategy point didn't move, we don't update the density estimate
<span class="lineNum">    2199 </span>            :      */
<span class="lineNum">    2200 </span><span class="lineCov">        490 :     if (strategy_delta &gt; 0 &amp;&amp; recent_alloc &gt; 0)</span>
<span class="lineNum">    2201 </span>            :     {
<span class="lineNum">    2202 </span><span class="lineNoCov">          0 :         scans_per_alloc = (float) strategy_delta / (float) recent_alloc;</span>
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :         smoothed_density += (scans_per_alloc - smoothed_density) /</span>
<span class="lineNum">    2204 </span>            :             smoothing_samples;
<span class="lineNum">    2205 </span>            :     }
<span class="lineNum">    2206 </span>            : 
<span class="lineNum">    2207 </span>            :     /*
<span class="lineNum">    2208 </span>            :      * Estimate how many reusable buffers there are between the current
<span class="lineNum">    2209 </span>            :      * strategy point and where we've scanned ahead to, based on the smoothed
<span class="lineNum">    2210 </span>            :      * density estimate.
<span class="lineNum">    2211 </span>            :      */
<span class="lineNum">    2212 </span><span class="lineCov">        490 :     bufs_ahead = NBuffers - bufs_to_lap;</span>
<span class="lineNum">    2213 </span><span class="lineCov">        490 :     reusable_buffers_est = (float) bufs_ahead / smoothed_density;</span>
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span>            :     /*
<span class="lineNum">    2216 </span>            :      * Track a moving average of recent buffer allocations.  Here, rather than
<span class="lineNum">    2217 </span>            :      * a true average we want a fast-attack, slow-decline behavior: we
<span class="lineNum">    2218 </span>            :      * immediately follow any increase.
<span class="lineNum">    2219 </span>            :      */
<span class="lineNum">    2220 </span><span class="lineCov">        490 :     if (smoothed_alloc &lt;= (float) recent_alloc)</span>
<span class="lineNum">    2221 </span><span class="lineCov">         42 :         smoothed_alloc = recent_alloc;</span>
<span class="lineNum">    2222 </span>            :     else
<span class="lineNum">    2223 </span><span class="lineCov">        448 :         smoothed_alloc += ((float) recent_alloc - smoothed_alloc) /</span>
<span class="lineNum">    2224 </span>            :             smoothing_samples;
<span class="lineNum">    2225 </span>            : 
<span class="lineNum">    2226 </span>            :     /* Scale the estimate by a GUC to allow more aggressive tuning. */
<span class="lineNum">    2227 </span><span class="lineCov">        490 :     upcoming_alloc_est = (int) (smoothed_alloc * bgwriter_lru_multiplier);</span>
<span class="lineNum">    2228 </span>            : 
<span class="lineNum">    2229 </span>            :     /*
<span class="lineNum">    2230 </span>            :      * If recent_alloc remains at zero for many cycles, smoothed_alloc will
<span class="lineNum">    2231 </span>            :      * eventually underflow to zero, and the underflows produce annoying
<span class="lineNum">    2232 </span>            :      * kernel warnings on some platforms.  Once upcoming_alloc_est has gone to
<span class="lineNum">    2233 </span>            :      * zero, there's no point in tracking smaller and smaller values of
<span class="lineNum">    2234 </span>            :      * smoothed_alloc, so just reset it to exactly zero to avoid this
<span class="lineNum">    2235 </span>            :      * syndrome.  It will pop back up as soon as recent_alloc increases.
<span class="lineNum">    2236 </span>            :      */
<span class="lineNum">    2237 </span><span class="lineCov">        490 :     if (upcoming_alloc_est == 0)</span>
<span class="lineNum">    2238 </span><span class="lineCov">          2 :         smoothed_alloc = 0;</span>
<span class="lineNum">    2239 </span>            : 
<span class="lineNum">    2240 </span>            :     /*
<span class="lineNum">    2241 </span>            :      * Even in cases where there's been little or no buffer allocation
<span class="lineNum">    2242 </span>            :      * activity, we want to make a small amount of progress through the buffer
<span class="lineNum">    2243 </span>            :      * cache so that as many reusable buffers as possible are clean after an
<span class="lineNum">    2244 </span>            :      * idle period.
<span class="lineNum">    2245 </span>            :      *
<span class="lineNum">    2246 </span>            :      * (scan_whole_pool_milliseconds / BgWriterDelay) computes how many times
<span class="lineNum">    2247 </span>            :      * the BGW will be called during the scan_whole_pool time; slice the
<span class="lineNum">    2248 </span>            :      * buffer pool into that many sections.
<span class="lineNum">    2249 </span>            :      */
<span class="lineNum">    2250 </span><span class="lineCov">        490 :     min_scan_buffers = (int) (NBuffers / (scan_whole_pool_milliseconds / BgWriterDelay));</span>
<span class="lineNum">    2251 </span>            : 
<span class="lineNum">    2252 </span><span class="lineCov">        490 :     if (upcoming_alloc_est &lt; (min_scan_buffers + reusable_buffers_est))</span>
<span class="lineNum">    2253 </span>            :     {
<span class="lineNum">    2254 </span>            : #ifdef BGW_DEBUG
<span class="lineNum">    2255 </span>            :         elog(DEBUG2, &quot;bgwriter: alloc_est=%d too small, using min=%d + reusable_est=%d&quot;,
<span class="lineNum">    2256 </span>            :              upcoming_alloc_est, min_scan_buffers, reusable_buffers_est);
<span class="lineNum">    2257 </span>            : #endif
<span class="lineNum">    2258 </span><span class="lineCov">        472 :         upcoming_alloc_est = min_scan_buffers + reusable_buffers_est;</span>
<span class="lineNum">    2259 </span>            :     }
<span class="lineNum">    2260 </span>            : 
<span class="lineNum">    2261 </span>            :     /*
<span class="lineNum">    2262 </span>            :      * Now write out dirty reusable buffers, working forward from the
<span class="lineNum">    2263 </span>            :      * next_to_clean point, until we have lapped the strategy scan, or cleaned
<span class="lineNum">    2264 </span>            :      * enough buffers to match our estimate of the next cycle's allocation
<span class="lineNum">    2265 </span>            :      * requirements, or hit the bgwriter_lru_maxpages limit.
<span class="lineNum">    2266 </span>            :      */
<span class="lineNum">    2267 </span>            : 
<span class="lineNum">    2268 </span>            :     /* Make sure we can handle the pin inside SyncOneBuffer */
<span class="lineNum">    2269 </span><span class="lineCov">        490 :     ResourceOwnerEnlargeBuffers(CurrentResourceOwner);</span>
<span class="lineNum">    2270 </span>            : 
<span class="lineNum">    2271 </span><span class="lineCov">        490 :     num_to_scan = bufs_to_lap;</span>
<span class="lineNum">    2272 </span><span class="lineCov">        490 :     num_written = 0;</span>
<span class="lineNum">    2273 </span><span class="lineCov">        490 :     reusable_buffers = reusable_buffers_est;</span>
<span class="lineNum">    2274 </span>            : 
<span class="lineNum">    2275 </span>            :     /* Execute the LRU scan */
<span class="lineNum">    2276 </span><span class="lineCov">      28020 :     while (num_to_scan &gt; 0 &amp;&amp; reusable_buffers &lt; upcoming_alloc_est)</span>
<span class="lineNum">    2277 </span>            :     {
<span class="lineNum">    2278 </span><span class="lineCov">      27040 :         int         sync_state = SyncOneBuffer(next_to_clean, true,</span>
<span class="lineNum">    2279 </span>            :                                                wb_context);
<span class="lineNum">    2280 </span>            : 
<span class="lineNum">    2281 </span><span class="lineCov">      27040 :         if (++next_to_clean &gt;= NBuffers)</span>
<span class="lineNum">    2282 </span>            :         {
<span class="lineNum">    2283 </span><span class="lineNoCov">          0 :             next_to_clean = 0;</span>
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :             next_passes++;</span>
<span class="lineNum">    2285 </span>            :         }
<span class="lineNum">    2286 </span><span class="lineCov">      27040 :         num_to_scan--;</span>
<span class="lineNum">    2287 </span>            : 
<span class="lineNum">    2288 </span><span class="lineCov">      27040 :         if (sync_state &amp; BUF_WRITTEN)</span>
<span class="lineNum">    2289 </span>            :         {
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 :             reusable_buffers++;</span>
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 :             if (++num_written &gt;= bgwriter_lru_maxpages)</span>
<span class="lineNum">    2292 </span>            :             {
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :                 BgWriterStats.m_maxwritten_clean++;</span>
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    2295 </span>            :             }
<span class="lineNum">    2296 </span>            :         }
<span class="lineNum">    2297 </span><span class="lineCov">      27040 :         else if (sync_state &amp; BUF_REUSABLE)</span>
<span class="lineNum">    2298 </span><span class="lineCov">      17114 :             reusable_buffers++;</span>
<span class="lineNum">    2299 </span>            :     }
<span class="lineNum">    2300 </span>            : 
<span class="lineNum">    2301 </span><span class="lineCov">        490 :     BgWriterStats.m_buf_written_clean += num_written;</span>
<span class="lineNum">    2302 </span>            : 
<span class="lineNum">    2303 </span>            : #ifdef BGW_DEBUG
<span class="lineNum">    2304 </span>            :     elog(DEBUG1, &quot;bgwriter: recent_alloc=%u smoothed=%.2f delta=%ld ahead=%d density=%.2f reusable_est=%d upcoming_est=%d scanned=%d wrote=%d reusable=%d&quot;,
<span class="lineNum">    2305 </span>            :          recent_alloc, smoothed_alloc, strategy_delta, bufs_ahead,
<span class="lineNum">    2306 </span>            :          smoothed_density, reusable_buffers_est, upcoming_alloc_est,
<span class="lineNum">    2307 </span>            :          bufs_to_lap - num_to_scan,
<span class="lineNum">    2308 </span>            :          num_written,
<span class="lineNum">    2309 </span>            :          reusable_buffers - reusable_buffers_est);
<span class="lineNum">    2310 </span>            : #endif
<span class="lineNum">    2311 </span>            : 
<span class="lineNum">    2312 </span>            :     /*
<span class="lineNum">    2313 </span>            :      * Consider the above scan as being like a new allocation scan.
<span class="lineNum">    2314 </span>            :      * Characterize its density and update the smoothed one based on it. This
<span class="lineNum">    2315 </span>            :      * effectively halves the moving average period in cases where both the
<span class="lineNum">    2316 </span>            :      * strategy and the background writer are doing some useful scanning,
<span class="lineNum">    2317 </span>            :      * which is helpful because a long memory isn't as desirable on the
<span class="lineNum">    2318 </span>            :      * density estimates.
<span class="lineNum">    2319 </span>            :      */
<span class="lineNum">    2320 </span><span class="lineCov">        490 :     new_strategy_delta = bufs_to_lap - num_to_scan;</span>
<span class="lineNum">    2321 </span><span class="lineCov">        490 :     new_recent_alloc = reusable_buffers - reusable_buffers_est;</span>
<span class="lineNum">    2322 </span><span class="lineCov">        490 :     if (new_strategy_delta &gt; 0 &amp;&amp; new_recent_alloc &gt; 0)</span>
<span class="lineNum">    2323 </span>            :     {
<span class="lineNum">    2324 </span><span class="lineCov">        490 :         scans_per_alloc = (float) new_strategy_delta / (float) new_recent_alloc;</span>
<span class="lineNum">    2325 </span><span class="lineCov">        490 :         smoothed_density += (scans_per_alloc - smoothed_density) /</span>
<span class="lineNum">    2326 </span>            :             smoothing_samples;
<span class="lineNum">    2327 </span>            : 
<span class="lineNum">    2328 </span>            : #ifdef BGW_DEBUG
<span class="lineNum">    2329 </span>            :         elog(DEBUG2, &quot;bgwriter: cleaner density alloc=%u scan=%ld density=%.2f new smoothed=%.2f&quot;,
<span class="lineNum">    2330 </span>            :              new_recent_alloc, new_strategy_delta,
<span class="lineNum">    2331 </span>            :              scans_per_alloc, smoothed_density);
<span class="lineNum">    2332 </span>            : #endif
<span class="lineNum">    2333 </span>            :     }
<span class="lineNum">    2334 </span>            : 
<span class="lineNum">    2335 </span>            :     /* Return true if OK to hibernate */
<span class="lineNum">    2336 </span><span class="lineCov">        490 :     return (bufs_to_lap == 0 &amp;&amp; recent_alloc == 0);</span>
<span class="lineNum">    2337 </span>            : }
<span class="lineNum">    2338 </span>            : 
<span class="lineNum">    2339 </span>            : /*
<span class="lineNum">    2340 </span>            :  * SyncOneBuffer -- process a single buffer during syncing.
<span class="lineNum">    2341 </span>            :  *
<span class="lineNum">    2342 </span>            :  * If skip_recently_used is true, we don't write currently-pinned buffers, nor
<span class="lineNum">    2343 </span>            :  * buffers marked recently used, as these are not replacement candidates.
<span class="lineNum">    2344 </span>            :  *
<span class="lineNum">    2345 </span>            :  * Returns a bitmask containing the following flag bits:
<span class="lineNum">    2346 </span>            :  *  BUF_WRITTEN: we wrote the buffer.
<span class="lineNum">    2347 </span>            :  *  BUF_REUSABLE: buffer is available for replacement, ie, it has
<span class="lineNum">    2348 </span>            :  *      pin count 0 and usage count 0.
<span class="lineNum">    2349 </span>            :  *
<span class="lineNum">    2350 </span>            :  * (BUF_WRITTEN could be set in error if FlushBuffer finds the buffer clean
<span class="lineNum">    2351 </span>            :  * after locking it, but we don't care all that much.)
<span class="lineNum">    2352 </span>            :  *
<span class="lineNum">    2353 </span>            :  * Note: caller must have done ResourceOwnerEnlargeBuffers.
<a name="2354"><span class="lineNum">    2354 </span>            :  */</a>
<span class="lineNum">    2355 </span>            : static int
<span class="lineNum">    2356 </span><span class="lineCov">      50526 : SyncOneBuffer(int buf_id, bool skip_recently_used, WritebackContext *wb_context)</span>
<span class="lineNum">    2357 </span>            : {
<span class="lineNum">    2358 </span><span class="lineCov">      50526 :     BufferDesc *bufHdr = GetBufferDescriptor(buf_id);</span>
<span class="lineNum">    2359 </span><span class="lineCov">      50526 :     int         result = 0;</span>
<span class="lineNum">    2360 </span>            :     uint32      buf_state;
<span class="lineNum">    2361 </span>            :     BufferTag   tag;
<span class="lineNum">    2362 </span>            : 
<span class="lineNum">    2363 </span><span class="lineCov">      50526 :     ReservePrivateRefCountEntry();</span>
<span class="lineNum">    2364 </span>            : 
<span class="lineNum">    2365 </span>            :     /*
<span class="lineNum">    2366 </span>            :      * Check whether buffer needs writing.
<span class="lineNum">    2367 </span>            :      *
<span class="lineNum">    2368 </span>            :      * We can make this check without taking the buffer content lock so long
<span class="lineNum">    2369 </span>            :      * as we mark pages dirty in access methods *before* logging changes with
<span class="lineNum">    2370 </span>            :      * XLogInsert(): if someone marks the buffer dirty just after our check we
<span class="lineNum">    2371 </span>            :      * don't worry because our checkpoint.redo points before log record for
<span class="lineNum">    2372 </span>            :      * upcoming changes and so we are not required to write such dirty buffer.
<span class="lineNum">    2373 </span>            :      */
<span class="lineNum">    2374 </span><span class="lineCov">      50526 :     buf_state = LockBufHdr(bufHdr);</span>
<span class="lineNum">    2375 </span>            : 
<span class="lineNum">    2376 </span><span class="lineCov">     100998 :     if (BUF_STATE_GET_REFCOUNT(buf_state) == 0 &amp;&amp;</span>
<span class="lineNum">    2377 </span><span class="lineCov">      50472 :         BUF_STATE_GET_USAGECOUNT(buf_state) == 0)</span>
<span class="lineNum">    2378 </span>            :     {
<span class="lineNum">    2379 </span><span class="lineCov">      17114 :         result |= BUF_REUSABLE;</span>
<span class="lineNum">    2380 </span>            :     }
<span class="lineNum">    2381 </span><span class="lineCov">      33412 :     else if (skip_recently_used)</span>
<span class="lineNum">    2382 </span>            :     {
<span class="lineNum">    2383 </span>            :         /* Caller told us not to write recently-used buffers */
<span class="lineNum">    2384 </span><span class="lineCov">       9926 :         UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    2385 </span><span class="lineCov">       9926 :         return result;</span>
<span class="lineNum">    2386 </span>            :     }
<span class="lineNum">    2387 </span>            : 
<span class="lineNum">    2388 </span><span class="lineCov">      40600 :     if (!(buf_state &amp; BM_VALID) || !(buf_state &amp; BM_DIRTY))</span>
<span class="lineNum">    2389 </span>            :     {
<span class="lineNum">    2390 </span>            :         /* It's clean, so nothing to do */
<span class="lineNum">    2391 </span><span class="lineCov">      17114 :         UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    2392 </span><span class="lineCov">      17114 :         return result;</span>
<span class="lineNum">    2393 </span>            :     }
<span class="lineNum">    2394 </span>            : 
<span class="lineNum">    2395 </span>            :     /*
<span class="lineNum">    2396 </span>            :      * Pin it, share-lock it, write it.  (FlushBuffer will do nothing if the
<span class="lineNum">    2397 </span>            :      * buffer is clean by the time we've locked it.)
<span class="lineNum">    2398 </span>            :      */
<span class="lineNum">    2399 </span><span class="lineCov">      23486 :     PinBuffer_Locked(bufHdr);</span>
<span class="lineNum">    2400 </span><span class="lineCov">      23486 :     LWLockAcquire(BufferDescriptorGetContentLock(bufHdr), LW_SHARED);</span>
<span class="lineNum">    2401 </span>            : 
<span class="lineNum">    2402 </span><span class="lineCov">      23486 :     FlushBuffer(bufHdr, NULL);</span>
<span class="lineNum">    2403 </span>            : 
<span class="lineNum">    2404 </span><span class="lineCov">      23486 :     LWLockRelease(BufferDescriptorGetContentLock(bufHdr));</span>
<span class="lineNum">    2405 </span>            : 
<span class="lineNum">    2406 </span><span class="lineCov">      23486 :     tag = bufHdr-&gt;tag;</span>
<span class="lineNum">    2407 </span>            : 
<span class="lineNum">    2408 </span><span class="lineCov">      23486 :     UnpinBuffer(bufHdr, true);</span>
<span class="lineNum">    2409 </span>            : 
<span class="lineNum">    2410 </span><span class="lineCov">      23486 :     ScheduleBufferTagForWriteback(wb_context, &amp;tag);</span>
<span class="lineNum">    2411 </span>            : 
<span class="lineNum">    2412 </span><span class="lineCov">      23486 :     return result | BUF_WRITTEN;</span>
<span class="lineNum">    2413 </span>            : }
<span class="lineNum">    2414 </span>            : 
<span class="lineNum">    2415 </span>            : /*
<span class="lineNum">    2416 </span>            :  *      AtEOXact_Buffers - clean up at end of transaction.
<span class="lineNum">    2417 </span>            :  *
<span class="lineNum">    2418 </span>            :  *      As of PostgreSQL 8.0, buffer pins should get released by the
<span class="lineNum">    2419 </span>            :  *      ResourceOwner mechanism.  This routine is just a debugging
<span class="lineNum">    2420 </span>            :  *      cross-check that no pins remain.
<a name="2421"><span class="lineNum">    2421 </span>            :  */</a>
<span class="lineNum">    2422 </span>            : void
<span class="lineNum">    2423 </span><span class="lineCov">      71316 : AtEOXact_Buffers(bool isCommit)</span>
<span class="lineNum">    2424 </span>            : {
<span class="lineNum">    2425 </span><span class="lineCov">      71316 :     CheckForBufferLeaks();</span>
<span class="lineNum">    2426 </span>            : 
<span class="lineNum">    2427 </span><span class="lineCov">      71316 :     AtEOXact_LocalBuffers(isCommit);</span>
<span class="lineNum">    2428 </span>            : 
<span class="lineNum">    2429 </span><span class="lineCov">      71316 :     Assert(PrivateRefCountOverflowed == 0);</span>
<span class="lineNum">    2430 </span><span class="lineCov">      71316 : }</span>
<span class="lineNum">    2431 </span>            : 
<span class="lineNum">    2432 </span>            : /*
<span class="lineNum">    2433 </span>            :  * Initialize access to shared buffer pool
<span class="lineNum">    2434 </span>            :  *
<span class="lineNum">    2435 </span>            :  * This is called during backend startup (whether standalone or under the
<span class="lineNum">    2436 </span>            :  * postmaster).  It sets up for this backend's access to the already-existing
<span class="lineNum">    2437 </span>            :  * buffer pool.
<span class="lineNum">    2438 </span>            :  *
<span class="lineNum">    2439 </span>            :  * NB: this is called before InitProcess(), so we do not have a PGPROC and
<span class="lineNum">    2440 </span>            :  * cannot do LWLockAcquire; hence we can't actually access stuff in
<span class="lineNum">    2441 </span>            :  * shared memory yet.  We are only initializing local data here.
<span class="lineNum">    2442 </span>            :  * (See also InitBufferPoolBackend)
<a name="2443"><span class="lineNum">    2443 </span>            :  */</a>
<span class="lineNum">    2444 </span>            : void
<span class="lineNum">    2445 </span><span class="lineCov">       1224 : InitBufferPoolAccess(void)</span>
<span class="lineNum">    2446 </span>            : {
<span class="lineNum">    2447 </span>            :     HASHCTL     hash_ctl;
<span class="lineNum">    2448 </span>            : 
<span class="lineNum">    2449 </span><span class="lineCov">       1224 :     memset(&amp;PrivateRefCountArray, 0, sizeof(PrivateRefCountArray));</span>
<span class="lineNum">    2450 </span>            : 
<span class="lineNum">    2451 </span><span class="lineCov">       1224 :     MemSet(&amp;hash_ctl, 0, sizeof(hash_ctl));</span>
<span class="lineNum">    2452 </span><span class="lineCov">       1224 :     hash_ctl.keysize = sizeof(int32);</span>
<span class="lineNum">    2453 </span><span class="lineCov">       1224 :     hash_ctl.entrysize = sizeof(PrivateRefCountEntry);</span>
<span class="lineNum">    2454 </span>            : 
<span class="lineNum">    2455 </span><span class="lineCov">       1224 :     PrivateRefCountHash = hash_create(&quot;PrivateRefCount&quot;, 100, &amp;hash_ctl,</span>
<span class="lineNum">    2456 </span>            :                                       HASH_ELEM | HASH_BLOBS);
<span class="lineNum">    2457 </span><span class="lineCov">       1224 : }</span>
<span class="lineNum">    2458 </span>            : 
<span class="lineNum">    2459 </span>            : /*
<span class="lineNum">    2460 </span>            :  * InitBufferPoolBackend --- second-stage initialization of a new backend
<span class="lineNum">    2461 </span>            :  *
<span class="lineNum">    2462 </span>            :  * This is called after we have acquired a PGPROC and so can safely get
<span class="lineNum">    2463 </span>            :  * LWLocks.  We don't currently need to do anything at this stage ...
<span class="lineNum">    2464 </span>            :  * except register a shmem-exit callback.  AtProcExit_Buffers needs LWLock
<span class="lineNum">    2465 </span>            :  * access, and thereby has to be called at the corresponding phase of
<span class="lineNum">    2466 </span>            :  * backend shutdown.
<a name="2467"><span class="lineNum">    2467 </span>            :  */</a>
<span class="lineNum">    2468 </span>            : void
<span class="lineNum">    2469 </span><span class="lineCov">       1220 : InitBufferPoolBackend(void)</span>
<span class="lineNum">    2470 </span>            : {
<span class="lineNum">    2471 </span><span class="lineCov">       1220 :     on_shmem_exit(AtProcExit_Buffers, 0);</span>
<span class="lineNum">    2472 </span><span class="lineCov">       1220 : }</span>
<span class="lineNum">    2473 </span>            : 
<span class="lineNum">    2474 </span>            : /*
<span class="lineNum">    2475 </span>            :  * During backend exit, ensure that we released all shared-buffer locks and
<span class="lineNum">    2476 </span>            :  * assert that we have no remaining pins.
<a name="2477"><span class="lineNum">    2477 </span>            :  */</a>
<span class="lineNum">    2478 </span>            : static void
<span class="lineNum">    2479 </span><span class="lineCov">       1220 : AtProcExit_Buffers(int code, Datum arg)</span>
<span class="lineNum">    2480 </span>            : {
<span class="lineNum">    2481 </span><span class="lineCov">       1220 :     AbortBufferIO();</span>
<span class="lineNum">    2482 </span><span class="lineCov">       1220 :     UnlockBuffers();</span>
<span class="lineNum">    2483 </span>            : 
<span class="lineNum">    2484 </span><span class="lineCov">       1220 :     CheckForBufferLeaks();</span>
<span class="lineNum">    2485 </span>            : 
<span class="lineNum">    2486 </span>            :     /* localbuf.c needs a chance too */
<span class="lineNum">    2487 </span><span class="lineCov">       1220 :     AtProcExit_LocalBuffers();</span>
<span class="lineNum">    2488 </span><span class="lineCov">       1220 : }</span>
<span class="lineNum">    2489 </span>            : 
<span class="lineNum">    2490 </span>            : /*
<span class="lineNum">    2491 </span>            :  *      CheckForBufferLeaks - ensure this backend holds no buffer pins
<span class="lineNum">    2492 </span>            :  *
<span class="lineNum">    2493 </span>            :  *      As of PostgreSQL 8.0, buffer pins should get released by the
<span class="lineNum">    2494 </span>            :  *      ResourceOwner mechanism.  This routine is just a debugging
<span class="lineNum">    2495 </span>            :  *      cross-check that no pins remain.
<a name="2496"><span class="lineNum">    2496 </span>            :  */</a>
<span class="lineNum">    2497 </span>            : static void
<span class="lineNum">    2498 </span><span class="lineCov">      72536 : CheckForBufferLeaks(void)</span>
<span class="lineNum">    2499 </span>            : {
<span class="lineNum">    2500 </span>            : #ifdef USE_ASSERT_CHECKING
<span class="lineNum">    2501 </span><span class="lineCov">      72536 :     int         RefCountErrors = 0;</span>
<span class="lineNum">    2502 </span>            :     PrivateRefCountEntry *res;
<span class="lineNum">    2503 </span>            :     int         i;
<span class="lineNum">    2504 </span>            : 
<span class="lineNum">    2505 </span>            :     /* check the array */
<span class="lineNum">    2506 </span><span class="lineCov">     652824 :     for (i = 0; i &lt; REFCOUNT_ARRAY_ENTRIES; i++)</span>
<span class="lineNum">    2507 </span>            :     {
<span class="lineNum">    2508 </span><span class="lineCov">     580288 :         res = &amp;PrivateRefCountArray[i];</span>
<span class="lineNum">    2509 </span>            : 
<span class="lineNum">    2510 </span><span class="lineCov">     580288 :         if (res-&gt;buffer != InvalidBuffer)</span>
<span class="lineNum">    2511 </span>            :         {
<span class="lineNum">    2512 </span><span class="lineNoCov">          0 :             PrintBufferLeakWarning(res-&gt;buffer);</span>
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :             RefCountErrors++;</span>
<span class="lineNum">    2514 </span>            :         }
<span class="lineNum">    2515 </span>            :     }
<span class="lineNum">    2516 </span>            : 
<span class="lineNum">    2517 </span>            :     /* if necessary search the hash */
<span class="lineNum">    2518 </span><span class="lineCov">      72536 :     if (PrivateRefCountOverflowed)</span>
<span class="lineNum">    2519 </span>            :     {
<span class="lineNum">    2520 </span>            :         HASH_SEQ_STATUS hstat;
<span class="lineNum">    2521 </span>            : 
<span class="lineNum">    2522 </span><span class="lineNoCov">          0 :         hash_seq_init(&amp;hstat, PrivateRefCountHash);</span>
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 :         while ((res = (PrivateRefCountEntry *) hash_seq_search(&amp;hstat)) != NULL)</span>
<span class="lineNum">    2524 </span>            :         {
<span class="lineNum">    2525 </span><span class="lineNoCov">          0 :             PrintBufferLeakWarning(res-&gt;buffer);</span>
<span class="lineNum">    2526 </span><span class="lineNoCov">          0 :             RefCountErrors++;</span>
<span class="lineNum">    2527 </span>            :         }
<span class="lineNum">    2528 </span>            : 
<span class="lineNum">    2529 </span>            :     }
<span class="lineNum">    2530 </span>            : 
<span class="lineNum">    2531 </span><span class="lineCov">      72536 :     Assert(RefCountErrors == 0);</span>
<span class="lineNum">    2532 </span>            : #endif
<span class="lineNum">    2533 </span><span class="lineCov">      72536 : }</span>
<span class="lineNum">    2534 </span>            : 
<span class="lineNum">    2535 </span>            : /*
<span class="lineNum">    2536 </span>            :  * Helper routine to issue warnings when a buffer is unexpectedly pinned
<a name="2537"><span class="lineNum">    2537 </span>            :  */</a>
<span class="lineNum">    2538 </span>            : void
<span class="lineNum">    2539 </span><span class="lineNoCov">          0 : PrintBufferLeakWarning(Buffer buffer)</span>
<span class="lineNum">    2540 </span>            : {
<span class="lineNum">    2541 </span>            :     BufferDesc *buf;
<span class="lineNum">    2542 </span>            :     int32       loccount;
<span class="lineNum">    2543 </span>            :     char       *path;
<span class="lineNum">    2544 </span>            :     BackendId   backend;
<span class="lineNum">    2545 </span>            :     uint32      buf_state;
<span class="lineNum">    2546 </span>            : 
<span class="lineNum">    2547 </span><span class="lineNoCov">          0 :     Assert(BufferIsValid(buffer));</span>
<span class="lineNum">    2548 </span><span class="lineNoCov">          0 :     if (BufferIsLocal(buffer))</span>
<span class="lineNum">    2549 </span>            :     {
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :         buf = GetLocalBufferDescriptor(-buffer - 1);</span>
<span class="lineNum">    2551 </span><span class="lineNoCov">          0 :         loccount = LocalRefCount[-buffer - 1];</span>
<span class="lineNum">    2552 </span><span class="lineNoCov">          0 :         backend = MyBackendId;</span>
<span class="lineNum">    2553 </span>            :     }
<span class="lineNum">    2554 </span>            :     else
<span class="lineNum">    2555 </span>            :     {
<span class="lineNum">    2556 </span><span class="lineNoCov">          0 :         buf = GetBufferDescriptor(buffer - 1);</span>
<span class="lineNum">    2557 </span><span class="lineNoCov">          0 :         loccount = GetPrivateRefCount(buffer);</span>
<span class="lineNum">    2558 </span><span class="lineNoCov">          0 :         backend = InvalidBackendId;</span>
<span class="lineNum">    2559 </span>            :     }
<span class="lineNum">    2560 </span>            : 
<span class="lineNum">    2561 </span>            :     /* theoretically we should lock the bufhdr here */
<span class="lineNum">    2562 </span><span class="lineNoCov">          0 :     path = relpathbackend(buf-&gt;tag.rnode, backend, buf-&gt;tag.forkNum);</span>
<span class="lineNum">    2563 </span><span class="lineNoCov">          0 :     buf_state = pg_atomic_read_u32(&amp;buf-&gt;state);</span>
<span class="lineNum">    2564 </span><span class="lineNoCov">          0 :     elog(WARNING,</span>
<span class="lineNum">    2565 </span>            :          &quot;buffer refcount leak: [%03d] &quot;
<span class="lineNum">    2566 </span>            :          &quot;(rel=%s, blockNum=%u, flags=0x%x, refcount=%u %d)&quot;,
<span class="lineNum">    2567 </span>            :          buffer, path,
<span class="lineNum">    2568 </span>            :          buf-&gt;tag.blockNum, buf_state &amp; BUF_FLAG_MASK,
<span class="lineNum">    2569 </span>            :          BUF_STATE_GET_REFCOUNT(buf_state), loccount);
<span class="lineNum">    2570 </span><span class="lineNoCov">          0 :     pfree(path);</span>
<span class="lineNum">    2571 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2572 </span>            : 
<span class="lineNum">    2573 </span>            : /*
<span class="lineNum">    2574 </span>            :  * CheckPointBuffers
<span class="lineNum">    2575 </span>            :  *
<span class="lineNum">    2576 </span>            :  * Flush all dirty blocks in buffer pool to disk at checkpoint time.
<span class="lineNum">    2577 </span>            :  *
<span class="lineNum">    2578 </span>            :  * Note: temporary relations do not participate in checkpoints, so they don't
<span class="lineNum">    2579 </span>            :  * need to be flushed.
<a name="2580"><span class="lineNum">    2580 </span>            :  */</a>
<span class="lineNum">    2581 </span>            : void
<span class="lineNum">    2582 </span><span class="lineCov">         22 : CheckPointBuffers(int flags)</span>
<span class="lineNum">    2583 </span>            : {
<span class="lineNum">    2584 </span>            :     TRACE_POSTGRESQL_BUFFER_CHECKPOINT_START(flags);
<span class="lineNum">    2585 </span><span class="lineCov">         22 :     CheckpointStats.ckpt_write_t = GetCurrentTimestamp();</span>
<span class="lineNum">    2586 </span><span class="lineCov">         22 :     BufferSync(flags);</span>
<span class="lineNum">    2587 </span><span class="lineCov">         22 :     CheckpointStats.ckpt_sync_t = GetCurrentTimestamp();</span>
<span class="lineNum">    2588 </span>            :     TRACE_POSTGRESQL_BUFFER_CHECKPOINT_SYNC_START();
<span class="lineNum">    2589 </span><span class="lineCov">         22 :     ProcessSyncRequests();</span>
<span class="lineNum">    2590 </span><span class="lineCov">         22 :     CheckpointStats.ckpt_sync_end_t = GetCurrentTimestamp();</span>
<span class="lineNum">    2591 </span>            :     TRACE_POSTGRESQL_BUFFER_CHECKPOINT_DONE();
<span class="lineNum">    2592 </span><span class="lineCov">         22 : }</span>
<span class="lineNum">    2593 </span>            : 
<span class="lineNum">    2594 </span>            : 
<span class="lineNum">    2595 </span>            : /*
<span class="lineNum">    2596 </span>            :  * Do whatever is needed to prepare for commit at the bufmgr and smgr levels
<a name="2597"><span class="lineNum">    2597 </span>            :  */</a>
<span class="lineNum">    2598 </span>            : void
<span class="lineNum">    2599 </span><span class="lineCov">      26438 : BufmgrCommit(void)</span>
<span class="lineNum">    2600 </span>            : {
<span class="lineNum">    2601 </span>            :     /* Nothing to do in bufmgr anymore... */
<span class="lineNum">    2602 </span><span class="lineCov">      26438 : }</span>
<span class="lineNum">    2603 </span>            : 
<span class="lineNum">    2604 </span>            : /*
<span class="lineNum">    2605 </span>            :  * BufferGetBlockNumber
<span class="lineNum">    2606 </span>            :  *      Returns the block number associated with a buffer.
<span class="lineNum">    2607 </span>            :  *
<span class="lineNum">    2608 </span>            :  * Note:
<span class="lineNum">    2609 </span>            :  *      Assumes that the buffer is valid and pinned, else the
<span class="lineNum">    2610 </span>            :  *      value may be obsolete immediately...
<a name="2611"><span class="lineNum">    2611 </span>            :  */</a>
<span class="lineNum">    2612 </span>            : BlockNumber
<span class="lineNum">    2613 </span><span class="lineCov">   24298662 : BufferGetBlockNumber(Buffer buffer)</span>
<span class="lineNum">    2614 </span>            : {
<span class="lineNum">    2615 </span>            :     BufferDesc *bufHdr;
<span class="lineNum">    2616 </span>            : 
<span class="lineNum">    2617 </span><span class="lineCov">   24298662 :     Assert(BufferIsPinned(buffer));</span>
<span class="lineNum">    2618 </span>            : 
<span class="lineNum">    2619 </span><span class="lineCov">   24298662 :     if (BufferIsLocal(buffer))</span>
<span class="lineNum">    2620 </span><span class="lineCov">     854634 :         bufHdr = GetLocalBufferDescriptor(-buffer - 1);</span>
<span class="lineNum">    2621 </span>            :     else
<span class="lineNum">    2622 </span><span class="lineCov">   23444028 :         bufHdr = GetBufferDescriptor(buffer - 1);</span>
<span class="lineNum">    2623 </span>            : 
<span class="lineNum">    2624 </span>            :     /* pinned, so OK to read tag without spinlock */
<span class="lineNum">    2625 </span><span class="lineCov">   24298662 :     return bufHdr-&gt;tag.blockNum;</span>
<span class="lineNum">    2626 </span>            : }
<span class="lineNum">    2627 </span>            : 
<span class="lineNum">    2628 </span>            : /*
<span class="lineNum">    2629 </span>            :  * BufferGetTag
<span class="lineNum">    2630 </span>            :  *      Returns the relfilenode, fork number and block number associated with
<span class="lineNum">    2631 </span>            :  *      a buffer.
<a name="2632"><span class="lineNum">    2632 </span>            :  */</a>
<span class="lineNum">    2633 </span>            : void
<span class="lineNum">    2634 </span><span class="lineCov">    3870642 : BufferGetTag(Buffer buffer, RelFileNode *rnode, ForkNumber *forknum,</span>
<span class="lineNum">    2635 </span>            :              BlockNumber *blknum)
<span class="lineNum">    2636 </span>            : {
<span class="lineNum">    2637 </span>            :     BufferDesc *bufHdr;
<span class="lineNum">    2638 </span>            : 
<span class="lineNum">    2639 </span>            :     /* Do the same checks as BufferGetBlockNumber. */
<span class="lineNum">    2640 </span><span class="lineCov">    3870642 :     Assert(BufferIsPinned(buffer));</span>
<span class="lineNum">    2641 </span>            : 
<span class="lineNum">    2642 </span><span class="lineCov">    3870642 :     if (BufferIsLocal(buffer))</span>
<span class="lineNum">    2643 </span><span class="lineNoCov">          0 :         bufHdr = GetLocalBufferDescriptor(-buffer - 1);</span>
<span class="lineNum">    2644 </span>            :     else
<span class="lineNum">    2645 </span><span class="lineCov">    3870642 :         bufHdr = GetBufferDescriptor(buffer - 1);</span>
<span class="lineNum">    2646 </span>            : 
<span class="lineNum">    2647 </span>            :     /* pinned, so OK to read tag without spinlock */
<span class="lineNum">    2648 </span><span class="lineCov">    3870642 :     *rnode = bufHdr-&gt;tag.rnode;</span>
<span class="lineNum">    2649 </span><span class="lineCov">    3870642 :     *forknum = bufHdr-&gt;tag.forkNum;</span>
<span class="lineNum">    2650 </span><span class="lineCov">    3870642 :     *blknum = bufHdr-&gt;tag.blockNum;</span>
<span class="lineNum">    2651 </span><span class="lineCov">    3870642 : }</span>
<span class="lineNum">    2652 </span>            : 
<span class="lineNum">    2653 </span>            : /*
<span class="lineNum">    2654 </span>            :  * FlushBuffer
<span class="lineNum">    2655 </span>            :  *      Physically write out a shared buffer.
<span class="lineNum">    2656 </span>            :  *
<span class="lineNum">    2657 </span>            :  * NOTE: this actually just passes the buffer contents to the kernel; the
<span class="lineNum">    2658 </span>            :  * real write to disk won't happen until the kernel feels like it.  This
<span class="lineNum">    2659 </span>            :  * is okay from our point of view since we can redo the changes from WAL.
<span class="lineNum">    2660 </span>            :  * However, we will need to force the changes to disk via fsync before
<span class="lineNum">    2661 </span>            :  * we can checkpoint WAL.
<span class="lineNum">    2662 </span>            :  *
<span class="lineNum">    2663 </span>            :  * The caller must hold a pin on the buffer and have share-locked the
<span class="lineNum">    2664 </span>            :  * buffer contents.  (Note: a share-lock does not prevent updates of
<span class="lineNum">    2665 </span>            :  * hint bits in the buffer, so the page could change while the write
<span class="lineNum">    2666 </span>            :  * is in progress, but we assume that that will not invalidate the data
<span class="lineNum">    2667 </span>            :  * written.)
<span class="lineNum">    2668 </span>            :  *
<span class="lineNum">    2669 </span>            :  * If the caller has an smgr reference for the buffer's relation, pass it
<span class="lineNum">    2670 </span>            :  * as the second parameter.  If not, pass NULL.
<a name="2671"><span class="lineNum">    2671 </span>            :  */</a>
<span class="lineNum">    2672 </span>            : static void
<span class="lineNum">    2673 </span><span class="lineCov">      23598 : FlushBuffer(BufferDesc *buf, SMgrRelation reln)</span>
<span class="lineNum">    2674 </span>            : {
<span class="lineNum">    2675 </span>            :     XLogRecPtr  recptr;
<span class="lineNum">    2676 </span>            :     ErrorContextCallback errcallback;
<span class="lineNum">    2677 </span>            :     instr_time  io_start,
<span class="lineNum">    2678 </span>            :                 io_time;
<span class="lineNum">    2679 </span>            :     Block       bufBlock;
<span class="lineNum">    2680 </span>            :     char       *bufToWrite;
<span class="lineNum">    2681 </span>            :     uint32      buf_state;
<span class="lineNum">    2682 </span>            : 
<span class="lineNum">    2683 </span>            :     /*
<span class="lineNum">    2684 </span>            :      * Acquire the buffer's io_in_progress lock.  If StartBufferIO returns
<span class="lineNum">    2685 </span>            :      * false, then someone else flushed the buffer before we could, so we need
<span class="lineNum">    2686 </span>            :      * not do anything.
<span class="lineNum">    2687 </span>            :      */
<span class="lineNum">    2688 </span><span class="lineCov">      23598 :     if (!StartBufferIO(buf, false))</span>
<span class="lineNum">    2689 </span><span class="lineCov">      23598 :         return;</span>
<span class="lineNum">    2690 </span>            : 
<span class="lineNum">    2691 </span>            :     /* Setup error traceback support for ereport() */
<span class="lineNum">    2692 </span><span class="lineCov">      23598 :     errcallback.callback = shared_buffer_write_error_callback;</span>
<span class="lineNum">    2693 </span><span class="lineCov">      23598 :     errcallback.arg = (void *) buf;</span>
<span class="lineNum">    2694 </span><span class="lineCov">      23598 :     errcallback.previous = error_context_stack;</span>
<span class="lineNum">    2695 </span><span class="lineCov">      23598 :     error_context_stack = &amp;errcallback;</span>
<span class="lineNum">    2696 </span>            : 
<span class="lineNum">    2697 </span>            :     /* Find smgr relation for buffer */
<span class="lineNum">    2698 </span><span class="lineCov">      23598 :     if (reln == NULL)</span>
<span class="lineNum">    2699 </span><span class="lineCov">      23534 :         reln = smgropen(buf-&gt;tag.rnode, InvalidBackendId);</span>
<span class="lineNum">    2700 </span>            : 
<span class="lineNum">    2701 </span>            :     TRACE_POSTGRESQL_BUFFER_FLUSH_START(buf-&gt;tag.forkNum,
<span class="lineNum">    2702 </span>            :                                         buf-&gt;tag.blockNum,
<span class="lineNum">    2703 </span>            :                                         reln-&gt;smgr_rnode.node.spcNode,
<span class="lineNum">    2704 </span>            :                                         reln-&gt;smgr_rnode.node.dbNode,
<span class="lineNum">    2705 </span>            :                                         reln-&gt;smgr_rnode.node.relNode);
<span class="lineNum">    2706 </span>            : 
<span class="lineNum">    2707 </span><span class="lineCov">      23598 :     buf_state = LockBufHdr(buf);</span>
<span class="lineNum">    2708 </span>            : 
<span class="lineNum">    2709 </span>            :     /*
<span class="lineNum">    2710 </span>            :      * Run PageGetLSN while holding header lock, since we don't have the
<span class="lineNum">    2711 </span>            :      * buffer locked exclusively in all cases.
<span class="lineNum">    2712 </span>            :      */
<span class="lineNum">    2713 </span><span class="lineCov">      23598 :     recptr = BufferGetLSN(buf);</span>
<span class="lineNum">    2714 </span>            : 
<span class="lineNum">    2715 </span>            :     /* To check if block content changes while flushing. - vadim 01/17/97 */
<span class="lineNum">    2716 </span><span class="lineCov">      23598 :     buf_state &amp;= ~BM_JUST_DIRTIED;</span>
<span class="lineNum">    2717 </span><span class="lineCov">      23598 :     UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    2718 </span>            : 
<span class="lineNum">    2719 </span>            :     /*
<span class="lineNum">    2720 </span>            :      * Force XLOG flush up to buffer's LSN.  This implements the basic WAL
<span class="lineNum">    2721 </span>            :      * rule that log updates must hit disk before any of the data-file changes
<span class="lineNum">    2722 </span>            :      * they describe do.
<span class="lineNum">    2723 </span>            :      *
<span class="lineNum">    2724 </span>            :      * However, this rule does not apply to unlogged relations, which will be
<span class="lineNum">    2725 </span>            :      * lost after a crash anyway.  Most unlogged relation pages do not bear
<span class="lineNum">    2726 </span>            :      * LSNs since we never emit WAL records for them, and therefore flushing
<span class="lineNum">    2727 </span>            :      * up through the buffer LSN would be useless, but harmless.  However,
<span class="lineNum">    2728 </span>            :      * GiST indexes use LSNs internally to track page-splits, and therefore
<span class="lineNum">    2729 </span>            :      * unlogged GiST pages bear &quot;fake&quot; LSNs generated by
<span class="lineNum">    2730 </span>            :      * GetFakeLSNForUnloggedRel.  It is unlikely but possible that the fake
<span class="lineNum">    2731 </span>            :      * LSN counter could advance past the WAL insertion point; and if it did
<span class="lineNum">    2732 </span>            :      * happen, attempting to flush WAL through that location would fail, with
<span class="lineNum">    2733 </span>            :      * disastrous system-wide consequences.  To make sure that can't happen,
<span class="lineNum">    2734 </span>            :      * skip the flush if the buffer isn't permanent.
<span class="lineNum">    2735 </span>            :      */
<span class="lineNum">    2736 </span><span class="lineCov">      23598 :     if (buf_state &amp; BM_PERMANENT)</span>
<span class="lineNum">    2737 </span><span class="lineCov">      23598 :         XLogFlush(recptr);</span>
<span class="lineNum">    2738 </span>            : 
<span class="lineNum">    2739 </span>            :     /*
<span class="lineNum">    2740 </span>            :      * Now it's safe to write buffer to disk. Note that no one else should
<span class="lineNum">    2741 </span>            :      * have been able to write it while we were busy with log flushing because
<span class="lineNum">    2742 </span>            :      * we have the io_in_progress lock.
<span class="lineNum">    2743 </span>            :      */
<span class="lineNum">    2744 </span><span class="lineCov">      23598 :     bufBlock = BufHdrGetBlock(buf);</span>
<span class="lineNum">    2745 </span>            : 
<span class="lineNum">    2746 </span>            :     /*
<span class="lineNum">    2747 </span>            :      * Update page checksum if desired.  Since we have only shared lock on the
<span class="lineNum">    2748 </span>            :      * buffer, other processes might be updating hint bits in it, so we must
<span class="lineNum">    2749 </span>            :      * copy the page to private storage if we do checksumming.
<span class="lineNum">    2750 </span>            :      */
<span class="lineNum">    2751 </span><span class="lineCov">      23598 :     bufToWrite = PageSetChecksumCopy((Page) bufBlock, buf-&gt;tag.blockNum);</span>
<span class="lineNum">    2752 </span>            : 
<span class="lineNum">    2753 </span><span class="lineCov">      23598 :     if (track_io_timing)</span>
<span class="lineNum">    2754 </span><span class="lineNoCov">          0 :         INSTR_TIME_SET_CURRENT(io_start);</span>
<span class="lineNum">    2755 </span>            : 
<span class="lineNum">    2756 </span>            :     /*
<span class="lineNum">    2757 </span>            :      * bufToWrite is either the shared buffer or a copy, as appropriate.
<span class="lineNum">    2758 </span>            :      */
<span class="lineNum">    2759 </span><span class="lineCov">      23598 :     smgrwrite(reln,</span>
<span class="lineNum">    2760 </span>            :               buf-&gt;tag.forkNum,
<span class="lineNum">    2761 </span>            :               buf-&gt;tag.blockNum,
<span class="lineNum">    2762 </span>            :               bufToWrite,
<span class="lineNum">    2763 </span>            :               false);
<span class="lineNum">    2764 </span>            : 
<span class="lineNum">    2765 </span><span class="lineCov">      23598 :     if (track_io_timing)</span>
<span class="lineNum">    2766 </span>            :     {
<span class="lineNum">    2767 </span><span class="lineNoCov">          0 :         INSTR_TIME_SET_CURRENT(io_time);</span>
<span class="lineNum">    2768 </span><span class="lineNoCov">          0 :         INSTR_TIME_SUBTRACT(io_time, io_start);</span>
<span class="lineNum">    2769 </span><span class="lineNoCov">          0 :         pgstat_count_buffer_write_time(INSTR_TIME_GET_MICROSEC(io_time));</span>
<span class="lineNum">    2770 </span><span class="lineNoCov">          0 :         INSTR_TIME_ADD(pgBufferUsage.blk_write_time, io_time);</span>
<span class="lineNum">    2771 </span>            :     }
<span class="lineNum">    2772 </span>            : 
<span class="lineNum">    2773 </span><span class="lineCov">      23598 :     pgBufferUsage.shared_blks_written++;</span>
<span class="lineNum">    2774 </span>            : 
<span class="lineNum">    2775 </span>            :     /*
<span class="lineNum">    2776 </span>            :      * Mark the buffer as clean (unless BM_JUST_DIRTIED has become set) and
<span class="lineNum">    2777 </span>            :      * end the io_in_progress state.
<span class="lineNum">    2778 </span>            :      */
<span class="lineNum">    2779 </span><span class="lineCov">      23598 :     TerminateBufferIO(buf, true, 0);</span>
<span class="lineNum">    2780 </span>            : 
<span class="lineNum">    2781 </span>            :     TRACE_POSTGRESQL_BUFFER_FLUSH_DONE(buf-&gt;tag.forkNum,
<span class="lineNum">    2782 </span>            :                                        buf-&gt;tag.blockNum,
<span class="lineNum">    2783 </span>            :                                        reln-&gt;smgr_rnode.node.spcNode,
<span class="lineNum">    2784 </span>            :                                        reln-&gt;smgr_rnode.node.dbNode,
<span class="lineNum">    2785 </span>            :                                        reln-&gt;smgr_rnode.node.relNode);
<span class="lineNum">    2786 </span>            : 
<span class="lineNum">    2787 </span>            :     /* Pop the error context stack */
<span class="lineNum">    2788 </span><span class="lineCov">      23598 :     error_context_stack = errcallback.previous;</span>
<span class="lineNum">    2789 </span>            : }
<span class="lineNum">    2790 </span>            : 
<span class="lineNum">    2791 </span>            : /*
<span class="lineNum">    2792 </span>            :  * RelationGetNumberOfBlocksInFork
<span class="lineNum">    2793 </span>            :  *      Determines the current number of pages in the specified relation fork.
<span class="lineNum">    2794 </span>            :  *
<span class="lineNum">    2795 </span>            :  * Note that the accuracy of the result will depend on the details of the
<span class="lineNum">    2796 </span>            :  * relation's storage. For builtin AMs it'll be accurate, but for external AMs
<span class="lineNum">    2797 </span>            :  * it might not be.
<a name="2798"><span class="lineNum">    2798 </span>            :  */</a>
<span class="lineNum">    2799 </span>            : BlockNumber
<span class="lineNum">    2800 </span><span class="lineCov">     232172 : RelationGetNumberOfBlocksInFork(Relation relation, ForkNumber forkNum)</span>
<span class="lineNum">    2801 </span>            : {
<span class="lineNum">    2802 </span><span class="lineCov">     232172 :     switch (relation-&gt;rd_rel-&gt;relkind)</span>
<span class="lineNum">    2803 </span>            :     {
<span class="lineNum">    2804 </span>            :         case RELKIND_SEQUENCE:
<span class="lineNum">    2805 </span>            :         case RELKIND_INDEX:
<span class="lineNum">    2806 </span>            :         case RELKIND_PARTITIONED_INDEX:
<span class="lineNum">    2807 </span>            :             /* Open it at the smgr level if not already done */
<span class="lineNum">    2808 </span><span class="lineCov">      85378 :             RelationOpenSmgr(relation);</span>
<span class="lineNum">    2809 </span>            : 
<span class="lineNum">    2810 </span><span class="lineCov">      85378 :             return smgrnblocks(relation-&gt;rd_smgr, forkNum);</span>
<span class="lineNum">    2811 </span>            : 
<span class="lineNum">    2812 </span>            :         case RELKIND_RELATION:
<span class="lineNum">    2813 </span>            :         case RELKIND_TOASTVALUE:
<span class="lineNum">    2814 </span>            :         case RELKIND_MATVIEW:
<span class="lineNum">    2815 </span>            :             {
<span class="lineNum">    2816 </span>            :                 /*
<span class="lineNum">    2817 </span>            :                  * Not every table AM uses BLCKSZ wide fixed size blocks.
<span class="lineNum">    2818 </span>            :                  * Therefore tableam returns the size in bytes - but for the
<span class="lineNum">    2819 </span>            :                  * purpose of this routine, we want the number of blocks.
<span class="lineNum">    2820 </span>            :                  * Therefore divide, rounding up.
<span class="lineNum">    2821 </span>            :                  */
<span class="lineNum">    2822 </span>            :                 uint64      szbytes;
<span class="lineNum">    2823 </span>            : 
<span class="lineNum">    2824 </span><span class="lineCov">     146794 :                 szbytes = table_relation_size(relation, forkNum);</span>
<span class="lineNum">    2825 </span>            : 
<span class="lineNum">    2826 </span><span class="lineCov">     146794 :                 return (szbytes + (BLCKSZ - 1)) / BLCKSZ;</span>
<span class="lineNum">    2827 </span>            :             }
<span class="lineNum">    2828 </span>            :         case RELKIND_VIEW:
<span class="lineNum">    2829 </span>            :         case RELKIND_COMPOSITE_TYPE:
<span class="lineNum">    2830 </span>            :         case RELKIND_FOREIGN_TABLE:
<span class="lineNum">    2831 </span>            :         case RELKIND_PARTITIONED_TABLE:
<span class="lineNum">    2832 </span>            :         default:
<span class="lineNum">    2833 </span><span class="lineNoCov">          0 :             Assert(false);</span>
<span class="lineNum">    2834 </span>            :             break;
<span class="lineNum">    2835 </span>            :     }
<span class="lineNum">    2836 </span>            : 
<span class="lineNum">    2837 </span>            :     return 0;                   /* keep compiler quiet */
<span class="lineNum">    2838 </span>            : }
<span class="lineNum">    2839 </span>            : 
<span class="lineNum">    2840 </span>            : /*
<span class="lineNum">    2841 </span>            :  * BufferIsPermanent
<span class="lineNum">    2842 </span>            :  *      Determines whether a buffer will potentially still be around after
<span class="lineNum">    2843 </span>            :  *      a crash.  Caller must hold a buffer pin.
<a name="2844"><span class="lineNum">    2844 </span>            :  */</a>
<span class="lineNum">    2845 </span>            : bool
<span class="lineNum">    2846 </span><span class="lineCov">    2368250 : BufferIsPermanent(Buffer buffer)</span>
<span class="lineNum">    2847 </span>            : {
<span class="lineNum">    2848 </span>            :     BufferDesc *bufHdr;
<span class="lineNum">    2849 </span>            : 
<span class="lineNum">    2850 </span>            :     /* Local buffers are used only for temp relations. */
<span class="lineNum">    2851 </span><span class="lineCov">    2368250 :     if (BufferIsLocal(buffer))</span>
<span class="lineNum">    2852 </span><span class="lineCov">     224346 :         return false;</span>
<span class="lineNum">    2853 </span>            : 
<span class="lineNum">    2854 </span>            :     /* Make sure we've got a real buffer, and that we hold a pin on it. */
<span class="lineNum">    2855 </span><span class="lineCov">    2143904 :     Assert(BufferIsValid(buffer));</span>
<span class="lineNum">    2856 </span><span class="lineCov">    2143904 :     Assert(BufferIsPinned(buffer));</span>
<span class="lineNum">    2857 </span>            : 
<span class="lineNum">    2858 </span>            :     /*
<span class="lineNum">    2859 </span>            :      * BM_PERMANENT can't be changed while we hold a pin on the buffer, so we
<span class="lineNum">    2860 </span>            :      * need not bother with the buffer header spinlock.  Even if someone else
<span class="lineNum">    2861 </span>            :      * changes the buffer header state while we're doing this, the state is
<span class="lineNum">    2862 </span>            :      * changed atomically, so we'll read the old value or the new value, but
<span class="lineNum">    2863 </span>            :      * not random garbage.
<span class="lineNum">    2864 </span>            :      */
<span class="lineNum">    2865 </span><span class="lineCov">    2143904 :     bufHdr = GetBufferDescriptor(buffer - 1);</span>
<span class="lineNum">    2866 </span><span class="lineCov">    2143904 :     return (pg_atomic_read_u32(&amp;bufHdr-&gt;state) &amp; BM_PERMANENT) != 0;</span>
<span class="lineNum">    2867 </span>            : }
<span class="lineNum">    2868 </span>            : 
<span class="lineNum">    2869 </span>            : /*
<span class="lineNum">    2870 </span>            :  * BufferGetLSNAtomic
<span class="lineNum">    2871 </span>            :  *      Retrieves the LSN of the buffer atomically using a buffer header lock.
<span class="lineNum">    2872 </span>            :  *      This is necessary for some callers who may not have an exclusive lock
<span class="lineNum">    2873 </span>            :  *      on the buffer.
<a name="2874"><span class="lineNum">    2874 </span>            :  */</a>
<span class="lineNum">    2875 </span>            : XLogRecPtr
<span class="lineNum">    2876 </span><span class="lineCov">    1815354 : BufferGetLSNAtomic(Buffer buffer)</span>
<span class="lineNum">    2877 </span>            : {
<span class="lineNum">    2878 </span><span class="lineCov">    1815354 :     BufferDesc *bufHdr = GetBufferDescriptor(buffer - 1);</span>
<span class="lineNum">    2879 </span><span class="lineCov">    1815354 :     char       *page = BufferGetPage(buffer);</span>
<span class="lineNum">    2880 </span>            :     XLogRecPtr  lsn;
<span class="lineNum">    2881 </span>            :     uint32      buf_state;
<span class="lineNum">    2882 </span>            : 
<span class="lineNum">    2883 </span>            :     /*
<span class="lineNum">    2884 </span>            :      * If we don't need locking for correctness, fastpath out.
<span class="lineNum">    2885 </span>            :      */
<span class="lineNum">    2886 </span><span class="lineCov">    1815354 :     if (!XLogHintBitIsNeeded() || BufferIsLocal(buffer))</span>
<span class="lineNum">    2887 </span><span class="lineCov">    1815354 :         return PageGetLSN(page);</span>
<span class="lineNum">    2888 </span>            : 
<span class="lineNum">    2889 </span>            :     /* Make sure we've got a real buffer, and that we hold a pin on it. */
<span class="lineNum">    2890 </span><span class="lineNoCov">          0 :     Assert(BufferIsValid(buffer));</span>
<span class="lineNum">    2891 </span><span class="lineNoCov">          0 :     Assert(BufferIsPinned(buffer));</span>
<span class="lineNum">    2892 </span>            : 
<span class="lineNum">    2893 </span><span class="lineNoCov">          0 :     buf_state = LockBufHdr(bufHdr);</span>
<span class="lineNum">    2894 </span><span class="lineNoCov">          0 :     lsn = PageGetLSN(page);</span>
<span class="lineNum">    2895 </span><span class="lineNoCov">          0 :     UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    2896 </span>            : 
<span class="lineNum">    2897 </span><span class="lineNoCov">          0 :     return lsn;</span>
<span class="lineNum">    2898 </span>            : }
<span class="lineNum">    2899 </span>            : 
<span class="lineNum">    2900 </span>            : /* ---------------------------------------------------------------------
<span class="lineNum">    2901 </span>            :  *      DropRelFileNodeBuffers
<span class="lineNum">    2902 </span>            :  *
<span class="lineNum">    2903 </span>            :  *      This function removes from the buffer pool all the pages of the
<span class="lineNum">    2904 </span>            :  *      specified relation forks that have block numbers &gt;= firstDelBlock.
<span class="lineNum">    2905 </span>            :  *      (In particular, with firstDelBlock = 0, all pages are removed.)
<span class="lineNum">    2906 </span>            :  *      Dirty pages are simply dropped, without bothering to write them
<span class="lineNum">    2907 </span>            :  *      out first.  Therefore, this is NOT rollback-able, and so should be
<span class="lineNum">    2908 </span>            :  *      used only with extreme caution!
<span class="lineNum">    2909 </span>            :  *
<span class="lineNum">    2910 </span>            :  *      Currently, this is called only from smgr.c when the underlying file
<span class="lineNum">    2911 </span>            :  *      is about to be deleted or truncated (firstDelBlock is needed for
<span class="lineNum">    2912 </span>            :  *      the truncation case).  The data in the affected pages would therefore
<span class="lineNum">    2913 </span>            :  *      be deleted momentarily anyway, and there is no point in writing it.
<span class="lineNum">    2914 </span>            :  *      It is the responsibility of higher-level code to ensure that the
<span class="lineNum">    2915 </span>            :  *      deletion or truncation does not lose any data that could be needed
<span class="lineNum">    2916 </span>            :  *      later.  It is also the responsibility of higher-level code to ensure
<span class="lineNum">    2917 </span>            :  *      that no other process could be trying to load more pages of the
<span class="lineNum">    2918 </span>            :  *      relation into buffers.
<span class="lineNum">    2919 </span>            :  *
<span class="lineNum">    2920 </span>            :  *      XXX currently it sequentially searches the buffer pool, should be
<span class="lineNum">    2921 </span>            :  *      changed to more clever ways of searching.  However, this routine
<span class="lineNum">    2922 </span>            :  *      is used only in code paths that aren't very performance-critical,
<span class="lineNum">    2923 </span>            :  *      and we shouldn't slow down the hot paths to make it faster ...
<span class="lineNum">    2924 </span>            :  * --------------------------------------------------------------------
<a name="2925"><span class="lineNum">    2925 </span>            :  */</a>
<span class="lineNum">    2926 </span>            : void
<span class="lineNum">    2927 </span><span class="lineCov">       1804 : DropRelFileNodeBuffers(RelFileNodeBackend rnode, ForkNumber *forkNum,</span>
<span class="lineNum">    2928 </span>            :                        int nforks, BlockNumber *firstDelBlock)
<span class="lineNum">    2929 </span>            : {
<span class="lineNum">    2930 </span>            :     int         i;
<span class="lineNum">    2931 </span>            :     int         j;
<span class="lineNum">    2932 </span>            : 
<span class="lineNum">    2933 </span>            :     /* If it's a local relation, it's localbuf.c's problem. */
<span class="lineNum">    2934 </span><span class="lineCov">       1804 :     if (RelFileNodeBackendIsTemp(rnode))</span>
<span class="lineNum">    2935 </span>            :     {
<span class="lineNum">    2936 </span><span class="lineCov">       1766 :         if (rnode.backend == MyBackendId)</span>
<span class="lineNum">    2937 </span>            :         {
<span class="lineNum">    2938 </span><span class="lineCov">       3532 :             for (j = 0; j &lt; nforks; j++)</span>
<span class="lineNum">    2939 </span><span class="lineCov">       1766 :                 DropRelFileNodeLocalBuffers(rnode.node, forkNum[j],</span>
<span class="lineNum">    2940 </span><span class="lineCov">       1766 :                                             firstDelBlock[j]);</span>
<span class="lineNum">    2941 </span>            :         }
<span class="lineNum">    2942 </span><span class="lineCov">       3570 :         return;</span>
<span class="lineNum">    2943 </span>            :     }
<span class="lineNum">    2944 </span>            : 
<span class="lineNum">    2945 </span><span class="lineCov">     622630 :     for (i = 0; i &lt; NBuffers; i++)</span>
<span class="lineNum">    2946 </span>            :     {
<span class="lineNum">    2947 </span><span class="lineCov">     622592 :         BufferDesc *bufHdr = GetBufferDescriptor(i);</span>
<span class="lineNum">    2948 </span>            :         uint32      buf_state;
<span class="lineNum">    2949 </span>            : 
<span class="lineNum">    2950 </span>            :         /*
<span class="lineNum">    2951 </span>            :          * We can make this a tad faster by prechecking the buffer tag before
<span class="lineNum">    2952 </span>            :          * we attempt to lock the buffer; this saves a lot of lock
<span class="lineNum">    2953 </span>            :          * acquisitions in typical cases.  It should be safe because the
<span class="lineNum">    2954 </span>            :          * caller must have AccessExclusiveLock on the relation, or some other
<span class="lineNum">    2955 </span>            :          * reason to be certain that no one is loading new pages of the rel
<span class="lineNum">    2956 </span>            :          * into the buffer pool.  (Otherwise we might well miss such pages
<span class="lineNum">    2957 </span>            :          * entirely.)  Therefore, while the tag might be changing while we
<span class="lineNum">    2958 </span>            :          * look at it, it can't be changing *to* a value we care about, only
<span class="lineNum">    2959 </span>            :          * *away* from such a value.  So false negatives are impossible, and
<span class="lineNum">    2960 </span>            :          * false positives are safe because we'll recheck after getting the
<span class="lineNum">    2961 </span>            :          * buffer lock.
<span class="lineNum">    2962 </span>            :          *
<span class="lineNum">    2963 </span>            :          * We could check forkNum and blockNum as well as the rnode, but the
<span class="lineNum">    2964 </span>            :          * incremental win from doing so seems small.
<span class="lineNum">    2965 </span>            :          */
<span class="lineNum">    2966 </span><span class="lineCov">     622592 :         if (!RelFileNodeEquals(bufHdr-&gt;tag.rnode, rnode.node))</span>
<span class="lineNum">    2967 </span><span class="lineCov">     621202 :             continue;</span>
<span class="lineNum">    2968 </span>            : 
<span class="lineNum">    2969 </span><span class="lineCov">       1390 :         buf_state = LockBufHdr(bufHdr);</span>
<span class="lineNum">    2970 </span>            : 
<span class="lineNum">    2971 </span><span class="lineCov">       3554 :         for (j = 0; j &lt; nforks; j++)</span>
<span class="lineNum">    2972 </span>            :         {
<span class="lineNum">    2973 </span><span class="lineCov">       5004 :             if (RelFileNodeEquals(bufHdr-&gt;tag.rnode, rnode.node) &amp;&amp;</span>
<span class="lineNum">    2974 </span><span class="lineCov">       3866 :                 bufHdr-&gt;tag.forkNum == forkNum[j] &amp;&amp;</span>
<span class="lineNum">    2975 </span><span class="lineCov">       1364 :                 bufHdr-&gt;tag.blockNum &gt;= firstDelBlock[j])</span>
<span class="lineNum">    2976 </span>            :             {
<span class="lineNum">    2977 </span><span class="lineCov">        338 :                 InvalidateBuffer(bufHdr); /* releases spinlock */</span>
<span class="lineNum">    2978 </span><span class="lineCov">        338 :                 break;</span>
<span class="lineNum">    2979 </span>            :             }
<span class="lineNum">    2980 </span>            :         }
<span class="lineNum">    2981 </span><span class="lineCov">       1390 :         if (j &gt;= nforks)</span>
<span class="lineNum">    2982 </span><span class="lineCov">       1052 :             UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    2983 </span>            :     }
<span class="lineNum">    2984 </span>            : }
<span class="lineNum">    2985 </span>            : 
<span class="lineNum">    2986 </span>            : /* ---------------------------------------------------------------------
<span class="lineNum">    2987 </span>            :  *      DropRelFileNodesAllBuffers
<span class="lineNum">    2988 </span>            :  *
<span class="lineNum">    2989 </span>            :  *      This function removes from the buffer pool all the pages of all
<span class="lineNum">    2990 </span>            :  *      forks of the specified relations.  It's equivalent to calling
<span class="lineNum">    2991 </span>            :  *      DropRelFileNodeBuffers once per fork per relation with
<span class="lineNum">    2992 </span>            :  *      firstDelBlock = 0.
<span class="lineNum">    2993 </span>            :  * --------------------------------------------------------------------
<a name="2994"><span class="lineNum">    2994 </span>            :  */</a>
<span class="lineNum">    2995 </span>            : void
<span class="lineNum">    2996 </span><span class="lineCov">       3250 : DropRelFileNodesAllBuffers(RelFileNodeBackend *rnodes, int nnodes)</span>
<span class="lineNum">    2997 </span>            : {
<span class="lineNum">    2998 </span>            :     int         i,
<span class="lineNum">    2999 </span><span class="lineCov">       3250 :                 n = 0;</span>
<span class="lineNum">    3000 </span>            :     RelFileNode *nodes;
<span class="lineNum">    3001 </span>            :     bool        use_bsearch;
<span class="lineNum">    3002 </span>            : 
<span class="lineNum">    3003 </span><span class="lineCov">       3250 :     if (nnodes == 0)</span>
<span class="lineNum">    3004 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    3005 </span>            : 
<span class="lineNum">    3006 </span><span class="lineCov">       3250 :     nodes = palloc(sizeof(RelFileNode) * nnodes);   /* non-local relations */</span>
<span class="lineNum">    3007 </span>            : 
<span class="lineNum">    3008 </span>            :     /* If it's a local relation, it's localbuf.c's problem. */
<span class="lineNum">    3009 </span><span class="lineCov">      15556 :     for (i = 0; i &lt; nnodes; i++)</span>
<span class="lineNum">    3010 </span>            :     {
<span class="lineNum">    3011 </span><span class="lineCov">      12306 :         if (RelFileNodeBackendIsTemp(rnodes[i]))</span>
<span class="lineNum">    3012 </span>            :         {
<span class="lineNum">    3013 </span><span class="lineCov">       2948 :             if (rnodes[i].backend == MyBackendId)</span>
<span class="lineNum">    3014 </span><span class="lineCov">       2948 :                 DropRelFileNodeAllLocalBuffers(rnodes[i].node);</span>
<span class="lineNum">    3015 </span>            :         }
<span class="lineNum">    3016 </span>            :         else
<span class="lineNum">    3017 </span><span class="lineCov">       9358 :             nodes[n++] = rnodes[i].node;</span>
<span class="lineNum">    3018 </span>            :     }
<span class="lineNum">    3019 </span>            : 
<span class="lineNum">    3020 </span>            :     /*
<span class="lineNum">    3021 </span>            :      * If there are no non-local relations, then we're done. Release the
<span class="lineNum">    3022 </span>            :      * memory and return.
<span class="lineNum">    3023 </span>            :      */
<span class="lineNum">    3024 </span><span class="lineCov">       3250 :     if (n == 0)</span>
<span class="lineNum">    3025 </span>            :     {
<span class="lineNum">    3026 </span><span class="lineCov">        510 :         pfree(nodes);</span>
<span class="lineNum">    3027 </span><span class="lineCov">        510 :         return;</span>
<span class="lineNum">    3028 </span>            :     }
<span class="lineNum">    3029 </span>            : 
<span class="lineNum">    3030 </span>            :     /*
<span class="lineNum">    3031 </span>            :      * For low number of relations to drop just use a simple walk through, to
<span class="lineNum">    3032 </span>            :      * save the bsearch overhead. The threshold to use is rather a guess than
<span class="lineNum">    3033 </span>            :      * an exactly determined value, as it depends on many factors (CPU and RAM
<span class="lineNum">    3034 </span>            :      * speeds, amount of shared buffers etc.).
<span class="lineNum">    3035 </span>            :      */
<span class="lineNum">    3036 </span><span class="lineCov">       2740 :     use_bsearch = n &gt; DROP_RELS_BSEARCH_THRESHOLD;</span>
<span class="lineNum">    3037 </span>            : 
<span class="lineNum">    3038 </span>            :     /* sort the list of rnodes if necessary */
<span class="lineNum">    3039 </span><span class="lineCov">       2740 :     if (use_bsearch)</span>
<span class="lineNum">    3040 </span><span class="lineCov">         56 :         pg_qsort(nodes, n, sizeof(RelFileNode), rnode_comparator);</span>
<span class="lineNum">    3041 </span>            : 
<span class="lineNum">    3042 </span><span class="lineCov">   44894900 :     for (i = 0; i &lt; NBuffers; i++)</span>
<span class="lineNum">    3043 </span>            :     {
<span class="lineNum">    3044 </span><span class="lineCov">   44892160 :         RelFileNode *rnode = NULL;</span>
<span class="lineNum">    3045 </span><span class="lineCov">   44892160 :         BufferDesc *bufHdr = GetBufferDescriptor(i);</span>
<span class="lineNum">    3046 </span>            :         uint32      buf_state;
<span class="lineNum">    3047 </span>            : 
<span class="lineNum">    3048 </span>            :         /*
<span class="lineNum">    3049 </span>            :          * As in DropRelFileNodeBuffers, an unlocked precheck should be safe
<span class="lineNum">    3050 </span>            :          * and saves some cycles.
<span class="lineNum">    3051 </span>            :          */
<span class="lineNum">    3052 </span>            : 
<span class="lineNum">    3053 </span><span class="lineCov">   44892160 :         if (!use_bsearch)</span>
<span class="lineNum">    3054 </span>            :         {
<span class="lineNum">    3055 </span>            :             int         j;
<span class="lineNum">    3056 </span>            : 
<span class="lineNum">    3057 </span><span class="lineCov">  168761378 :             for (j = 0; j &lt; n; j++)</span>
<span class="lineNum">    3058 </span>            :             {
<span class="lineNum">    3059 </span><span class="lineCov">  124809462 :                 if (RelFileNodeEquals(bufHdr-&gt;tag.rnode, nodes[j]))</span>
<span class="lineNum">    3060 </span>            :                 {
<span class="lineNum">    3061 </span><span class="lineCov">      22740 :                     rnode = &amp;nodes[j];</span>
<span class="lineNum">    3062 </span><span class="lineCov">      22740 :                     break;</span>
<span class="lineNum">    3063 </span>            :                 }
<span class="lineNum">    3064 </span>            :             }
<span class="lineNum">    3065 </span>            :         }
<span class="lineNum">    3066 </span>            :         else
<span class="lineNum">    3067 </span>            :         {
<span class="lineNum">    3068 </span><span class="lineCov">     917504 :             rnode = bsearch((const void *) &amp;(bufHdr-&gt;tag.rnode),</span>
<span class="lineNum">    3069 </span>            :                             nodes, n, sizeof(RelFileNode),
<span class="lineNum">    3070 </span>            :                             rnode_comparator);
<span class="lineNum">    3071 </span>            :         }
<span class="lineNum">    3072 </span>            : 
<span class="lineNum">    3073 </span>            :         /* buffer doesn't belong to any of the given relfilenodes; skip it */
<span class="lineNum">    3074 </span><span class="lineCov">   44892160 :         if (rnode == NULL)</span>
<span class="lineNum">    3075 </span><span class="lineCov">   44869100 :             continue;</span>
<span class="lineNum">    3076 </span>            : 
<span class="lineNum">    3077 </span><span class="lineCov">      23060 :         buf_state = LockBufHdr(bufHdr);</span>
<span class="lineNum">    3078 </span><span class="lineCov">      23060 :         if (RelFileNodeEquals(bufHdr-&gt;tag.rnode, (*rnode)))</span>
<span class="lineNum">    3079 </span><span class="lineCov">      23060 :             InvalidateBuffer(bufHdr);   /* releases spinlock */</span>
<span class="lineNum">    3080 </span>            :         else
<span class="lineNum">    3081 </span><span class="lineNoCov">          0 :             UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    3082 </span>            :     }
<span class="lineNum">    3083 </span>            : 
<span class="lineNum">    3084 </span><span class="lineCov">       2740 :     pfree(nodes);</span>
<span class="lineNum">    3085 </span>            : }
<span class="lineNum">    3086 </span>            : 
<span class="lineNum">    3087 </span>            : /* ---------------------------------------------------------------------
<span class="lineNum">    3088 </span>            :  *      DropDatabaseBuffers
<span class="lineNum">    3089 </span>            :  *
<span class="lineNum">    3090 </span>            :  *      This function removes all the buffers in the buffer cache for a
<span class="lineNum">    3091 </span>            :  *      particular database.  Dirty pages are simply dropped, without
<span class="lineNum">    3092 </span>            :  *      bothering to write them out first.  This is used when we destroy a
<span class="lineNum">    3093 </span>            :  *      database, to avoid trying to flush data to disk when the directory
<span class="lineNum">    3094 </span>            :  *      tree no longer exists.  Implementation is pretty similar to
<span class="lineNum">    3095 </span>            :  *      DropRelFileNodeBuffers() which is for destroying just one relation.
<span class="lineNum">    3096 </span>            :  * --------------------------------------------------------------------
<a name="3097"><span class="lineNum">    3097 </span>            :  */</a>
<span class="lineNum">    3098 </span>            : void
<span class="lineNum">    3099 </span><span class="lineNoCov">          0 : DropDatabaseBuffers(Oid dbid)</span>
<span class="lineNum">    3100 </span>            : {
<span class="lineNum">    3101 </span>            :     int         i;
<span class="lineNum">    3102 </span>            : 
<span class="lineNum">    3103 </span>            :     /*
<span class="lineNum">    3104 </span>            :      * We needn't consider local buffers, since by assumption the target
<span class="lineNum">    3105 </span>            :      * database isn't our own.
<span class="lineNum">    3106 </span>            :      */
<span class="lineNum">    3107 </span>            : 
<span class="lineNum">    3108 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; NBuffers; i++)</span>
<span class="lineNum">    3109 </span>            :     {
<span class="lineNum">    3110 </span><span class="lineNoCov">          0 :         BufferDesc *bufHdr = GetBufferDescriptor(i);</span>
<span class="lineNum">    3111 </span>            :         uint32      buf_state;
<span class="lineNum">    3112 </span>            : 
<span class="lineNum">    3113 </span>            :         /*
<span class="lineNum">    3114 </span>            :          * As in DropRelFileNodeBuffers, an unlocked precheck should be safe
<span class="lineNum">    3115 </span>            :          * and saves some cycles.
<span class="lineNum">    3116 </span>            :          */
<span class="lineNum">    3117 </span><span class="lineNoCov">          0 :         if (bufHdr-&gt;tag.rnode.dbNode != dbid)</span>
<span class="lineNum">    3118 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    3119 </span>            : 
<span class="lineNum">    3120 </span><span class="lineNoCov">          0 :         buf_state = LockBufHdr(bufHdr);</span>
<span class="lineNum">    3121 </span><span class="lineNoCov">          0 :         if (bufHdr-&gt;tag.rnode.dbNode == dbid)</span>
<span class="lineNum">    3122 </span><span class="lineNoCov">          0 :             InvalidateBuffer(bufHdr);   /* releases spinlock */</span>
<span class="lineNum">    3123 </span>            :         else
<span class="lineNum">    3124 </span><span class="lineNoCov">          0 :             UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    3125 </span>            :     }
<span class="lineNum">    3126 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3127 </span>            : 
<span class="lineNum">    3128 </span>            : /* -----------------------------------------------------------------
<span class="lineNum">    3129 </span>            :  *      PrintBufferDescs
<span class="lineNum">    3130 </span>            :  *
<span class="lineNum">    3131 </span>            :  *      this function prints all the buffer descriptors, for debugging
<span class="lineNum">    3132 </span>            :  *      use only.
<span class="lineNum">    3133 </span>            :  * -----------------------------------------------------------------
<span class="lineNum">    3134 </span>            :  */
<span class="lineNum">    3135 </span>            : #ifdef NOT_USED
<span class="lineNum">    3136 </span>            : void
<span class="lineNum">    3137 </span>            : PrintBufferDescs(void)
<span class="lineNum">    3138 </span>            : {
<span class="lineNum">    3139 </span>            :     int         i;
<span class="lineNum">    3140 </span>            : 
<span class="lineNum">    3141 </span>            :     for (i = 0; i &lt; NBuffers; ++i)
<span class="lineNum">    3142 </span>            :     {
<span class="lineNum">    3143 </span>            :         BufferDesc *buf = GetBufferDescriptor(i);
<span class="lineNum">    3144 </span>            :         Buffer      b = BufferDescriptorGetBuffer(buf);
<span class="lineNum">    3145 </span>            : 
<span class="lineNum">    3146 </span>            :         /* theoretically we should lock the bufhdr here */
<span class="lineNum">    3147 </span>            :         elog(LOG,
<span class="lineNum">    3148 </span>            :              &quot;[%02d] (freeNext=%d, rel=%s, &quot;
<span class="lineNum">    3149 </span>            :              &quot;blockNum=%u, flags=0x%x, refcount=%u %d)&quot;,
<span class="lineNum">    3150 </span>            :              i, buf-&gt;freeNext,
<span class="lineNum">    3151 </span>            :              relpathbackend(buf-&gt;tag.rnode, InvalidBackendId, buf-&gt;tag.forkNum),
<span class="lineNum">    3152 </span>            :              buf-&gt;tag.blockNum, buf-&gt;flags,
<span class="lineNum">    3153 </span>            :              buf-&gt;refcount, GetPrivateRefCount(b));
<span class="lineNum">    3154 </span>            :     }
<span class="lineNum">    3155 </span>            : }
<span class="lineNum">    3156 </span>            : #endif
<span class="lineNum">    3157 </span>            : 
<span class="lineNum">    3158 </span>            : #ifdef NOT_USED
<span class="lineNum">    3159 </span>            : void
<span class="lineNum">    3160 </span>            : PrintPinnedBufs(void)
<span class="lineNum">    3161 </span>            : {
<span class="lineNum">    3162 </span>            :     int         i;
<span class="lineNum">    3163 </span>            : 
<span class="lineNum">    3164 </span>            :     for (i = 0; i &lt; NBuffers; ++i)
<span class="lineNum">    3165 </span>            :     {
<span class="lineNum">    3166 </span>            :         BufferDesc *buf = GetBufferDescriptor(i);
<span class="lineNum">    3167 </span>            :         Buffer      b = BufferDescriptorGetBuffer(buf);
<span class="lineNum">    3168 </span>            : 
<span class="lineNum">    3169 </span>            :         if (GetPrivateRefCount(b) &gt; 0)
<span class="lineNum">    3170 </span>            :         {
<span class="lineNum">    3171 </span>            :             /* theoretically we should lock the bufhdr here */
<span class="lineNum">    3172 </span>            :             elog(LOG,
<span class="lineNum">    3173 </span>            :                  &quot;[%02d] (freeNext=%d, rel=%s, &quot;
<span class="lineNum">    3174 </span>            :                  &quot;blockNum=%u, flags=0x%x, refcount=%u %d)&quot;,
<span class="lineNum">    3175 </span>            :                  i, buf-&gt;freeNext,
<span class="lineNum">    3176 </span>            :                  relpathperm(buf-&gt;tag.rnode, buf-&gt;tag.forkNum),
<span class="lineNum">    3177 </span>            :                  buf-&gt;tag.blockNum, buf-&gt;flags,
<span class="lineNum">    3178 </span>            :                  buf-&gt;refcount, GetPrivateRefCount(b));
<span class="lineNum">    3179 </span>            :         }
<span class="lineNum">    3180 </span>            :     }
<span class="lineNum">    3181 </span>            : }
<span class="lineNum">    3182 </span>            : #endif
<span class="lineNum">    3183 </span>            : 
<span class="lineNum">    3184 </span>            : /* ---------------------------------------------------------------------
<span class="lineNum">    3185 </span>            :  *      FlushRelationBuffers
<span class="lineNum">    3186 </span>            :  *
<span class="lineNum">    3187 </span>            :  *      This function writes all dirty pages of a relation out to disk
<span class="lineNum">    3188 </span>            :  *      (or more accurately, out to kernel disk buffers), ensuring that the
<span class="lineNum">    3189 </span>            :  *      kernel has an up-to-date view of the relation.
<span class="lineNum">    3190 </span>            :  *
<span class="lineNum">    3191 </span>            :  *      Generally, the caller should be holding AccessExclusiveLock on the
<span class="lineNum">    3192 </span>            :  *      target relation to ensure that no other backend is busy dirtying
<span class="lineNum">    3193 </span>            :  *      more blocks of the relation; the effects can't be expected to last
<span class="lineNum">    3194 </span>            :  *      after the lock is released.
<span class="lineNum">    3195 </span>            :  *
<span class="lineNum">    3196 </span>            :  *      XXX currently it sequentially searches the buffer pool, should be
<span class="lineNum">    3197 </span>            :  *      changed to more clever ways of searching.  This routine is not
<span class="lineNum">    3198 </span>            :  *      used in any performance-critical code paths, so it's not worth
<span class="lineNum">    3199 </span>            :  *      adding additional overhead to normal paths to make it go faster;
<span class="lineNum">    3200 </span>            :  *      but see also DropRelFileNodeBuffers.
<span class="lineNum">    3201 </span>            :  * --------------------------------------------------------------------
<a name="3202"><span class="lineNum">    3202 </span>            :  */</a>
<span class="lineNum">    3203 </span>            : void
<span class="lineNum">    3204 </span><span class="lineCov">        104 : FlushRelationBuffers(Relation rel)</span>
<span class="lineNum">    3205 </span>            : {
<span class="lineNum">    3206 </span>            :     int         i;
<span class="lineNum">    3207 </span>            :     BufferDesc *bufHdr;
<span class="lineNum">    3208 </span>            : 
<span class="lineNum">    3209 </span>            :     /* Open rel at the smgr level if not already done */
<span class="lineNum">    3210 </span><span class="lineCov">        104 :     RelationOpenSmgr(rel);</span>
<span class="lineNum">    3211 </span>            : 
<span class="lineNum">    3212 </span><span class="lineCov">        104 :     if (RelationUsesLocalBuffers(rel))</span>
<span class="lineNum">    3213 </span>            :     {
<span class="lineNum">    3214 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; NLocBuffer; i++)</span>
<span class="lineNum">    3215 </span>            :         {
<span class="lineNum">    3216 </span>            :             uint32      buf_state;
<span class="lineNum">    3217 </span>            : 
<span class="lineNum">    3218 </span><span class="lineNoCov">          0 :             bufHdr = GetLocalBufferDescriptor(i);</span>
<span class="lineNum">    3219 </span><span class="lineNoCov">          0 :             if (RelFileNodeEquals(bufHdr-&gt;tag.rnode, rel-&gt;rd_node) &amp;&amp;</span>
<span class="lineNum">    3220 </span><span class="lineNoCov">          0 :                 ((buf_state = pg_atomic_read_u32(&amp;bufHdr-&gt;state)) &amp;</span>
<span class="lineNum">    3221 </span>            :                  (BM_VALID | BM_DIRTY)) == (BM_VALID | BM_DIRTY))
<span class="lineNum">    3222 </span>            :             {
<span class="lineNum">    3223 </span>            :                 ErrorContextCallback errcallback;
<span class="lineNum">    3224 </span>            :                 Page        localpage;
<span class="lineNum">    3225 </span>            : 
<span class="lineNum">    3226 </span><span class="lineNoCov">          0 :                 localpage = (char *) LocalBufHdrGetBlock(bufHdr);</span>
<span class="lineNum">    3227 </span>            : 
<span class="lineNum">    3228 </span>            :                 /* Setup error traceback support for ereport() */
<span class="lineNum">    3229 </span><span class="lineNoCov">          0 :                 errcallback.callback = local_buffer_write_error_callback;</span>
<span class="lineNum">    3230 </span><span class="lineNoCov">          0 :                 errcallback.arg = (void *) bufHdr;</span>
<span class="lineNum">    3231 </span><span class="lineNoCov">          0 :                 errcallback.previous = error_context_stack;</span>
<span class="lineNum">    3232 </span><span class="lineNoCov">          0 :                 error_context_stack = &amp;errcallback;</span>
<span class="lineNum">    3233 </span>            : 
<span class="lineNum">    3234 </span><span class="lineNoCov">          0 :                 PageSetChecksumInplace(localpage, bufHdr-&gt;tag.blockNum);</span>
<span class="lineNum">    3235 </span>            : 
<span class="lineNum">    3236 </span><span class="lineNoCov">          0 :                 smgrwrite(rel-&gt;rd_smgr,</span>
<span class="lineNum">    3237 </span>            :                           bufHdr-&gt;tag.forkNum,
<span class="lineNum">    3238 </span>            :                           bufHdr-&gt;tag.blockNum,
<span class="lineNum">    3239 </span>            :                           localpage,
<span class="lineNum">    3240 </span>            :                           false);
<span class="lineNum">    3241 </span>            : 
<span class="lineNum">    3242 </span><span class="lineNoCov">          0 :                 buf_state &amp;= ~(BM_DIRTY | BM_JUST_DIRTIED);</span>
<span class="lineNum">    3243 </span><span class="lineNoCov">          0 :                 pg_atomic_unlocked_write_u32(&amp;bufHdr-&gt;state, buf_state);</span>
<span class="lineNum">    3244 </span>            : 
<span class="lineNum">    3245 </span>            :                 /* Pop the error context stack */
<span class="lineNum">    3246 </span><span class="lineNoCov">          0 :                 error_context_stack = errcallback.previous;</span>
<span class="lineNum">    3247 </span>            :             }
<span class="lineNum">    3248 </span>            :         }
<span class="lineNum">    3249 </span>            : 
<span class="lineNum">    3250 </span><span class="lineCov">        104 :         return;</span>
<span class="lineNum">    3251 </span>            :     }
<span class="lineNum">    3252 </span>            : 
<span class="lineNum">    3253 </span>            :     /* Make sure we can handle the pin inside the loop */
<span class="lineNum">    3254 </span><span class="lineCov">        104 :     ResourceOwnerEnlargeBuffers(CurrentResourceOwner);</span>
<span class="lineNum">    3255 </span>            : 
<span class="lineNum">    3256 </span><span class="lineCov">    1704040 :     for (i = 0; i &lt; NBuffers; i++)</span>
<span class="lineNum">    3257 </span>            :     {
<span class="lineNum">    3258 </span>            :         uint32      buf_state;
<span class="lineNum">    3259 </span>            : 
<span class="lineNum">    3260 </span><span class="lineCov">    1703936 :         bufHdr = GetBufferDescriptor(i);</span>
<span class="lineNum">    3261 </span>            : 
<span class="lineNum">    3262 </span>            :         /*
<span class="lineNum">    3263 </span>            :          * As in DropRelFileNodeBuffers, an unlocked precheck should be safe
<span class="lineNum">    3264 </span>            :          * and saves some cycles.
<span class="lineNum">    3265 </span>            :          */
<span class="lineNum">    3266 </span><span class="lineCov">    1703936 :         if (!RelFileNodeEquals(bufHdr-&gt;tag.rnode, rel-&gt;rd_node))</span>
<span class="lineNum">    3267 </span><span class="lineCov">    1703860 :             continue;</span>
<span class="lineNum">    3268 </span>            : 
<span class="lineNum">    3269 </span><span class="lineCov">         76 :         ReservePrivateRefCountEntry();</span>
<span class="lineNum">    3270 </span>            : 
<span class="lineNum">    3271 </span><span class="lineCov">         76 :         buf_state = LockBufHdr(bufHdr);</span>
<span class="lineNum">    3272 </span><span class="lineCov">        152 :         if (RelFileNodeEquals(bufHdr-&gt;tag.rnode, rel-&gt;rd_node) &amp;&amp;</span>
<span class="lineNum">    3273 </span><span class="lineCov">         76 :             (buf_state &amp; (BM_VALID | BM_DIRTY)) == (BM_VALID | BM_DIRTY))</span>
<span class="lineNum">    3274 </span>            :         {
<span class="lineNum">    3275 </span><span class="lineCov">         64 :             PinBuffer_Locked(bufHdr);</span>
<span class="lineNum">    3276 </span><span class="lineCov">         64 :             LWLockAcquire(BufferDescriptorGetContentLock(bufHdr), LW_SHARED);</span>
<span class="lineNum">    3277 </span><span class="lineCov">         64 :             FlushBuffer(bufHdr, rel-&gt;rd_smgr);</span>
<span class="lineNum">    3278 </span><span class="lineCov">         64 :             LWLockRelease(BufferDescriptorGetContentLock(bufHdr));</span>
<span class="lineNum">    3279 </span><span class="lineCov">         64 :             UnpinBuffer(bufHdr, true);</span>
<span class="lineNum">    3280 </span>            :         }
<span class="lineNum">    3281 </span>            :         else
<span class="lineNum">    3282 </span><span class="lineCov">         12 :             UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    3283 </span>            :     }
<span class="lineNum">    3284 </span>            : }
<span class="lineNum">    3285 </span>            : 
<span class="lineNum">    3286 </span>            : /* ---------------------------------------------------------------------
<span class="lineNum">    3287 </span>            :  *      FlushDatabaseBuffers
<span class="lineNum">    3288 </span>            :  *
<span class="lineNum">    3289 </span>            :  *      This function writes all dirty pages of a database out to disk
<span class="lineNum">    3290 </span>            :  *      (or more accurately, out to kernel disk buffers), ensuring that the
<span class="lineNum">    3291 </span>            :  *      kernel has an up-to-date view of the database.
<span class="lineNum">    3292 </span>            :  *
<span class="lineNum">    3293 </span>            :  *      Generally, the caller should be holding an appropriate lock to ensure
<span class="lineNum">    3294 </span>            :  *      no other backend is active in the target database; otherwise more
<span class="lineNum">    3295 </span>            :  *      pages could get dirtied.
<span class="lineNum">    3296 </span>            :  *
<span class="lineNum">    3297 </span>            :  *      Note we don't worry about flushing any pages of temporary relations.
<span class="lineNum">    3298 </span>            :  *      It's assumed these wouldn't be interesting.
<span class="lineNum">    3299 </span>            :  * --------------------------------------------------------------------
<a name="3300"><span class="lineNum">    3300 </span>            :  */</a>
<span class="lineNum">    3301 </span>            : void
<span class="lineNum">    3302 </span><span class="lineNoCov">          0 : FlushDatabaseBuffers(Oid dbid)</span>
<span class="lineNum">    3303 </span>            : {
<span class="lineNum">    3304 </span>            :     int         i;
<span class="lineNum">    3305 </span>            :     BufferDesc *bufHdr;
<span class="lineNum">    3306 </span>            : 
<span class="lineNum">    3307 </span>            :     /* Make sure we can handle the pin inside the loop */
<span class="lineNum">    3308 </span><span class="lineNoCov">          0 :     ResourceOwnerEnlargeBuffers(CurrentResourceOwner);</span>
<span class="lineNum">    3309 </span>            : 
<span class="lineNum">    3310 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; NBuffers; i++)</span>
<span class="lineNum">    3311 </span>            :     {
<span class="lineNum">    3312 </span>            :         uint32      buf_state;
<span class="lineNum">    3313 </span>            : 
<span class="lineNum">    3314 </span><span class="lineNoCov">          0 :         bufHdr = GetBufferDescriptor(i);</span>
<span class="lineNum">    3315 </span>            : 
<span class="lineNum">    3316 </span>            :         /*
<span class="lineNum">    3317 </span>            :          * As in DropRelFileNodeBuffers, an unlocked precheck should be safe
<span class="lineNum">    3318 </span>            :          * and saves some cycles.
<span class="lineNum">    3319 </span>            :          */
<span class="lineNum">    3320 </span><span class="lineNoCov">          0 :         if (bufHdr-&gt;tag.rnode.dbNode != dbid)</span>
<span class="lineNum">    3321 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    3322 </span>            : 
<span class="lineNum">    3323 </span><span class="lineNoCov">          0 :         ReservePrivateRefCountEntry();</span>
<span class="lineNum">    3324 </span>            : 
<span class="lineNum">    3325 </span><span class="lineNoCov">          0 :         buf_state = LockBufHdr(bufHdr);</span>
<span class="lineNum">    3326 </span><span class="lineNoCov">          0 :         if (bufHdr-&gt;tag.rnode.dbNode == dbid &amp;&amp;</span>
<span class="lineNum">    3327 </span><span class="lineNoCov">          0 :             (buf_state &amp; (BM_VALID | BM_DIRTY)) == (BM_VALID | BM_DIRTY))</span>
<span class="lineNum">    3328 </span>            :         {
<span class="lineNum">    3329 </span><span class="lineNoCov">          0 :             PinBuffer_Locked(bufHdr);</span>
<span class="lineNum">    3330 </span><span class="lineNoCov">          0 :             LWLockAcquire(BufferDescriptorGetContentLock(bufHdr), LW_SHARED);</span>
<span class="lineNum">    3331 </span><span class="lineNoCov">          0 :             FlushBuffer(bufHdr, NULL);</span>
<span class="lineNum">    3332 </span><span class="lineNoCov">          0 :             LWLockRelease(BufferDescriptorGetContentLock(bufHdr));</span>
<span class="lineNum">    3333 </span><span class="lineNoCov">          0 :             UnpinBuffer(bufHdr, true);</span>
<span class="lineNum">    3334 </span>            :         }
<span class="lineNum">    3335 </span>            :         else
<span class="lineNum">    3336 </span><span class="lineNoCov">          0 :             UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    3337 </span>            :     }
<span class="lineNum">    3338 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3339 </span>            : 
<span class="lineNum">    3340 </span>            : /*
<span class="lineNum">    3341 </span>            :  * Flush a previously, shared or exclusively, locked and pinned buffer to the
<span class="lineNum">    3342 </span>            :  * OS.
<a name="3343"><span class="lineNum">    3343 </span>            :  */</a>
<span class="lineNum">    3344 </span>            : void
<span class="lineNum">    3345 </span><span class="lineNoCov">          0 : FlushOneBuffer(Buffer buffer)</span>
<span class="lineNum">    3346 </span>            : {
<span class="lineNum">    3347 </span>            :     BufferDesc *bufHdr;
<span class="lineNum">    3348 </span>            : 
<span class="lineNum">    3349 </span>            :     /* currently not needed, but no fundamental reason not to support */
<span class="lineNum">    3350 </span><span class="lineNoCov">          0 :     Assert(!BufferIsLocal(buffer));</span>
<span class="lineNum">    3351 </span>            : 
<span class="lineNum">    3352 </span><span class="lineNoCov">          0 :     Assert(BufferIsPinned(buffer));</span>
<span class="lineNum">    3353 </span>            : 
<span class="lineNum">    3354 </span><span class="lineNoCov">          0 :     bufHdr = GetBufferDescriptor(buffer - 1);</span>
<span class="lineNum">    3355 </span>            : 
<span class="lineNum">    3356 </span><span class="lineNoCov">          0 :     Assert(LWLockHeldByMe(BufferDescriptorGetContentLock(bufHdr)));</span>
<span class="lineNum">    3357 </span>            : 
<span class="lineNum">    3358 </span><span class="lineNoCov">          0 :     FlushBuffer(bufHdr, NULL);</span>
<span class="lineNum">    3359 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3360 </span>            : 
<span class="lineNum">    3361 </span>            : /*
<span class="lineNum">    3362 </span>            :  * ReleaseBuffer -- release the pin on a buffer
<a name="3363"><span class="lineNum">    3363 </span>            :  */</a>
<span class="lineNum">    3364 </span>            : void
<span class="lineNum">    3365 </span><span class="lineCov">   10697358 : ReleaseBuffer(Buffer buffer)</span>
<span class="lineNum">    3366 </span>            : {
<span class="lineNum">    3367 </span><span class="lineCov">   10697358 :     if (!BufferIsValid(buffer))</span>
<span class="lineNum">    3368 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;bad buffer ID: %d&quot;, buffer);</span>
<span class="lineNum">    3369 </span>            : 
<span class="lineNum">    3370 </span><span class="lineCov">   10697358 :     if (BufferIsLocal(buffer))</span>
<span class="lineNum">    3371 </span>            :     {
<span class="lineNum">    3372 </span><span class="lineCov">     279436 :         ResourceOwnerForgetBuffer(CurrentResourceOwner, buffer);</span>
<span class="lineNum">    3373 </span>            : 
<span class="lineNum">    3374 </span><span class="lineCov">     279436 :         Assert(LocalRefCount[-buffer - 1] &gt; 0);</span>
<span class="lineNum">    3375 </span><span class="lineCov">     279436 :         LocalRefCount[-buffer - 1]--;</span>
<span class="lineNum">    3376 </span><span class="lineCov">   10976794 :         return;</span>
<span class="lineNum">    3377 </span>            :     }
<span class="lineNum">    3378 </span>            : 
<span class="lineNum">    3379 </span><span class="lineCov">   10417922 :     UnpinBuffer(GetBufferDescriptor(buffer - 1), true);</span>
<span class="lineNum">    3380 </span>            : }
<span class="lineNum">    3381 </span>            : 
<span class="lineNum">    3382 </span>            : /*
<span class="lineNum">    3383 </span>            :  * UnlockReleaseBuffer -- release the content lock and pin on a buffer
<span class="lineNum">    3384 </span>            :  *
<span class="lineNum">    3385 </span>            :  * This is just a shorthand for a common combination.
<a name="3386"><span class="lineNum">    3386 </span>            :  */</a>
<span class="lineNum">    3387 </span>            : void
<span class="lineNum">    3388 </span><span class="lineCov">    4305478 : UnlockReleaseBuffer(Buffer buffer)</span>
<span class="lineNum">    3389 </span>            : {
<span class="lineNum">    3390 </span><span class="lineCov">    4305478 :     LockBuffer(buffer, BUFFER_LOCK_UNLOCK);</span>
<span class="lineNum">    3391 </span><span class="lineCov">    4305478 :     ReleaseBuffer(buffer);</span>
<span class="lineNum">    3392 </span><span class="lineCov">    4305478 : }</span>
<span class="lineNum">    3393 </span>            : 
<span class="lineNum">    3394 </span>            : /*
<span class="lineNum">    3395 </span>            :  * IncrBufferRefCount
<span class="lineNum">    3396 </span>            :  *      Increment the pin count on a buffer that we have *already* pinned
<span class="lineNum">    3397 </span>            :  *      at least once.
<span class="lineNum">    3398 </span>            :  *
<span class="lineNum">    3399 </span>            :  *      This function cannot be used on a buffer we do not have pinned,
<span class="lineNum">    3400 </span>            :  *      because it doesn't change the shared buffer state.
<a name="3401"><span class="lineNum">    3401 </span>            :  */</a>
<span class="lineNum">    3402 </span>            : void
<span class="lineNum">    3403 </span><span class="lineCov">    2688224 : IncrBufferRefCount(Buffer buffer)</span>
<span class="lineNum">    3404 </span>            : {
<span class="lineNum">    3405 </span><span class="lineCov">    2688224 :     Assert(BufferIsPinned(buffer));</span>
<span class="lineNum">    3406 </span><span class="lineCov">    2688224 :     ResourceOwnerEnlargeBuffers(CurrentResourceOwner);</span>
<span class="lineNum">    3407 </span><span class="lineCov">    2688224 :     if (BufferIsLocal(buffer))</span>
<span class="lineNum">    3408 </span><span class="lineCov">     199354 :         LocalRefCount[-buffer - 1]++;</span>
<span class="lineNum">    3409 </span>            :     else
<span class="lineNum">    3410 </span>            :     {
<span class="lineNum">    3411 </span>            :         PrivateRefCountEntry *ref;
<span class="lineNum">    3412 </span>            : 
<span class="lineNum">    3413 </span><span class="lineCov">    2488870 :         ref = GetPrivateRefCountEntry(buffer, true);</span>
<span class="lineNum">    3414 </span><span class="lineCov">    2488870 :         Assert(ref != NULL);</span>
<span class="lineNum">    3415 </span><span class="lineCov">    2488870 :         ref-&gt;refcount++;</span>
<span class="lineNum">    3416 </span>            :     }
<span class="lineNum">    3417 </span><span class="lineCov">    2688224 :     ResourceOwnerRememberBuffer(CurrentResourceOwner, buffer);</span>
<span class="lineNum">    3418 </span><span class="lineCov">    2688224 : }</span>
<span class="lineNum">    3419 </span>            : 
<span class="lineNum">    3420 </span>            : /*
<span class="lineNum">    3421 </span>            :  * MarkBufferDirtyHint
<span class="lineNum">    3422 </span>            :  *
<span class="lineNum">    3423 </span>            :  *  Mark a buffer dirty for non-critical changes.
<span class="lineNum">    3424 </span>            :  *
<span class="lineNum">    3425 </span>            :  * This is essentially the same as MarkBufferDirty, except:
<span class="lineNum">    3426 </span>            :  *
<span class="lineNum">    3427 </span>            :  * 1. The caller does not write WAL; so if checksums are enabled, we may need
<span class="lineNum">    3428 </span>            :  *    to write an XLOG_FPI WAL record to protect against torn pages.
<span class="lineNum">    3429 </span>            :  * 2. The caller might have only share-lock instead of exclusive-lock on the
<span class="lineNum">    3430 </span>            :  *    buffer's content lock.
<span class="lineNum">    3431 </span>            :  * 3. This function does not guarantee that the buffer is always marked dirty
<span class="lineNum">    3432 </span>            :  *    (due to a race condition), so it cannot be used for important changes.
<a name="3433"><span class="lineNum">    3433 </span>            :  */</a>
<span class="lineNum">    3434 </span>            : void
<span class="lineNum">    3435 </span><span class="lineCov">    2441098 : MarkBufferDirtyHint(Buffer buffer, bool buffer_std)</span>
<span class="lineNum">    3436 </span>            : {
<span class="lineNum">    3437 </span>            :     BufferDesc *bufHdr;
<span class="lineNum">    3438 </span><span class="lineCov">    2441098 :     Page        page = BufferGetPage(buffer);</span>
<span class="lineNum">    3439 </span>            : 
<span class="lineNum">    3440 </span><span class="lineCov">    2441098 :     if (!BufferIsValid(buffer))</span>
<span class="lineNum">    3441 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;bad buffer ID: %d&quot;, buffer);</span>
<span class="lineNum">    3442 </span>            : 
<span class="lineNum">    3443 </span><span class="lineCov">    2441098 :     if (BufferIsLocal(buffer))</span>
<span class="lineNum">    3444 </span>            :     {
<span class="lineNum">    3445 </span><span class="lineCov">     225948 :         MarkLocalBufferDirty(buffer);</span>
<span class="lineNum">    3446 </span><span class="lineCov">     225948 :         return;</span>
<span class="lineNum">    3447 </span>            :     }
<span class="lineNum">    3448 </span>            : 
<span class="lineNum">    3449 </span><span class="lineCov">    2215150 :     bufHdr = GetBufferDescriptor(buffer - 1);</span>
<span class="lineNum">    3450 </span>            : 
<span class="lineNum">    3451 </span><span class="lineCov">    2215150 :     Assert(GetPrivateRefCount(buffer) &gt; 0);</span>
<span class="lineNum">    3452 </span>            :     /* here, either share or exclusive lock is OK */
<span class="lineNum">    3453 </span><span class="lineCov">    2215150 :     Assert(LWLockHeldByMe(BufferDescriptorGetContentLock(bufHdr)));</span>
<span class="lineNum">    3454 </span>            : 
<span class="lineNum">    3455 </span>            :     /*
<span class="lineNum">    3456 </span>            :      * This routine might get called many times on the same page, if we are
<span class="lineNum">    3457 </span>            :      * making the first scan after commit of an xact that added/deleted many
<span class="lineNum">    3458 </span>            :      * tuples. So, be as quick as we can if the buffer is already dirty.  We
<span class="lineNum">    3459 </span>            :      * do this by not acquiring spinlock if it looks like the status bits are
<span class="lineNum">    3460 </span>            :      * already set.  Since we make this test unlocked, there's a chance we
<span class="lineNum">    3461 </span>            :      * might fail to notice that the flags have just been cleared, and failed
<span class="lineNum">    3462 </span>            :      * to reset them, due to memory-ordering issues.  But since this function
<span class="lineNum">    3463 </span>            :      * is only intended to be used in cases where failing to write out the
<span class="lineNum">    3464 </span>            :      * data would be harmless anyway, it doesn't really matter.
<span class="lineNum">    3465 </span>            :      */
<span class="lineNum">    3466 </span><span class="lineCov">    2215150 :     if ((pg_atomic_read_u32(&amp;bufHdr-&gt;state) &amp; (BM_DIRTY | BM_JUST_DIRTIED)) !=</span>
<span class="lineNum">    3467 </span>            :         (BM_DIRTY | BM_JUST_DIRTIED))
<span class="lineNum">    3468 </span>            :     {
<span class="lineNum">    3469 </span><span class="lineCov">       1550 :         XLogRecPtr  lsn = InvalidXLogRecPtr;</span>
<span class="lineNum">    3470 </span><span class="lineCov">       1550 :         bool        dirtied = false;</span>
<span class="lineNum">    3471 </span><span class="lineCov">       1550 :         bool        delayChkpt = false;</span>
<span class="lineNum">    3472 </span>            :         uint32      buf_state;
<span class="lineNum">    3473 </span>            : 
<span class="lineNum">    3474 </span>            :         /*
<span class="lineNum">    3475 </span>            :          * If we need to protect hint bit updates from torn writes, WAL-log a
<span class="lineNum">    3476 </span>            :          * full page image of the page. This full page image is only necessary
<span class="lineNum">    3477 </span>            :          * if the hint bit update is the first change to the page since the
<span class="lineNum">    3478 </span>            :          * last checkpoint.
<span class="lineNum">    3479 </span>            :          *
<span class="lineNum">    3480 </span>            :          * We don't check full_page_writes here because that logic is included
<span class="lineNum">    3481 </span>            :          * when we call XLogInsert() since the value changes dynamically.
<span class="lineNum">    3482 </span>            :          */
<span class="lineNum">    3483 </span><span class="lineCov">       1550 :         if (XLogHintBitIsNeeded() &amp;&amp;</span>
<span class="lineNum">    3484 </span><span class="lineNoCov">          0 :             (pg_atomic_read_u32(&amp;bufHdr-&gt;state) &amp; BM_PERMANENT))</span>
<span class="lineNum">    3485 </span>            :         {
<span class="lineNum">    3486 </span>            :             /*
<span class="lineNum">    3487 </span>            :              * If we're in recovery we cannot dirty a page because of a hint.
<span class="lineNum">    3488 </span>            :              * We can set the hint, just not dirty the page as a result so the
<span class="lineNum">    3489 </span>            :              * hint is lost when we evict the page or shutdown.
<span class="lineNum">    3490 </span>            :              *
<span class="lineNum">    3491 </span>            :              * See src/backend/storage/page/README for longer discussion.
<span class="lineNum">    3492 </span>            :              */
<span class="lineNum">    3493 </span><span class="lineNoCov">          0 :             if (RecoveryInProgress())</span>
<span class="lineNum">    3494 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    3495 </span>            : 
<span class="lineNum">    3496 </span>            :             /*
<span class="lineNum">    3497 </span>            :              * If the block is already dirty because we either made a change
<span class="lineNum">    3498 </span>            :              * or set a hint already, then we don't need to write a full page
<span class="lineNum">    3499 </span>            :              * image.  Note that aggressive cleaning of blocks dirtied by hint
<span class="lineNum">    3500 </span>            :              * bit setting would increase the call rate. Bulk setting of hint
<span class="lineNum">    3501 </span>            :              * bits would reduce the call rate...
<span class="lineNum">    3502 </span>            :              *
<span class="lineNum">    3503 </span>            :              * We must issue the WAL record before we mark the buffer dirty.
<span class="lineNum">    3504 </span>            :              * Otherwise we might write the page before we write the WAL. That
<span class="lineNum">    3505 </span>            :              * causes a race condition, since a checkpoint might occur between
<span class="lineNum">    3506 </span>            :              * writing the WAL record and marking the buffer dirty. We solve
<span class="lineNum">    3507 </span>            :              * that with a kluge, but one that is already in use during
<span class="lineNum">    3508 </span>            :              * transaction commit to prevent race conditions. Basically, we
<span class="lineNum">    3509 </span>            :              * simply prevent the checkpoint WAL record from being written
<span class="lineNum">    3510 </span>            :              * until we have marked the buffer dirty. We don't start the
<span class="lineNum">    3511 </span>            :              * checkpoint flush until we have marked dirty, so our checkpoint
<span class="lineNum">    3512 </span>            :              * must flush the change to disk successfully or the checkpoint
<span class="lineNum">    3513 </span>            :              * never gets written, so crash recovery will fix.
<span class="lineNum">    3514 </span>            :              *
<span class="lineNum">    3515 </span>            :              * It's possible we may enter here without an xid, so it is
<span class="lineNum">    3516 </span>            :              * essential that CreateCheckpoint waits for virtual transactions
<span class="lineNum">    3517 </span>            :              * rather than full transactionids.
<span class="lineNum">    3518 </span>            :              */
<span class="lineNum">    3519 </span><span class="lineNoCov">          0 :             MyPgXact-&gt;delayChkpt = delayChkpt = true;</span>
<span class="lineNum">    3520 </span><span class="lineNoCov">          0 :             lsn = XLogSaveBufferForHint(buffer, buffer_std);</span>
<span class="lineNum">    3521 </span>            :         }
<span class="lineNum">    3522 </span>            : 
<span class="lineNum">    3523 </span><span class="lineCov">       1550 :         buf_state = LockBufHdr(bufHdr);</span>
<span class="lineNum">    3524 </span>            : 
<span class="lineNum">    3525 </span><span class="lineCov">       1550 :         Assert(BUF_STATE_GET_REFCOUNT(buf_state) &gt; 0);</span>
<span class="lineNum">    3526 </span>            : 
<span class="lineNum">    3527 </span><span class="lineCov">       1550 :         if (!(buf_state &amp; BM_DIRTY))</span>
<span class="lineNum">    3528 </span>            :         {
<span class="lineNum">    3529 </span><span class="lineCov">       1550 :             dirtied = true;     /* Means &quot;will be dirtied by this action&quot; */</span>
<span class="lineNum">    3530 </span>            : 
<span class="lineNum">    3531 </span>            :             /*
<span class="lineNum">    3532 </span>            :              * Set the page LSN if we wrote a backup block. We aren't supposed
<span class="lineNum">    3533 </span>            :              * to set this when only holding a share lock but as long as we
<span class="lineNum">    3534 </span>            :              * serialise it somehow we're OK. We choose to set LSN while
<span class="lineNum">    3535 </span>            :              * holding the buffer header lock, which causes any reader of an
<span class="lineNum">    3536 </span>            :              * LSN who holds only a share lock to also obtain a buffer header
<span class="lineNum">    3537 </span>            :              * lock before using PageGetLSN(), which is enforced in
<span class="lineNum">    3538 </span>            :              * BufferGetLSNAtomic().
<span class="lineNum">    3539 </span>            :              *
<span class="lineNum">    3540 </span>            :              * If checksums are enabled, you might think we should reset the
<span class="lineNum">    3541 </span>            :              * checksum here. That will happen when the page is written
<span class="lineNum">    3542 </span>            :              * sometime later in this checkpoint cycle.
<span class="lineNum">    3543 </span>            :              */
<span class="lineNum">    3544 </span><span class="lineCov">       1550 :             if (!XLogRecPtrIsInvalid(lsn))</span>
<span class="lineNum">    3545 </span><span class="lineNoCov">          0 :                 PageSetLSN(page, lsn);</span>
<span class="lineNum">    3546 </span>            :         }
<span class="lineNum">    3547 </span>            : 
<span class="lineNum">    3548 </span><span class="lineCov">       1550 :         buf_state |= BM_DIRTY | BM_JUST_DIRTIED;</span>
<span class="lineNum">    3549 </span><span class="lineCov">       1550 :         UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    3550 </span>            : 
<span class="lineNum">    3551 </span><span class="lineCov">       1550 :         if (delayChkpt)</span>
<span class="lineNum">    3552 </span><span class="lineNoCov">          0 :             MyPgXact-&gt;delayChkpt = false;</span>
<span class="lineNum">    3553 </span>            : 
<span class="lineNum">    3554 </span><span class="lineCov">       1550 :         if (dirtied)</span>
<span class="lineNum">    3555 </span>            :         {
<span class="lineNum">    3556 </span><span class="lineCov">       1550 :             VacuumPageDirty++;</span>
<span class="lineNum">    3557 </span><span class="lineCov">       1550 :             pgBufferUsage.shared_blks_dirtied++;</span>
<span class="lineNum">    3558 </span><span class="lineCov">       1550 :             if (VacuumCostActive)</span>
<span class="lineNum">    3559 </span><span class="lineCov">         52 :                 VacuumCostBalance += VacuumCostPageDirty;</span>
<span class="lineNum">    3560 </span>            :         }
<span class="lineNum">    3561 </span>            :     }
<span class="lineNum">    3562 </span>            : }
<span class="lineNum">    3563 </span>            : 
<span class="lineNum">    3564 </span>            : /*
<span class="lineNum">    3565 </span>            :  * Release buffer content locks for shared buffers.
<span class="lineNum">    3566 </span>            :  *
<span class="lineNum">    3567 </span>            :  * Used to clean up after errors.
<span class="lineNum">    3568 </span>            :  *
<span class="lineNum">    3569 </span>            :  * Currently, we can expect that lwlock.c's LWLockReleaseAll() took care
<span class="lineNum">    3570 </span>            :  * of releasing buffer content locks per se; the only thing we need to deal
<span class="lineNum">    3571 </span>            :  * with here is clearing any PIN_COUNT request that was in progress.
<a name="3572"><span class="lineNum">    3572 </span>            :  */</a>
<span class="lineNum">    3573 </span>            : void
<span class="lineNum">    3574 </span><span class="lineCov">      10468 : UnlockBuffers(void)</span>
<span class="lineNum">    3575 </span>            : {
<span class="lineNum">    3576 </span><span class="lineCov">      10468 :     BufferDesc *buf = PinCountWaitBuf;</span>
<span class="lineNum">    3577 </span>            : 
<span class="lineNum">    3578 </span><span class="lineCov">      10468 :     if (buf)</span>
<span class="lineNum">    3579 </span>            :     {
<span class="lineNum">    3580 </span>            :         uint32      buf_state;
<span class="lineNum">    3581 </span>            : 
<span class="lineNum">    3582 </span><span class="lineNoCov">          0 :         buf_state = LockBufHdr(buf);</span>
<span class="lineNum">    3583 </span>            : 
<span class="lineNum">    3584 </span>            :         /*
<span class="lineNum">    3585 </span>            :          * Don't complain if flag bit not set; it could have been reset but we
<span class="lineNum">    3586 </span>            :          * got a cancel/die interrupt before getting the signal.
<span class="lineNum">    3587 </span>            :          */
<span class="lineNum">    3588 </span><span class="lineNoCov">          0 :         if ((buf_state &amp; BM_PIN_COUNT_WAITER) != 0 &amp;&amp;</span>
<span class="lineNum">    3589 </span><span class="lineNoCov">          0 :             buf-&gt;wait_backend_pid == MyProcPid)</span>
<span class="lineNum">    3590 </span><span class="lineNoCov">          0 :             buf_state &amp;= ~BM_PIN_COUNT_WAITER;</span>
<span class="lineNum">    3591 </span>            : 
<span class="lineNum">    3592 </span><span class="lineNoCov">          0 :         UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    3593 </span>            : 
<span class="lineNum">    3594 </span><span class="lineNoCov">          0 :         PinCountWaitBuf = NULL;</span>
<span class="lineNum">    3595 </span>            :     }
<span class="lineNum">    3596 </span><span class="lineCov">      10468 : }</span>
<span class="lineNum">    3597 </span>            : 
<span class="lineNum">    3598 </span>            : /*
<span class="lineNum">    3599 </span>            :  * Acquire or release the content_lock for the buffer.
<a name="3600"><span class="lineNum">    3600 </span>            :  */</a>
<span class="lineNum">    3601 </span>            : void
<span class="lineNum">    3602 </span><span class="lineCov">   35106768 : LockBuffer(Buffer buffer, int mode)</span>
<span class="lineNum">    3603 </span>            : {
<span class="lineNum">    3604 </span>            :     BufferDesc *buf;
<span class="lineNum">    3605 </span>            : 
<span class="lineNum">    3606 </span><span class="lineCov">   35106768 :     Assert(BufferIsValid(buffer));</span>
<span class="lineNum">    3607 </span><span class="lineCov">   35106768 :     if (BufferIsLocal(buffer))</span>
<span class="lineNum">    3608 </span><span class="lineCov">   35872376 :         return;                 /* local buffers need no lock */</span>
<span class="lineNum">    3609 </span>            : 
<span class="lineNum">    3610 </span><span class="lineCov">   34341160 :     buf = GetBufferDescriptor(buffer - 1);</span>
<span class="lineNum">    3611 </span>            : 
<span class="lineNum">    3612 </span><span class="lineCov">   34341160 :     if (mode == BUFFER_LOCK_UNLOCK)</span>
<span class="lineNum">    3613 </span><span class="lineCov">   17465796 :         LWLockRelease(BufferDescriptorGetContentLock(buf));</span>
<span class="lineNum">    3614 </span><span class="lineCov">   16875364 :     else if (mode == BUFFER_LOCK_SHARE)</span>
<span class="lineNum">    3615 </span><span class="lineCov">   12313248 :         LWLockAcquire(BufferDescriptorGetContentLock(buf), LW_SHARED);</span>
<span class="lineNum">    3616 </span><span class="lineCov">    4562116 :     else if (mode == BUFFER_LOCK_EXCLUSIVE)</span>
<span class="lineNum">    3617 </span><span class="lineCov">    4562116 :         LWLockAcquire(BufferDescriptorGetContentLock(buf), LW_EXCLUSIVE);</span>
<span class="lineNum">    3618 </span>            :     else
<span class="lineNum">    3619 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;unrecognized buffer lock mode: %d&quot;, mode);</span>
<span class="lineNum">    3620 </span>            : }
<span class="lineNum">    3621 </span>            : 
<span class="lineNum">    3622 </span>            : /*
<span class="lineNum">    3623 </span>            :  * Acquire the content_lock for the buffer, but only if we don't have to wait.
<span class="lineNum">    3624 </span>            :  *
<span class="lineNum">    3625 </span>            :  * This assumes the caller wants BUFFER_LOCK_EXCLUSIVE mode.
<a name="3626"><span class="lineNum">    3626 </span>            :  */</a>
<span class="lineNum">    3627 </span>            : bool
<span class="lineNum">    3628 </span><span class="lineCov">     565554 : ConditionalLockBuffer(Buffer buffer)</span>
<span class="lineNum">    3629 </span>            : {
<span class="lineNum">    3630 </span>            :     BufferDesc *buf;
<span class="lineNum">    3631 </span>            : 
<span class="lineNum">    3632 </span><span class="lineCov">     565554 :     Assert(BufferIsValid(buffer));</span>
<span class="lineNum">    3633 </span><span class="lineCov">     565554 :     if (BufferIsLocal(buffer))</span>
<span class="lineNum">    3634 </span><span class="lineCov">         16 :         return true;            /* act as though we got it */</span>
<span class="lineNum">    3635 </span>            : 
<span class="lineNum">    3636 </span><span class="lineCov">     565538 :     buf = GetBufferDescriptor(buffer - 1);</span>
<span class="lineNum">    3637 </span>            : 
<span class="lineNum">    3638 </span><span class="lineCov">     565538 :     return LWLockConditionalAcquire(BufferDescriptorGetContentLock(buf),</span>
<span class="lineNum">    3639 </span>            :                                     LW_EXCLUSIVE);
<span class="lineNum">    3640 </span>            : }
<span class="lineNum">    3641 </span>            : 
<span class="lineNum">    3642 </span>            : /*
<span class="lineNum">    3643 </span>            :  * LockBufferForCleanup - lock a buffer in preparation for deleting items
<span class="lineNum">    3644 </span>            :  *
<span class="lineNum">    3645 </span>            :  * Items may be deleted from a disk page only when the caller (a) holds an
<span class="lineNum">    3646 </span>            :  * exclusive lock on the buffer and (b) has observed that no other backend
<span class="lineNum">    3647 </span>            :  * holds a pin on the buffer.  If there is a pin, then the other backend
<span class="lineNum">    3648 </span>            :  * might have a pointer into the buffer (for example, a heapscan reference
<span class="lineNum">    3649 </span>            :  * to an item --- see README for more details).  It's OK if a pin is added
<span class="lineNum">    3650 </span>            :  * after the cleanup starts, however; the newly-arrived backend will be
<span class="lineNum">    3651 </span>            :  * unable to look at the page until we release the exclusive lock.
<span class="lineNum">    3652 </span>            :  *
<span class="lineNum">    3653 </span>            :  * To implement this protocol, a would-be deleter must pin the buffer and
<span class="lineNum">    3654 </span>            :  * then call LockBufferForCleanup().  LockBufferForCleanup() is similar to
<span class="lineNum">    3655 </span>            :  * LockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE), except that it loops until
<span class="lineNum">    3656 </span>            :  * it has successfully observed pin count = 1.
<a name="3657"><span class="lineNum">    3657 </span>            :  */</a>
<span class="lineNum">    3658 </span>            : void
<span class="lineNum">    3659 </span><span class="lineCov">       5044 : LockBufferForCleanup(Buffer buffer)</span>
<span class="lineNum">    3660 </span>            : {
<span class="lineNum">    3661 </span>            :     BufferDesc *bufHdr;
<span class="lineNum">    3662 </span>            : 
<span class="lineNum">    3663 </span><span class="lineCov">       5044 :     Assert(BufferIsValid(buffer));</span>
<span class="lineNum">    3664 </span><span class="lineCov">       5044 :     Assert(PinCountWaitBuf == NULL);</span>
<span class="lineNum">    3665 </span>            : 
<span class="lineNum">    3666 </span><span class="lineCov">       5044 :     if (BufferIsLocal(buffer))</span>
<span class="lineNum">    3667 </span>            :     {
<span class="lineNum">    3668 </span>            :         /* There should be exactly one pin */
<span class="lineNum">    3669 </span><span class="lineNoCov">          0 :         if (LocalRefCount[-buffer - 1] != 1)</span>
<span class="lineNum">    3670 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;incorrect local pin count: %d&quot;,</span>
<span class="lineNum">    3671 </span>            :                  LocalRefCount[-buffer - 1]);
<span class="lineNum">    3672 </span>            :         /* Nobody else to wait for */
<span class="lineNum">    3673 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    3674 </span>            :     }
<span class="lineNum">    3675 </span>            : 
<span class="lineNum">    3676 </span>            :     /* There should be exactly one local pin */
<span class="lineNum">    3677 </span><span class="lineCov">       5044 :     if (GetPrivateRefCount(buffer) != 1)</span>
<span class="lineNum">    3678 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;incorrect local pin count: %d&quot;,</span>
<span class="lineNum">    3679 </span>            :              GetPrivateRefCount(buffer));
<span class="lineNum">    3680 </span>            : 
<span class="lineNum">    3681 </span><span class="lineCov">       5044 :     bufHdr = GetBufferDescriptor(buffer - 1);</span>
<span class="lineNum">    3682 </span>            : 
<span class="lineNum">    3683 </span>            :     for (;;)
<span class="lineNum">    3684 </span>            :     {
<span class="lineNum">    3685 </span>            :         uint32      buf_state;
<span class="lineNum">    3686 </span>            : 
<span class="lineNum">    3687 </span>            :         /* Try to acquire lock */
<span class="lineNum">    3688 </span><span class="lineCov">       5044 :         LockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE);</span>
<span class="lineNum">    3689 </span><span class="lineCov">       5044 :         buf_state = LockBufHdr(bufHdr);</span>
<span class="lineNum">    3690 </span>            : 
<span class="lineNum">    3691 </span><span class="lineCov">       5044 :         Assert(BUF_STATE_GET_REFCOUNT(buf_state) &gt; 0);</span>
<span class="lineNum">    3692 </span><span class="lineCov">       5044 :         if (BUF_STATE_GET_REFCOUNT(buf_state) == 1)</span>
<span class="lineNum">    3693 </span>            :         {
<span class="lineNum">    3694 </span>            :             /* Successfully acquired exclusive lock with pincount 1 */
<span class="lineNum">    3695 </span><span class="lineCov">       5044 :             UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    3696 </span><span class="lineCov">       5044 :             return;</span>
<span class="lineNum">    3697 </span>            :         }
<span class="lineNum">    3698 </span>            :         /* Failed, so mark myself as waiting for pincount 1 */
<span class="lineNum">    3699 </span><span class="lineNoCov">          0 :         if (buf_state &amp; BM_PIN_COUNT_WAITER)</span>
<span class="lineNum">    3700 </span>            :         {
<span class="lineNum">    3701 </span><span class="lineNoCov">          0 :             UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    3702 </span><span class="lineNoCov">          0 :             LockBuffer(buffer, BUFFER_LOCK_UNLOCK);</span>
<span class="lineNum">    3703 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;multiple backends attempting to wait for pincount 1&quot;);</span>
<span class="lineNum">    3704 </span>            :         }
<span class="lineNum">    3705 </span><span class="lineNoCov">          0 :         bufHdr-&gt;wait_backend_pid = MyProcPid;</span>
<span class="lineNum">    3706 </span><span class="lineNoCov">          0 :         PinCountWaitBuf = bufHdr;</span>
<span class="lineNum">    3707 </span><span class="lineNoCov">          0 :         buf_state |= BM_PIN_COUNT_WAITER;</span>
<span class="lineNum">    3708 </span><span class="lineNoCov">          0 :         UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    3709 </span><span class="lineNoCov">          0 :         LockBuffer(buffer, BUFFER_LOCK_UNLOCK);</span>
<span class="lineNum">    3710 </span>            : 
<span class="lineNum">    3711 </span>            :         /* Wait to be signaled by UnpinBuffer() */
<span class="lineNum">    3712 </span><span class="lineNoCov">          0 :         if (InHotStandby)</span>
<span class="lineNum">    3713 </span>            :         {
<span class="lineNum">    3714 </span>            :             /* Publish the bufid that Startup process waits on */
<span class="lineNum">    3715 </span><span class="lineNoCov">          0 :             SetStartupBufferPinWaitBufId(buffer - 1);</span>
<span class="lineNum">    3716 </span>            :             /* Set alarm and then wait to be signaled by UnpinBuffer() */
<span class="lineNum">    3717 </span><span class="lineNoCov">          0 :             ResolveRecoveryConflictWithBufferPin();</span>
<span class="lineNum">    3718 </span>            :             /* Reset the published bufid */
<span class="lineNum">    3719 </span><span class="lineNoCov">          0 :             SetStartupBufferPinWaitBufId(-1);</span>
<span class="lineNum">    3720 </span>            :         }
<span class="lineNum">    3721 </span>            :         else
<span class="lineNum">    3722 </span><span class="lineNoCov">          0 :             ProcWaitForSignal(PG_WAIT_BUFFER_PIN);</span>
<span class="lineNum">    3723 </span>            : 
<span class="lineNum">    3724 </span>            :         /*
<span class="lineNum">    3725 </span>            :          * Remove flag marking us as waiter. Normally this will not be set
<span class="lineNum">    3726 </span>            :          * anymore, but ProcWaitForSignal() can return for other signals as
<span class="lineNum">    3727 </span>            :          * well.  We take care to only reset the flag if we're the waiter, as
<span class="lineNum">    3728 </span>            :          * theoretically another backend could have started waiting. That's
<span class="lineNum">    3729 </span>            :          * impossible with the current usages due to table level locking, but
<span class="lineNum">    3730 </span>            :          * better be safe.
<span class="lineNum">    3731 </span>            :          */
<span class="lineNum">    3732 </span><span class="lineNoCov">          0 :         buf_state = LockBufHdr(bufHdr);</span>
<span class="lineNum">    3733 </span><span class="lineNoCov">          0 :         if ((buf_state &amp; BM_PIN_COUNT_WAITER) != 0 &amp;&amp;</span>
<span class="lineNum">    3734 </span><span class="lineNoCov">          0 :             bufHdr-&gt;wait_backend_pid == MyProcPid)</span>
<span class="lineNum">    3735 </span><span class="lineNoCov">          0 :             buf_state &amp;= ~BM_PIN_COUNT_WAITER;</span>
<span class="lineNum">    3736 </span><span class="lineNoCov">          0 :         UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    3737 </span>            : 
<span class="lineNum">    3738 </span><span class="lineNoCov">          0 :         PinCountWaitBuf = NULL;</span>
<span class="lineNum">    3739 </span>            :         /* Loop back and try again */
<span class="lineNum">    3740 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    3741 </span>            : }
<span class="lineNum">    3742 </span>            : 
<span class="lineNum">    3743 </span>            : /*
<span class="lineNum">    3744 </span>            :  * Check called from RecoveryConflictInterrupt handler when Startup
<span class="lineNum">    3745 </span>            :  * process requests cancellation of all pin holders that are blocking it.
<a name="3746"><span class="lineNum">    3746 </span>            :  */</a>
<span class="lineNum">    3747 </span>            : bool
<span class="lineNum">    3748 </span><span class="lineNoCov">          0 : HoldingBufferPinThatDelaysRecovery(void)</span>
<span class="lineNum">    3749 </span>            : {
<span class="lineNum">    3750 </span><span class="lineNoCov">          0 :     int         bufid = GetStartupBufferPinWaitBufId();</span>
<span class="lineNum">    3751 </span>            : 
<span class="lineNum">    3752 </span>            :     /*
<span class="lineNum">    3753 </span>            :      * If we get woken slowly then it's possible that the Startup process was
<span class="lineNum">    3754 </span>            :      * already woken by other backends before we got here. Also possible that
<span class="lineNum">    3755 </span>            :      * we get here by multiple interrupts or interrupts at inappropriate
<span class="lineNum">    3756 </span>            :      * times, so make sure we do nothing if the bufid is not set.
<span class="lineNum">    3757 </span>            :      */
<span class="lineNum">    3758 </span><span class="lineNoCov">          0 :     if (bufid &lt; 0)</span>
<span class="lineNum">    3759 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3760 </span>            : 
<span class="lineNum">    3761 </span><span class="lineNoCov">          0 :     if (GetPrivateRefCount(bufid + 1) &gt; 0)</span>
<span class="lineNum">    3762 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    3763 </span>            : 
<span class="lineNum">    3764 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    3765 </span>            : }
<span class="lineNum">    3766 </span>            : 
<span class="lineNum">    3767 </span>            : /*
<span class="lineNum">    3768 </span>            :  * ConditionalLockBufferForCleanup - as above, but don't wait to get the lock
<span class="lineNum">    3769 </span>            :  *
<span class="lineNum">    3770 </span>            :  * We won't loop, but just check once to see if the pin count is OK.  If
<span class="lineNum">    3771 </span>            :  * not, return false with no lock held.
<a name="3772"><span class="lineNum">    3772 </span>            :  */</a>
<span class="lineNum">    3773 </span>            : bool
<span class="lineNum">    3774 </span><span class="lineCov">      25036 : ConditionalLockBufferForCleanup(Buffer buffer)</span>
<span class="lineNum">    3775 </span>            : {
<span class="lineNum">    3776 </span>            :     BufferDesc *bufHdr;
<span class="lineNum">    3777 </span>            :     uint32      buf_state,
<span class="lineNum">    3778 </span>            :                 refcount;
<span class="lineNum">    3779 </span>            : 
<span class="lineNum">    3780 </span><span class="lineCov">      25036 :     Assert(BufferIsValid(buffer));</span>
<span class="lineNum">    3781 </span>            : 
<span class="lineNum">    3782 </span><span class="lineCov">      25036 :     if (BufferIsLocal(buffer))</span>
<span class="lineNum">    3783 </span>            :     {
<span class="lineNum">    3784 </span><span class="lineNoCov">          0 :         refcount = LocalRefCount[-buffer - 1];</span>
<span class="lineNum">    3785 </span>            :         /* There should be exactly one pin */
<span class="lineNum">    3786 </span><span class="lineNoCov">          0 :         Assert(refcount &gt; 0);</span>
<span class="lineNum">    3787 </span><span class="lineNoCov">          0 :         if (refcount != 1)</span>
<span class="lineNum">    3788 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    3789 </span>            :         /* Nobody else to wait for */
<span class="lineNum">    3790 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    3791 </span>            :     }
<span class="lineNum">    3792 </span>            : 
<span class="lineNum">    3793 </span>            :     /* There should be exactly one local pin */
<span class="lineNum">    3794 </span><span class="lineCov">      25036 :     refcount = GetPrivateRefCount(buffer);</span>
<span class="lineNum">    3795 </span><span class="lineCov">      25036 :     Assert(refcount);</span>
<span class="lineNum">    3796 </span><span class="lineCov">      25036 :     if (refcount != 1)</span>
<span class="lineNum">    3797 </span><span class="lineCov">          8 :         return false;</span>
<span class="lineNum">    3798 </span>            : 
<span class="lineNum">    3799 </span>            :     /* Try to acquire lock */
<span class="lineNum">    3800 </span><span class="lineCov">      25028 :     if (!ConditionalLockBuffer(buffer))</span>
<span class="lineNum">    3801 </span><span class="lineCov">         14 :         return false;</span>
<span class="lineNum">    3802 </span>            : 
<span class="lineNum">    3803 </span><span class="lineCov">      25014 :     bufHdr = GetBufferDescriptor(buffer - 1);</span>
<span class="lineNum">    3804 </span><span class="lineCov">      25014 :     buf_state = LockBufHdr(bufHdr);</span>
<span class="lineNum">    3805 </span><span class="lineCov">      25014 :     refcount = BUF_STATE_GET_REFCOUNT(buf_state);</span>
<span class="lineNum">    3806 </span>            : 
<span class="lineNum">    3807 </span><span class="lineCov">      25014 :     Assert(refcount &gt; 0);</span>
<span class="lineNum">    3808 </span><span class="lineCov">      25014 :     if (refcount == 1)</span>
<span class="lineNum">    3809 </span>            :     {
<span class="lineNum">    3810 </span>            :         /* Successfully acquired exclusive lock with pincount 1 */
<span class="lineNum">    3811 </span><span class="lineCov">      25004 :         UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    3812 </span><span class="lineCov">      25004 :         return true;</span>
<span class="lineNum">    3813 </span>            :     }
<span class="lineNum">    3814 </span>            : 
<span class="lineNum">    3815 </span>            :     /* Failed, so release the lock */
<span class="lineNum">    3816 </span><span class="lineCov">         10 :     UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    3817 </span><span class="lineCov">         10 :     LockBuffer(buffer, BUFFER_LOCK_UNLOCK);</span>
<span class="lineNum">    3818 </span><span class="lineCov">         10 :     return false;</span>
<span class="lineNum">    3819 </span>            : }
<span class="lineNum">    3820 </span>            : 
<span class="lineNum">    3821 </span>            : /*
<span class="lineNum">    3822 </span>            :  * IsBufferCleanupOK - as above, but we already have the lock
<span class="lineNum">    3823 </span>            :  *
<span class="lineNum">    3824 </span>            :  * Check whether it's OK to perform cleanup on a buffer we've already
<span class="lineNum">    3825 </span>            :  * locked.  If we observe that the pin count is 1, our exclusive lock
<span class="lineNum">    3826 </span>            :  * happens to be a cleanup lock, and we can proceed with anything that
<span class="lineNum">    3827 </span>            :  * would have been allowable had we sought a cleanup lock originally.
<a name="3828"><span class="lineNum">    3828 </span>            :  */</a>
<span class="lineNum">    3829 </span>            : bool
<span class="lineNum">    3830 </span><span class="lineCov">       1286 : IsBufferCleanupOK(Buffer buffer)</span>
<span class="lineNum">    3831 </span>            : {
<span class="lineNum">    3832 </span>            :     BufferDesc *bufHdr;
<span class="lineNum">    3833 </span>            :     uint32      buf_state;
<span class="lineNum">    3834 </span>            : 
<span class="lineNum">    3835 </span><span class="lineCov">       1286 :     Assert(BufferIsValid(buffer));</span>
<span class="lineNum">    3836 </span>            : 
<span class="lineNum">    3837 </span><span class="lineCov">       1286 :     if (BufferIsLocal(buffer))</span>
<span class="lineNum">    3838 </span>            :     {
<span class="lineNum">    3839 </span>            :         /* There should be exactly one pin */
<span class="lineNum">    3840 </span><span class="lineNoCov">          0 :         if (LocalRefCount[-buffer - 1] != 1)</span>
<span class="lineNum">    3841 </span><span class="lineNoCov">          0 :             return false;</span>
<span class="lineNum">    3842 </span>            :         /* Nobody else to wait for */
<span class="lineNum">    3843 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    3844 </span>            :     }
<span class="lineNum">    3845 </span>            : 
<span class="lineNum">    3846 </span>            :     /* There should be exactly one local pin */
<span class="lineNum">    3847 </span><span class="lineCov">       1286 :     if (GetPrivateRefCount(buffer) != 1)</span>
<span class="lineNum">    3848 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3849 </span>            : 
<span class="lineNum">    3850 </span><span class="lineCov">       1286 :     bufHdr = GetBufferDescriptor(buffer - 1);</span>
<span class="lineNum">    3851 </span>            : 
<span class="lineNum">    3852 </span>            :     /* caller must hold exclusive lock on buffer */
<span class="lineNum">    3853 </span><span class="lineCov">       1286 :     Assert(LWLockHeldByMeInMode(BufferDescriptorGetContentLock(bufHdr),</span>
<span class="lineNum">    3854 </span>            :                                 LW_EXCLUSIVE));
<span class="lineNum">    3855 </span>            : 
<span class="lineNum">    3856 </span><span class="lineCov">       1286 :     buf_state = LockBufHdr(bufHdr);</span>
<span class="lineNum">    3857 </span>            : 
<span class="lineNum">    3858 </span><span class="lineCov">       1286 :     Assert(BUF_STATE_GET_REFCOUNT(buf_state) &gt; 0);</span>
<span class="lineNum">    3859 </span><span class="lineCov">       1286 :     if (BUF_STATE_GET_REFCOUNT(buf_state) == 1)</span>
<span class="lineNum">    3860 </span>            :     {
<span class="lineNum">    3861 </span>            :         /* pincount is OK. */
<span class="lineNum">    3862 </span><span class="lineCov">       1286 :         UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    3863 </span><span class="lineCov">       1286 :         return true;</span>
<span class="lineNum">    3864 </span>            :     }
<span class="lineNum">    3865 </span>            : 
<span class="lineNum">    3866 </span><span class="lineNoCov">          0 :     UnlockBufHdr(bufHdr, buf_state);</span>
<span class="lineNum">    3867 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    3868 </span>            : }
<span class="lineNum">    3869 </span>            : 
<span class="lineNum">    3870 </span>            : 
<span class="lineNum">    3871 </span>            : /*
<span class="lineNum">    3872 </span>            :  *  Functions for buffer I/O handling
<span class="lineNum">    3873 </span>            :  *
<span class="lineNum">    3874 </span>            :  *  Note: We assume that nested buffer I/O never occurs.
<span class="lineNum">    3875 </span>            :  *  i.e at most one io_in_progress lock is held per proc.
<span class="lineNum">    3876 </span>            :  *
<span class="lineNum">    3877 </span>            :  *  Also note that these are used only for shared buffers, not local ones.
<span class="lineNum">    3878 </span>            :  */
<span class="lineNum">    3879 </span>            : 
<span class="lineNum">    3880 </span>            : /*
<span class="lineNum">    3881 </span>            :  * WaitIO -- Block until the IO_IN_PROGRESS flag on 'buf' is cleared.
<a name="3882"><span class="lineNum">    3882 </span>            :  */</a>
<span class="lineNum">    3883 </span>            : static void
<span class="lineNum">    3884 </span><span class="lineNoCov">          0 : WaitIO(BufferDesc *buf)</span>
<span class="lineNum">    3885 </span>            : {
<span class="lineNum">    3886 </span>            :     /*
<span class="lineNum">    3887 </span>            :      * Changed to wait until there's no IO - Inoue 01/13/2000
<span class="lineNum">    3888 </span>            :      *
<span class="lineNum">    3889 </span>            :      * Note this is *necessary* because an error abort in the process doing
<span class="lineNum">    3890 </span>            :      * I/O could release the io_in_progress_lock prematurely. See
<span class="lineNum">    3891 </span>            :      * AbortBufferIO.
<span class="lineNum">    3892 </span>            :      */
<span class="lineNum">    3893 </span>            :     for (;;)
<span class="lineNum">    3894 </span>            :     {
<span class="lineNum">    3895 </span>            :         uint32      buf_state;
<span class="lineNum">    3896 </span>            : 
<span class="lineNum">    3897 </span>            :         /*
<span class="lineNum">    3898 </span>            :          * It may not be necessary to acquire the spinlock to check the flag
<span class="lineNum">    3899 </span>            :          * here, but since this test is essential for correctness, we'd better
<span class="lineNum">    3900 </span>            :          * play it safe.
<span class="lineNum">    3901 </span>            :          */
<span class="lineNum">    3902 </span><span class="lineNoCov">          0 :         buf_state = LockBufHdr(buf);</span>
<span class="lineNum">    3903 </span><span class="lineNoCov">          0 :         UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    3904 </span>            : 
<span class="lineNum">    3905 </span><span class="lineNoCov">          0 :         if (!(buf_state &amp; BM_IO_IN_PROGRESS))</span>
<span class="lineNum">    3906 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3907 </span><span class="lineNoCov">          0 :         LWLockAcquire(BufferDescriptorGetIOLock(buf), LW_SHARED);</span>
<span class="lineNum">    3908 </span><span class="lineNoCov">          0 :         LWLockRelease(BufferDescriptorGetIOLock(buf));</span>
<span class="lineNum">    3909 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    3910 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3911 </span>            : 
<span class="lineNum">    3912 </span>            : /*
<span class="lineNum">    3913 </span>            :  * StartBufferIO: begin I/O on this buffer
<span class="lineNum">    3914 </span>            :  *  (Assumptions)
<span class="lineNum">    3915 </span>            :  *  My process is executing no IO
<span class="lineNum">    3916 </span>            :  *  The buffer is Pinned
<span class="lineNum">    3917 </span>            :  *
<span class="lineNum">    3918 </span>            :  * In some scenarios there are race conditions in which multiple backends
<span class="lineNum">    3919 </span>            :  * could attempt the same I/O operation concurrently.  If someone else
<span class="lineNum">    3920 </span>            :  * has already started I/O on this buffer then we will block on the
<span class="lineNum">    3921 </span>            :  * io_in_progress lock until he's done.
<span class="lineNum">    3922 </span>            :  *
<span class="lineNum">    3923 </span>            :  * Input operations are only attempted on buffers that are not BM_VALID,
<span class="lineNum">    3924 </span>            :  * and output operations only on buffers that are BM_VALID and BM_DIRTY,
<span class="lineNum">    3925 </span>            :  * so we can always tell if the work is already done.
<span class="lineNum">    3926 </span>            :  *
<span class="lineNum">    3927 </span>            :  * Returns true if we successfully marked the buffer as I/O busy,
<span class="lineNum">    3928 </span>            :  * false if someone else already did the work.
<a name="3929"><span class="lineNum">    3929 </span>            :  */</a>
<span class="lineNum">    3930 </span>            : static bool
<span class="lineNum">    3931 </span><span class="lineCov">      73282 : StartBufferIO(BufferDesc *buf, bool forInput)</span>
<span class="lineNum">    3932 </span>            : {
<span class="lineNum">    3933 </span>            :     uint32      buf_state;
<span class="lineNum">    3934 </span>            : 
<span class="lineNum">    3935 </span><span class="lineCov">      73282 :     Assert(!InProgressBuf);</span>
<span class="lineNum">    3936 </span>            : 
<span class="lineNum">    3937 </span>            :     for (;;)
<span class="lineNum">    3938 </span>            :     {
<span class="lineNum">    3939 </span>            :         /*
<span class="lineNum">    3940 </span>            :          * Grab the io_in_progress lock so that other processes can wait for
<span class="lineNum">    3941 </span>            :          * me to finish the I/O.
<span class="lineNum">    3942 </span>            :          */
<span class="lineNum">    3943 </span><span class="lineCov">      73282 :         LWLockAcquire(BufferDescriptorGetIOLock(buf), LW_EXCLUSIVE);</span>
<span class="lineNum">    3944 </span>            : 
<span class="lineNum">    3945 </span><span class="lineCov">      73282 :         buf_state = LockBufHdr(buf);</span>
<span class="lineNum">    3946 </span>            : 
<span class="lineNum">    3947 </span><span class="lineCov">      73282 :         if (!(buf_state &amp; BM_IO_IN_PROGRESS))</span>
<span class="lineNum">    3948 </span><span class="lineCov">      73282 :             break;</span>
<span class="lineNum">    3949 </span>            : 
<span class="lineNum">    3950 </span>            :         /*
<span class="lineNum">    3951 </span>            :          * The only way BM_IO_IN_PROGRESS could be set when the io_in_progress
<span class="lineNum">    3952 </span>            :          * lock isn't held is if the process doing the I/O is recovering from
<span class="lineNum">    3953 </span>            :          * an error (see AbortBufferIO).  If that's the case, we must wait for
<span class="lineNum">    3954 </span>            :          * him to get unwedged.
<span class="lineNum">    3955 </span>            :          */
<span class="lineNum">    3956 </span><span class="lineNoCov">          0 :         UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    3957 </span><span class="lineNoCov">          0 :         LWLockRelease(BufferDescriptorGetIOLock(buf));</span>
<span class="lineNum">    3958 </span><span class="lineNoCov">          0 :         WaitIO(buf);</span>
<span class="lineNum">    3959 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    3960 </span>            : 
<span class="lineNum">    3961 </span>            :     /* Once we get here, there is definitely no I/O active on this buffer */
<span class="lineNum">    3962 </span>            : 
<span class="lineNum">    3963 </span><span class="lineCov">      73282 :     if (forInput ? (buf_state &amp; BM_VALID) : !(buf_state &amp; BM_DIRTY))</span>
<span class="lineNum">    3964 </span>            :     {
<span class="lineNum">    3965 </span>            :         /* someone else already did the I/O */
<span class="lineNum">    3966 </span><span class="lineNoCov">          0 :         UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    3967 </span><span class="lineNoCov">          0 :         LWLockRelease(BufferDescriptorGetIOLock(buf));</span>
<span class="lineNum">    3968 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3969 </span>            :     }
<span class="lineNum">    3970 </span>            : 
<span class="lineNum">    3971 </span><span class="lineCov">      73282 :     buf_state |= BM_IO_IN_PROGRESS;</span>
<span class="lineNum">    3972 </span><span class="lineCov">      73282 :     UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    3973 </span>            : 
<span class="lineNum">    3974 </span><span class="lineCov">      73282 :     InProgressBuf = buf;</span>
<span class="lineNum">    3975 </span><span class="lineCov">      73282 :     IsForInput = forInput;</span>
<span class="lineNum">    3976 </span>            : 
<span class="lineNum">    3977 </span><span class="lineCov">      73282 :     return true;</span>
<span class="lineNum">    3978 </span>            : }
<span class="lineNum">    3979 </span>            : 
<span class="lineNum">    3980 </span>            : /*
<span class="lineNum">    3981 </span>            :  * TerminateBufferIO: release a buffer we were doing I/O on
<span class="lineNum">    3982 </span>            :  *  (Assumptions)
<span class="lineNum">    3983 </span>            :  *  My process is executing IO for the buffer
<span class="lineNum">    3984 </span>            :  *  BM_IO_IN_PROGRESS bit is set for the buffer
<span class="lineNum">    3985 </span>            :  *  We hold the buffer's io_in_progress lock
<span class="lineNum">    3986 </span>            :  *  The buffer is Pinned
<span class="lineNum">    3987 </span>            :  *
<span class="lineNum">    3988 </span>            :  * If clear_dirty is true and BM_JUST_DIRTIED is not set, we clear the
<span class="lineNum">    3989 </span>            :  * buffer's BM_DIRTY flag.  This is appropriate when terminating a
<span class="lineNum">    3990 </span>            :  * successful write.  The check on BM_JUST_DIRTIED is necessary to avoid
<span class="lineNum">    3991 </span>            :  * marking the buffer clean if it was re-dirtied while we were writing.
<span class="lineNum">    3992 </span>            :  *
<span class="lineNum">    3993 </span>            :  * set_flag_bits gets ORed into the buffer's flags.  It must include
<span class="lineNum">    3994 </span>            :  * BM_IO_ERROR in a failure case.  For successful completion it could
<span class="lineNum">    3995 </span>            :  * be 0, or BM_VALID if we just finished reading in the page.
<a name="3996"><span class="lineNum">    3996 </span>            :  */</a>
<span class="lineNum">    3997 </span>            : static void
<span class="lineNum">    3998 </span><span class="lineCov">      73282 : TerminateBufferIO(BufferDesc *buf, bool clear_dirty, uint32 set_flag_bits)</span>
<span class="lineNum">    3999 </span>            : {
<span class="lineNum">    4000 </span>            :     uint32      buf_state;
<span class="lineNum">    4001 </span>            : 
<span class="lineNum">    4002 </span><span class="lineCov">      73282 :     Assert(buf == InProgressBuf);</span>
<span class="lineNum">    4003 </span>            : 
<span class="lineNum">    4004 </span><span class="lineCov">      73282 :     buf_state = LockBufHdr(buf);</span>
<span class="lineNum">    4005 </span>            : 
<span class="lineNum">    4006 </span><span class="lineCov">      73282 :     Assert(buf_state &amp; BM_IO_IN_PROGRESS);</span>
<span class="lineNum">    4007 </span>            : 
<span class="lineNum">    4008 </span><span class="lineCov">      73282 :     buf_state &amp;= ~(BM_IO_IN_PROGRESS | BM_IO_ERROR);</span>
<span class="lineNum">    4009 </span><span class="lineCov">      73282 :     if (clear_dirty &amp;&amp; !(buf_state &amp; BM_JUST_DIRTIED))</span>
<span class="lineNum">    4010 </span><span class="lineCov">      23598 :         buf_state &amp;= ~(BM_DIRTY | BM_CHECKPOINT_NEEDED);</span>
<span class="lineNum">    4011 </span>            : 
<span class="lineNum">    4012 </span><span class="lineCov">      73282 :     buf_state |= set_flag_bits;</span>
<span class="lineNum">    4013 </span><span class="lineCov">      73282 :     UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    4014 </span>            : 
<span class="lineNum">    4015 </span><span class="lineCov">      73282 :     InProgressBuf = NULL;</span>
<span class="lineNum">    4016 </span>            : 
<span class="lineNum">    4017 </span><span class="lineCov">      73282 :     LWLockRelease(BufferDescriptorGetIOLock(buf));</span>
<span class="lineNum">    4018 </span><span class="lineCov">      73282 : }</span>
<span class="lineNum">    4019 </span>            : 
<span class="lineNum">    4020 </span>            : /*
<span class="lineNum">    4021 </span>            :  * AbortBufferIO: Clean up any active buffer I/O after an error.
<span class="lineNum">    4022 </span>            :  *
<span class="lineNum">    4023 </span>            :  *  All LWLocks we might have held have been released,
<span class="lineNum">    4024 </span>            :  *  but we haven't yet released buffer pins, so the buffer is still pinned.
<span class="lineNum">    4025 </span>            :  *
<span class="lineNum">    4026 </span>            :  *  If I/O was in progress, we always set BM_IO_ERROR, even though it's
<span class="lineNum">    4027 </span>            :  *  possible the error condition wasn't related to the I/O.
<a name="4028"><span class="lineNum">    4028 </span>            :  */</a>
<span class="lineNum">    4029 </span>            : void
<span class="lineNum">    4030 </span><span class="lineCov">      10468 : AbortBufferIO(void)</span>
<span class="lineNum">    4031 </span>            : {
<span class="lineNum">    4032 </span><span class="lineCov">      10468 :     BufferDesc *buf = InProgressBuf;</span>
<span class="lineNum">    4033 </span>            : 
<span class="lineNum">    4034 </span><span class="lineCov">      10468 :     if (buf)</span>
<span class="lineNum">    4035 </span>            :     {
<span class="lineNum">    4036 </span>            :         uint32      buf_state;
<span class="lineNum">    4037 </span>            : 
<span class="lineNum">    4038 </span>            :         /*
<span class="lineNum">    4039 </span>            :          * Since LWLockReleaseAll has already been called, we're not holding
<span class="lineNum">    4040 </span>            :          * the buffer's io_in_progress_lock. We have to re-acquire it so that
<span class="lineNum">    4041 </span>            :          * we can use TerminateBufferIO. Anyone who's executing WaitIO on the
<span class="lineNum">    4042 </span>            :          * buffer will be in a busy spin until we succeed in doing this.
<span class="lineNum">    4043 </span>            :          */
<span class="lineNum">    4044 </span><span class="lineNoCov">          0 :         LWLockAcquire(BufferDescriptorGetIOLock(buf), LW_EXCLUSIVE);</span>
<span class="lineNum">    4045 </span>            : 
<span class="lineNum">    4046 </span><span class="lineNoCov">          0 :         buf_state = LockBufHdr(buf);</span>
<span class="lineNum">    4047 </span><span class="lineNoCov">          0 :         Assert(buf_state &amp; BM_IO_IN_PROGRESS);</span>
<span class="lineNum">    4048 </span><span class="lineNoCov">          0 :         if (IsForInput)</span>
<span class="lineNum">    4049 </span>            :         {
<span class="lineNum">    4050 </span><span class="lineNoCov">          0 :             Assert(!(buf_state &amp; BM_DIRTY));</span>
<span class="lineNum">    4051 </span>            : 
<span class="lineNum">    4052 </span>            :             /* We'd better not think buffer is valid yet */
<span class="lineNum">    4053 </span><span class="lineNoCov">          0 :             Assert(!(buf_state &amp; BM_VALID));</span>
<span class="lineNum">    4054 </span><span class="lineNoCov">          0 :             UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    4055 </span>            :         }
<span class="lineNum">    4056 </span>            :         else
<span class="lineNum">    4057 </span>            :         {
<span class="lineNum">    4058 </span><span class="lineNoCov">          0 :             Assert(buf_state &amp; BM_DIRTY);</span>
<span class="lineNum">    4059 </span><span class="lineNoCov">          0 :             UnlockBufHdr(buf, buf_state);</span>
<span class="lineNum">    4060 </span>            :             /* Issue notice if this is not the first failure... */
<span class="lineNum">    4061 </span><span class="lineNoCov">          0 :             if (buf_state &amp; BM_IO_ERROR)</span>
<span class="lineNum">    4062 </span>            :             {
<span class="lineNum">    4063 </span>            :                 /* Buffer is pinned, so we can read tag without spinlock */
<span class="lineNum">    4064 </span>            :                 char       *path;
<span class="lineNum">    4065 </span>            : 
<span class="lineNum">    4066 </span><span class="lineNoCov">          0 :                 path = relpathperm(buf-&gt;tag.rnode, buf-&gt;tag.forkNum);</span>
<span class="lineNum">    4067 </span><span class="lineNoCov">          0 :                 ereport(WARNING,</span>
<span class="lineNum">    4068 </span>            :                         (errcode(ERRCODE_IO_ERROR),
<span class="lineNum">    4069 </span>            :                          errmsg(&quot;could not write block %u of %s&quot;,
<span class="lineNum">    4070 </span>            :                                 buf-&gt;tag.blockNum, path),
<span class="lineNum">    4071 </span>            :                          errdetail(&quot;Multiple failures --- write error might be permanent.&quot;)));
<span class="lineNum">    4072 </span><span class="lineNoCov">          0 :                 pfree(path);</span>
<span class="lineNum">    4073 </span>            :             }
<span class="lineNum">    4074 </span>            :         }
<span class="lineNum">    4075 </span><span class="lineNoCov">          0 :         TerminateBufferIO(buf, false, BM_IO_ERROR);</span>
<span class="lineNum">    4076 </span>            :     }
<span class="lineNum">    4077 </span><span class="lineCov">      10468 : }</span>
<span class="lineNum">    4078 </span>            : 
<span class="lineNum">    4079 </span>            : /*
<span class="lineNum">    4080 </span>            :  * Error context callback for errors occurring during shared buffer writes.
<a name="4081"><span class="lineNum">    4081 </span>            :  */</a>
<span class="lineNum">    4082 </span>            : static void
<span class="lineNum">    4083 </span><span class="lineNoCov">          0 : shared_buffer_write_error_callback(void *arg)</span>
<span class="lineNum">    4084 </span>            : {
<span class="lineNum">    4085 </span><span class="lineNoCov">          0 :     BufferDesc *bufHdr = (BufferDesc *) arg;</span>
<span class="lineNum">    4086 </span>            : 
<span class="lineNum">    4087 </span>            :     /* Buffer is pinned, so we can read the tag without locking the spinlock */
<span class="lineNum">    4088 </span><span class="lineNoCov">          0 :     if (bufHdr != NULL)</span>
<span class="lineNum">    4089 </span>            :     {
<span class="lineNum">    4090 </span><span class="lineNoCov">          0 :         char       *path = relpathperm(bufHdr-&gt;tag.rnode, bufHdr-&gt;tag.forkNum);</span>
<span class="lineNum">    4091 </span>            : 
<span class="lineNum">    4092 </span><span class="lineNoCov">          0 :         errcontext(&quot;writing block %u of relation %s&quot;,</span>
<span class="lineNum">    4093 </span>            :                    bufHdr-&gt;tag.blockNum, path);
<span class="lineNum">    4094 </span><span class="lineNoCov">          0 :         pfree(path);</span>
<span class="lineNum">    4095 </span>            :     }
<span class="lineNum">    4096 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4097 </span>            : 
<span class="lineNum">    4098 </span>            : /*
<span class="lineNum">    4099 </span>            :  * Error context callback for errors occurring during local buffer writes.
<a name="4100"><span class="lineNum">    4100 </span>            :  */</a>
<span class="lineNum">    4101 </span>            : static void
<span class="lineNum">    4102 </span><span class="lineNoCov">          0 : local_buffer_write_error_callback(void *arg)</span>
<span class="lineNum">    4103 </span>            : {
<span class="lineNum">    4104 </span><span class="lineNoCov">          0 :     BufferDesc *bufHdr = (BufferDesc *) arg;</span>
<span class="lineNum">    4105 </span>            : 
<span class="lineNum">    4106 </span><span class="lineNoCov">          0 :     if (bufHdr != NULL)</span>
<span class="lineNum">    4107 </span>            :     {
<span class="lineNum">    4108 </span><span class="lineNoCov">          0 :         char       *path = relpathbackend(bufHdr-&gt;tag.rnode, MyBackendId,</span>
<span class="lineNum">    4109 </span>            :                                           bufHdr-&gt;tag.forkNum);
<span class="lineNum">    4110 </span>            : 
<span class="lineNum">    4111 </span><span class="lineNoCov">          0 :         errcontext(&quot;writing block %u of relation %s&quot;,</span>
<span class="lineNum">    4112 </span>            :                    bufHdr-&gt;tag.blockNum, path);
<span class="lineNum">    4113 </span><span class="lineNoCov">          0 :         pfree(path);</span>
<span class="lineNum">    4114 </span>            :     }
<span class="lineNum">    4115 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4116 </span>            : 
<span class="lineNum">    4117 </span>            : /*
<span class="lineNum">    4118 </span>            :  * RelFileNode qsort/bsearch comparator; see RelFileNodeEquals.
<a name="4119"><span class="lineNum">    4119 </span>            :  */</a>
<span class="lineNum">    4120 </span>            : static int
<span class="lineNum">    4121 </span><span class="lineCov">    4970724 : rnode_comparator(const void *p1, const void *p2)</span>
<span class="lineNum">    4122 </span>            : {
<span class="lineNum">    4123 </span><span class="lineCov">    4970724 :     RelFileNode n1 = *(const RelFileNode *) p1;</span>
<span class="lineNum">    4124 </span><span class="lineCov">    4970724 :     RelFileNode n2 = *(const RelFileNode *) p2;</span>
<span class="lineNum">    4125 </span>            : 
<span class="lineNum">    4126 </span><span class="lineCov">    4970724 :     if (n1.relNode &lt; n2.relNode)</span>
<span class="lineNum">    4127 </span><span class="lineCov">    4898658 :         return -1;</span>
<span class="lineNum">    4128 </span><span class="lineCov">      72066 :     else if (n1.relNode &gt; n2.relNode)</span>
<span class="lineNum">    4129 </span><span class="lineCov">      29326 :         return 1;</span>
<span class="lineNum">    4130 </span>            : 
<span class="lineNum">    4131 </span><span class="lineCov">      42740 :     if (n1.dbNode &lt; n2.dbNode)</span>
<span class="lineNum">    4132 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">    4133 </span><span class="lineCov">      42740 :     else if (n1.dbNode &gt; n2.dbNode)</span>
<span class="lineNum">    4134 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">    4135 </span>            : 
<span class="lineNum">    4136 </span><span class="lineCov">      42740 :     if (n1.spcNode &lt; n2.spcNode)</span>
<span class="lineNum">    4137 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">    4138 </span><span class="lineCov">      42740 :     else if (n1.spcNode &gt; n2.spcNode)</span>
<span class="lineNum">    4139 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">    4140 </span>            :     else
<span class="lineNum">    4141 </span><span class="lineCov">      42740 :         return 0;</span>
<span class="lineNum">    4142 </span>            : }
<span class="lineNum">    4143 </span>            : 
<span class="lineNum">    4144 </span>            : /*
<span class="lineNum">    4145 </span>            :  * Lock buffer header - set BM_LOCKED in buffer state.
<a name="4146"><span class="lineNum">    4146 </span>            :  */</a>
<span class="lineNum">    4147 </span>            : uint32
<span class="lineNum">    4148 </span><span class="lineCov">     761370 : LockBufHdr(BufferDesc *desc)</span>
<span class="lineNum">    4149 </span>            : {
<span class="lineNum">    4150 </span>            :     SpinDelayStatus delayStatus;
<span class="lineNum">    4151 </span>            :     uint32      old_buf_state;
<span class="lineNum">    4152 </span>            : 
<span class="lineNum">    4153 </span><span class="lineCov">     761370 :     init_local_spin_delay(&amp;delayStatus);</span>
<span class="lineNum">    4154 </span>            : 
<span class="lineNum">    4155 </span>            :     while (true)
<span class="lineNum">    4156 </span>            :     {
<span class="lineNum">    4157 </span>            :         /* set BM_LOCKED flag */
<span class="lineNum">    4158 </span><span class="lineCov">     761370 :         old_buf_state = pg_atomic_fetch_or_u32(&amp;desc-&gt;state, BM_LOCKED);</span>
<span class="lineNum">    4159 </span>            :         /* if it wasn't set before we're OK */
<span class="lineNum">    4160 </span><span class="lineCov">     761370 :         if (!(old_buf_state &amp; BM_LOCKED))</span>
<span class="lineNum">    4161 </span><span class="lineCov">     761370 :             break;</span>
<span class="lineNum">    4162 </span><span class="lineNoCov">          0 :         perform_spin_delay(&amp;delayStatus);</span>
<span class="lineNum">    4163 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    4164 </span><span class="lineCov">     761370 :     finish_spin_delay(&amp;delayStatus);</span>
<span class="lineNum">    4165 </span><span class="lineCov">     761370 :     return old_buf_state | BM_LOCKED;</span>
<span class="lineNum">    4166 </span>            : }
<span class="lineNum">    4167 </span>            : 
<span class="lineNum">    4168 </span>            : /*
<span class="lineNum">    4169 </span>            :  * Wait until the BM_LOCKED flag isn't set anymore and return the buffer's
<span class="lineNum">    4170 </span>            :  * state at that point.
<span class="lineNum">    4171 </span>            :  *
<span class="lineNum">    4172 </span>            :  * Obviously the buffer could be locked by the time the value is returned, so
<span class="lineNum">    4173 </span>            :  * this is primarily useful in CAS style loops.
<a name="4174"><span class="lineNum">    4174 </span>            :  */</a>
<span class="lineNum">    4175 </span>            : static uint32
<span class="lineNum">    4176 </span><span class="lineNoCov">          0 : WaitBufHdrUnlocked(BufferDesc *buf)</span>
<span class="lineNum">    4177 </span>            : {
<span class="lineNum">    4178 </span>            :     SpinDelayStatus delayStatus;
<span class="lineNum">    4179 </span>            :     uint32      buf_state;
<span class="lineNum">    4180 </span>            : 
<span class="lineNum">    4181 </span><span class="lineNoCov">          0 :     init_local_spin_delay(&amp;delayStatus);</span>
<span class="lineNum">    4182 </span>            : 
<span class="lineNum">    4183 </span><span class="lineNoCov">          0 :     buf_state = pg_atomic_read_u32(&amp;buf-&gt;state);</span>
<span class="lineNum">    4184 </span>            : 
<span class="lineNum">    4185 </span><span class="lineNoCov">          0 :     while (buf_state &amp; BM_LOCKED)</span>
<span class="lineNum">    4186 </span>            :     {
<span class="lineNum">    4187 </span><span class="lineNoCov">          0 :         perform_spin_delay(&amp;delayStatus);</span>
<span class="lineNum">    4188 </span><span class="lineNoCov">          0 :         buf_state = pg_atomic_read_u32(&amp;buf-&gt;state);</span>
<span class="lineNum">    4189 </span>            :     }
<span class="lineNum">    4190 </span>            : 
<span class="lineNum">    4191 </span><span class="lineNoCov">          0 :     finish_spin_delay(&amp;delayStatus);</span>
<span class="lineNum">    4192 </span>            : 
<span class="lineNum">    4193 </span><span class="lineNoCov">          0 :     return buf_state;</span>
<span class="lineNum">    4194 </span>            : }
<span class="lineNum">    4195 </span>            : 
<span class="lineNum">    4196 </span>            : /*
<span class="lineNum">    4197 </span>            :  * BufferTag comparator.
<a name="4198"><span class="lineNum">    4198 </span>            :  */</a>
<span class="lineNum">    4199 </span>            : static int
<span class="lineNum">    4200 </span><span class="lineCov">      53444 : buffertag_comparator(const void *a, const void *b)</span>
<span class="lineNum">    4201 </span>            : {
<span class="lineNum">    4202 </span><span class="lineCov">      53444 :     const BufferTag *ba = (const BufferTag *) a;</span>
<span class="lineNum">    4203 </span><span class="lineCov">      53444 :     const BufferTag *bb = (const BufferTag *) b;</span>
<span class="lineNum">    4204 </span>            :     int         ret;
<span class="lineNum">    4205 </span>            : 
<span class="lineNum">    4206 </span><span class="lineCov">      53444 :     ret = rnode_comparator(&amp;ba-&gt;rnode, &amp;bb-&gt;rnode);</span>
<span class="lineNum">    4207 </span>            : 
<span class="lineNum">    4208 </span><span class="lineCov">      53444 :     if (ret != 0)</span>
<span class="lineNum">    4209 </span><span class="lineCov">      11024 :         return ret;</span>
<span class="lineNum">    4210 </span>            : 
<span class="lineNum">    4211 </span><span class="lineCov">      42420 :     if (ba-&gt;forkNum &lt; bb-&gt;forkNum)</span>
<span class="lineNum">    4212 </span><span class="lineCov">       1400 :         return -1;</span>
<span class="lineNum">    4213 </span><span class="lineCov">      41020 :     if (ba-&gt;forkNum &gt; bb-&gt;forkNum)</span>
<span class="lineNum">    4214 </span><span class="lineCov">        740 :         return 1;</span>
<span class="lineNum">    4215 </span>            : 
<span class="lineNum">    4216 </span><span class="lineCov">      40280 :     if (ba-&gt;blockNum &lt; bb-&gt;blockNum)</span>
<span class="lineNum">    4217 </span><span class="lineCov">      29908 :         return -1;</span>
<span class="lineNum">    4218 </span><span class="lineCov">      10372 :     if (ba-&gt;blockNum &gt; bb-&gt;blockNum)</span>
<span class="lineNum">    4219 </span><span class="lineCov">      10372 :         return 1;</span>
<span class="lineNum">    4220 </span>            : 
<span class="lineNum">    4221 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    4222 </span>            : }
<span class="lineNum">    4223 </span>            : 
<span class="lineNum">    4224 </span>            : /*
<span class="lineNum">    4225 </span>            :  * Comparator determining the writeout order in a checkpoint.
<span class="lineNum">    4226 </span>            :  *
<span class="lineNum">    4227 </span>            :  * It is important that tablespaces are compared first, the logic balancing
<span class="lineNum">    4228 </span>            :  * writes between tablespaces relies on it.
<a name="4229"><span class="lineNum">    4229 </span>            :  */</a>
<span class="lineNum">    4230 </span>            : static int
<span class="lineNum">    4231 </span><span class="lineCov">     314820 : ckpt_buforder_comparator(const void *pa, const void *pb)</span>
<span class="lineNum">    4232 </span>            : {
<span class="lineNum">    4233 </span><span class="lineCov">     314820 :     const CkptSortItem *a = (const CkptSortItem *) pa;</span>
<span class="lineNum">    4234 </span><span class="lineCov">     314820 :     const CkptSortItem *b = (const CkptSortItem *) pb;</span>
<span class="lineNum">    4235 </span>            : 
<span class="lineNum">    4236 </span>            :     /* compare tablespace */
<span class="lineNum">    4237 </span><span class="lineCov">     314820 :     if (a-&gt;tsId &lt; b-&gt;tsId)</span>
<span class="lineNum">    4238 </span><span class="lineCov">        392 :         return -1;</span>
<span class="lineNum">    4239 </span><span class="lineCov">     314428 :     else if (a-&gt;tsId &gt; b-&gt;tsId)</span>
<span class="lineNum">    4240 </span><span class="lineCov">       1388 :         return 1;</span>
<span class="lineNum">    4241 </span>            :     /* compare relation */
<span class="lineNum">    4242 </span><span class="lineCov">     313040 :     if (a-&gt;relNode &lt; b-&gt;relNode)</span>
<span class="lineNum">    4243 </span><span class="lineCov">      79638 :         return -1;</span>
<span class="lineNum">    4244 </span><span class="lineCov">     233402 :     else if (a-&gt;relNode &gt; b-&gt;relNode)</span>
<span class="lineNum">    4245 </span><span class="lineCov">      83014 :         return 1;</span>
<span class="lineNum">    4246 </span>            :     /* compare fork */
<span class="lineNum">    4247 </span><span class="lineCov">     150388 :     else if (a-&gt;forkNum &lt; b-&gt;forkNum)</span>
<span class="lineNum">    4248 </span><span class="lineCov">       3008 :         return -1;</span>
<span class="lineNum">    4249 </span><span class="lineCov">     147380 :     else if (a-&gt;forkNum &gt; b-&gt;forkNum)</span>
<span class="lineNum">    4250 </span><span class="lineCov">       3150 :         return 1;</span>
<span class="lineNum">    4251 </span>            :     /* compare block number */
<span class="lineNum">    4252 </span><span class="lineCov">     144230 :     else if (a-&gt;blockNum &lt; b-&gt;blockNum)</span>
<span class="lineNum">    4253 </span><span class="lineCov">      72322 :         return -1;</span>
<span class="lineNum">    4254 </span><span class="lineCov">      71908 :     else if (a-&gt;blockNum &gt; b-&gt;blockNum)</span>
<span class="lineNum">    4255 </span><span class="lineCov">      71908 :         return 1;</span>
<span class="lineNum">    4256 </span>            :     /* equal page IDs are unlikely, but not impossible */
<span class="lineNum">    4257 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    4258 </span>            : }
<span class="lineNum">    4259 </span>            : 
<span class="lineNum">    4260 </span>            : /*
<span class="lineNum">    4261 </span>            :  * Comparator for a Min-Heap over the per-tablespace checkpoint completion
<span class="lineNum">    4262 </span>            :  * progress.
<a name="4263"><span class="lineNum">    4263 </span>            :  */</a>
<span class="lineNum">    4264 </span>            : static int
<span class="lineNum">    4265 </span><span class="lineCov">      23148 : ts_ckpt_progress_comparator(Datum a, Datum b, void *arg)</span>
<span class="lineNum">    4266 </span>            : {
<span class="lineNum">    4267 </span><span class="lineCov">      23148 :     CkptTsStatus *sa = (CkptTsStatus *) a;</span>
<span class="lineNum">    4268 </span><span class="lineCov">      23148 :     CkptTsStatus *sb = (CkptTsStatus *) b;</span>
<span class="lineNum">    4269 </span>            : 
<span class="lineNum">    4270 </span>            :     /* we want a min-heap, so return 1 for the a &lt; b */
<span class="lineNum">    4271 </span><span class="lineCov">      23148 :     if (sa-&gt;progress &lt; sb-&gt;progress)</span>
<span class="lineNum">    4272 </span><span class="lineCov">      22466 :         return 1;</span>
<span class="lineNum">    4273 </span><span class="lineCov">        682 :     else if (sa-&gt;progress == sb-&gt;progress)</span>
<span class="lineNum">    4274 </span><span class="lineCov">         16 :         return 0;</span>
<span class="lineNum">    4275 </span>            :     else
<span class="lineNum">    4276 </span><span class="lineCov">        666 :         return -1;</span>
<span class="lineNum">    4277 </span>            : }
<span class="lineNum">    4278 </span>            : 
<span class="lineNum">    4279 </span>            : /*
<span class="lineNum">    4280 </span>            :  * Initialize a writeback context, discarding potential previous state.
<span class="lineNum">    4281 </span>            :  *
<span class="lineNum">    4282 </span>            :  * *max_pending is a pointer instead of an immediate value, so the coalesce
<span class="lineNum">    4283 </span>            :  * limits can easily changed by the GUC mechanism, and so calling code does
<span class="lineNum">    4284 </span>            :  * not have to check the current configuration. A value is 0 means that no
<span class="lineNum">    4285 </span>            :  * writeback control will be performed.
<a name="4286"><span class="lineNum">    4286 </span>            :  */</a>
<span class="lineNum">    4287 </span>            : void
<span class="lineNum">    4288 </span><span class="lineCov">       1246 : WritebackContextInit(WritebackContext *context, int *max_pending)</span>
<span class="lineNum">    4289 </span>            : {
<span class="lineNum">    4290 </span><span class="lineCov">       1246 :     Assert(*max_pending &lt;= WRITEBACK_MAX_PENDING_FLUSHES);</span>
<span class="lineNum">    4291 </span>            : 
<span class="lineNum">    4292 </span><span class="lineCov">       1246 :     context-&gt;max_pending = max_pending;</span>
<span class="lineNum">    4293 </span><span class="lineCov">       1246 :     context-&gt;nr_pending = 0;</span>
<span class="lineNum">    4294 </span><span class="lineCov">       1246 : }</span>
<span class="lineNum">    4295 </span>            : 
<span class="lineNum">    4296 </span>            : /*
<span class="lineNum">    4297 </span>            :  * Add buffer to list of pending writeback requests.
<a name="4298"><span class="lineNum">    4298 </span>            :  */</a>
<span class="lineNum">    4299 </span>            : void
<span class="lineNum">    4300 </span><span class="lineCov">      23534 : ScheduleBufferTagForWriteback(WritebackContext *context, BufferTag *tag)</span>
<span class="lineNum">    4301 </span>            : {
<span class="lineNum">    4302 </span>            :     PendingWriteback *pending;
<span class="lineNum">    4303 </span>            : 
<span class="lineNum">    4304 </span>            :     /*
<span class="lineNum">    4305 </span>            :      * Add buffer to the pending writeback array, unless writeback control is
<span class="lineNum">    4306 </span>            :      * disabled.
<span class="lineNum">    4307 </span>            :      */
<span class="lineNum">    4308 </span><span class="lineCov">      23534 :     if (*context-&gt;max_pending &gt; 0)</span>
<span class="lineNum">    4309 </span>            :     {
<span class="lineNum">    4310 </span><span class="lineCov">      23486 :         Assert(*context-&gt;max_pending &lt;= WRITEBACK_MAX_PENDING_FLUSHES);</span>
<span class="lineNum">    4311 </span>            : 
<span class="lineNum">    4312 </span><span class="lineCov">      23486 :         pending = &amp;context-&gt;pending_writebacks[context-&gt;nr_pending++];</span>
<span class="lineNum">    4313 </span>            : 
<span class="lineNum">    4314 </span><span class="lineCov">      23486 :         pending-&gt;tag = *tag;</span>
<span class="lineNum">    4315 </span>            :     }
<span class="lineNum">    4316 </span>            : 
<span class="lineNum">    4317 </span>            :     /*
<span class="lineNum">    4318 </span>            :      * Perform pending flushes if the writeback limit is exceeded. This
<span class="lineNum">    4319 </span>            :      * includes the case where previously an item has been added, but control
<span class="lineNum">    4320 </span>            :      * is now disabled.
<span class="lineNum">    4321 </span>            :      */
<span class="lineNum">    4322 </span><span class="lineCov">      23534 :     if (context-&gt;nr_pending &gt;= *context-&gt;max_pending)</span>
<span class="lineNum">    4323 </span><span class="lineCov">        776 :         IssuePendingWritebacks(context);</span>
<span class="lineNum">    4324 </span><span class="lineCov">      23534 : }</span>
<span class="lineNum">    4325 </span>            : 
<span class="lineNum">    4326 </span>            : /*
<span class="lineNum">    4327 </span>            :  * Issue all pending writeback requests, previously scheduled with
<span class="lineNum">    4328 </span>            :  * ScheduleBufferTagForWriteback, to the OS.
<span class="lineNum">    4329 </span>            :  *
<span class="lineNum">    4330 </span>            :  * Because this is only used to improve the OSs IO scheduling we try to never
<span class="lineNum">    4331 </span>            :  * error out - it's just a hint.
<a name="4332"><span class="lineNum">    4332 </span>            :  */</a>
<span class="lineNum">    4333 </span>            : void
<span class="lineNum">    4334 </span><span class="lineCov">        792 : IssuePendingWritebacks(WritebackContext *context)</span>
<span class="lineNum">    4335 </span>            : {
<span class="lineNum">    4336 </span>            :     int         i;
<span class="lineNum">    4337 </span>            : 
<span class="lineNum">    4338 </span><span class="lineCov">        792 :     if (context-&gt;nr_pending == 0)</span>
<span class="lineNum">    4339 </span><span class="lineCov">        840 :         return;</span>
<span class="lineNum">    4340 </span>            : 
<span class="lineNum">    4341 </span>            :     /*
<span class="lineNum">    4342 </span>            :      * Executing the writes in-order can make them a lot faster, and allows to
<span class="lineNum">    4343 </span>            :      * merge writeback requests to consecutive blocks into larger writebacks.
<span class="lineNum">    4344 </span>            :      */
<span class="lineNum">    4345 </span><span class="lineCov">        744 :     qsort(&amp;context-&gt;pending_writebacks, context-&gt;nr_pending,</span>
<span class="lineNum">    4346 </span>            :           sizeof(PendingWriteback), buffertag_comparator);
<span class="lineNum">    4347 </span>            : 
<span class="lineNum">    4348 </span>            :     /*
<span class="lineNum">    4349 </span>            :      * Coalesce neighbouring writes, but nothing else. For that we iterate
<span class="lineNum">    4350 </span>            :      * through the, now sorted, array of pending flushes, and look forward to
<span class="lineNum">    4351 </span>            :      * find all neighbouring (or identical) writes.
<span class="lineNum">    4352 </span>            :      */
<span class="lineNum">    4353 </span><span class="lineCov">       4672 :     for (i = 0; i &lt; context-&gt;nr_pending; i++)</span>
<span class="lineNum">    4354 </span>            :     {
<span class="lineNum">    4355 </span>            :         PendingWriteback *cur;
<span class="lineNum">    4356 </span>            :         PendingWriteback *next;
<span class="lineNum">    4357 </span>            :         SMgrRelation reln;
<span class="lineNum">    4358 </span>            :         int         ahead;
<span class="lineNum">    4359 </span>            :         BufferTag   tag;
<span class="lineNum">    4360 </span><span class="lineCov">       3928 :         Size        nblocks = 1;</span>
<span class="lineNum">    4361 </span>            : 
<span class="lineNum">    4362 </span><span class="lineCov">       3928 :         cur = &amp;context-&gt;pending_writebacks[i];</span>
<span class="lineNum">    4363 </span><span class="lineCov">       3928 :         tag = cur-&gt;tag;</span>
<span class="lineNum">    4364 </span>            : 
<span class="lineNum">    4365 </span>            :         /*
<span class="lineNum">    4366 </span>            :          * Peek ahead, into following writeback requests, to see if they can
<span class="lineNum">    4367 </span>            :          * be combined with the current one.
<span class="lineNum">    4368 </span>            :          */
<span class="lineNum">    4369 </span><span class="lineCov">      23486 :         for (ahead = 0; i + ahead + 1 &lt; context-&gt;nr_pending; ahead++)</span>
<span class="lineNum">    4370 </span>            :         {
<span class="lineNum">    4371 </span><span class="lineCov">      22742 :             next = &amp;context-&gt;pending_writebacks[i + ahead + 1];</span>
<span class="lineNum">    4372 </span>            : 
<span class="lineNum">    4373 </span>            :             /* different file, stop */
<span class="lineNum">    4374 </span><span class="lineCov">      43320 :             if (!RelFileNodeEquals(cur-&gt;tag.rnode, next-&gt;tag.rnode) ||</span>
<span class="lineNum">    4375 </span><span class="lineCov">      20578 :                 cur-&gt;tag.forkNum != next-&gt;tag.forkNum)</span>
<span class="lineNum">    4376 </span>            :                 break;
<span class="lineNum">    4377 </span>            : 
<span class="lineNum">    4378 </span>            :             /* ok, block queued twice, skip */
<span class="lineNum">    4379 </span><span class="lineCov">      19752 :             if (cur-&gt;tag.blockNum == next-&gt;tag.blockNum)</span>
<span class="lineNum">    4380 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    4381 </span>            : 
<span class="lineNum">    4382 </span>            :             /* only merge consecutive writes */
<span class="lineNum">    4383 </span><span class="lineCov">      19752 :             if (cur-&gt;tag.blockNum + 1 != next-&gt;tag.blockNum)</span>
<span class="lineNum">    4384 </span><span class="lineCov">        194 :                 break;</span>
<span class="lineNum">    4385 </span>            : 
<span class="lineNum">    4386 </span><span class="lineCov">      19558 :             nblocks++;</span>
<span class="lineNum">    4387 </span><span class="lineCov">      19558 :             cur = next;</span>
<span class="lineNum">    4388 </span>            :         }
<span class="lineNum">    4389 </span>            : 
<span class="lineNum">    4390 </span><span class="lineCov">       3928 :         i += ahead;</span>
<span class="lineNum">    4391 </span>            : 
<span class="lineNum">    4392 </span>            :         /* and finally tell the kernel to write the data to storage */
<span class="lineNum">    4393 </span><span class="lineCov">       3928 :         reln = smgropen(tag.rnode, InvalidBackendId);</span>
<span class="lineNum">    4394 </span><span class="lineCov">       3928 :         smgrwriteback(reln, tag.forkNum, tag.blockNum, nblocks);</span>
<span class="lineNum">    4395 </span>            :     }
<span class="lineNum">    4396 </span>            : 
<span class="lineNum">    4397 </span><span class="lineCov">        744 :     context-&gt;nr_pending = 0;</span>
<span class="lineNum">    4398 </span>            : }
<span class="lineNum">    4399 </span>            : 
<span class="lineNum">    4400 </span>            : 
<span class="lineNum">    4401 </span>            : /*
<span class="lineNum">    4402 </span>            :  * Implement slower/larger portions of TestForOldSnapshot
<span class="lineNum">    4403 </span>            :  *
<span class="lineNum">    4404 </span>            :  * Smaller/faster portions are put inline, but the entire set of logic is too
<span class="lineNum">    4405 </span>            :  * big for that.
<a name="4406"><span class="lineNum">    4406 </span>            :  */</a>
<span class="lineNum">    4407 </span>            : void
<span class="lineNum">    4408 </span><span class="lineNoCov">          0 : TestForOldSnapshot_impl(Snapshot snapshot, Relation relation)</span>
<span class="lineNum">    4409 </span>            : {
<span class="lineNum">    4410 </span><span class="lineNoCov">          0 :     if (RelationAllowsEarlyPruning(relation)</span>
<span class="lineNum">    4411 </span><span class="lineNoCov">          0 :         &amp;&amp; (snapshot)-&gt;whenTaken &lt; GetOldSnapshotThresholdTimestamp())</span>
<span class="lineNum">    4412 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    4413 </span>            :                 (errcode(ERRCODE_SNAPSHOT_TOO_OLD),
<span class="lineNum">    4414 </span>            :                  errmsg(&quot;snapshot too old&quot;)));
<span class="lineNum">    4415 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
