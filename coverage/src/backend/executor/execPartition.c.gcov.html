<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/executor/execPartition.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/backend/executor</a> - execPartition.c<span style="font-size: 80%;"> (source / <a href="execPartition.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">538</td>
            <td class="headerCovTableEntry">565</td>
            <td class="headerCovTableEntryHi">95.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * execPartition.c
<span class="lineNum">       4 </span>            :  *    Support routines for partitioning.
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  * IDENTIFICATION
<span class="lineNum">      10 </span>            :  *    src/backend/executor/execPartition.c
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      13 </span>            :  */
<span class="lineNum">      14 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &quot;access/table.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;access/tableam.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;catalog/partition.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;catalog/pg_inherits.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;catalog/pg_type.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;executor/execPartition.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;executor/executor.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;foreign/fdwapi.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;mb/pg_wchar.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;miscadmin.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nodes/makefuncs.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;partitioning/partbounds.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;partitioning/partdesc.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;partitioning/partprune.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;rewrite/rewriteManip.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;utils/lsyscache.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;utils/partcache.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;utils/rel.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;utils/rls.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;utils/ruleutils.h&quot;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : /*-----------------------
<span class="lineNum">      39 </span>            :  * PartitionTupleRouting - Encapsulates all information required to
<span class="lineNum">      40 </span>            :  * route a tuple inserted into a partitioned table to one of its leaf
<span class="lineNum">      41 </span>            :  * partitions.
<span class="lineNum">      42 </span>            :  *
<span class="lineNum">      43 </span>            :  * partition_root
<span class="lineNum">      44 </span>            :  *      The partitioned table that's the target of the command.
<span class="lineNum">      45 </span>            :  *
<span class="lineNum">      46 </span>            :  * partition_dispatch_info
<span class="lineNum">      47 </span>            :  *      Array of 'max_dispatch' elements containing a pointer to a
<span class="lineNum">      48 </span>            :  *      PartitionDispatch object for every partitioned table touched by tuple
<span class="lineNum">      49 </span>            :  *      routing.  The entry for the target partitioned table is *always*
<span class="lineNum">      50 </span>            :  *      present in the 0th element of this array.  See comment for
<span class="lineNum">      51 </span>            :  *      PartitionDispatchData-&gt;indexes for details on how this array is
<span class="lineNum">      52 </span>            :  *      indexed.
<span class="lineNum">      53 </span>            :  *
<span class="lineNum">      54 </span>            :  * num_dispatch
<span class="lineNum">      55 </span>            :  *      The current number of items stored in the 'partition_dispatch_info'
<span class="lineNum">      56 </span>            :  *      array.  Also serves as the index of the next free array element for
<span class="lineNum">      57 </span>            :  *      new PartitionDispatch objects that need to be stored.
<span class="lineNum">      58 </span>            :  *
<span class="lineNum">      59 </span>            :  * max_dispatch
<span class="lineNum">      60 </span>            :  *      The current allocated size of the 'partition_dispatch_info' array.
<span class="lineNum">      61 </span>            :  *
<span class="lineNum">      62 </span>            :  * partitions
<span class="lineNum">      63 </span>            :  *      Array of 'max_partitions' elements containing a pointer to a
<span class="lineNum">      64 </span>            :  *      ResultRelInfo for every leaf partitions touched by tuple routing.
<span class="lineNum">      65 </span>            :  *      Some of these are pointers to ResultRelInfos which are borrowed out of
<span class="lineNum">      66 </span>            :  *      'subplan_resultrel_htab'.  The remainder have been built especially
<span class="lineNum">      67 </span>            :  *      for tuple routing.  See comment for PartitionDispatchData-&gt;indexes for
<span class="lineNum">      68 </span>            :  *      details on how this array is indexed.
<span class="lineNum">      69 </span>            :  *
<span class="lineNum">      70 </span>            :  * num_partitions
<span class="lineNum">      71 </span>            :  *      The current number of items stored in the 'partitions' array.  Also
<span class="lineNum">      72 </span>            :  *      serves as the index of the next free array element for new
<span class="lineNum">      73 </span>            :  *      ResultRelInfo objects that need to be stored.
<span class="lineNum">      74 </span>            :  *
<span class="lineNum">      75 </span>            :  * max_partitions
<span class="lineNum">      76 </span>            :  *      The current allocated size of the 'partitions' array.
<span class="lineNum">      77 </span>            :  *
<span class="lineNum">      78 </span>            :  * subplan_resultrel_htab
<span class="lineNum">      79 </span>            :  *      Hash table to store subplan ResultRelInfos by Oid.  This is used to
<span class="lineNum">      80 </span>            :  *      cache ResultRelInfos from subplans of an UPDATE ModifyTable node;
<span class="lineNum">      81 </span>            :  *      NULL in other cases.  Some of these may be useful for tuple routing
<span class="lineNum">      82 </span>            :  *      to save having to build duplicates.
<span class="lineNum">      83 </span>            :  *
<span class="lineNum">      84 </span>            :  * memcxt
<span class="lineNum">      85 </span>            :  *      Memory context used to allocate subsidiary structs.
<span class="lineNum">      86 </span>            :  *-----------------------
<span class="lineNum">      87 </span>            :  */
<span class="lineNum">      88 </span>            : struct PartitionTupleRouting
<span class="lineNum">      89 </span>            : {
<span class="lineNum">      90 </span>            :     Relation    partition_root;
<span class="lineNum">      91 </span>            :     PartitionDispatch *partition_dispatch_info;
<span class="lineNum">      92 </span>            :     int         num_dispatch;
<span class="lineNum">      93 </span>            :     int         max_dispatch;
<span class="lineNum">      94 </span>            :     ResultRelInfo **partitions;
<span class="lineNum">      95 </span>            :     int         num_partitions;
<span class="lineNum">      96 </span>            :     int         max_partitions;
<span class="lineNum">      97 </span>            :     HTAB       *subplan_resultrel_htab;
<span class="lineNum">      98 </span>            :     MemoryContext memcxt;
<span class="lineNum">      99 </span>            : };
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : /*-----------------------
<span class="lineNum">     102 </span>            :  * PartitionDispatch - information about one partitioned table in a partition
<span class="lineNum">     103 </span>            :  * hierarchy required to route a tuple to any of its partitions.  A
<span class="lineNum">     104 </span>            :  * PartitionDispatch is always encapsulated inside a PartitionTupleRouting
<span class="lineNum">     105 </span>            :  * struct and stored inside its 'partition_dispatch_info' array.
<span class="lineNum">     106 </span>            :  *
<span class="lineNum">     107 </span>            :  * reldesc
<span class="lineNum">     108 </span>            :  *      Relation descriptor of the table
<span class="lineNum">     109 </span>            :  *
<span class="lineNum">     110 </span>            :  * key
<span class="lineNum">     111 </span>            :  *      Partition key information of the table
<span class="lineNum">     112 </span>            :  *
<span class="lineNum">     113 </span>            :  * keystate
<span class="lineNum">     114 </span>            :  *      Execution state required for expressions in the partition key
<span class="lineNum">     115 </span>            :  *
<span class="lineNum">     116 </span>            :  * partdesc
<span class="lineNum">     117 </span>            :  *      Partition descriptor of the table
<span class="lineNum">     118 </span>            :  *
<span class="lineNum">     119 </span>            :  * tupslot
<span class="lineNum">     120 </span>            :  *      A standalone TupleTableSlot initialized with this table's tuple
<span class="lineNum">     121 </span>            :  *      descriptor, or NULL if no tuple conversion between the parent is
<span class="lineNum">     122 </span>            :  *      required.
<span class="lineNum">     123 </span>            :  *
<span class="lineNum">     124 </span>            :  * tupmap
<span class="lineNum">     125 </span>            :  *      TupleConversionMap to convert from the parent's rowtype to this table's
<span class="lineNum">     126 </span>            :  *      rowtype  (when extracting the partition key of a tuple just before
<span class="lineNum">     127 </span>            :  *      routing it through this table). A NULL value is stored if no tuple
<span class="lineNum">     128 </span>            :  *      conversion is required.
<span class="lineNum">     129 </span>            :  *
<span class="lineNum">     130 </span>            :  * indexes
<span class="lineNum">     131 </span>            :  *      Array of partdesc-&gt;nparts elements.  For leaf partitions the index
<span class="lineNum">     132 </span>            :  *      corresponds to the partition's ResultRelInfo in the encapsulating
<span class="lineNum">     133 </span>            :  *      PartitionTupleRouting's partitions array.  For partitioned partitions,
<span class="lineNum">     134 </span>            :  *      the index corresponds to the PartitionDispatch for it in its
<span class="lineNum">     135 </span>            :  *      partition_dispatch_info array.  -1 indicates we've not yet allocated
<span class="lineNum">     136 </span>            :  *      anything in PartitionTupleRouting for the partition.
<span class="lineNum">     137 </span>            :  *-----------------------
<span class="lineNum">     138 </span>            :  */
<span class="lineNum">     139 </span>            : typedef struct PartitionDispatchData
<span class="lineNum">     140 </span>            : {
<span class="lineNum">     141 </span>            :     Relation    reldesc;
<span class="lineNum">     142 </span>            :     PartitionKey key;
<span class="lineNum">     143 </span>            :     List       *keystate;       /* list of ExprState */
<span class="lineNum">     144 </span>            :     PartitionDesc partdesc;
<span class="lineNum">     145 </span>            :     TupleTableSlot *tupslot;
<span class="lineNum">     146 </span>            :     AttrNumber *tupmap;
<span class="lineNum">     147 </span>            :     int         indexes[FLEXIBLE_ARRAY_MEMBER];
<span class="lineNum">     148 </span>            : }           PartitionDispatchData;
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            : /* struct to hold result relations coming from UPDATE subplans */
<span class="lineNum">     151 </span>            : typedef struct SubplanResultRelHashElem
<span class="lineNum">     152 </span>            : {
<span class="lineNum">     153 </span>            :     Oid         relid;          /* hash key -- must be first */
<span class="lineNum">     154 </span>            :     ResultRelInfo *rri;
<span class="lineNum">     155 </span>            : } SubplanResultRelHashElem;
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : static void ExecHashSubPlanResultRelsByOid(ModifyTableState *mtstate,
<span class="lineNum">     159 </span>            :                                            PartitionTupleRouting *proute);
<span class="lineNum">     160 </span>            : static ResultRelInfo *ExecInitPartitionInfo(ModifyTableState *mtstate,
<span class="lineNum">     161 </span>            :                                             EState *estate, PartitionTupleRouting *proute,
<span class="lineNum">     162 </span>            :                                             PartitionDispatch dispatch,
<span class="lineNum">     163 </span>            :                                             ResultRelInfo *rootResultRelInfo,
<span class="lineNum">     164 </span>            :                                             int partidx);
<span class="lineNum">     165 </span>            : static void ExecInitRoutingInfo(ModifyTableState *mtstate,
<span class="lineNum">     166 </span>            :                                 EState *estate,
<span class="lineNum">     167 </span>            :                                 PartitionTupleRouting *proute,
<span class="lineNum">     168 </span>            :                                 PartitionDispatch dispatch,
<span class="lineNum">     169 </span>            :                                 ResultRelInfo *partRelInfo,
<span class="lineNum">     170 </span>            :                                 int partidx);
<span class="lineNum">     171 </span>            : static PartitionDispatch ExecInitPartitionDispatchInfo(EState *estate,
<span class="lineNum">     172 </span>            :                                                        PartitionTupleRouting *proute,
<span class="lineNum">     173 </span>            :                                                        Oid partoid, PartitionDispatch parent_pd, int partidx);
<span class="lineNum">     174 </span>            : static void FormPartitionKeyDatum(PartitionDispatch pd,
<span class="lineNum">     175 </span>            :                                   TupleTableSlot *slot,
<span class="lineNum">     176 </span>            :                                   EState *estate,
<span class="lineNum">     177 </span>            :                                   Datum *values,
<span class="lineNum">     178 </span>            :                                   bool *isnull);
<span class="lineNum">     179 </span>            : static int  get_partition_for_tuple(PartitionDispatch pd, Datum *values,
<span class="lineNum">     180 </span>            :                                     bool *isnull);
<span class="lineNum">     181 </span>            : static char *ExecBuildSlotPartitionKeyDescription(Relation rel,
<span class="lineNum">     182 </span>            :                                                   Datum *values,
<span class="lineNum">     183 </span>            :                                                   bool *isnull,
<span class="lineNum">     184 </span>            :                                                   int maxfieldlen);
<span class="lineNum">     185 </span>            : static List *adjust_partition_tlist(List *tlist, TupleConversionMap *map);
<span class="lineNum">     186 </span>            : static void ExecInitPruningContext(PartitionPruneContext *context,
<span class="lineNum">     187 </span>            :                                    List *pruning_steps,
<span class="lineNum">     188 </span>            :                                    PartitionDesc partdesc,
<span class="lineNum">     189 </span>            :                                    PartitionKey partkey,
<span class="lineNum">     190 </span>            :                                    PlanState *planstate);
<span class="lineNum">     191 </span>            : static void find_matching_subplans_recurse(PartitionPruningData *prunedata,
<span class="lineNum">     192 </span>            :                                            PartitionedRelPruningData *pprune,
<span class="lineNum">     193 </span>            :                                            bool initial_prune,
<span class="lineNum">     194 </span>            :                                            Bitmapset **validsubplans);
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            : /*
<span class="lineNum">     198 </span>            :  * ExecSetupPartitionTupleRouting - sets up information needed during
<span class="lineNum">     199 </span>            :  * tuple routing for partitioned tables, encapsulates it in
<span class="lineNum">     200 </span>            :  * PartitionTupleRouting, and returns it.
<span class="lineNum">     201 </span>            :  *
<span class="lineNum">     202 </span>            :  * Callers must use the returned PartitionTupleRouting during calls to
<span class="lineNum">     203 </span>            :  * ExecFindPartition().  The actual ResultRelInfo for a partition is only
<span class="lineNum">     204 </span>            :  * allocated when the partition is found for the first time.
<span class="lineNum">     205 </span>            :  *
<span class="lineNum">     206 </span>            :  * The current memory context is used to allocate this struct and all
<span class="lineNum">     207 </span>            :  * subsidiary structs that will be allocated from it later on.  Typically
<span class="lineNum">     208 </span>            :  * it should be estate-&gt;es_query_cxt.
<a name="209"><span class="lineNum">     209 </span>            :  */</a>
<span class="lineNum">     210 </span>            : PartitionTupleRouting *
<span class="lineNum">     211 </span><span class="lineCov">        684 : ExecSetupPartitionTupleRouting(EState *estate, ModifyTableState *mtstate,</span>
<span class="lineNum">     212 </span>            :                                Relation rel)
<span class="lineNum">     213 </span>            : {
<span class="lineNum">     214 </span>            :     PartitionTupleRouting *proute;
<span class="lineNum">     215 </span><span class="lineCov">        684 :     ModifyTable *node = mtstate ? (ModifyTable *) mtstate-&gt;ps.plan : NULL;</span>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            :     /*
<span class="lineNum">     218 </span>            :      * Here we attempt to expend as little effort as possible in setting up
<span class="lineNum">     219 </span>            :      * the PartitionTupleRouting.  Each partition's ResultRelInfo is built on
<span class="lineNum">     220 </span>            :      * demand, only when we actually need to route a tuple to that partition.
<span class="lineNum">     221 </span>            :      * The reason for this is that a common case is for INSERT to insert a
<span class="lineNum">     222 </span>            :      * single tuple into a partitioned table and this must be fast.
<span class="lineNum">     223 </span>            :      */
<span class="lineNum">     224 </span><span class="lineCov">        684 :     proute = (PartitionTupleRouting *) palloc0(sizeof(PartitionTupleRouting));</span>
<span class="lineNum">     225 </span><span class="lineCov">        684 :     proute-&gt;partition_root = rel;</span>
<span class="lineNum">     226 </span><span class="lineCov">        684 :     proute-&gt;memcxt = CurrentMemoryContext;</span>
<span class="lineNum">     227 </span>            :     /* Rest of members initialized by zeroing */
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :     /*
<span class="lineNum">     230 </span>            :      * Initialize this table's PartitionDispatch object.  Here we pass in the
<span class="lineNum">     231 </span>            :      * parent as NULL as we don't need to care about any parent of the target
<span class="lineNum">     232 </span>            :      * partitioned table.
<span class="lineNum">     233 </span>            :      */
<span class="lineNum">     234 </span><span class="lineCov">        684 :     ExecInitPartitionDispatchInfo(estate, proute, RelationGetRelid(rel),</span>
<span class="lineNum">     235 </span>            :                                   NULL, 0);
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            :     /*
<span class="lineNum">     238 </span>            :      * If performing an UPDATE with tuple routing, we can reuse partition
<span class="lineNum">     239 </span>            :      * sub-plan result rels.  We build a hash table to map the OIDs of
<span class="lineNum">     240 </span>            :      * partitions present in mtstate-&gt;resultRelInfo to their ResultRelInfos.
<span class="lineNum">     241 </span>            :      * Every time a tuple is routed to a partition that we've yet to set the
<span class="lineNum">     242 </span>            :      * ResultRelInfo for, before we go to the trouble of making one, we check
<span class="lineNum">     243 </span>            :      * for a pre-made one in the hash table.
<span class="lineNum">     244 </span>            :      */
<span class="lineNum">     245 </span><span class="lineCov">        684 :     if (node &amp;&amp; node-&gt;operation == CMD_UPDATE)</span>
<span class="lineNum">     246 </span><span class="lineCov">        138 :         ExecHashSubPlanResultRelsByOid(mtstate, proute);</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineCov">        684 :     return proute;</span>
<span class="lineNum">     249 </span>            : }
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            : /*
<span class="lineNum">     252 </span>            :  * ExecFindPartition -- Return the ResultRelInfo for the leaf partition that
<span class="lineNum">     253 </span>            :  * the tuple contained in *slot should belong to.
<span class="lineNum">     254 </span>            :  *
<span class="lineNum">     255 </span>            :  * If the partition's ResultRelInfo does not yet exist in 'proute' then we set
<span class="lineNum">     256 </span>            :  * one up or reuse one from mtstate's resultRelInfo array.  When reusing a
<span class="lineNum">     257 </span>            :  * ResultRelInfo from the mtstate we verify that the relation is a valid
<span class="lineNum">     258 </span>            :  * target for INSERTs and then set up a PartitionRoutingInfo for it.
<span class="lineNum">     259 </span>            :  *
<span class="lineNum">     260 </span>            :  * rootResultRelInfo is the relation named in the query.
<span class="lineNum">     261 </span>            :  *
<span class="lineNum">     262 </span>            :  * estate must be non-NULL; we'll need it to compute any expressions in the
<span class="lineNum">     263 </span>            :  * partition keys.  Also, its per-tuple contexts are used as evaluation
<span class="lineNum">     264 </span>            :  * scratch space.
<span class="lineNum">     265 </span>            :  *
<span class="lineNum">     266 </span>            :  * If no leaf partition is found, this routine errors out with the appropriate
<span class="lineNum">     267 </span>            :  * error message.  An error may also be raised if the found target partition
<span class="lineNum">     268 </span>            :  * is not a valid target for an INSERT.
<a name="269"><span class="lineNum">     269 </span>            :  */</a>
<span class="lineNum">     270 </span>            : ResultRelInfo *
<span class="lineNum">     271 </span><span class="lineCov">     149230 : ExecFindPartition(ModifyTableState *mtstate,</span>
<span class="lineNum">     272 </span>            :                   ResultRelInfo *rootResultRelInfo,
<span class="lineNum">     273 </span>            :                   PartitionTupleRouting *proute,
<span class="lineNum">     274 </span>            :                   TupleTableSlot *slot, EState *estate)
<span class="lineNum">     275 </span>            : {
<span class="lineNum">     276 </span><span class="lineCov">     149230 :     PartitionDispatch *pd = proute-&gt;partition_dispatch_info;</span>
<span class="lineNum">     277 </span>            :     Datum       values[PARTITION_MAX_KEYS];
<span class="lineNum">     278 </span>            :     bool        isnull[PARTITION_MAX_KEYS];
<span class="lineNum">     279 </span>            :     Relation    rel;
<span class="lineNum">     280 </span>            :     PartitionDispatch dispatch;
<span class="lineNum">     281 </span>            :     PartitionDesc partdesc;
<span class="lineNum">     282 </span><span class="lineCov">     149230 :     ExprContext *ecxt = GetPerTupleExprContext(estate);</span>
<span class="lineNum">     283 </span><span class="lineCov">     149230 :     TupleTableSlot *ecxt_scantuple_old = ecxt-&gt;ecxt_scantuple;</span>
<span class="lineNum">     284 </span><span class="lineCov">     149230 :     TupleTableSlot *myslot = NULL;</span>
<span class="lineNum">     285 </span>            :     MemoryContext oldcxt;
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :     /* use per-tuple context here to avoid leaking memory */
<span class="lineNum">     288 </span><span class="lineCov">     149230 :     oldcxt = MemoryContextSwitchTo(GetPerTupleMemoryContext(estate));</span>
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :     /*
<span class="lineNum">     291 </span>            :      * First check the root table's partition constraint, if any.  No point in
<span class="lineNum">     292 </span>            :      * routing the tuple if it doesn't belong in the root table itself.
<span class="lineNum">     293 </span>            :      */
<span class="lineNum">     294 </span><span class="lineCov">     149230 :     if (rootResultRelInfo-&gt;ri_PartitionCheck)</span>
<span class="lineNum">     295 </span><span class="lineCov">         40 :         ExecPartitionCheck(rootResultRelInfo, slot, estate, true);</span>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :     /* start with the root partitioned table */
<span class="lineNum">     298 </span><span class="lineCov">     149226 :     dispatch = pd[0];</span>
<span class="lineNum">     299 </span>            :     while (true)
<span class="lineNum">     300 </span>            :     {
<span class="lineNum">     301 </span><span class="lineCov">     190420 :         AttrNumber *map = dispatch-&gt;tupmap;</span>
<span class="lineNum">     302 </span><span class="lineCov">     190420 :         int         partidx = -1;</span>
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span><span class="lineCov">     190420 :         CHECK_FOR_INTERRUPTS();</span>
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span><span class="lineCov">     190420 :         rel = dispatch-&gt;reldesc;</span>
<span class="lineNum">     307 </span><span class="lineCov">     190420 :         partdesc = dispatch-&gt;partdesc;</span>
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            :         /*
<span class="lineNum">     310 </span>            :          * Convert the tuple to this parent's layout, if different from the
<span class="lineNum">     311 </span>            :          * current relation.
<span class="lineNum">     312 </span>            :          */
<span class="lineNum">     313 </span><span class="lineCov">     190420 :         myslot = dispatch-&gt;tupslot;</span>
<span class="lineNum">     314 </span><span class="lineCov">     190420 :         if (myslot != NULL)</span>
<span class="lineNum">     315 </span>            :         {
<span class="lineNum">     316 </span><span class="lineCov">      20354 :             Assert(map != NULL);</span>
<span class="lineNum">     317 </span><span class="lineCov">      20354 :             slot = execute_attr_map_slot(map, slot, myslot);</span>
<span class="lineNum">     318 </span>            :         }
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :         /*
<span class="lineNum">     321 </span>            :          * Extract partition key from tuple. Expression evaluation machinery
<span class="lineNum">     322 </span>            :          * that FormPartitionKeyDatum() invokes expects ecxt_scantuple to
<span class="lineNum">     323 </span>            :          * point to the correct tuple slot.  The slot might have changed from
<span class="lineNum">     324 </span>            :          * what was used for the parent table if the table of the current
<span class="lineNum">     325 </span>            :          * partitioning level has different tuple descriptor from the parent.
<span class="lineNum">     326 </span>            :          * So update ecxt_scantuple accordingly.
<span class="lineNum">     327 </span>            :          */
<span class="lineNum">     328 </span><span class="lineCov">     190420 :         ecxt-&gt;ecxt_scantuple = slot;</span>
<span class="lineNum">     329 </span><span class="lineCov">     190420 :         FormPartitionKeyDatum(dispatch, slot, estate, values, isnull);</span>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            :         /*
<span class="lineNum">     332 </span>            :          * If this partitioned table has no partitions or no partition for
<span class="lineNum">     333 </span>            :          * these values, error out.
<span class="lineNum">     334 </span>            :          */
<span class="lineNum">     335 </span><span class="lineCov">     190420 :         if (partdesc-&gt;nparts == 0 ||</span>
<span class="lineNum">     336 </span>            :             (partidx = get_partition_for_tuple(dispatch, values, isnull)) &lt; 0)
<span class="lineNum">     337 </span>            :         {
<span class="lineNum">     338 </span>            :             char       *val_desc;
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span><span class="lineCov">         40 :             val_desc = ExecBuildSlotPartitionKeyDescription(rel,</span>
<span class="lineNum">     341 </span>            :                                                             values, isnull, 64);
<span class="lineNum">     342 </span><span class="lineCov">         40 :             Assert(OidIsValid(RelationGetRelid(rel)));</span>
<span class="lineNum">     343 </span><span class="lineCov">         40 :             ereport(ERROR,</span>
<span class="lineNum">     344 </span>            :                     (errcode(ERRCODE_CHECK_VIOLATION),
<span class="lineNum">     345 </span>            :                      errmsg(&quot;no partition of relation \&quot;%s\&quot; found for row&quot;,
<span class="lineNum">     346 </span>            :                             RelationGetRelationName(rel)),
<span class="lineNum">     347 </span>            :                      val_desc ?
<span class="lineNum">     348 </span>            :                      errdetail(&quot;Partition key of the failing row contains %s.&quot;,
<span class="lineNum">     349 </span>            :                                val_desc) : 0));
<span class="lineNum">     350 </span>            :         }
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineCov">     190380 :         if (partdesc-&gt;is_leaf[partidx])</span>
<span class="lineNum">     353 </span>            :         {
<span class="lineNum">     354 </span>            :             ResultRelInfo *rri;
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            :             /*
<span class="lineNum">     357 </span>            :              * Look to see if we've already got a ResultRelInfo for this
<span class="lineNum">     358 </span>            :              * partition.
<span class="lineNum">     359 </span>            :              */
<span class="lineNum">     360 </span><span class="lineCov">     149186 :             if (likely(dispatch-&gt;indexes[partidx] &gt;= 0))</span>
<span class="lineNum">     361 </span>            :             {
<span class="lineNum">     362 </span>            :                 /* ResultRelInfo already built */
<span class="lineNum">     363 </span><span class="lineCov">     148212 :                 Assert(dispatch-&gt;indexes[partidx] &lt; proute-&gt;num_partitions);</span>
<span class="lineNum">     364 </span><span class="lineCov">     148212 :                 rri = proute-&gt;partitions[dispatch-&gt;indexes[partidx]];</span>
<span class="lineNum">     365 </span>            :             }
<span class="lineNum">     366 </span>            :             else
<span class="lineNum">     367 </span>            :             {
<span class="lineNum">     368 </span><span class="lineCov">        974 :                 bool        found = false;</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :                 /*
<span class="lineNum">     371 </span>            :                  * We have not yet set up a ResultRelInfo for this partition,
<span class="lineNum">     372 </span>            :                  * but if we have a subplan hash table, we might have one
<span class="lineNum">     373 </span>            :                  * there.  If not, we'll have to create one.
<span class="lineNum">     374 </span>            :                  */
<span class="lineNum">     375 </span><span class="lineCov">        974 :                 if (proute-&gt;subplan_resultrel_htab)</span>
<span class="lineNum">     376 </span>            :                 {
<span class="lineNum">     377 </span><span class="lineCov">         82 :                     Oid         partoid = partdesc-&gt;oids[partidx];</span>
<span class="lineNum">     378 </span>            :                     SubplanResultRelHashElem *elem;
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span><span class="lineCov">         82 :                     elem = hash_search(proute-&gt;subplan_resultrel_htab,</span>
<span class="lineNum">     381 </span>            :                                        &amp;partoid, HASH_FIND, NULL);
<span class="lineNum">     382 </span><span class="lineCov">         82 :                     if (elem)</span>
<span class="lineNum">     383 </span>            :                     {
<span class="lineNum">     384 </span><span class="lineCov">         36 :                         found = true;</span>
<span class="lineNum">     385 </span><span class="lineCov">         36 :                         rri = elem-&gt;rri;</span>
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            :                         /* Verify this ResultRelInfo allows INSERTs */
<span class="lineNum">     388 </span><span class="lineCov">         36 :                         CheckValidResultRel(rri, CMD_INSERT);</span>
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :                         /* Set up the PartitionRoutingInfo for it */
<span class="lineNum">     391 </span><span class="lineCov">         36 :                         ExecInitRoutingInfo(mtstate, estate, proute, dispatch,</span>
<span class="lineNum">     392 </span>            :                                             rri, partidx);
<span class="lineNum">     393 </span>            :                     }
<span class="lineNum">     394 </span>            :                 }
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            :                 /* We need to create a new one. */
<span class="lineNum">     397 </span><span class="lineCov">        974 :                 if (!found)</span>
<span class="lineNum">     398 </span><span class="lineCov">        938 :                     rri = ExecInitPartitionInfo(mtstate, estate, proute,</span>
<span class="lineNum">     399 </span>            :                                                 dispatch,
<span class="lineNum">     400 </span>            :                                                 rootResultRelInfo, partidx);
<span class="lineNum">     401 </span>            :             }
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :             /* Release the tuple in the lowest parent's dedicated slot. */
<span class="lineNum">     404 </span><span class="lineCov">     149186 :             if (slot == myslot)</span>
<span class="lineNum">     405 </span><span class="lineCov">      20238 :                 ExecClearTuple(myslot);</span>
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span><span class="lineCov">     149186 :             MemoryContextSwitchTo(oldcxt);</span>
<span class="lineNum">     408 </span><span class="lineCov">     149186 :             ecxt-&gt;ecxt_scantuple = ecxt_scantuple_old;</span>
<span class="lineNum">     409 </span><span class="lineCov">     298372 :             return rri;</span>
<span class="lineNum">     410 </span>            :         }
<span class="lineNum">     411 </span>            :         else
<span class="lineNum">     412 </span>            :         {
<span class="lineNum">     413 </span>            :             /*
<span class="lineNum">     414 </span>            :              * Partition is a sub-partitioned table; get the PartitionDispatch
<span class="lineNum">     415 </span>            :              */
<span class="lineNum">     416 </span><span class="lineCov">      41194 :             if (likely(dispatch-&gt;indexes[partidx] &gt;= 0))</span>
<span class="lineNum">     417 </span>            :             {
<span class="lineNum">     418 </span>            :                 /* Already built. */
<span class="lineNum">     419 </span><span class="lineCov">      40894 :                 Assert(dispatch-&gt;indexes[partidx] &lt; proute-&gt;num_dispatch);</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            :                 /*
<span class="lineNum">     422 </span>            :                  * Move down to the next partition level and search again
<span class="lineNum">     423 </span>            :                  * until we find a leaf partition that matches this tuple
<span class="lineNum">     424 </span>            :                  */
<span class="lineNum">     425 </span><span class="lineCov">      40894 :                 dispatch = pd[dispatch-&gt;indexes[partidx]];</span>
<span class="lineNum">     426 </span>            :             }
<span class="lineNum">     427 </span>            :             else
<span class="lineNum">     428 </span>            :             {
<span class="lineNum">     429 </span>            :                 /* Not yet built. Do that now. */
<span class="lineNum">     430 </span>            :                 PartitionDispatch subdispatch;
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            :                 /*
<span class="lineNum">     433 </span>            :                  * Create the new PartitionDispatch.  We pass the current one
<span class="lineNum">     434 </span>            :                  * in as the parent PartitionDispatch
<span class="lineNum">     435 </span>            :                  */
<span class="lineNum">     436 </span><span class="lineCov">        300 :                 subdispatch = ExecInitPartitionDispatchInfo(mtstate-&gt;ps.state,</span>
<span class="lineNum">     437 </span>            :                                                             proute,
<span class="lineNum">     438 </span><span class="lineCov">        300 :                                                             partdesc-&gt;oids[partidx],</span>
<span class="lineNum">     439 </span>            :                                                             dispatch, partidx);
<span class="lineNum">     440 </span><span class="lineCov">        300 :                 Assert(dispatch-&gt;indexes[partidx] &gt;= 0 &amp;&amp;</span>
<span class="lineNum">     441 </span>            :                        dispatch-&gt;indexes[partidx] &lt; proute-&gt;num_dispatch);
<span class="lineNum">     442 </span><span class="lineCov">        300 :                 dispatch = subdispatch;</span>
<span class="lineNum">     443 </span>            :             }
<span class="lineNum">     444 </span>            :         }
<span class="lineNum">     445 </span><span class="lineCov">      41194 :     }</span>
<span class="lineNum">     446 </span>            : }
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            : /*
<span class="lineNum">     449 </span>            :  * ExecHashSubPlanResultRelsByOid
<span class="lineNum">     450 </span>            :  *      Build a hash table to allow fast lookups of subplan ResultRelInfos by
<span class="lineNum">     451 </span>            :  *      partition Oid.  We also populate the subplan ResultRelInfo with an
<span class="lineNum">     452 </span>            :  *      ri_PartitionRoot.
<a name="453"><span class="lineNum">     453 </span>            :  */</a>
<span class="lineNum">     454 </span>            : static void
<span class="lineNum">     455 </span><span class="lineCov">        138 : ExecHashSubPlanResultRelsByOid(ModifyTableState *mtstate,</span>
<span class="lineNum">     456 </span>            :                                PartitionTupleRouting *proute)
<span class="lineNum">     457 </span>            : {
<span class="lineNum">     458 </span>            :     HASHCTL     ctl;
<span class="lineNum">     459 </span>            :     HTAB       *htab;
<span class="lineNum">     460 </span>            :     int         i;
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span><span class="lineCov">        138 :     memset(&amp;ctl, 0, sizeof(ctl));</span>
<span class="lineNum">     463 </span><span class="lineCov">        138 :     ctl.keysize = sizeof(Oid);</span>
<span class="lineNum">     464 </span><span class="lineCov">        138 :     ctl.entrysize = sizeof(SubplanResultRelHashElem);</span>
<span class="lineNum">     465 </span><span class="lineCov">        138 :     ctl.hcxt = CurrentMemoryContext;</span>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span><span class="lineCov">        138 :     htab = hash_create(&quot;PartitionTupleRouting table&quot;, mtstate-&gt;mt_nplans,</span>
<span class="lineNum">     468 </span>            :                        &amp;ctl, HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);
<span class="lineNum">     469 </span><span class="lineCov">        138 :     proute-&gt;subplan_resultrel_htab = htab;</span>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :     /* Hash all subplans by their Oid */
<span class="lineNum">     472 </span><span class="lineCov">        500 :     for (i = 0; i &lt; mtstate-&gt;mt_nplans; i++)</span>
<span class="lineNum">     473 </span>            :     {
<span class="lineNum">     474 </span><span class="lineCov">        362 :         ResultRelInfo *rri = &amp;mtstate-&gt;resultRelInfo[i];</span>
<span class="lineNum">     475 </span>            :         bool        found;
<span class="lineNum">     476 </span><span class="lineCov">        362 :         Oid         partoid = RelationGetRelid(rri-&gt;ri_RelationDesc);</span>
<span class="lineNum">     477 </span>            :         SubplanResultRelHashElem *elem;
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineCov">        362 :         elem = (SubplanResultRelHashElem *)</span>
<span class="lineNum">     480 </span>            :             hash_search(htab, &amp;partoid, HASH_ENTER, &amp;found);
<span class="lineNum">     481 </span><span class="lineCov">        362 :         Assert(!found);</span>
<span class="lineNum">     482 </span><span class="lineCov">        362 :         elem-&gt;rri = rri;</span>
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :         /*
<span class="lineNum">     485 </span>            :          * This is required in order to convert the partition's tuple to be
<span class="lineNum">     486 </span>            :          * compatible with the root partitioned table's tuple descriptor. When
<span class="lineNum">     487 </span>            :          * generating the per-subplan result rels, this was not set.
<span class="lineNum">     488 </span>            :          */
<span class="lineNum">     489 </span><span class="lineCov">        362 :         rri-&gt;ri_PartitionRoot = proute-&gt;partition_root;</span>
<span class="lineNum">     490 </span>            :     }
<span class="lineNum">     491 </span><span class="lineCov">        138 : }</span>
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            : /*
<span class="lineNum">     494 </span>            :  * ExecInitPartitionInfo
<span class="lineNum">     495 </span>            :  *      Lock the partition and initialize ResultRelInfo.  Also setup other
<span class="lineNum">     496 </span>            :  *      information for the partition and store it in the next empty slot in
<span class="lineNum">     497 </span>            :  *      the proute-&gt;partitions array.
<span class="lineNum">     498 </span>            :  *
<span class="lineNum">     499 </span>            :  * Returns the ResultRelInfo
<a name="500"><span class="lineNum">     500 </span>            :  */</a>
<span class="lineNum">     501 </span>            : static ResultRelInfo *
<span class="lineNum">     502 </span><span class="lineCov">        938 : ExecInitPartitionInfo(ModifyTableState *mtstate, EState *estate,</span>
<span class="lineNum">     503 </span>            :                       PartitionTupleRouting *proute,
<span class="lineNum">     504 </span>            :                       PartitionDispatch dispatch,
<span class="lineNum">     505 </span>            :                       ResultRelInfo *rootResultRelInfo,
<span class="lineNum">     506 </span>            :                       int partidx)
<span class="lineNum">     507 </span>            : {
<span class="lineNum">     508 </span><span class="lineCov">        938 :     ModifyTable *node = (ModifyTable *) mtstate-&gt;ps.plan;</span>
<span class="lineNum">     509 </span><span class="lineCov">        938 :     Relation    rootrel = rootResultRelInfo-&gt;ri_RelationDesc,</span>
<span class="lineNum">     510 </span>            :                 partrel;
<span class="lineNum">     511 </span><span class="lineCov">        938 :     Relation    firstResultRel = mtstate-&gt;resultRelInfo[0].ri_RelationDesc;</span>
<span class="lineNum">     512 </span>            :     ResultRelInfo *leaf_part_rri;
<span class="lineNum">     513 </span>            :     MemoryContext oldcxt;
<span class="lineNum">     514 </span><span class="lineCov">        938 :     AttrNumber *part_attnos = NULL;</span>
<span class="lineNum">     515 </span>            :     bool        found_whole_row;
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span><span class="lineCov">        938 :     oldcxt = MemoryContextSwitchTo(proute-&gt;memcxt);</span>
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span><span class="lineCov">        938 :     partrel = table_open(dispatch-&gt;partdesc-&gt;oids[partidx], RowExclusiveLock);</span>
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span><span class="lineCov">        938 :     leaf_part_rri = makeNode(ResultRelInfo);</span>
<span class="lineNum">     522 </span><span class="lineCov">        938 :     InitResultRelInfo(leaf_part_rri,</span>
<span class="lineNum">     523 </span>            :                       partrel,
<span class="lineNum">     524 </span>            :                       node ? node-&gt;rootRelation : 1,
<span class="lineNum">     525 </span>            :                       rootrel,
<span class="lineNum">     526 </span>            :                       estate-&gt;es_instrument);
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            :     /*
<span class="lineNum">     529 </span>            :      * Verify result relation is a valid target for an INSERT.  An UPDATE of a
<span class="lineNum">     530 </span>            :      * partition-key becomes a DELETE+INSERT operation, so this check is still
<span class="lineNum">     531 </span>            :      * required when the operation is CMD_UPDATE.
<span class="lineNum">     532 </span>            :      */
<span class="lineNum">     533 </span><span class="lineCov">        938 :     CheckValidResultRel(leaf_part_rri, CMD_INSERT);</span>
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span>            :     /*
<span class="lineNum">     536 </span>            :      * Open partition indices.  The user may have asked to check for conflicts
<span class="lineNum">     537 </span>            :      * within this leaf partition and do &quot;nothing&quot; instead of throwing an
<span class="lineNum">     538 </span>            :      * error.  Be prepared in that case by initializing the index information
<span class="lineNum">     539 </span>            :      * needed by ExecInsert() to perform speculative insertions.
<span class="lineNum">     540 </span>            :      */
<span class="lineNum">     541 </span><span class="lineCov">       1104 :     if (partrel-&gt;rd_rel-&gt;relhasindex &amp;&amp;</span>
<span class="lineNum">     542 </span><span class="lineCov">        166 :         leaf_part_rri-&gt;ri_IndexRelationDescs == NULL)</span>
<span class="lineNum">     543 </span><span class="lineCov">        166 :         ExecOpenIndices(leaf_part_rri,</span>
<span class="lineNum">     544 </span><span class="lineCov">        328 :                         (node != NULL &amp;&amp;</span>
<span class="lineNum">     545 </span><span class="lineCov">        162 :                          node-&gt;onConflictAction != ONCONFLICT_NONE));</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            :     /*
<span class="lineNum">     548 </span>            :      * Build WITH CHECK OPTION constraints for the partition.  Note that we
<span class="lineNum">     549 </span>            :      * didn't build the withCheckOptionList for partitions within the planner,
<span class="lineNum">     550 </span>            :      * but simple translation of varattnos will suffice.  This only occurs for
<span class="lineNum">     551 </span>            :      * the INSERT case or in the case of UPDATE tuple routing where we didn't
<span class="lineNum">     552 </span>            :      * find a result rel to reuse in ExecSetupPartitionTupleRouting().
<span class="lineNum">     553 </span>            :      */
<span class="lineNum">     554 </span><span class="lineCov">        938 :     if (node &amp;&amp; node-&gt;withCheckOptionLists != NIL)</span>
<span class="lineNum">     555 </span>            :     {
<span class="lineNum">     556 </span>            :         List       *wcoList;
<span class="lineNum">     557 </span><span class="lineCov">         28 :         List       *wcoExprs = NIL;</span>
<span class="lineNum">     558 </span>            :         ListCell   *ll;
<span class="lineNum">     559 </span><span class="lineCov">         28 :         int         firstVarno = mtstate-&gt;resultRelInfo[0].ri_RangeTableIndex;</span>
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            :         /*
<span class="lineNum">     562 </span>            :          * In the case of INSERT on a partitioned table, there is only one
<span class="lineNum">     563 </span>            :          * plan.  Likewise, there is only one WCO list, not one per partition.
<span class="lineNum">     564 </span>            :          * For UPDATE, there are as many WCO lists as there are plans.
<span class="lineNum">     565 </span>            :          */
<span class="lineNum">     566 </span><span class="lineCov">         28 :         Assert((node-&gt;operation == CMD_INSERT &amp;&amp;</span>
<span class="lineNum">     567 </span>            :                 list_length(node-&gt;withCheckOptionLists) == 1 &amp;&amp;
<span class="lineNum">     568 </span>            :                 list_length(node-&gt;plans) == 1) ||
<span class="lineNum">     569 </span>            :                (node-&gt;operation == CMD_UPDATE &amp;&amp;
<span class="lineNum">     570 </span>            :                 list_length(node-&gt;withCheckOptionLists) ==
<span class="lineNum">     571 </span>            :                 list_length(node-&gt;plans)));
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            :         /*
<span class="lineNum">     574 </span>            :          * Use the WCO list of the first plan as a reference to calculate
<span class="lineNum">     575 </span>            :          * attno's for the WCO list of this partition.  In the INSERT case,
<span class="lineNum">     576 </span>            :          * that refers to the root partitioned table, whereas in the UPDATE
<span class="lineNum">     577 </span>            :          * tuple routing case, that refers to the first partition in the
<span class="lineNum">     578 </span>            :          * mtstate-&gt;resultRelInfo array.  In any case, both that relation and
<span class="lineNum">     579 </span>            :          * this partition should have the same columns, so we should be able
<span class="lineNum">     580 </span>            :          * to map attributes successfully.
<span class="lineNum">     581 </span>            :          */
<span class="lineNum">     582 </span><span class="lineCov">         28 :         wcoList = linitial(node-&gt;withCheckOptionLists);</span>
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            :         /*
<span class="lineNum">     585 </span>            :          * Convert Vars in it to contain this partition's attribute numbers.
<span class="lineNum">     586 </span>            :          */
<span class="lineNum">     587 </span><span class="lineCov">         28 :         part_attnos =</span>
<span class="lineNum">     588 </span><span class="lineCov">         28 :             convert_tuples_by_name_map(RelationGetDescr(partrel),</span>
<span class="lineNum">     589 </span>            :                                        RelationGetDescr(firstResultRel));
<span class="lineNum">     590 </span><span class="lineCov">         28 :         wcoList = (List *)</span>
<span class="lineNum">     591 </span><span class="lineCov">         56 :             map_variable_attnos((Node *) wcoList,</span>
<span class="lineNum">     592 </span>            :                                 firstVarno, 0,
<span class="lineNum">     593 </span>            :                                 part_attnos,
<span class="lineNum">     594 </span><span class="lineCov">         28 :                                 RelationGetDescr(firstResultRel)-&gt;natts,</span>
<span class="lineNum">     595 </span><span class="lineCov">         28 :                                 RelationGetForm(partrel)-&gt;reltype,</span>
<span class="lineNum">     596 </span>            :                                 &amp;found_whole_row);
<span class="lineNum">     597 </span>            :         /* We ignore the value of found_whole_row. */
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span><span class="lineCov">         76 :         foreach(ll, wcoList)</span>
<span class="lineNum">     600 </span>            :         {
<span class="lineNum">     601 </span><span class="lineCov">         48 :             WithCheckOption *wco = castNode(WithCheckOption, lfirst(ll));</span>
<span class="lineNum">     602 </span><span class="lineCov">         48 :             ExprState  *wcoExpr = ExecInitQual(castNode(List, wco-&gt;qual),</span>
<span class="lineNum">     603 </span>            :                                                &amp;mtstate-&gt;ps);
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span><span class="lineCov">         48 :             wcoExprs = lappend(wcoExprs, wcoExpr);</span>
<span class="lineNum">     606 </span>            :         }
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span><span class="lineCov">         28 :         leaf_part_rri-&gt;ri_WithCheckOptions = wcoList;</span>
<span class="lineNum">     609 </span><span class="lineCov">         28 :         leaf_part_rri-&gt;ri_WithCheckOptionExprs = wcoExprs;</span>
<span class="lineNum">     610 </span>            :     }
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            :     /*
<span class="lineNum">     613 </span>            :      * Build the RETURNING projection for the partition.  Note that we didn't
<span class="lineNum">     614 </span>            :      * build the returningList for partitions within the planner, but simple
<span class="lineNum">     615 </span>            :      * translation of varattnos will suffice.  This only occurs for the INSERT
<span class="lineNum">     616 </span>            :      * case or in the case of UPDATE tuple routing where we didn't find a
<span class="lineNum">     617 </span>            :      * result rel to reuse in ExecSetupPartitionTupleRouting().
<span class="lineNum">     618 </span>            :      */
<span class="lineNum">     619 </span><span class="lineCov">        938 :     if (node &amp;&amp; node-&gt;returningLists != NIL)</span>
<span class="lineNum">     620 </span>            :     {
<span class="lineNum">     621 </span>            :         TupleTableSlot *slot;
<span class="lineNum">     622 </span>            :         ExprContext *econtext;
<span class="lineNum">     623 </span>            :         List       *returningList;
<span class="lineNum">     624 </span><span class="lineCov">         28 :         int         firstVarno = mtstate-&gt;resultRelInfo[0].ri_RangeTableIndex;</span>
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            :         /* See the comment above for WCO lists. */
<span class="lineNum">     627 </span><span class="lineCov">         28 :         Assert((node-&gt;operation == CMD_INSERT &amp;&amp;</span>
<span class="lineNum">     628 </span>            :                 list_length(node-&gt;returningLists) == 1 &amp;&amp;
<span class="lineNum">     629 </span>            :                 list_length(node-&gt;plans) == 1) ||
<span class="lineNum">     630 </span>            :                (node-&gt;operation == CMD_UPDATE &amp;&amp;
<span class="lineNum">     631 </span>            :                 list_length(node-&gt;returningLists) ==
<span class="lineNum">     632 </span>            :                 list_length(node-&gt;plans)));
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :         /*
<span class="lineNum">     635 </span>            :          * Use the RETURNING list of the first plan as a reference to
<span class="lineNum">     636 </span>            :          * calculate attno's for the RETURNING list of this partition.  See
<span class="lineNum">     637 </span>            :          * the comment above for WCO lists for more details on why this is
<span class="lineNum">     638 </span>            :          * okay.
<span class="lineNum">     639 </span>            :          */
<span class="lineNum">     640 </span><span class="lineCov">         28 :         returningList = linitial(node-&gt;returningLists);</span>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            :         /*
<span class="lineNum">     643 </span>            :          * Convert Vars in it to contain this partition's attribute numbers.
<span class="lineNum">     644 </span>            :          */
<span class="lineNum">     645 </span><span class="lineCov">         28 :         if (part_attnos == NULL)</span>
<span class="lineNum">     646 </span><span class="lineCov">         28 :             part_attnos =</span>
<span class="lineNum">     647 </span><span class="lineCov">         28 :                 convert_tuples_by_name_map(RelationGetDescr(partrel),</span>
<span class="lineNum">     648 </span>            :                                            RelationGetDescr(firstResultRel));
<span class="lineNum">     649 </span><span class="lineCov">         28 :         returningList = (List *)</span>
<span class="lineNum">     650 </span><span class="lineCov">         56 :             map_variable_attnos((Node *) returningList,</span>
<span class="lineNum">     651 </span>            :                                 firstVarno, 0,
<span class="lineNum">     652 </span>            :                                 part_attnos,
<span class="lineNum">     653 </span><span class="lineCov">         28 :                                 RelationGetDescr(firstResultRel)-&gt;natts,</span>
<span class="lineNum">     654 </span><span class="lineCov">         28 :                                 RelationGetForm(partrel)-&gt;reltype,</span>
<span class="lineNum">     655 </span>            :                                 &amp;found_whole_row);
<span class="lineNum">     656 </span>            :         /* We ignore the value of found_whole_row. */
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span><span class="lineCov">         28 :         leaf_part_rri-&gt;ri_returningList = returningList;</span>
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            :         /*
<span class="lineNum">     661 </span>            :          * Initialize the projection itself.
<span class="lineNum">     662 </span>            :          *
<span class="lineNum">     663 </span>            :          * Use the slot and the expression context that would have been set up
<span class="lineNum">     664 </span>            :          * in ExecInitModifyTable() for projection's output.
<span class="lineNum">     665 </span>            :          */
<span class="lineNum">     666 </span><span class="lineCov">         28 :         Assert(mtstate-&gt;ps.ps_ResultTupleSlot != NULL);</span>
<span class="lineNum">     667 </span><span class="lineCov">         28 :         slot = mtstate-&gt;ps.ps_ResultTupleSlot;</span>
<span class="lineNum">     668 </span><span class="lineCov">         28 :         Assert(mtstate-&gt;ps.ps_ExprContext != NULL);</span>
<span class="lineNum">     669 </span><span class="lineCov">         28 :         econtext = mtstate-&gt;ps.ps_ExprContext;</span>
<span class="lineNum">     670 </span><span class="lineCov">         28 :         leaf_part_rri-&gt;ri_projectReturning =</span>
<span class="lineNum">     671 </span><span class="lineCov">         28 :             ExecBuildProjectionInfo(returningList, econtext, slot,</span>
<span class="lineNum">     672 </span>            :                                     &amp;mtstate-&gt;ps, RelationGetDescr(partrel));
<span class="lineNum">     673 </span>            :     }
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :     /* Set up information needed for routing tuples to the partition. */
<span class="lineNum">     676 </span><span class="lineCov">        938 :     ExecInitRoutingInfo(mtstate, estate, proute, dispatch,</span>
<span class="lineNum">     677 </span>            :                         leaf_part_rri, partidx);
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            :     /*
<span class="lineNum">     680 </span>            :      * If there is an ON CONFLICT clause, initialize state for it.
<span class="lineNum">     681 </span>            :      */
<span class="lineNum">     682 </span><span class="lineCov">        938 :     if (node &amp;&amp; node-&gt;onConflictAction != ONCONFLICT_NONE)</span>
<span class="lineNum">     683 </span>            :     {
<span class="lineNum">     684 </span><span class="lineCov">         48 :         int         firstVarno = mtstate-&gt;resultRelInfo[0].ri_RangeTableIndex;</span>
<span class="lineNum">     685 </span><span class="lineCov">         48 :         TupleDesc   partrelDesc = RelationGetDescr(partrel);</span>
<span class="lineNum">     686 </span><span class="lineCov">         48 :         ExprContext *econtext = mtstate-&gt;ps.ps_ExprContext;</span>
<span class="lineNum">     687 </span>            :         ListCell   *lc;
<span class="lineNum">     688 </span><span class="lineCov">         48 :         List       *arbiterIndexes = NIL;</span>
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            :         /*
<span class="lineNum">     691 </span>            :          * If there is a list of arbiter indexes, map it to a list of indexes
<span class="lineNum">     692 </span>            :          * in the partition.  We do that by scanning the partition's index
<span class="lineNum">     693 </span>            :          * list and searching for ancestry relationships to each index in the
<span class="lineNum">     694 </span>            :          * ancestor table.
<span class="lineNum">     695 </span>            :          */
<span class="lineNum">     696 </span><span class="lineCov">         48 :         if (list_length(rootResultRelInfo-&gt;ri_onConflictArbiterIndexes) &gt; 0)</span>
<span class="lineNum">     697 </span>            :         {
<span class="lineNum">     698 </span>            :             List       *childIdxs;
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span><span class="lineCov">         46 :             childIdxs = RelationGetIndexList(leaf_part_rri-&gt;ri_RelationDesc);</span>
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span><span class="lineCov">         96 :             foreach(lc, childIdxs)</span>
<span class="lineNum">     703 </span>            :             {
<span class="lineNum">     704 </span><span class="lineCov">         50 :                 Oid         childIdx = lfirst_oid(lc);</span>
<span class="lineNum">     705 </span>            :                 List       *ancestors;
<span class="lineNum">     706 </span>            :                 ListCell   *lc2;
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span><span class="lineCov">         50 :                 ancestors = get_partition_ancestors(childIdx);</span>
<span class="lineNum">     709 </span><span class="lineCov">        100 :                 foreach(lc2, rootResultRelInfo-&gt;ri_onConflictArbiterIndexes)</span>
<span class="lineNum">     710 </span>            :                 {
<span class="lineNum">     711 </span><span class="lineCov">         50 :                     if (list_member_oid(ancestors, lfirst_oid(lc2)))</span>
<span class="lineNum">     712 </span><span class="lineCov">         46 :                         arbiterIndexes = lappend_oid(arbiterIndexes, childIdx);</span>
<span class="lineNum">     713 </span>            :                 }
<span class="lineNum">     714 </span><span class="lineCov">         50 :                 list_free(ancestors);</span>
<span class="lineNum">     715 </span>            :             }
<span class="lineNum">     716 </span>            :         }
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span>            :         /*
<span class="lineNum">     719 </span>            :          * If the resulting lists are of inequal length, something is wrong.
<span class="lineNum">     720 </span>            :          * (This shouldn't happen, since arbiter index selection should not
<span class="lineNum">     721 </span>            :          * pick up an invalid index.)
<span class="lineNum">     722 </span>            :          */
<span class="lineNum">     723 </span><span class="lineCov">         96 :         if (list_length(rootResultRelInfo-&gt;ri_onConflictArbiterIndexes) !=</span>
<span class="lineNum">     724 </span><span class="lineCov">         48 :             list_length(arbiterIndexes))</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;invalid arbiter index list&quot;);</span>
<span class="lineNum">     726 </span><span class="lineCov">         48 :         leaf_part_rri-&gt;ri_onConflictArbiterIndexes = arbiterIndexes;</span>
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            :         /*
<span class="lineNum">     729 </span>            :          * In the DO UPDATE case, we have some more state to initialize.
<span class="lineNum">     730 </span>            :          */
<span class="lineNum">     731 </span><span class="lineCov">         48 :         if (node-&gt;onConflictAction == ONCONFLICT_UPDATE)</span>
<span class="lineNum">     732 </span>            :         {
<span class="lineNum">     733 </span>            :             TupleConversionMap *map;
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span><span class="lineCov">         44 :             map = leaf_part_rri-&gt;ri_PartitionInfo-&gt;pi_RootToPartitionMap;</span>
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span><span class="lineCov">         44 :             Assert(node-&gt;onConflictSet != NIL);</span>
<span class="lineNum">     738 </span><span class="lineCov">         44 :             Assert(rootResultRelInfo-&gt;ri_onConflict != NULL);</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineCov">         44 :             leaf_part_rri-&gt;ri_onConflict = makeNode(OnConflictSetState);</span>
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            :             /*
<span class="lineNum">     743 </span>            :              * Need a separate existing slot for each partition, as the
<span class="lineNum">     744 </span>            :              * partition could be of a different AM, even if the tuple
<span class="lineNum">     745 </span>            :              * descriptors match.
<span class="lineNum">     746 </span>            :              */
<span class="lineNum">     747 </span><span class="lineCov">         88 :             leaf_part_rri-&gt;ri_onConflict-&gt;oc_Existing =</span>
<span class="lineNum">     748 </span><span class="lineCov">         44 :                 table_slot_create(leaf_part_rri-&gt;ri_RelationDesc,</span>
<span class="lineNum">     749 </span><span class="lineCov">         44 :                                   &amp;mtstate-&gt;ps.state-&gt;es_tupleTable);</span>
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            :             /*
<span class="lineNum">     752 </span>            :              * If the partition's tuple descriptor matches exactly the root
<span class="lineNum">     753 </span>            :              * parent (the common case), we can re-use most of the parent's ON
<span class="lineNum">     754 </span>            :              * CONFLICT SET state, skipping a bunch of work.  Otherwise, we
<span class="lineNum">     755 </span>            :              * need to create state specific to this partition.
<span class="lineNum">     756 </span>            :              */
<span class="lineNum">     757 </span><span class="lineCov">         44 :             if (map == NULL)</span>
<span class="lineNum">     758 </span>            :             {
<span class="lineNum">     759 </span>            :                 /*
<span class="lineNum">     760 </span>            :                  * It's safe to reuse these from the partition root, as we
<span class="lineNum">     761 </span>            :                  * only process one tuple at a time (therefore we won't
<span class="lineNum">     762 </span>            :                  * overwrite needed data in slots), and the results of
<span class="lineNum">     763 </span>            :                  * projections are independent of the underlying storage.
<span class="lineNum">     764 </span>            :                  * Projections and where clauses themselves don't store state
<span class="lineNum">     765 </span>            :                  * / are independent of the underlying storage.
<span class="lineNum">     766 </span>            :                  */
<span class="lineNum">     767 </span><span class="lineCov">         48 :                 leaf_part_rri-&gt;ri_onConflict-&gt;oc_ProjSlot =</span>
<span class="lineNum">     768 </span><span class="lineCov">         24 :                     rootResultRelInfo-&gt;ri_onConflict-&gt;oc_ProjSlot;</span>
<span class="lineNum">     769 </span><span class="lineCov">         48 :                 leaf_part_rri-&gt;ri_onConflict-&gt;oc_ProjInfo =</span>
<span class="lineNum">     770 </span><span class="lineCov">         24 :                     rootResultRelInfo-&gt;ri_onConflict-&gt;oc_ProjInfo;</span>
<span class="lineNum">     771 </span><span class="lineCov">         48 :                 leaf_part_rri-&gt;ri_onConflict-&gt;oc_WhereClause =</span>
<span class="lineNum">     772 </span><span class="lineCov">         24 :                     rootResultRelInfo-&gt;ri_onConflict-&gt;oc_WhereClause;</span>
<span class="lineNum">     773 </span>            :             }
<span class="lineNum">     774 </span>            :             else
<span class="lineNum">     775 </span>            :             {
<span class="lineNum">     776 </span>            :                 List       *onconflset;
<span class="lineNum">     777 </span>            :                 TupleDesc   tupDesc;
<span class="lineNum">     778 </span>            :                 bool        found_whole_row;
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            :                 /*
<span class="lineNum">     781 </span>            :                  * Translate expressions in onConflictSet to account for
<span class="lineNum">     782 </span>            :                  * different attribute numbers.  For that, map partition
<span class="lineNum">     783 </span>            :                  * varattnos twice: first to catch the EXCLUDED
<span class="lineNum">     784 </span>            :                  * pseudo-relation (INNER_VAR), and second to handle the main
<span class="lineNum">     785 </span>            :                  * target relation (firstVarno).
<span class="lineNum">     786 </span>            :                  */
<span class="lineNum">     787 </span><span class="lineCov">         20 :                 onconflset = (List *) copyObject((Node *) node-&gt;onConflictSet);</span>
<span class="lineNum">     788 </span><span class="lineCov">         20 :                 if (part_attnos == NULL)</span>
<span class="lineNum">     789 </span><span class="lineCov">         20 :                     part_attnos =</span>
<span class="lineNum">     790 </span><span class="lineCov">         20 :                         convert_tuples_by_name_map(RelationGetDescr(partrel),</span>
<span class="lineNum">     791 </span>            :                                                    RelationGetDescr(firstResultRel));
<span class="lineNum">     792 </span><span class="lineCov">         20 :                 onconflset = (List *)</span>
<span class="lineNum">     793 </span><span class="lineCov">         40 :                     map_variable_attnos((Node *) onconflset,</span>
<span class="lineNum">     794 </span>            :                                         INNER_VAR, 0,
<span class="lineNum">     795 </span>            :                                         part_attnos,
<span class="lineNum">     796 </span><span class="lineCov">         20 :                                         RelationGetDescr(firstResultRel)-&gt;natts,</span>
<span class="lineNum">     797 </span><span class="lineCov">         20 :                                         RelationGetForm(partrel)-&gt;reltype,</span>
<span class="lineNum">     798 </span>            :                                         &amp;found_whole_row);
<span class="lineNum">     799 </span>            :                 /* We ignore the value of found_whole_row. */
<span class="lineNum">     800 </span><span class="lineCov">         20 :                 onconflset = (List *)</span>
<span class="lineNum">     801 </span><span class="lineCov">         40 :                     map_variable_attnos((Node *) onconflset,</span>
<span class="lineNum">     802 </span>            :                                         firstVarno, 0,
<span class="lineNum">     803 </span>            :                                         part_attnos,
<span class="lineNum">     804 </span><span class="lineCov">         20 :                                         RelationGetDescr(firstResultRel)-&gt;natts,</span>
<span class="lineNum">     805 </span><span class="lineCov">         20 :                                         RelationGetForm(partrel)-&gt;reltype,</span>
<span class="lineNum">     806 </span>            :                                         &amp;found_whole_row);
<span class="lineNum">     807 </span>            :                 /* We ignore the value of found_whole_row. */
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :                 /* Finally, adjust this tlist to match the partition. */
<span class="lineNum">     810 </span><span class="lineCov">         20 :                 onconflset = adjust_partition_tlist(onconflset, map);</span>
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            :                 /* create the tuple slot for the UPDATE SET projection */
<span class="lineNum">     813 </span><span class="lineCov">         20 :                 tupDesc = ExecTypeFromTL(onconflset);</span>
<span class="lineNum">     814 </span><span class="lineCov">         40 :                 leaf_part_rri-&gt;ri_onConflict-&gt;oc_ProjSlot =</span>
<span class="lineNum">     815 </span><span class="lineCov">         20 :                     ExecInitExtraTupleSlot(mtstate-&gt;ps.state, tupDesc,</span>
<span class="lineNum">     816 </span>            :                                            &amp;TTSOpsVirtual);
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span>            :                 /* build UPDATE SET projection state */
<span class="lineNum">     819 </span><span class="lineCov">         40 :                 leaf_part_rri-&gt;ri_onConflict-&gt;oc_ProjInfo =</span>
<span class="lineNum">     820 </span><span class="lineCov">         40 :                     ExecBuildProjectionInfo(onconflset, econtext,</span>
<span class="lineNum">     821 </span><span class="lineCov">         20 :                                             leaf_part_rri-&gt;ri_onConflict-&gt;oc_ProjSlot,</span>
<span class="lineNum">     822 </span>            :                                             &amp;mtstate-&gt;ps, partrelDesc);
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            :                 /*
<span class="lineNum">     825 </span>            :                  * If there is a WHERE clause, initialize state where it will
<span class="lineNum">     826 </span>            :                  * be evaluated, mapping the attribute numbers appropriately.
<span class="lineNum">     827 </span>            :                  * As with onConflictSet, we need to map partition varattnos
<span class="lineNum">     828 </span>            :                  * to the partition's tupdesc.
<span class="lineNum">     829 </span>            :                  */
<span class="lineNum">     830 </span><span class="lineCov">         20 :                 if (node-&gt;onConflictWhere)</span>
<span class="lineNum">     831 </span>            :                 {
<span class="lineNum">     832 </span>            :                     List       *clause;
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span><span class="lineCov">         10 :                     clause = copyObject((List *) node-&gt;onConflictWhere);</span>
<span class="lineNum">     835 </span><span class="lineCov">         10 :                     clause = (List *)</span>
<span class="lineNum">     836 </span><span class="lineCov">         20 :                         map_variable_attnos((Node *) clause,</span>
<span class="lineNum">     837 </span>            :                                             INNER_VAR, 0,
<span class="lineNum">     838 </span>            :                                             part_attnos,
<span class="lineNum">     839 </span><span class="lineCov">         10 :                                             RelationGetDescr(firstResultRel)-&gt;natts,</span>
<span class="lineNum">     840 </span><span class="lineCov">         10 :                                             RelationGetForm(partrel)-&gt;reltype,</span>
<span class="lineNum">     841 </span>            :                                             &amp;found_whole_row);
<span class="lineNum">     842 </span>            :                     /* We ignore the value of found_whole_row. */
<span class="lineNum">     843 </span><span class="lineCov">         10 :                     clause = (List *)</span>
<span class="lineNum">     844 </span><span class="lineCov">         20 :                         map_variable_attnos((Node *) clause,</span>
<span class="lineNum">     845 </span>            :                                             firstVarno, 0,
<span class="lineNum">     846 </span>            :                                             part_attnos,
<span class="lineNum">     847 </span><span class="lineCov">         10 :                                             RelationGetDescr(firstResultRel)-&gt;natts,</span>
<span class="lineNum">     848 </span><span class="lineCov">         10 :                                             RelationGetForm(partrel)-&gt;reltype,</span>
<span class="lineNum">     849 </span>            :                                             &amp;found_whole_row);
<span class="lineNum">     850 </span>            :                     /* We ignore the value of found_whole_row. */
<span class="lineNum">     851 </span><span class="lineCov">         20 :                     leaf_part_rri-&gt;ri_onConflict-&gt;oc_WhereClause =</span>
<span class="lineNum">     852 </span><span class="lineCov">         10 :                         ExecInitQual((List *) clause, &amp;mtstate-&gt;ps);</span>
<span class="lineNum">     853 </span>            :                 }
<span class="lineNum">     854 </span>            :             }
<span class="lineNum">     855 </span>            :         }
<span class="lineNum">     856 </span>            :     }
<span class="lineNum">     857 </span>            : 
<span class="lineNum">     858 </span>            :     /*
<span class="lineNum">     859 </span>            :      * Since we've just initialized this ResultRelInfo, it's not in any list
<span class="lineNum">     860 </span>            :      * attached to the estate as yet.  Add it, so that it can be found later.
<span class="lineNum">     861 </span>            :      *
<span class="lineNum">     862 </span>            :      * Note that the entries in this list appear in no predetermined order,
<span class="lineNum">     863 </span>            :      * because partition result rels are initialized as and when they're
<span class="lineNum">     864 </span>            :      * needed.
<span class="lineNum">     865 </span>            :      */
<span class="lineNum">     866 </span><span class="lineCov">        938 :     MemoryContextSwitchTo(estate-&gt;es_query_cxt);</span>
<span class="lineNum">     867 </span><span class="lineCov">        938 :     estate-&gt;es_tuple_routing_result_relations =</span>
<span class="lineNum">     868 </span><span class="lineCov">        938 :         lappend(estate-&gt;es_tuple_routing_result_relations,</span>
<span class="lineNum">     869 </span>            :                 leaf_part_rri);
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span><span class="lineCov">        938 :     MemoryContextSwitchTo(oldcxt);</span>
<span class="lineNum">     872 </span>            : 
<span class="lineNum">     873 </span><span class="lineCov">        938 :     return leaf_part_rri;</span>
<span class="lineNum">     874 </span>            : }
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span>            : /*
<span class="lineNum">     877 </span>            :  * ExecInitRoutingInfo
<span class="lineNum">     878 </span>            :  *      Set up information needed for translating tuples between root
<span class="lineNum">     879 </span>            :  *      partitioned table format and partition format, and keep track of it
<span class="lineNum">     880 </span>            :  *      in PartitionTupleRouting.
<a name="881"><span class="lineNum">     881 </span>            :  */</a>
<span class="lineNum">     882 </span>            : static void
<span class="lineNum">     883 </span><span class="lineCov">        974 : ExecInitRoutingInfo(ModifyTableState *mtstate,</span>
<span class="lineNum">     884 </span>            :                     EState *estate,
<span class="lineNum">     885 </span>            :                     PartitionTupleRouting *proute,
<span class="lineNum">     886 </span>            :                     PartitionDispatch dispatch,
<span class="lineNum">     887 </span>            :                     ResultRelInfo *partRelInfo,
<span class="lineNum">     888 </span>            :                     int partidx)
<span class="lineNum">     889 </span>            : {
<span class="lineNum">     890 </span>            :     MemoryContext oldcxt;
<span class="lineNum">     891 </span>            :     PartitionRoutingInfo *partrouteinfo;
<span class="lineNum">     892 </span>            :     int         rri_index;
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span><span class="lineCov">        974 :     oldcxt = MemoryContextSwitchTo(proute-&gt;memcxt);</span>
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span><span class="lineCov">        974 :     partrouteinfo = palloc(sizeof(PartitionRoutingInfo));</span>
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span>            :     /*
<span class="lineNum">     899 </span>            :      * Set up a tuple conversion map to convert a tuple routed to the
<span class="lineNum">     900 </span>            :      * partition from the parent's type to the partition's.
<span class="lineNum">     901 </span>            :      */
<span class="lineNum">     902 </span><span class="lineCov">        974 :     partrouteinfo-&gt;pi_RootToPartitionMap =</span>
<span class="lineNum">     903 </span><span class="lineCov">        974 :         convert_tuples_by_name(RelationGetDescr(partRelInfo-&gt;ri_PartitionRoot),</span>
<span class="lineNum">     904 </span><span class="lineCov">        974 :                                RelationGetDescr(partRelInfo-&gt;ri_RelationDesc));</span>
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            :     /*
<span class="lineNum">     907 </span>            :      * If a partition has a different rowtype than the root parent, initialize
<span class="lineNum">     908 </span>            :      * a slot dedicated to storing this partition's tuples.  The slot is used
<span class="lineNum">     909 </span>            :      * for various operations that are applied to tuples after routing, such
<span class="lineNum">     910 </span>            :      * as checking constraints.
<span class="lineNum">     911 </span>            :      */
<span class="lineNum">     912 </span><span class="lineCov">        974 :     if (partrouteinfo-&gt;pi_RootToPartitionMap != NULL)</span>
<span class="lineNum">     913 </span>            :     {
<span class="lineNum">     914 </span><span class="lineCov">        286 :         Relation    partrel = partRelInfo-&gt;ri_RelationDesc;</span>
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span>            :         /*
<span class="lineNum">     917 </span>            :          * Initialize the slot itself setting its descriptor to this
<span class="lineNum">     918 </span>            :          * partition's TupleDesc; TupleDesc reference will be released at the
<span class="lineNum">     919 </span>            :          * end of the command.
<span class="lineNum">     920 </span>            :          */
<span class="lineNum">     921 </span><span class="lineCov">        286 :         partrouteinfo-&gt;pi_PartitionTupleSlot =</span>
<span class="lineNum">     922 </span><span class="lineCov">        286 :             table_slot_create(partrel, &amp;estate-&gt;es_tupleTable);</span>
<span class="lineNum">     923 </span>            :     }
<span class="lineNum">     924 </span>            :     else
<span class="lineNum">     925 </span><span class="lineCov">        688 :         partrouteinfo-&gt;pi_PartitionTupleSlot = NULL;</span>
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span>            :     /*
<span class="lineNum">     928 </span>            :      * Also, if transition capture is required, store a map to convert tuples
<span class="lineNum">     929 </span>            :      * from partition's rowtype to the root partition table's.
<span class="lineNum">     930 </span>            :      */
<span class="lineNum">     931 </span><span class="lineCov">       1948 :     if (mtstate &amp;&amp;</span>
<span class="lineNum">     932 </span><span class="lineCov">       1892 :         (mtstate-&gt;mt_transition_capture || mtstate-&gt;mt_oc_transition_capture))</span>
<span class="lineNum">     933 </span>            :     {
<span class="lineNum">     934 </span><span class="lineCov">         58 :         partrouteinfo-&gt;pi_PartitionToRootMap =</span>
<span class="lineNum">     935 </span><span class="lineCov">         58 :             convert_tuples_by_name(RelationGetDescr(partRelInfo-&gt;ri_RelationDesc),</span>
<span class="lineNum">     936 </span><span class="lineCov">         58 :                                    RelationGetDescr(partRelInfo-&gt;ri_PartitionRoot));</span>
<span class="lineNum">     937 </span>            :     }
<span class="lineNum">     938 </span>            :     else
<span class="lineNum">     939 </span><span class="lineCov">        916 :         partrouteinfo-&gt;pi_PartitionToRootMap = NULL;</span>
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            :     /*
<span class="lineNum">     942 </span>            :      * If the partition is a foreign table, let the FDW init itself for
<span class="lineNum">     943 </span>            :      * routing tuples to the partition.
<span class="lineNum">     944 </span>            :      */
<span class="lineNum">     945 </span><span class="lineCov">        974 :     if (partRelInfo-&gt;ri_FdwRoutine != NULL &amp;&amp;</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :         partRelInfo-&gt;ri_FdwRoutine-&gt;BeginForeignInsert != NULL)</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :         partRelInfo-&gt;ri_FdwRoutine-&gt;BeginForeignInsert(mtstate, partRelInfo);</span>
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span><span class="lineCov">        974 :     partRelInfo-&gt;ri_PartitionInfo = partrouteinfo;</span>
<span class="lineNum">     950 </span><span class="lineCov">        974 :     partRelInfo-&gt;ri_CopyMultiInsertBuffer = NULL;</span>
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span>            :     /*
<span class="lineNum">     953 </span>            :      * Keep track of it in the PartitionTupleRouting-&gt;partitions array.
<span class="lineNum">     954 </span>            :      */
<span class="lineNum">     955 </span><span class="lineCov">        974 :     Assert(dispatch-&gt;indexes[partidx] == -1);</span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span><span class="lineCov">        974 :     rri_index = proute-&gt;num_partitions++;</span>
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            :     /* Allocate or enlarge the array, as needed */
<span class="lineNum">     960 </span><span class="lineCov">        974 :     if (proute-&gt;num_partitions &gt;= proute-&gt;max_partitions)</span>
<span class="lineNum">     961 </span>            :     {
<span class="lineNum">     962 </span><span class="lineCov">        578 :         if (proute-&gt;max_partitions == 0)</span>
<span class="lineNum">     963 </span>            :         {
<span class="lineNum">     964 </span><span class="lineCov">        576 :             proute-&gt;max_partitions = 8;</span>
<span class="lineNum">     965 </span><span class="lineCov">        576 :             proute-&gt;partitions = (ResultRelInfo **)</span>
<span class="lineNum">     966 </span><span class="lineCov">        576 :                 palloc(sizeof(ResultRelInfo *) * proute-&gt;max_partitions);</span>
<span class="lineNum">     967 </span>            :         }
<span class="lineNum">     968 </span>            :         else
<span class="lineNum">     969 </span>            :         {
<span class="lineNum">     970 </span><span class="lineCov">          2 :             proute-&gt;max_partitions *= 2;</span>
<span class="lineNum">     971 </span><span class="lineCov">          2 :             proute-&gt;partitions = (ResultRelInfo **)</span>
<span class="lineNum">     972 </span><span class="lineCov">          2 :                 repalloc(proute-&gt;partitions, sizeof(ResultRelInfo *) *</span>
<span class="lineNum">     973 </span><span class="lineCov">          2 :                          proute-&gt;max_partitions);</span>
<span class="lineNum">     974 </span>            :         }
<span class="lineNum">     975 </span>            :     }
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineCov">        974 :     proute-&gt;partitions[rri_index] = partRelInfo;</span>
<span class="lineNum">     978 </span><span class="lineCov">        974 :     dispatch-&gt;indexes[partidx] = rri_index;</span>
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span><span class="lineCov">        974 :     MemoryContextSwitchTo(oldcxt);</span>
<span class="lineNum">     981 </span><span class="lineCov">        974 : }</span>
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span>            : /*
<span class="lineNum">     984 </span>            :  * ExecInitPartitionDispatchInfo
<span class="lineNum">     985 </span>            :  *      Lock the partitioned table (if not locked already) and initialize
<span class="lineNum">     986 </span>            :  *      PartitionDispatch for a partitioned table and store it in the next
<span class="lineNum">     987 </span>            :  *      available slot in the proute-&gt;partition_dispatch_info array.  Also,
<span class="lineNum">     988 </span>            :  *      record the index into this array in the parent_pd-&gt;indexes[] array in
<span class="lineNum">     989 </span>            :  *      the partidx element so that we can properly retrieve the newly created
<span class="lineNum">     990 </span>            :  *      PartitionDispatch later.
<a name="991"><span class="lineNum">     991 </span>            :  */</a>
<span class="lineNum">     992 </span>            : static PartitionDispatch
<span class="lineNum">     993 </span><span class="lineCov">        984 : ExecInitPartitionDispatchInfo(EState *estate,</span>
<span class="lineNum">     994 </span>            :                               PartitionTupleRouting *proute, Oid partoid,
<span class="lineNum">     995 </span>            :                               PartitionDispatch parent_pd, int partidx)
<span class="lineNum">     996 </span>            : {
<span class="lineNum">     997 </span>            :     Relation    rel;
<span class="lineNum">     998 </span>            :     PartitionDesc partdesc;
<span class="lineNum">     999 </span>            :     PartitionDispatch pd;
<span class="lineNum">    1000 </span>            :     int         dispatchidx;
<span class="lineNum">    1001 </span>            :     MemoryContext oldcxt;
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span><span class="lineCov">        984 :     if (estate-&gt;es_partition_directory == NULL)</span>
<span class="lineNum">    1004 </span><span class="lineCov">        678 :         estate-&gt;es_partition_directory =</span>
<span class="lineNum">    1005 </span><span class="lineCov">        678 :             CreatePartitionDirectory(estate-&gt;es_query_cxt);</span>
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span><span class="lineCov">        984 :     oldcxt = MemoryContextSwitchTo(proute-&gt;memcxt);</span>
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span>            :     /*
<span class="lineNum">    1010 </span>            :      * Only sub-partitioned tables need to be locked here.  The root
<span class="lineNum">    1011 </span>            :      * partitioned table will already have been locked as it's referenced in
<span class="lineNum">    1012 </span>            :      * the query's rtable.
<span class="lineNum">    1013 </span>            :      */
<span class="lineNum">    1014 </span><span class="lineCov">        984 :     if (partoid != RelationGetRelid(proute-&gt;partition_root))</span>
<span class="lineNum">    1015 </span><span class="lineCov">        300 :         rel = table_open(partoid, RowExclusiveLock);</span>
<span class="lineNum">    1016 </span>            :     else
<span class="lineNum">    1017 </span><span class="lineCov">        684 :         rel = proute-&gt;partition_root;</span>
<span class="lineNum">    1018 </span><span class="lineCov">        984 :     partdesc = PartitionDirectoryLookup(estate-&gt;es_partition_directory, rel);</span>
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span><span class="lineCov">        984 :     pd = (PartitionDispatch) palloc(offsetof(PartitionDispatchData, indexes) +</span>
<span class="lineNum">    1021 </span><span class="lineCov">        984 :                                     partdesc-&gt;nparts * sizeof(int));</span>
<span class="lineNum">    1022 </span><span class="lineCov">        984 :     pd-&gt;reldesc = rel;</span>
<span class="lineNum">    1023 </span><span class="lineCov">        984 :     pd-&gt;key = RelationGetPartitionKey(rel);</span>
<span class="lineNum">    1024 </span><span class="lineCov">        984 :     pd-&gt;keystate = NIL;</span>
<span class="lineNum">    1025 </span><span class="lineCov">        984 :     pd-&gt;partdesc = partdesc;</span>
<span class="lineNum">    1026 </span><span class="lineCov">        984 :     if (parent_pd != NULL)</span>
<span class="lineNum">    1027 </span>            :     {
<span class="lineNum">    1028 </span><span class="lineCov">        300 :         TupleDesc   tupdesc = RelationGetDescr(rel);</span>
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span>            :         /*
<span class="lineNum">    1031 </span>            :          * For sub-partitioned tables where the column order differs from its
<span class="lineNum">    1032 </span>            :          * direct parent partitioned table, we must store a tuple table slot
<span class="lineNum">    1033 </span>            :          * initialized with its tuple descriptor and a tuple conversion map to
<span class="lineNum">    1034 </span>            :          * convert a tuple from its parent's rowtype to its own.  This is to
<span class="lineNum">    1035 </span>            :          * make sure that we are looking at the correct row using the correct
<span class="lineNum">    1036 </span>            :          * tuple descriptor when computing its partition key for tuple
<span class="lineNum">    1037 </span>            :          * routing.
<span class="lineNum">    1038 </span>            :          */
<span class="lineNum">    1039 </span><span class="lineCov">        300 :         pd-&gt;tupmap = convert_tuples_by_name_map_if_req(RelationGetDescr(parent_pd-&gt;reldesc),</span>
<span class="lineNum">    1040 </span>            :                                                        tupdesc);
<span class="lineNum">    1041 </span><span class="lineCov">        600 :         pd-&gt;tupslot = pd-&gt;tupmap ?</span>
<span class="lineNum">    1042 </span><span class="lineCov">        300 :             MakeSingleTupleTableSlot(tupdesc, &amp;TTSOpsVirtual) : NULL;</span>
<span class="lineNum">    1043 </span>            :     }
<span class="lineNum">    1044 </span>            :     else
<span class="lineNum">    1045 </span>            :     {
<span class="lineNum">    1046 </span>            :         /* Not required for the root partitioned table */
<span class="lineNum">    1047 </span><span class="lineCov">        684 :         pd-&gt;tupmap = NULL;</span>
<span class="lineNum">    1048 </span><span class="lineCov">        684 :         pd-&gt;tupslot = NULL;</span>
<span class="lineNum">    1049 </span>            :     }
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span>            :     /*
<span class="lineNum">    1052 </span>            :      * Initialize with -1 to signify that the corresponding partition's
<span class="lineNum">    1053 </span>            :      * ResultRelInfo or PartitionDispatch has not been created yet.
<span class="lineNum">    1054 </span>            :      */
<span class="lineNum">    1055 </span><span class="lineCov">        984 :     memset(pd-&gt;indexes, -1, sizeof(int) * partdesc-&gt;nparts);</span>
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span>            :     /* Track in PartitionTupleRouting for later use */
<span class="lineNum">    1058 </span><span class="lineCov">        984 :     dispatchidx = proute-&gt;num_dispatch++;</span>
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span>            :     /* Allocate or enlarge the array, as needed */
<span class="lineNum">    1061 </span><span class="lineCov">        984 :     if (proute-&gt;num_dispatch &gt;= proute-&gt;max_dispatch)</span>
<span class="lineNum">    1062 </span>            :     {
<span class="lineNum">    1063 </span><span class="lineCov">        684 :         if (proute-&gt;max_dispatch == 0)</span>
<span class="lineNum">    1064 </span>            :         {
<span class="lineNum">    1065 </span><span class="lineCov">        684 :             proute-&gt;max_dispatch = 4;</span>
<span class="lineNum">    1066 </span><span class="lineCov">        684 :             proute-&gt;partition_dispatch_info = (PartitionDispatch *)</span>
<span class="lineNum">    1067 </span><span class="lineCov">        684 :                 palloc(sizeof(PartitionDispatch) * proute-&gt;max_dispatch);</span>
<span class="lineNum">    1068 </span>            :         }
<span class="lineNum">    1069 </span>            :         else
<span class="lineNum">    1070 </span>            :         {
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :             proute-&gt;max_dispatch *= 2;</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :             proute-&gt;partition_dispatch_info = (PartitionDispatch *)</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :                 repalloc(proute-&gt;partition_dispatch_info,</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :                          sizeof(PartitionDispatch) * proute-&gt;max_dispatch);</span>
<span class="lineNum">    1075 </span>            :         }
<span class="lineNum">    1076 </span>            :     }
<span class="lineNum">    1077 </span><span class="lineCov">        984 :     proute-&gt;partition_dispatch_info[dispatchidx] = pd;</span>
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            :     /*
<span class="lineNum">    1080 </span>            :      * Finally, if setting up a PartitionDispatch for a sub-partitioned table,
<span class="lineNum">    1081 </span>            :      * install a downlink in the parent to allow quick descent.
<span class="lineNum">    1082 </span>            :      */
<span class="lineNum">    1083 </span><span class="lineCov">        984 :     if (parent_pd)</span>
<span class="lineNum">    1084 </span>            :     {
<span class="lineNum">    1085 </span><span class="lineCov">        300 :         Assert(parent_pd-&gt;indexes[partidx] == -1);</span>
<span class="lineNum">    1086 </span><span class="lineCov">        300 :         parent_pd-&gt;indexes[partidx] = dispatchidx;</span>
<span class="lineNum">    1087 </span>            :     }
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span><span class="lineCov">        984 :     MemoryContextSwitchTo(oldcxt);</span>
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span><span class="lineCov">        984 :     return pd;</span>
<span class="lineNum">    1092 </span>            : }
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span>            : /*
<span class="lineNum">    1095 </span>            :  * ExecCleanupTupleRouting -- Clean up objects allocated for partition tuple
<span class="lineNum">    1096 </span>            :  * routing.
<span class="lineNum">    1097 </span>            :  *
<span class="lineNum">    1098 </span>            :  * Close all the partitioned tables, leaf partitions, and their indices.
<a name="1099"><span class="lineNum">    1099 </span>            :  */</a>
<span class="lineNum">    1100 </span>            : void
<span class="lineNum">    1101 </span><span class="lineCov">        536 : ExecCleanupTupleRouting(ModifyTableState *mtstate,</span>
<span class="lineNum">    1102 </span>            :                         PartitionTupleRouting *proute)
<span class="lineNum">    1103 </span>            : {
<span class="lineNum">    1104 </span><span class="lineCov">        536 :     HTAB       *htab = proute-&gt;subplan_resultrel_htab;</span>
<span class="lineNum">    1105 </span>            :     int         i;
<span class="lineNum">    1106 </span>            : 
<span class="lineNum">    1107 </span>            :     /*
<span class="lineNum">    1108 </span>            :      * Remember, proute-&gt;partition_dispatch_info[0] corresponds to the root
<span class="lineNum">    1109 </span>            :      * partitioned table, which we must not try to close, because it is the
<span class="lineNum">    1110 </span>            :      * main target table of the query that will be closed by callers such as
<span class="lineNum">    1111 </span>            :      * ExecEndPlan() or DoCopy(). Also, tupslot is NULL for the root
<span class="lineNum">    1112 </span>            :      * partitioned table.
<span class="lineNum">    1113 </span>            :      */
<span class="lineNum">    1114 </span><span class="lineCov">        778 :     for (i = 1; i &lt; proute-&gt;num_dispatch; i++)</span>
<span class="lineNum">    1115 </span>            :     {
<span class="lineNum">    1116 </span><span class="lineCov">        242 :         PartitionDispatch pd = proute-&gt;partition_dispatch_info[i];</span>
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineCov">        242 :         table_close(pd-&gt;reldesc, NoLock);</span>
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span><span class="lineCov">        242 :         if (pd-&gt;tupslot)</span>
<span class="lineNum">    1121 </span><span class="lineCov">        144 :             ExecDropSingleTupleTableSlot(pd-&gt;tupslot);</span>
<span class="lineNum">    1122 </span>            :     }
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span><span class="lineCov">       1424 :     for (i = 0; i &lt; proute-&gt;num_partitions; i++)</span>
<span class="lineNum">    1125 </span>            :     {
<span class="lineNum">    1126 </span><span class="lineCov">        888 :         ResultRelInfo *resultRelInfo = proute-&gt;partitions[i];</span>
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span>            :         /* Allow any FDWs to shut down */
<span class="lineNum">    1129 </span><span class="lineCov">        888 :         if (resultRelInfo-&gt;ri_FdwRoutine != NULL &amp;&amp;</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :             resultRelInfo-&gt;ri_FdwRoutine-&gt;EndForeignInsert != NULL)</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :             resultRelInfo-&gt;ri_FdwRoutine-&gt;EndForeignInsert(mtstate-&gt;ps.state,</span>
<span class="lineNum">    1132 </span>            :                                                            resultRelInfo);
<span class="lineNum">    1133 </span>            : 
<span class="lineNum">    1134 </span>            :         /*
<span class="lineNum">    1135 </span>            :          * Check if this result rel is one belonging to the node's subplans,
<span class="lineNum">    1136 </span>            :          * if so, let ExecEndPlan() clean it up.
<span class="lineNum">    1137 </span>            :          */
<span class="lineNum">    1138 </span><span class="lineCov">        888 :         if (htab)</span>
<span class="lineNum">    1139 </span>            :         {
<span class="lineNum">    1140 </span>            :             Oid         partoid;
<span class="lineNum">    1141 </span>            :             bool        found;
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span><span class="lineCov">         68 :             partoid = RelationGetRelid(resultRelInfo-&gt;ri_RelationDesc);</span>
<span class="lineNum">    1144 </span>            : 
<span class="lineNum">    1145 </span><span class="lineCov">         68 :             (void) hash_search(htab, &amp;partoid, HASH_FIND, &amp;found);</span>
<span class="lineNum">    1146 </span><span class="lineCov">         68 :             if (found)</span>
<span class="lineNum">    1147 </span><span class="lineCov">         34 :                 continue;</span>
<span class="lineNum">    1148 </span>            :         }
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span><span class="lineCov">        854 :         ExecCloseIndices(resultRelInfo);</span>
<span class="lineNum">    1151 </span><span class="lineCov">        854 :         table_close(resultRelInfo-&gt;ri_RelationDesc, NoLock);</span>
<span class="lineNum">    1152 </span>            :     }
<span class="lineNum">    1153 </span><span class="lineCov">        536 : }</span>
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span>            : /* ----------------
<span class="lineNum">    1156 </span>            :  *      FormPartitionKeyDatum
<span class="lineNum">    1157 </span>            :  *          Construct values[] and isnull[] arrays for the partition key
<span class="lineNum">    1158 </span>            :  *          of a tuple.
<span class="lineNum">    1159 </span>            :  *
<span class="lineNum">    1160 </span>            :  *  pd              Partition dispatch object of the partitioned table
<span class="lineNum">    1161 </span>            :  *  slot            Heap tuple from which to extract partition key
<span class="lineNum">    1162 </span>            :  *  estate          executor state for evaluating any partition key
<span class="lineNum">    1163 </span>            :  *                  expressions (must be non-NULL)
<span class="lineNum">    1164 </span>            :  *  values          Array of partition key Datums (output area)
<span class="lineNum">    1165 </span>            :  *  isnull          Array of is-null indicators (output area)
<span class="lineNum">    1166 </span>            :  *
<span class="lineNum">    1167 </span>            :  * the ecxt_scantuple slot of estate's per-tuple expr context must point to
<span class="lineNum">    1168 </span>            :  * the heap tuple passed in.
<span class="lineNum">    1169 </span>            :  * ----------------
<a name="1170"><span class="lineNum">    1170 </span>            :  */</a>
<span class="lineNum">    1171 </span>            : static void
<span class="lineNum">    1172 </span><span class="lineCov">     190420 : FormPartitionKeyDatum(PartitionDispatch pd,</span>
<span class="lineNum">    1173 </span>            :                       TupleTableSlot *slot,
<span class="lineNum">    1174 </span>            :                       EState *estate,
<span class="lineNum">    1175 </span>            :                       Datum *values,
<span class="lineNum">    1176 </span>            :                       bool *isnull)
<span class="lineNum">    1177 </span>            : {
<span class="lineNum">    1178 </span>            :     ListCell   *partexpr_item;
<span class="lineNum">    1179 </span>            :     int         i;
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span><span class="lineCov">     190420 :     if (pd-&gt;key-&gt;partexprs != NIL &amp;&amp; pd-&gt;keystate == NIL)</span>
<span class="lineNum">    1182 </span>            :     {
<span class="lineNum">    1183 </span>            :         /* Check caller has set up context correctly */
<span class="lineNum">    1184 </span><span class="lineCov">        166 :         Assert(estate != NULL &amp;&amp;</span>
<span class="lineNum">    1185 </span>            :                GetPerTupleExprContext(estate)-&gt;ecxt_scantuple == slot);
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span>            :         /* First time through, set up expression evaluation state */
<span class="lineNum">    1188 </span><span class="lineCov">        166 :         pd-&gt;keystate = ExecPrepareExprList(pd-&gt;key-&gt;partexprs, estate);</span>
<span class="lineNum">    1189 </span>            :     }
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span><span class="lineCov">     190420 :     partexpr_item = list_head(pd-&gt;keystate);</span>
<span class="lineNum">    1192 </span><span class="lineCov">     388340 :     for (i = 0; i &lt; pd-&gt;key-&gt;partnatts; i++)</span>
<span class="lineNum">    1193 </span>            :     {
<span class="lineNum">    1194 </span><span class="lineCov">     197920 :         AttrNumber  keycol = pd-&gt;key-&gt;partattrs[i];</span>
<span class="lineNum">    1195 </span>            :         Datum       datum;
<span class="lineNum">    1196 </span>            :         bool        isNull;
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span><span class="lineCov">     197920 :         if (keycol != 0)</span>
<span class="lineNum">    1199 </span>            :         {
<span class="lineNum">    1200 </span>            :             /* Plain column; get the value directly from the heap tuple */
<span class="lineNum">    1201 </span><span class="lineCov">     188726 :             datum = slot_getattr(slot, keycol, &amp;isNull);</span>
<span class="lineNum">    1202 </span>            :         }
<span class="lineNum">    1203 </span>            :         else
<span class="lineNum">    1204 </span>            :         {
<span class="lineNum">    1205 </span>            :             /* Expression; need to evaluate it */
<span class="lineNum">    1206 </span><span class="lineCov">       9194 :             if (partexpr_item == NULL)</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :                 elog(ERROR, &quot;wrong number of partition key expressions&quot;);</span>
<span class="lineNum">    1208 </span><span class="lineCov">       9194 :             datum = ExecEvalExprSwitchContext((ExprState *) lfirst(partexpr_item),</span>
<span class="lineNum">    1209 </span><span class="lineCov">       9194 :                                               GetPerTupleExprContext(estate),</span>
<span class="lineNum">    1210 </span>            :                                               &amp;isNull);
<span class="lineNum">    1211 </span><span class="lineCov">       9194 :             partexpr_item = lnext(pd-&gt;keystate, partexpr_item);</span>
<span class="lineNum">    1212 </span>            :         }
<span class="lineNum">    1213 </span><span class="lineCov">     197920 :         values[i] = datum;</span>
<span class="lineNum">    1214 </span><span class="lineCov">     197920 :         isnull[i] = isNull;</span>
<span class="lineNum">    1215 </span>            :     }
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span><span class="lineCov">     190420 :     if (partexpr_item != NULL)</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;wrong number of partition key expressions&quot;);</span>
<span class="lineNum">    1219 </span><span class="lineCov">     190420 : }</span>
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span>            : /*
<span class="lineNum">    1222 </span>            :  * get_partition_for_tuple
<span class="lineNum">    1223 </span>            :  *      Finds partition of relation which accepts the partition key specified
<span class="lineNum">    1224 </span>            :  *      in values and isnull
<span class="lineNum">    1225 </span>            :  *
<span class="lineNum">    1226 </span>            :  * Return value is index of the partition (&gt;= 0 and &lt; partdesc-&gt;nparts) if one
<span class="lineNum">    1227 </span>            :  * found or -1 if none found.
<a name="1228"><span class="lineNum">    1228 </span>            :  */</a>
<span class="lineNum">    1229 </span>            : static int
<span class="lineNum">    1230 </span><span class="lineCov">     190408 : get_partition_for_tuple(PartitionDispatch pd, Datum *values, bool *isnull)</span>
<span class="lineNum">    1231 </span>            : {
<span class="lineNum">    1232 </span>            :     int         bound_offset;
<span class="lineNum">    1233 </span><span class="lineCov">     190408 :     int         part_index = -1;</span>
<span class="lineNum">    1234 </span><span class="lineCov">     190408 :     PartitionKey key = pd-&gt;key;</span>
<span class="lineNum">    1235 </span><span class="lineCov">     190408 :     PartitionDesc partdesc = pd-&gt;partdesc;</span>
<span class="lineNum">    1236 </span><span class="lineCov">     190408 :     PartitionBoundInfo boundinfo = partdesc-&gt;boundinfo;</span>
<span class="lineNum">    1237 </span>            : 
<span class="lineNum">    1238 </span>            :     /* Route as appropriate based on partitioning strategy. */
<span class="lineNum">    1239 </span><span class="lineCov">     190408 :     switch (key-&gt;strategy)</span>
<span class="lineNum">    1240 </span>            :     {
<span class="lineNum">    1241 </span>            :         case PARTITION_STRATEGY_HASH:
<span class="lineNum">    1242 </span>            :             {
<span class="lineNum">    1243 </span>            :                 int         greatest_modulus;
<span class="lineNum">    1244 </span>            :                 uint64      rowHash;
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span><span class="lineCov">       1360 :                 greatest_modulus = get_hash_partition_greatest_modulus(boundinfo);</span>
<span class="lineNum">    1247 </span><span class="lineCov">       1360 :                 rowHash = compute_partition_hash_value(key-&gt;partnatts,</span>
<span class="lineNum">    1248 </span>            :                                                        key-&gt;partsupfunc,
<span class="lineNum">    1249 </span>            :                                                        key-&gt;partcollation,
<span class="lineNum">    1250 </span>            :                                                        values, isnull);
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span><span class="lineCov">       1360 :                 part_index = boundinfo-&gt;indexes[rowHash % greatest_modulus];</span>
<span class="lineNum">    1253 </span>            :             }
<span class="lineNum">    1254 </span><span class="lineCov">       1360 :             break;</span>
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span>            :         case PARTITION_STRATEGY_LIST:
<span class="lineNum">    1257 </span><span class="lineCov">      35758 :             if (isnull[0])</span>
<span class="lineNum">    1258 </span>            :             {
<span class="lineNum">    1259 </span><span class="lineCov">         18 :                 if (partition_bound_accepts_nulls(boundinfo))</span>
<span class="lineNum">    1260 </span><span class="lineCov">         12 :                     part_index = boundinfo-&gt;null_index;</span>
<span class="lineNum">    1261 </span>            :             }
<span class="lineNum">    1262 </span>            :             else
<span class="lineNum">    1263 </span>            :             {
<span class="lineNum">    1264 </span><span class="lineCov">      35740 :                 bool        equal = false;</span>
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span><span class="lineCov">      35740 :                 bound_offset = partition_list_bsearch(key-&gt;partsupfunc,</span>
<span class="lineNum">    1267 </span>            :                                                       key-&gt;partcollation,
<span class="lineNum">    1268 </span>            :                                                       boundinfo,
<span class="lineNum">    1269 </span>            :                                                       values[0], &amp;equal);
<span class="lineNum">    1270 </span><span class="lineCov">      35740 :                 if (bound_offset &gt;= 0 &amp;&amp; equal)</span>
<span class="lineNum">    1271 </span><span class="lineCov">      35732 :                     part_index = boundinfo-&gt;indexes[bound_offset];</span>
<span class="lineNum">    1272 </span>            :             }
<span class="lineNum">    1273 </span><span class="lineCov">      35758 :             break;</span>
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span>            :         case PARTITION_STRATEGY_RANGE:
<span class="lineNum">    1276 </span>            :             {
<span class="lineNum">    1277 </span><span class="lineCov">     153290 :                 bool        equal = false,</span>
<span class="lineNum">    1278 </span><span class="lineCov">     153290 :                             range_partkey_has_null = false;</span>
<span class="lineNum">    1279 </span>            :                 int         i;
<span class="lineNum">    1280 </span>            : 
<span class="lineNum">    1281 </span>            :                 /*
<span class="lineNum">    1282 </span>            :                  * No range includes NULL, so this will be accepted by the
<span class="lineNum">    1283 </span>            :                  * default partition if there is one, and otherwise rejected.
<span class="lineNum">    1284 </span>            :                  */
<span class="lineNum">    1285 </span><span class="lineCov">     314036 :                 for (i = 0; i &lt; key-&gt;partnatts; i++)</span>
<span class="lineNum">    1286 </span>            :                 {
<span class="lineNum">    1287 </span><span class="lineCov">     160764 :                     if (isnull[i])</span>
<span class="lineNum">    1288 </span>            :                     {
<span class="lineNum">    1289 </span><span class="lineCov">         18 :                         range_partkey_has_null = true;</span>
<span class="lineNum">    1290 </span><span class="lineCov">         18 :                         break;</span>
<span class="lineNum">    1291 </span>            :                     }
<span class="lineNum">    1292 </span>            :                 }
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span><span class="lineCov">     153290 :                 if (!range_partkey_has_null)</span>
<span class="lineNum">    1295 </span>            :                 {
<span class="lineNum">    1296 </span><span class="lineCov">     153272 :                     bound_offset = partition_range_datum_bsearch(key-&gt;partsupfunc,</span>
<span class="lineNum">    1297 </span>            :                                                                  key-&gt;partcollation,
<span class="lineNum">    1298 </span>            :                                                                  boundinfo,
<span class="lineNum">    1299 </span><span class="lineCov">     153272 :                                                                  key-&gt;partnatts,</span>
<span class="lineNum">    1300 </span>            :                                                                  values,
<span class="lineNum">    1301 </span>            :                                                                  &amp;equal);
<span class="lineNum">    1302 </span>            : 
<span class="lineNum">    1303 </span>            :                     /*
<span class="lineNum">    1304 </span>            :                      * The bound at bound_offset is less than or equal to the
<span class="lineNum">    1305 </span>            :                      * tuple value, so the bound at offset+1 is the upper
<span class="lineNum">    1306 </span>            :                      * bound of the partition we're looking for, if there
<span class="lineNum">    1307 </span>            :                      * actually exists one.
<span class="lineNum">    1308 </span>            :                      */
<span class="lineNum">    1309 </span><span class="lineCov">     153272 :                     part_index = boundinfo-&gt;indexes[bound_offset + 1];</span>
<span class="lineNum">    1310 </span>            :                 }
<span class="lineNum">    1311 </span>            :             }
<span class="lineNum">    1312 </span><span class="lineCov">     153290 :             break;</span>
<span class="lineNum">    1313 </span>            : 
<span class="lineNum">    1314 </span>            :         default:
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;unexpected partition strategy: %d&quot;,</span>
<span class="lineNum">    1316 </span>            :                  (int) key-&gt;strategy);
<span class="lineNum">    1317 </span>            :     }
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span>            :     /*
<span class="lineNum">    1320 </span>            :      * part_index &lt; 0 means we failed to find a partition of this parent. Use
<span class="lineNum">    1321 </span>            :      * the default partition, if there is one.
<span class="lineNum">    1322 </span>            :      */
<span class="lineNum">    1323 </span><span class="lineCov">     190408 :     if (part_index &lt; 0)</span>
<span class="lineNum">    1324 </span><span class="lineCov">         92 :         part_index = boundinfo-&gt;default_index;</span>
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span><span class="lineCov">     190408 :     return part_index;</span>
<span class="lineNum">    1327 </span>            : }
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span>            : /*
<span class="lineNum">    1330 </span>            :  * ExecBuildSlotPartitionKeyDescription
<span class="lineNum">    1331 </span>            :  *
<span class="lineNum">    1332 </span>            :  * This works very much like BuildIndexValueDescription() and is currently
<span class="lineNum">    1333 </span>            :  * used for building error messages when ExecFindPartition() fails to find
<span class="lineNum">    1334 </span>            :  * partition for a row.
<a name="1335"><span class="lineNum">    1335 </span>            :  */</a>
<span class="lineNum">    1336 </span>            : static char *
<span class="lineNum">    1337 </span><span class="lineCov">         40 : ExecBuildSlotPartitionKeyDescription(Relation rel,</span>
<span class="lineNum">    1338 </span>            :                                      Datum *values,
<span class="lineNum">    1339 </span>            :                                      bool *isnull,
<span class="lineNum">    1340 </span>            :                                      int maxfieldlen)
<span class="lineNum">    1341 </span>            : {
<span class="lineNum">    1342 </span>            :     StringInfoData buf;
<span class="lineNum">    1343 </span><span class="lineCov">         40 :     PartitionKey key = RelationGetPartitionKey(rel);</span>
<span class="lineNum">    1344 </span><span class="lineCov">         40 :     int         partnatts = get_partition_natts(key);</span>
<span class="lineNum">    1345 </span>            :     int         i;
<span class="lineNum">    1346 </span><span class="lineCov">         40 :     Oid         relid = RelationGetRelid(rel);</span>
<span class="lineNum">    1347 </span>            :     AclResult   aclresult;
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span><span class="lineCov">         40 :     if (check_enable_rls(relid, InvalidOid, true) == RLS_ENABLED)</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span>            :     /* If the user has table-level access, just go build the description. */
<span class="lineNum">    1353 </span><span class="lineCov">         40 :     aclresult = pg_class_aclcheck(relid, GetUserId(), ACL_SELECT);</span>
<span class="lineNum">    1354 </span><span class="lineCov">         40 :     if (aclresult != ACLCHECK_OK)</span>
<span class="lineNum">    1355 </span>            :     {
<span class="lineNum">    1356 </span>            :         /*
<span class="lineNum">    1357 </span>            :          * Step through the columns of the partition key and make sure the
<span class="lineNum">    1358 </span>            :          * user has SELECT rights on all of them.
<span class="lineNum">    1359 </span>            :          */
<span class="lineNum">    1360 </span><span class="lineCov">          8 :         for (i = 0; i &lt; partnatts; i++)</span>
<span class="lineNum">    1361 </span>            :         {
<span class="lineNum">    1362 </span><span class="lineCov">          6 :             AttrNumber  attnum = get_partition_col_attnum(key, i);</span>
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span>            :             /*
<span class="lineNum">    1365 </span>            :              * If this partition key column is an expression, we return no
<span class="lineNum">    1366 </span>            :              * detail rather than try to figure out what column(s) the
<span class="lineNum">    1367 </span>            :              * expression includes and if the user has SELECT rights on them.
<span class="lineNum">    1368 </span>            :              */
<span class="lineNum">    1369 </span><span class="lineCov">         10 :             if (attnum == InvalidAttrNumber ||</span>
<span class="lineNum">    1370 </span><span class="lineCov">          4 :                 pg_attribute_aclcheck(relid, attnum, GetUserId(),</span>
<span class="lineNum">    1371 </span>            :                                       ACL_SELECT) != ACLCHECK_OK)
<span class="lineNum">    1372 </span><span class="lineCov">          4 :                 return NULL;</span>
<span class="lineNum">    1373 </span>            :         }
<span class="lineNum">    1374 </span>            :     }
<span class="lineNum">    1375 </span>            : 
<span class="lineNum">    1376 </span><span class="lineCov">         36 :     initStringInfo(&amp;buf);</span>
<span class="lineNum">    1377 </span><span class="lineCov">         36 :     appendStringInfo(&amp;buf, &quot;(%s) = (&quot;,</span>
<span class="lineNum">    1378 </span>            :                      pg_get_partkeydef_columns(relid, true));
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span><span class="lineCov">         90 :     for (i = 0; i &lt; partnatts; i++)</span>
<span class="lineNum">    1381 </span>            :     {
<span class="lineNum">    1382 </span>            :         char       *val;
<span class="lineNum">    1383 </span>            :         int         vallen;
<span class="lineNum">    1384 </span>            : 
<span class="lineNum">    1385 </span><span class="lineCov">         54 :         if (isnull[i])</span>
<span class="lineNum">    1386 </span><span class="lineCov">         10 :             val = &quot;null&quot;;</span>
<span class="lineNum">    1387 </span>            :         else
<span class="lineNum">    1388 </span>            :         {
<span class="lineNum">    1389 </span>            :             Oid         foutoid;
<span class="lineNum">    1390 </span>            :             bool        typisvarlena;
<span class="lineNum">    1391 </span>            : 
<span class="lineNum">    1392 </span><span class="lineCov">         44 :             getTypeOutputInfo(get_partition_col_typid(key, i),</span>
<span class="lineNum">    1393 </span>            :                               &amp;foutoid, &amp;typisvarlena);
<span class="lineNum">    1394 </span><span class="lineCov">         44 :             val = OidOutputFunctionCall(foutoid, values[i]);</span>
<span class="lineNum">    1395 </span>            :         }
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span><span class="lineCov">         54 :         if (i &gt; 0)</span>
<span class="lineNum">    1398 </span><span class="lineCov">         18 :             appendStringInfoString(&amp;buf, &quot;, &quot;);</span>
<span class="lineNum">    1399 </span>            : 
<span class="lineNum">    1400 </span>            :         /* truncate if needed */
<span class="lineNum">    1401 </span><span class="lineCov">         54 :         vallen = strlen(val);</span>
<span class="lineNum">    1402 </span><span class="lineCov">         54 :         if (vallen &lt;= maxfieldlen)</span>
<span class="lineNum">    1403 </span><span class="lineCov">         54 :             appendBinaryStringInfo(&amp;buf, val, vallen);</span>
<span class="lineNum">    1404 </span>            :         else
<span class="lineNum">    1405 </span>            :         {
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :             vallen = pg_mbcliplen(val, vallen, maxfieldlen);</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :             appendBinaryStringInfo(&amp;buf, val, vallen);</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :             appendStringInfoString(&amp;buf, &quot;...&quot;);</span>
<span class="lineNum">    1409 </span>            :         }
<span class="lineNum">    1410 </span>            :     }
<span class="lineNum">    1411 </span>            : 
<span class="lineNum">    1412 </span><span class="lineCov">         36 :     appendStringInfoChar(&amp;buf, ')');</span>
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span><span class="lineCov">         36 :     return buf.data;</span>
<span class="lineNum">    1415 </span>            : }
<span class="lineNum">    1416 </span>            : 
<span class="lineNum">    1417 </span>            : /*
<span class="lineNum">    1418 </span>            :  * adjust_partition_tlist
<span class="lineNum">    1419 </span>            :  *      Adjust the targetlist entries for a given partition to account for
<span class="lineNum">    1420 </span>            :  *      attribute differences between parent and the partition
<span class="lineNum">    1421 </span>            :  *
<span class="lineNum">    1422 </span>            :  * The expressions have already been fixed, but here we fix the list to make
<span class="lineNum">    1423 </span>            :  * target resnos match the partition's attribute numbers.  This results in a
<span class="lineNum">    1424 </span>            :  * copy of the original target list in which the entries appear in resno
<span class="lineNum">    1425 </span>            :  * order, including both the existing entries (that may have their resno
<span class="lineNum">    1426 </span>            :  * changed in-place) and the newly added entries for columns that don't exist
<span class="lineNum">    1427 </span>            :  * in the parent.
<span class="lineNum">    1428 </span>            :  *
<span class="lineNum">    1429 </span>            :  * Scribbles on the input tlist, so callers must make sure to make a copy
<span class="lineNum">    1430 </span>            :  * before passing it to us.
<a name="1431"><span class="lineNum">    1431 </span>            :  */</a>
<span class="lineNum">    1432 </span>            : static List *
<span class="lineNum">    1433 </span><span class="lineCov">         20 : adjust_partition_tlist(List *tlist, TupleConversionMap *map)</span>
<span class="lineNum">    1434 </span>            : {
<span class="lineNum">    1435 </span><span class="lineCov">         20 :     List       *new_tlist = NIL;</span>
<span class="lineNum">    1436 </span><span class="lineCov">         20 :     TupleDesc   tupdesc = map-&gt;outdesc;</span>
<span class="lineNum">    1437 </span><span class="lineCov">         20 :     AttrNumber *attrMap = map-&gt;attrMap;</span>
<span class="lineNum">    1438 </span>            :     AttrNumber  attrno;
<span class="lineNum">    1439 </span>            : 
<span class="lineNum">    1440 </span><span class="lineCov">         68 :     for (attrno = 1; attrno &lt;= tupdesc-&gt;natts; attrno++)</span>
<span class="lineNum">    1441 </span>            :     {
<span class="lineNum">    1442 </span><span class="lineCov">         48 :         Form_pg_attribute att_tup = TupleDescAttr(tupdesc, attrno - 1);</span>
<span class="lineNum">    1443 </span>            :         TargetEntry *tle;
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span><span class="lineCov">         48 :         if (attrMap[attrno - 1] != InvalidAttrNumber)</span>
<span class="lineNum">    1446 </span>            :         {
<span class="lineNum">    1447 </span><span class="lineCov">         44 :             Assert(!att_tup-&gt;attisdropped);</span>
<span class="lineNum">    1448 </span>            : 
<span class="lineNum">    1449 </span>            :             /*
<span class="lineNum">    1450 </span>            :              * Use the corresponding entry from the parent's tlist, adjusting
<span class="lineNum">    1451 </span>            :              * the resno the match the partition's attno.
<span class="lineNum">    1452 </span>            :              */
<span class="lineNum">    1453 </span><span class="lineCov">         44 :             tle = (TargetEntry *) list_nth(tlist, attrMap[attrno - 1] - 1);</span>
<span class="lineNum">    1454 </span><span class="lineCov">         44 :             tle-&gt;resno = attrno;</span>
<span class="lineNum">    1455 </span>            :         }
<span class="lineNum">    1456 </span>            :         else
<span class="lineNum">    1457 </span>            :         {
<span class="lineNum">    1458 </span>            :             Const      *expr;
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span>            :             /*
<span class="lineNum">    1461 </span>            :              * For a dropped attribute in the partition, generate a dummy
<span class="lineNum">    1462 </span>            :              * entry with resno matching the partition's attno.
<span class="lineNum">    1463 </span>            :              */
<span class="lineNum">    1464 </span><span class="lineCov">          4 :             Assert(att_tup-&gt;attisdropped);</span>
<span class="lineNum">    1465 </span><span class="lineCov">          4 :             expr = makeConst(INT4OID,</span>
<span class="lineNum">    1466 </span>            :                              -1,
<span class="lineNum">    1467 </span>            :                              InvalidOid,
<span class="lineNum">    1468 </span>            :                              sizeof(int32),
<span class="lineNum">    1469 </span>            :                              (Datum) 0,
<span class="lineNum">    1470 </span>            :                              true,  /* isnull */
<span class="lineNum">    1471 </span>            :                              true /* byval */ );
<span class="lineNum">    1472 </span><span class="lineCov">          4 :             tle = makeTargetEntry((Expr *) expr,</span>
<span class="lineNum">    1473 </span>            :                                   attrno,
<span class="lineNum">    1474 </span><span class="lineCov">          4 :                                   pstrdup(NameStr(att_tup-&gt;attname)),</span>
<span class="lineNum">    1475 </span>            :                                   false);
<span class="lineNum">    1476 </span>            :         }
<span class="lineNum">    1477 </span>            : 
<span class="lineNum">    1478 </span><span class="lineCov">         48 :         new_tlist = lappend(new_tlist, tle);</span>
<span class="lineNum">    1479 </span>            :     }
<span class="lineNum">    1480 </span>            : 
<span class="lineNum">    1481 </span><span class="lineCov">         20 :     return new_tlist;</span>
<span class="lineNum">    1482 </span>            : }
<span class="lineNum">    1483 </span>            : 
<span class="lineNum">    1484 </span>            : /*-------------------------------------------------------------------------
<span class="lineNum">    1485 </span>            :  * Run-Time Partition Pruning Support.
<span class="lineNum">    1486 </span>            :  *
<span class="lineNum">    1487 </span>            :  * The following series of functions exist to support the removal of unneeded
<span class="lineNum">    1488 </span>            :  * subplans for queries against partitioned tables.  The supporting functions
<span class="lineNum">    1489 </span>            :  * here are designed to work with any plan type which supports an arbitrary
<span class="lineNum">    1490 </span>            :  * number of subplans, e.g. Append, MergeAppend.
<span class="lineNum">    1491 </span>            :  *
<span class="lineNum">    1492 </span>            :  * When pruning involves comparison of a partition key to a constant, it's
<span class="lineNum">    1493 </span>            :  * done by the planner.  However, if we have a comparison to a non-constant
<span class="lineNum">    1494 </span>            :  * but not volatile expression, that presents an opportunity for run-time
<span class="lineNum">    1495 </span>            :  * pruning by the executor, allowing irrelevant partitions to be skipped
<span class="lineNum">    1496 </span>            :  * dynamically.
<span class="lineNum">    1497 </span>            :  *
<span class="lineNum">    1498 </span>            :  * We must distinguish expressions containing PARAM_EXEC Params from
<span class="lineNum">    1499 </span>            :  * expressions that don't contain those.  Even though a PARAM_EXEC Param is
<span class="lineNum">    1500 </span>            :  * considered to be a stable expression, it can change value from one plan
<span class="lineNum">    1501 </span>            :  * node scan to the next during query execution.  Stable comparison
<span class="lineNum">    1502 </span>            :  * expressions that don't involve such Params allow partition pruning to be
<span class="lineNum">    1503 </span>            :  * done once during executor startup.  Expressions that do involve such Params
<span class="lineNum">    1504 </span>            :  * require us to prune separately for each scan of the parent plan node.
<span class="lineNum">    1505 </span>            :  *
<span class="lineNum">    1506 </span>            :  * Note that pruning away unneeded subplans during executor startup has the
<span class="lineNum">    1507 </span>            :  * added benefit of not having to initialize the unneeded subplans at all.
<span class="lineNum">    1508 </span>            :  *
<span class="lineNum">    1509 </span>            :  *
<span class="lineNum">    1510 </span>            :  * Functions:
<span class="lineNum">    1511 </span>            :  *
<span class="lineNum">    1512 </span>            :  * ExecCreatePartitionPruneState:
<span class="lineNum">    1513 </span>            :  *      Creates the PartitionPruneState required by each of the two pruning
<span class="lineNum">    1514 </span>            :  *      functions.  Details stored include how to map the partition index
<span class="lineNum">    1515 </span>            :  *      returned by the partition pruning code into subplan indexes.
<span class="lineNum">    1516 </span>            :  *
<span class="lineNum">    1517 </span>            :  * ExecFindInitialMatchingSubPlans:
<span class="lineNum">    1518 </span>            :  *      Returns indexes of matching subplans.  Partition pruning is attempted
<span class="lineNum">    1519 </span>            :  *      without any evaluation of expressions containing PARAM_EXEC Params.
<span class="lineNum">    1520 </span>            :  *      This function must be called during executor startup for the parent
<span class="lineNum">    1521 </span>            :  *      plan before the subplans themselves are initialized.  Subplans which
<span class="lineNum">    1522 </span>            :  *      are found not to match by this function must be removed from the
<span class="lineNum">    1523 </span>            :  *      plan's list of subplans during execution, as this function performs a
<span class="lineNum">    1524 </span>            :  *      remap of the partition index to subplan index map and the newly
<span class="lineNum">    1525 </span>            :  *      created map provides indexes only for subplans which remain after
<span class="lineNum">    1526 </span>            :  *      calling this function.
<span class="lineNum">    1527 </span>            :  *
<span class="lineNum">    1528 </span>            :  * ExecFindMatchingSubPlans:
<span class="lineNum">    1529 </span>            :  *      Returns indexes of matching subplans after evaluating all available
<span class="lineNum">    1530 </span>            :  *      expressions.  This function can only be called during execution and
<span class="lineNum">    1531 </span>            :  *      must be called again each time the value of a Param listed in
<span class="lineNum">    1532 </span>            :  *      PartitionPruneState's 'execparamids' changes.
<span class="lineNum">    1533 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">    1534 </span>            :  */
<span class="lineNum">    1535 </span>            : 
<span class="lineNum">    1536 </span>            : /*
<span class="lineNum">    1537 </span>            :  * ExecCreatePartitionPruneState
<span class="lineNum">    1538 </span>            :  *      Build the data structure required for calling
<span class="lineNum">    1539 </span>            :  *      ExecFindInitialMatchingSubPlans and ExecFindMatchingSubPlans.
<span class="lineNum">    1540 </span>            :  *
<span class="lineNum">    1541 </span>            :  * 'planstate' is the parent plan node's execution state.
<span class="lineNum">    1542 </span>            :  *
<span class="lineNum">    1543 </span>            :  * 'partitionpruneinfo' is a PartitionPruneInfo as generated by
<span class="lineNum">    1544 </span>            :  * make_partition_pruneinfo.  Here we build a PartitionPruneState containing a
<span class="lineNum">    1545 </span>            :  * PartitionPruningData for each partitioning hierarchy (i.e., each sublist of
<span class="lineNum">    1546 </span>            :  * partitionpruneinfo-&gt;prune_infos), each of which contains a
<span class="lineNum">    1547 </span>            :  * PartitionedRelPruningData for each PartitionedRelPruneInfo appearing in
<span class="lineNum">    1548 </span>            :  * that sublist.  This two-level system is needed to keep from confusing the
<span class="lineNum">    1549 </span>            :  * different hierarchies when a UNION ALL contains multiple partitioned tables
<span class="lineNum">    1550 </span>            :  * as children.  The data stored in each PartitionedRelPruningData can be
<span class="lineNum">    1551 </span>            :  * re-used each time we re-evaluate which partitions match the pruning steps
<span class="lineNum">    1552 </span>            :  * provided in each PartitionedRelPruneInfo.
<a name="1553"><span class="lineNum">    1553 </span>            :  */</a>
<span class="lineNum">    1554 </span>            : PartitionPruneState *
<span class="lineNum">    1555 </span><span class="lineCov">        174 : ExecCreatePartitionPruneState(PlanState *planstate,</span>
<span class="lineNum">    1556 </span>            :                               PartitionPruneInfo *partitionpruneinfo)
<span class="lineNum">    1557 </span>            : {
<span class="lineNum">    1558 </span><span class="lineCov">        174 :     EState     *estate = planstate-&gt;state;</span>
<span class="lineNum">    1559 </span>            :     PartitionPruneState *prunestate;
<span class="lineNum">    1560 </span>            :     int         n_part_hierarchies;
<span class="lineNum">    1561 </span>            :     ListCell   *lc;
<span class="lineNum">    1562 </span>            :     int         i;
<span class="lineNum">    1563 </span>            : 
<span class="lineNum">    1564 </span><span class="lineCov">        174 :     if (estate-&gt;es_partition_directory == NULL)</span>
<span class="lineNum">    1565 </span><span class="lineCov">        166 :         estate-&gt;es_partition_directory =</span>
<span class="lineNum">    1566 </span><span class="lineCov">        166 :             CreatePartitionDirectory(estate-&gt;es_query_cxt);</span>
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span><span class="lineCov">        174 :     n_part_hierarchies = list_length(partitionpruneinfo-&gt;prune_infos);</span>
<span class="lineNum">    1569 </span><span class="lineCov">        174 :     Assert(n_part_hierarchies &gt; 0);</span>
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span>            :     /*
<span class="lineNum">    1572 </span>            :      * Allocate the data structure
<span class="lineNum">    1573 </span>            :      */
<span class="lineNum">    1574 </span><span class="lineCov">        174 :     prunestate = (PartitionPruneState *)</span>
<span class="lineNum">    1575 </span><span class="lineCov">        174 :         palloc(offsetof(PartitionPruneState, partprunedata) +</span>
<span class="lineNum">    1576 </span>            :                sizeof(PartitionPruningData *) * n_part_hierarchies);
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span><span class="lineCov">        174 :     prunestate-&gt;execparamids = NULL;</span>
<span class="lineNum">    1579 </span>            :     /* other_subplans can change at runtime, so we need our own copy */
<span class="lineNum">    1580 </span><span class="lineCov">        174 :     prunestate-&gt;other_subplans = bms_copy(partitionpruneinfo-&gt;other_subplans);</span>
<span class="lineNum">    1581 </span><span class="lineCov">        174 :     prunestate-&gt;do_initial_prune = false;    /* may be set below */</span>
<span class="lineNum">    1582 </span><span class="lineCov">        174 :     prunestate-&gt;do_exec_prune = false;   /* may be set below */</span>
<span class="lineNum">    1583 </span><span class="lineCov">        174 :     prunestate-&gt;num_partprunedata = n_part_hierarchies;</span>
<span class="lineNum">    1584 </span>            : 
<span class="lineNum">    1585 </span>            :     /*
<span class="lineNum">    1586 </span>            :      * Create a short-term memory context which we'll use when making calls to
<span class="lineNum">    1587 </span>            :      * the partition pruning functions.  This avoids possible memory leaks,
<span class="lineNum">    1588 </span>            :      * since the pruning functions call comparison functions that aren't under
<span class="lineNum">    1589 </span>            :      * our control.
<span class="lineNum">    1590 </span>            :      */
<span class="lineNum">    1591 </span><span class="lineCov">        174 :     prunestate-&gt;prune_context =</span>
<span class="lineNum">    1592 </span><span class="lineCov">        174 :         AllocSetContextCreate(CurrentMemoryContext,</span>
<span class="lineNum">    1593 </span>            :                               &quot;Partition Prune&quot;,
<span class="lineNum">    1594 </span>            :                               ALLOCSET_DEFAULT_SIZES);
<span class="lineNum">    1595 </span>            : 
<span class="lineNum">    1596 </span><span class="lineCov">        174 :     i = 0;</span>
<span class="lineNum">    1597 </span><span class="lineCov">        356 :     foreach(lc, partitionpruneinfo-&gt;prune_infos)</span>
<span class="lineNum">    1598 </span>            :     {
<span class="lineNum">    1599 </span><span class="lineCov">        182 :         List       *partrelpruneinfos = lfirst_node(List, lc);</span>
<span class="lineNum">    1600 </span><span class="lineCov">        182 :         int         npartrelpruneinfos = list_length(partrelpruneinfos);</span>
<span class="lineNum">    1601 </span>            :         PartitionPruningData *prunedata;
<span class="lineNum">    1602 </span>            :         ListCell   *lc2;
<span class="lineNum">    1603 </span>            :         int         j;
<span class="lineNum">    1604 </span>            : 
<span class="lineNum">    1605 </span><span class="lineCov">        182 :         prunedata = (PartitionPruningData *)</span>
<span class="lineNum">    1606 </span><span class="lineCov">        182 :             palloc(offsetof(PartitionPruningData, partrelprunedata) +</span>
<span class="lineNum">    1607 </span><span class="lineCov">        182 :                    npartrelpruneinfos * sizeof(PartitionedRelPruningData));</span>
<span class="lineNum">    1608 </span><span class="lineCov">        182 :         prunestate-&gt;partprunedata[i] = prunedata;</span>
<span class="lineNum">    1609 </span><span class="lineCov">        182 :         prunedata-&gt;num_partrelprunedata = npartrelpruneinfos;</span>
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span><span class="lineCov">        182 :         j = 0;</span>
<span class="lineNum">    1612 </span><span class="lineCov">        632 :         foreach(lc2, partrelpruneinfos)</span>
<span class="lineNum">    1613 </span>            :         {
<span class="lineNum">    1614 </span><span class="lineCov">        450 :             PartitionedRelPruneInfo *pinfo = lfirst_node(PartitionedRelPruneInfo, lc2);</span>
<span class="lineNum">    1615 </span><span class="lineCov">        450 :             PartitionedRelPruningData *pprune = &amp;prunedata-&gt;partrelprunedata[j];</span>
<span class="lineNum">    1616 </span>            :             Relation    partrel;
<span class="lineNum">    1617 </span>            :             PartitionDesc partdesc;
<span class="lineNum">    1618 </span>            :             PartitionKey partkey;
<span class="lineNum">    1619 </span>            : 
<span class="lineNum">    1620 </span>            :             /*
<span class="lineNum">    1621 </span>            :              * We can rely on the copies of the partitioned table's partition
<span class="lineNum">    1622 </span>            :              * key and partition descriptor appearing in its relcache entry,
<span class="lineNum">    1623 </span>            :              * because that entry will be held open and locked for the
<span class="lineNum">    1624 </span>            :              * duration of this executor run.
<span class="lineNum">    1625 </span>            :              */
<span class="lineNum">    1626 </span><span class="lineCov">        450 :             partrel = ExecGetRangeTableRelation(estate, pinfo-&gt;rtindex);</span>
<span class="lineNum">    1627 </span><span class="lineCov">        450 :             partkey = RelationGetPartitionKey(partrel);</span>
<span class="lineNum">    1628 </span><span class="lineCov">        450 :             partdesc = PartitionDirectoryLookup(estate-&gt;es_partition_directory,</span>
<span class="lineNum">    1629 </span>            :                                                 partrel);
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span>            :             /*
<span class="lineNum">    1632 </span>            :              * Initialize the subplan_map and subpart_map.  Since detaching a
<span class="lineNum">    1633 </span>            :              * partition requires AccessExclusiveLock, no partitions can have
<span class="lineNum">    1634 </span>            :              * disappeared, nor can the bounds for any partition have changed.
<span class="lineNum">    1635 </span>            :              * However, new partitions may have been added.
<span class="lineNum">    1636 </span>            :              */
<span class="lineNum">    1637 </span><span class="lineCov">        450 :             Assert(partdesc-&gt;nparts &gt;= pinfo-&gt;nparts);</span>
<span class="lineNum">    1638 </span><span class="lineCov">        450 :             pprune-&gt;nparts = partdesc-&gt;nparts;</span>
<span class="lineNum">    1639 </span><span class="lineCov">        450 :             pprune-&gt;subplan_map = palloc(sizeof(int) * partdesc-&gt;nparts);</span>
<span class="lineNum">    1640 </span><span class="lineCov">        450 :             if (partdesc-&gt;nparts == pinfo-&gt;nparts)</span>
<span class="lineNum">    1641 </span>            :             {
<span class="lineNum">    1642 </span>            :                 /*
<span class="lineNum">    1643 </span>            :                  * There are no new partitions, so this is simple.  We can
<span class="lineNum">    1644 </span>            :                  * simply point to the subpart_map from the plan, but we must
<span class="lineNum">    1645 </span>            :                  * copy the subplan_map since we may change it later.
<span class="lineNum">    1646 </span>            :                  */
<span class="lineNum">    1647 </span><span class="lineCov">        450 :                 pprune-&gt;subpart_map = pinfo-&gt;subpart_map;</span>
<span class="lineNum">    1648 </span><span class="lineCov">        450 :                 memcpy(pprune-&gt;subplan_map, pinfo-&gt;subplan_map,</span>
<span class="lineNum">    1649 </span><span class="lineCov">        450 :                        sizeof(int) * pinfo-&gt;nparts);</span>
<span class="lineNum">    1650 </span>            : 
<span class="lineNum">    1651 </span>            :                 /*
<span class="lineNum">    1652 </span>            :                  * Double-check that the list of unpruned relations has not
<span class="lineNum">    1653 </span>            :                  * changed.  (Pruned partitions are not in relid_map[].)
<span class="lineNum">    1654 </span>            :                  */
<span class="lineNum">    1655 </span>            : #ifdef USE_ASSERT_CHECKING
<span class="lineNum">    1656 </span><span class="lineCov">       1786 :                 for (int k = 0; k &lt; pinfo-&gt;nparts; k++)</span>
<span class="lineNum">    1657 </span>            :                 {
<span class="lineNum">    1658 </span><span class="lineCov">       1336 :                     Assert(partdesc-&gt;oids[k] == pinfo-&gt;relid_map[k] ||</span>
<span class="lineNum">    1659 </span>            :                            pinfo-&gt;subplan_map[k] == -1);
<span class="lineNum">    1660 </span>            :                 }
<span class="lineNum">    1661 </span>            : #endif
<span class="lineNum">    1662 </span>            :             }
<span class="lineNum">    1663 </span>            :             else
<span class="lineNum">    1664 </span>            :             {
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :                 int         pd_idx = 0;</span>
<span class="lineNum">    1666 </span>            :                 int         pp_idx;
<span class="lineNum">    1667 </span>            : 
<span class="lineNum">    1668 </span>            :                 /*
<span class="lineNum">    1669 </span>            :                  * Some new partitions have appeared since plan time, and
<span class="lineNum">    1670 </span>            :                  * those are reflected in our PartitionDesc but were not
<span class="lineNum">    1671 </span>            :                  * present in the one used to construct subplan_map and
<span class="lineNum">    1672 </span>            :                  * subpart_map.  So we must construct new and longer arrays
<span class="lineNum">    1673 </span>            :                  * where the partitions that were originally present map to
<span class="lineNum">    1674 </span>            :                  * the same place, and any added indexes map to -1, as if the
<span class="lineNum">    1675 </span>            :                  * new partitions had been pruned.
<span class="lineNum">    1676 </span>            :                  */
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :                 pprune-&gt;subpart_map = palloc(sizeof(int) * partdesc-&gt;nparts);</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :                 for (pp_idx = 0; pp_idx &lt; partdesc-&gt;nparts; ++pp_idx)</span>
<span class="lineNum">    1679 </span>            :                 {
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :                     if (pinfo-&gt;relid_map[pd_idx] != partdesc-&gt;oids[pp_idx])</span>
<span class="lineNum">    1681 </span>            :                     {
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :                         pprune-&gt;subplan_map[pp_idx] = -1;</span>
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :                         pprune-&gt;subpart_map[pp_idx] = -1;</span>
<span class="lineNum">    1684 </span>            :                     }
<span class="lineNum">    1685 </span>            :                     else
<span class="lineNum">    1686 </span>            :                     {
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :                         pprune-&gt;subplan_map[pp_idx] =</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :                             pinfo-&gt;subplan_map[pd_idx];</span>
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :                         pprune-&gt;subpart_map[pp_idx] =</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :                             pinfo-&gt;subpart_map[pd_idx++];</span>
<span class="lineNum">    1691 </span>            :                     }
<span class="lineNum">    1692 </span>            :                 }
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :                 Assert(pd_idx == pinfo-&gt;nparts);</span>
<span class="lineNum">    1694 </span>            :             }
<span class="lineNum">    1695 </span>            : 
<span class="lineNum">    1696 </span>            :             /* present_parts is also subject to later modification */
<span class="lineNum">    1697 </span><span class="lineCov">        450 :             pprune-&gt;present_parts = bms_copy(pinfo-&gt;present_parts);</span>
<span class="lineNum">    1698 </span>            : 
<span class="lineNum">    1699 </span>            :             /*
<span class="lineNum">    1700 </span>            :              * Initialize pruning contexts as needed.
<span class="lineNum">    1701 </span>            :              */
<span class="lineNum">    1702 </span><span class="lineCov">        450 :             pprune-&gt;initial_pruning_steps = pinfo-&gt;initial_pruning_steps;</span>
<span class="lineNum">    1703 </span><span class="lineCov">        450 :             if (pinfo-&gt;initial_pruning_steps)</span>
<span class="lineNum">    1704 </span>            :             {
<span class="lineNum">    1705 </span><span class="lineCov">        116 :                 ExecInitPruningContext(&amp;pprune-&gt;initial_context,</span>
<span class="lineNum">    1706 </span>            :                                        pinfo-&gt;initial_pruning_steps,
<span class="lineNum">    1707 </span>            :                                        partdesc, partkey, planstate);
<span class="lineNum">    1708 </span>            :                 /* Record whether initial pruning is needed at any level */
<span class="lineNum">    1709 </span><span class="lineCov">        116 :                 prunestate-&gt;do_initial_prune = true;</span>
<span class="lineNum">    1710 </span>            :             }
<span class="lineNum">    1711 </span><span class="lineCov">        450 :             pprune-&gt;exec_pruning_steps = pinfo-&gt;exec_pruning_steps;</span>
<span class="lineNum">    1712 </span><span class="lineCov">        450 :             if (pinfo-&gt;exec_pruning_steps)</span>
<span class="lineNum">    1713 </span>            :             {
<span class="lineNum">    1714 </span><span class="lineCov">        146 :                 ExecInitPruningContext(&amp;pprune-&gt;exec_context,</span>
<span class="lineNum">    1715 </span>            :                                        pinfo-&gt;exec_pruning_steps,
<span class="lineNum">    1716 </span>            :                                        partdesc, partkey, planstate);
<span class="lineNum">    1717 </span>            :                 /* Record whether exec pruning is needed at any level */
<span class="lineNum">    1718 </span><span class="lineCov">        146 :                 prunestate-&gt;do_exec_prune = true;</span>
<span class="lineNum">    1719 </span>            :             }
<span class="lineNum">    1720 </span>            : 
<span class="lineNum">    1721 </span>            :             /*
<span class="lineNum">    1722 </span>            :              * Accumulate the IDs of all PARAM_EXEC Params affecting the
<span class="lineNum">    1723 </span>            :              * partitioning decisions at this plan node.
<span class="lineNum">    1724 </span>            :              */
<span class="lineNum">    1725 </span><span class="lineCov">        450 :             prunestate-&gt;execparamids = bms_add_members(prunestate-&gt;execparamids,</span>
<span class="lineNum">    1726 </span><span class="lineCov">        450 :                                                        pinfo-&gt;execparamids);</span>
<span class="lineNum">    1727 </span>            : 
<span class="lineNum">    1728 </span><span class="lineCov">        450 :             j++;</span>
<span class="lineNum">    1729 </span>            :         }
<span class="lineNum">    1730 </span><span class="lineCov">        182 :         i++;</span>
<span class="lineNum">    1731 </span>            :     }
<span class="lineNum">    1732 </span>            : 
<span class="lineNum">    1733 </span><span class="lineCov">        174 :     return prunestate;</span>
<span class="lineNum">    1734 </span>            : }
<span class="lineNum">    1735 </span>            : 
<span class="lineNum">    1736 </span>            : /*
<span class="lineNum">    1737 </span>            :  * Initialize a PartitionPruneContext for the given list of pruning steps.
<a name="1738"><span class="lineNum">    1738 </span>            :  */</a>
<span class="lineNum">    1739 </span>            : static void
<span class="lineNum">    1740 </span><span class="lineCov">        262 : ExecInitPruningContext(PartitionPruneContext *context,</span>
<span class="lineNum">    1741 </span>            :                        List *pruning_steps,
<span class="lineNum">    1742 </span>            :                        PartitionDesc partdesc,
<span class="lineNum">    1743 </span>            :                        PartitionKey partkey,
<span class="lineNum">    1744 </span>            :                        PlanState *planstate)
<span class="lineNum">    1745 </span>            : {
<span class="lineNum">    1746 </span>            :     int         n_steps;
<span class="lineNum">    1747 </span>            :     int         partnatts;
<span class="lineNum">    1748 </span>            :     ListCell   *lc;
<span class="lineNum">    1749 </span>            : 
<span class="lineNum">    1750 </span><span class="lineCov">        262 :     n_steps = list_length(pruning_steps);</span>
<span class="lineNum">    1751 </span>            : 
<span class="lineNum">    1752 </span><span class="lineCov">        262 :     context-&gt;strategy = partkey-&gt;strategy;</span>
<span class="lineNum">    1753 </span><span class="lineCov">        262 :     context-&gt;partnatts = partnatts = partkey-&gt;partnatts;</span>
<span class="lineNum">    1754 </span><span class="lineCov">        262 :     context-&gt;nparts = partdesc-&gt;nparts;</span>
<span class="lineNum">    1755 </span><span class="lineCov">        262 :     context-&gt;boundinfo = partdesc-&gt;boundinfo;</span>
<span class="lineNum">    1756 </span><span class="lineCov">        262 :     context-&gt;partcollation = partkey-&gt;partcollation;</span>
<span class="lineNum">    1757 </span><span class="lineCov">        262 :     context-&gt;partsupfunc = partkey-&gt;partsupfunc;</span>
<span class="lineNum">    1758 </span>            : 
<span class="lineNum">    1759 </span>            :     /* We'll look up type-specific support functions as needed */
<span class="lineNum">    1760 </span><span class="lineCov">        262 :     context-&gt;stepcmpfuncs = (FmgrInfo *)</span>
<span class="lineNum">    1761 </span><span class="lineCov">        262 :         palloc0(sizeof(FmgrInfo) * n_steps * partnatts);</span>
<span class="lineNum">    1762 </span>            : 
<span class="lineNum">    1763 </span><span class="lineCov">        262 :     context-&gt;ppccontext = CurrentMemoryContext;</span>
<span class="lineNum">    1764 </span><span class="lineCov">        262 :     context-&gt;planstate = planstate;</span>
<span class="lineNum">    1765 </span>            : 
<span class="lineNum">    1766 </span>            :     /* Initialize expression state for each expression we need */
<span class="lineNum">    1767 </span><span class="lineCov">        262 :     context-&gt;exprstates = (ExprState **)</span>
<span class="lineNum">    1768 </span><span class="lineCov">        262 :         palloc0(sizeof(ExprState *) * n_steps * partnatts);</span>
<span class="lineNum">    1769 </span><span class="lineCov">        742 :     foreach(lc, pruning_steps)</span>
<span class="lineNum">    1770 </span>            :     {
<span class="lineNum">    1771 </span><span class="lineCov">        480 :         PartitionPruneStepOp *step = (PartitionPruneStepOp *) lfirst(lc);</span>
<span class="lineNum">    1772 </span>            :         ListCell   *lc2;
<span class="lineNum">    1773 </span>            :         int         keyno;
<span class="lineNum">    1774 </span>            : 
<span class="lineNum">    1775 </span>            :         /* not needed for other step kinds */
<span class="lineNum">    1776 </span><span class="lineCov">        480 :         if (!IsA(step, PartitionPruneStepOp))</span>
<span class="lineNum">    1777 </span><span class="lineCov">         98 :             continue;</span>
<span class="lineNum">    1778 </span>            : 
<span class="lineNum">    1779 </span><span class="lineCov">        382 :         Assert(list_length(step-&gt;exprs) &lt;= partnatts);</span>
<span class="lineNum">    1780 </span>            : 
<span class="lineNum">    1781 </span><span class="lineCov">        382 :         keyno = 0;</span>
<span class="lineNum">    1782 </span><span class="lineCov">        780 :         foreach(lc2, step-&gt;exprs)</span>
<span class="lineNum">    1783 </span>            :         {
<span class="lineNum">    1784 </span><span class="lineCov">        398 :             Expr       *expr = (Expr *) lfirst(lc2);</span>
<span class="lineNum">    1785 </span>            : 
<span class="lineNum">    1786 </span>            :             /* not needed for Consts */
<span class="lineNum">    1787 </span><span class="lineCov">        398 :             if (!IsA(expr, Const))</span>
<span class="lineNum">    1788 </span>            :             {
<span class="lineNum">    1789 </span><span class="lineCov">        370 :                 int         stateidx = PruneCxtStateIdx(partnatts,</span>
<span class="lineNum">    1790 </span>            :                                                         step-&gt;step.step_id,
<span class="lineNum">    1791 </span>            :                                                         keyno);
<span class="lineNum">    1792 </span>            : 
<span class="lineNum">    1793 </span><span class="lineCov">        740 :                 context-&gt;exprstates[stateidx] =</span>
<span class="lineNum">    1794 </span><span class="lineCov">        370 :                     ExecInitExpr(expr, context-&gt;planstate);</span>
<span class="lineNum">    1795 </span>            :             }
<span class="lineNum">    1796 </span><span class="lineCov">        398 :             keyno++;</span>
<span class="lineNum">    1797 </span>            :         }
<span class="lineNum">    1798 </span>            :     }
<span class="lineNum">    1799 </span><span class="lineCov">        262 : }</span>
<span class="lineNum">    1800 </span>            : 
<span class="lineNum">    1801 </span>            : /*
<span class="lineNum">    1802 </span>            :  * ExecFindInitialMatchingSubPlans
<span class="lineNum">    1803 </span>            :  *      Identify the set of subplans that cannot be eliminated by initial
<span class="lineNum">    1804 </span>            :  *      pruning, disregarding any pruning constraints involving PARAM_EXEC
<span class="lineNum">    1805 </span>            :  *      Params.
<span class="lineNum">    1806 </span>            :  *
<span class="lineNum">    1807 </span>            :  * If additional pruning passes will be required (because of PARAM_EXEC
<span class="lineNum">    1808 </span>            :  * Params), we must also update the translation data that allows conversion
<span class="lineNum">    1809 </span>            :  * of partition indexes into subplan indexes to account for the unneeded
<span class="lineNum">    1810 </span>            :  * subplans having been removed.
<span class="lineNum">    1811 </span>            :  *
<span class="lineNum">    1812 </span>            :  * Must only be called once per 'prunestate', and only if initial pruning
<span class="lineNum">    1813 </span>            :  * is required.
<span class="lineNum">    1814 </span>            :  *
<span class="lineNum">    1815 </span>            :  * 'nsubplans' must be passed as the total number of unpruned subplans.
<a name="1816"><span class="lineNum">    1816 </span>            :  */</a>
<span class="lineNum">    1817 </span>            : Bitmapset *
<span class="lineNum">    1818 </span><span class="lineCov">         82 : ExecFindInitialMatchingSubPlans(PartitionPruneState *prunestate, int nsubplans)</span>
<span class="lineNum">    1819 </span>            : {
<span class="lineNum">    1820 </span><span class="lineCov">         82 :     Bitmapset  *result = NULL;</span>
<span class="lineNum">    1821 </span>            :     MemoryContext oldcontext;
<span class="lineNum">    1822 </span>            :     int         i;
<span class="lineNum">    1823 </span>            : 
<span class="lineNum">    1824 </span>            :     /* Caller error if we get here without do_initial_prune */
<span class="lineNum">    1825 </span><span class="lineCov">         82 :     Assert(prunestate-&gt;do_initial_prune);</span>
<span class="lineNum">    1826 </span>            : 
<span class="lineNum">    1827 </span>            :     /*
<span class="lineNum">    1828 </span>            :      * Switch to a temp context to avoid leaking memory in the executor's
<span class="lineNum">    1829 </span>            :      * query-lifespan memory context.
<span class="lineNum">    1830 </span>            :      */
<span class="lineNum">    1831 </span><span class="lineCov">         82 :     oldcontext = MemoryContextSwitchTo(prunestate-&gt;prune_context);</span>
<span class="lineNum">    1832 </span>            : 
<span class="lineNum">    1833 </span>            :     /*
<span class="lineNum">    1834 </span>            :      * For each hierarchy, do the pruning tests, and add nondeletable
<span class="lineNum">    1835 </span>            :      * subplans' indexes to &quot;result&quot;.
<span class="lineNum">    1836 </span>            :      */
<span class="lineNum">    1837 </span><span class="lineCov">        172 :     for (i = 0; i &lt; prunestate-&gt;num_partprunedata; i++)</span>
<span class="lineNum">    1838 </span>            :     {
<span class="lineNum">    1839 </span>            :         PartitionPruningData *prunedata;
<span class="lineNum">    1840 </span>            :         PartitionedRelPruningData *pprune;
<span class="lineNum">    1841 </span>            : 
<span class="lineNum">    1842 </span><span class="lineCov">         90 :         prunedata = prunestate-&gt;partprunedata[i];</span>
<span class="lineNum">    1843 </span><span class="lineCov">         90 :         pprune = &amp;prunedata-&gt;partrelprunedata[0];</span>
<span class="lineNum">    1844 </span>            : 
<span class="lineNum">    1845 </span>            :         /* Perform pruning without using PARAM_EXEC Params */
<span class="lineNum">    1846 </span><span class="lineCov">         90 :         find_matching_subplans_recurse(prunedata, pprune, true, &amp;result);</span>
<span class="lineNum">    1847 </span>            : 
<span class="lineNum">    1848 </span>            :         /* Expression eval may have used space in node's ps_ExprContext too */
<span class="lineNum">    1849 </span><span class="lineCov">         90 :         if (pprune-&gt;initial_pruning_steps)</span>
<span class="lineNum">    1850 </span><span class="lineCov">         78 :             ResetExprContext(pprune-&gt;initial_context.planstate-&gt;ps_ExprContext);</span>
<span class="lineNum">    1851 </span>            :     }
<span class="lineNum">    1852 </span>            : 
<span class="lineNum">    1853 </span>            :     /* Add in any subplans that partition pruning didn't account for */
<span class="lineNum">    1854 </span><span class="lineCov">         82 :     result = bms_add_members(result, prunestate-&gt;other_subplans);</span>
<span class="lineNum">    1855 </span>            : 
<span class="lineNum">    1856 </span><span class="lineCov">         82 :     MemoryContextSwitchTo(oldcontext);</span>
<span class="lineNum">    1857 </span>            : 
<span class="lineNum">    1858 </span>            :     /* Copy result out of the temp context before we reset it */
<span class="lineNum">    1859 </span><span class="lineCov">         82 :     result = bms_copy(result);</span>
<span class="lineNum">    1860 </span>            : 
<span class="lineNum">    1861 </span><span class="lineCov">         82 :     MemoryContextReset(prunestate-&gt;prune_context);</span>
<span class="lineNum">    1862 </span>            : 
<span class="lineNum">    1863 </span>            :     /*
<span class="lineNum">    1864 </span>            :      * If exec-time pruning is required and we pruned subplans above, then we
<span class="lineNum">    1865 </span>            :      * must re-sequence the subplan indexes so that ExecFindMatchingSubPlans
<span class="lineNum">    1866 </span>            :      * properly returns the indexes from the subplans which will remain after
<span class="lineNum">    1867 </span>            :      * execution of this function.
<span class="lineNum">    1868 </span>            :      *
<span class="lineNum">    1869 </span>            :      * We can safely skip this when !do_exec_prune, even though that leaves
<span class="lineNum">    1870 </span>            :      * invalid data in prunestate, because that data won't be consulted again
<span class="lineNum">    1871 </span>            :      * (cf initial Assert in ExecFindMatchingSubPlans).
<span class="lineNum">    1872 </span>            :      */
<span class="lineNum">    1873 </span><span class="lineCov">         82 :     if (prunestate-&gt;do_exec_prune &amp;&amp; bms_num_members(result) &lt; nsubplans)</span>
<span class="lineNum">    1874 </span>            :     {
<span class="lineNum">    1875 </span>            :         int        *new_subplan_indexes;
<span class="lineNum">    1876 </span>            :         Bitmapset  *new_other_subplans;
<span class="lineNum">    1877 </span>            :         int         i;
<span class="lineNum">    1878 </span>            :         int         newidx;
<span class="lineNum">    1879 </span>            : 
<span class="lineNum">    1880 </span>            :         /*
<span class="lineNum">    1881 </span>            :          * First we must build a temporary array which maps old subplan
<span class="lineNum">    1882 </span>            :          * indexes to new ones.  For convenience of initialization, we use
<span class="lineNum">    1883 </span>            :          * 1-based indexes in this array and leave pruned items as 0.
<span class="lineNum">    1884 </span>            :          */
<span class="lineNum">    1885 </span><span class="lineCov">         16 :         new_subplan_indexes = (int *) palloc0(sizeof(int) * nsubplans);</span>
<span class="lineNum">    1886 </span><span class="lineCov">         16 :         newidx = 1;</span>
<span class="lineNum">    1887 </span><span class="lineCov">         16 :         i = -1;</span>
<span class="lineNum">    1888 </span><span class="lineCov">         78 :         while ((i = bms_next_member(result, i)) &gt;= 0)</span>
<span class="lineNum">    1889 </span>            :         {
<span class="lineNum">    1890 </span><span class="lineCov">         46 :             Assert(i &lt; nsubplans);</span>
<span class="lineNum">    1891 </span><span class="lineCov">         46 :             new_subplan_indexes[i] = newidx++;</span>
<span class="lineNum">    1892 </span>            :         }
<span class="lineNum">    1893 </span>            : 
<span class="lineNum">    1894 </span>            :         /*
<span class="lineNum">    1895 </span>            :          * Now we can update each PartitionedRelPruneInfo's subplan_map with
<span class="lineNum">    1896 </span>            :          * new subplan indexes.  We must also recompute its present_parts
<span class="lineNum">    1897 </span>            :          * bitmap.
<span class="lineNum">    1898 </span>            :          */
<span class="lineNum">    1899 </span><span class="lineCov">         40 :         for (i = 0; i &lt; prunestate-&gt;num_partprunedata; i++)</span>
<span class="lineNum">    1900 </span>            :         {
<span class="lineNum">    1901 </span><span class="lineCov">         24 :             PartitionPruningData *prunedata = prunestate-&gt;partprunedata[i];</span>
<span class="lineNum">    1902 </span>            :             int         j;
<span class="lineNum">    1903 </span>            : 
<span class="lineNum">    1904 </span>            :             /*
<span class="lineNum">    1905 </span>            :              * Within each hierarchy, we perform this loop in back-to-front
<span class="lineNum">    1906 </span>            :              * order so that we determine present_parts for the lowest-level
<span class="lineNum">    1907 </span>            :              * partitioned tables first.  This way we can tell whether a
<span class="lineNum">    1908 </span>            :              * sub-partitioned table's partitions were entirely pruned so we
<span class="lineNum">    1909 </span>            :              * can exclude it from the current level's present_parts.
<span class="lineNum">    1910 </span>            :              */
<span class="lineNum">    1911 </span><span class="lineCov">         88 :             for (j = prunedata-&gt;num_partrelprunedata - 1; j &gt;= 0; j--)</span>
<span class="lineNum">    1912 </span>            :             {
<span class="lineNum">    1913 </span><span class="lineCov">         64 :                 PartitionedRelPruningData *pprune = &amp;prunedata-&gt;partrelprunedata[j];</span>
<span class="lineNum">    1914 </span><span class="lineCov">         64 :                 int         nparts = pprune-&gt;nparts;</span>
<span class="lineNum">    1915 </span>            :                 int         k;
<span class="lineNum">    1916 </span>            : 
<span class="lineNum">    1917 </span>            :                 /* We just rebuild present_parts from scratch */
<span class="lineNum">    1918 </span><span class="lineCov">         64 :                 bms_free(pprune-&gt;present_parts);</span>
<span class="lineNum">    1919 </span><span class="lineCov">         64 :                 pprune-&gt;present_parts = NULL;</span>
<span class="lineNum">    1920 </span>            : 
<span class="lineNum">    1921 </span><span class="lineCov">        236 :                 for (k = 0; k &lt; nparts; k++)</span>
<span class="lineNum">    1922 </span>            :                 {
<span class="lineNum">    1923 </span><span class="lineCov">        172 :                     int         oldidx = pprune-&gt;subplan_map[k];</span>
<span class="lineNum">    1924 </span>            :                     int         subidx;
<span class="lineNum">    1925 </span>            : 
<span class="lineNum">    1926 </span>            :                     /*
<span class="lineNum">    1927 </span>            :                      * If this partition existed as a subplan then change the
<span class="lineNum">    1928 </span>            :                      * old subplan index to the new subplan index.  The new
<span class="lineNum">    1929 </span>            :                      * index may become -1 if the partition was pruned above,
<span class="lineNum">    1930 </span>            :                      * or it may just come earlier in the subplan list due to
<span class="lineNum">    1931 </span>            :                      * some subplans being removed earlier in the list.  If
<span class="lineNum">    1932 </span>            :                      * it's a subpartition, add it to present_parts unless
<span class="lineNum">    1933 </span>            :                      * it's entirely pruned.
<span class="lineNum">    1934 </span>            :                      */
<span class="lineNum">    1935 </span><span class="lineCov">        172 :                     if (oldidx &gt;= 0)</span>
<span class="lineNum">    1936 </span>            :                     {
<span class="lineNum">    1937 </span><span class="lineCov">        132 :                         Assert(oldidx &lt; nsubplans);</span>
<span class="lineNum">    1938 </span><span class="lineCov">        132 :                         pprune-&gt;subplan_map[k] = new_subplan_indexes[oldidx] - 1;</span>
<span class="lineNum">    1939 </span>            : 
<span class="lineNum">    1940 </span><span class="lineCov">        132 :                         if (new_subplan_indexes[oldidx] &gt; 0)</span>
<span class="lineNum">    1941 </span><span class="lineCov">         38 :                             pprune-&gt;present_parts =</span>
<span class="lineNum">    1942 </span><span class="lineCov">         38 :                                 bms_add_member(pprune-&gt;present_parts, k);</span>
<span class="lineNum">    1943 </span>            :                     }
<span class="lineNum">    1944 </span><span class="lineCov">         40 :                     else if ((subidx = pprune-&gt;subpart_map[k]) &gt;= 0)</span>
<span class="lineNum">    1945 </span>            :                     {
<span class="lineNum">    1946 </span>            :                         PartitionedRelPruningData *subprune;
<span class="lineNum">    1947 </span>            : 
<span class="lineNum">    1948 </span><span class="lineCov">         40 :                         subprune = &amp;prunedata-&gt;partrelprunedata[subidx];</span>
<span class="lineNum">    1949 </span>            : 
<span class="lineNum">    1950 </span><span class="lineCov">         40 :                         if (!bms_is_empty(subprune-&gt;present_parts))</span>
<span class="lineNum">    1951 </span><span class="lineCov">         16 :                             pprune-&gt;present_parts =</span>
<span class="lineNum">    1952 </span><span class="lineCov">         16 :                                 bms_add_member(pprune-&gt;present_parts, k);</span>
<span class="lineNum">    1953 </span>            :                     }
<span class="lineNum">    1954 </span>            :                 }
<span class="lineNum">    1955 </span>            :             }
<span class="lineNum">    1956 </span>            :         }
<span class="lineNum">    1957 </span>            : 
<span class="lineNum">    1958 </span>            :         /*
<span class="lineNum">    1959 </span>            :          * We must also recompute the other_subplans set, since indexes in it
<span class="lineNum">    1960 </span>            :          * may change.
<span class="lineNum">    1961 </span>            :          */
<span class="lineNum">    1962 </span><span class="lineCov">         16 :         new_other_subplans = NULL;</span>
<span class="lineNum">    1963 </span><span class="lineCov">         16 :         i = -1;</span>
<span class="lineNum">    1964 </span><span class="lineCov">         40 :         while ((i = bms_next_member(prunestate-&gt;other_subplans, i)) &gt;= 0)</span>
<span class="lineNum">    1965 </span><span class="lineCov">          8 :             new_other_subplans = bms_add_member(new_other_subplans,</span>
<span class="lineNum">    1966 </span><span class="lineCov">          8 :                                                 new_subplan_indexes[i] - 1);</span>
<span class="lineNum">    1967 </span>            : 
<span class="lineNum">    1968 </span><span class="lineCov">         16 :         bms_free(prunestate-&gt;other_subplans);</span>
<span class="lineNum">    1969 </span><span class="lineCov">         16 :         prunestate-&gt;other_subplans = new_other_subplans;</span>
<span class="lineNum">    1970 </span>            : 
<span class="lineNum">    1971 </span><span class="lineCov">         16 :         pfree(new_subplan_indexes);</span>
<span class="lineNum">    1972 </span>            :     }
<span class="lineNum">    1973 </span>            : 
<span class="lineNum">    1974 </span><span class="lineCov">         82 :     return result;</span>
<span class="lineNum">    1975 </span>            : }
<span class="lineNum">    1976 </span>            : 
<span class="lineNum">    1977 </span>            : /*
<span class="lineNum">    1978 </span>            :  * ExecFindMatchingSubPlans
<span class="lineNum">    1979 </span>            :  *      Determine which subplans match the pruning steps detailed in
<span class="lineNum">    1980 </span>            :  *      'prunestate' for the current comparison expression values.
<span class="lineNum">    1981 </span>            :  *
<span class="lineNum">    1982 </span>            :  * Here we assume we may evaluate PARAM_EXEC Params.
<a name="1983"><span class="lineNum">    1983 </span>            :  */</a>
<span class="lineNum">    1984 </span>            : Bitmapset *
<span class="lineNum">    1985 </span><span class="lineCov">       1136 : ExecFindMatchingSubPlans(PartitionPruneState *prunestate)</span>
<span class="lineNum">    1986 </span>            : {
<span class="lineNum">    1987 </span><span class="lineCov">       1136 :     Bitmapset  *result = NULL;</span>
<span class="lineNum">    1988 </span>            :     MemoryContext oldcontext;
<span class="lineNum">    1989 </span>            :     int         i;
<span class="lineNum">    1990 </span>            : 
<span class="lineNum">    1991 </span>            :     /*
<span class="lineNum">    1992 </span>            :      * If !do_exec_prune, we've got problems because
<span class="lineNum">    1993 </span>            :      * ExecFindInitialMatchingSubPlans will not have bothered to update
<span class="lineNum">    1994 </span>            :      * prunestate for whatever pruning it did.
<span class="lineNum">    1995 </span>            :      */
<span class="lineNum">    1996 </span><span class="lineCov">       1136 :     Assert(prunestate-&gt;do_exec_prune);</span>
<span class="lineNum">    1997 </span>            : 
<span class="lineNum">    1998 </span>            :     /*
<span class="lineNum">    1999 </span>            :      * Switch to a temp context to avoid leaking memory in the executor's
<span class="lineNum">    2000 </span>            :      * query-lifespan memory context.
<span class="lineNum">    2001 </span>            :      */
<span class="lineNum">    2002 </span><span class="lineCov">       1136 :     oldcontext = MemoryContextSwitchTo(prunestate-&gt;prune_context);</span>
<span class="lineNum">    2003 </span>            : 
<span class="lineNum">    2004 </span>            :     /*
<span class="lineNum">    2005 </span>            :      * For each hierarchy, do the pruning tests, and add nondeletable
<span class="lineNum">    2006 </span>            :      * subplans' indexes to &quot;result&quot;.
<span class="lineNum">    2007 </span>            :      */
<span class="lineNum">    2008 </span><span class="lineCov">       2278 :     for (i = 0; i &lt; prunestate-&gt;num_partprunedata; i++)</span>
<span class="lineNum">    2009 </span>            :     {
<span class="lineNum">    2010 </span>            :         PartitionPruningData *prunedata;
<span class="lineNum">    2011 </span>            :         PartitionedRelPruningData *pprune;
<span class="lineNum">    2012 </span>            : 
<span class="lineNum">    2013 </span><span class="lineCov">       1142 :         prunedata = prunestate-&gt;partprunedata[i];</span>
<span class="lineNum">    2014 </span><span class="lineCov">       1142 :         pprune = &amp;prunedata-&gt;partrelprunedata[0];</span>
<span class="lineNum">    2015 </span>            : 
<span class="lineNum">    2016 </span><span class="lineCov">       1142 :         find_matching_subplans_recurse(prunedata, pprune, false, &amp;result);</span>
<span class="lineNum">    2017 </span>            : 
<span class="lineNum">    2018 </span>            :         /* Expression eval may have used space in node's ps_ExprContext too */
<span class="lineNum">    2019 </span><span class="lineCov">       1142 :         if (pprune-&gt;exec_pruning_steps)</span>
<span class="lineNum">    2020 </span><span class="lineCov">       1118 :             ResetExprContext(pprune-&gt;exec_context.planstate-&gt;ps_ExprContext);</span>
<span class="lineNum">    2021 </span>            :     }
<span class="lineNum">    2022 </span>            : 
<span class="lineNum">    2023 </span>            :     /* Add in any subplans that partition pruning didn't account for */
<span class="lineNum">    2024 </span><span class="lineCov">       1136 :     result = bms_add_members(result, prunestate-&gt;other_subplans);</span>
<span class="lineNum">    2025 </span>            : 
<span class="lineNum">    2026 </span><span class="lineCov">       1136 :     MemoryContextSwitchTo(oldcontext);</span>
<span class="lineNum">    2027 </span>            : 
<span class="lineNum">    2028 </span>            :     /* Copy result out of the temp context before we reset it */
<span class="lineNum">    2029 </span><span class="lineCov">       1136 :     result = bms_copy(result);</span>
<span class="lineNum">    2030 </span>            : 
<span class="lineNum">    2031 </span><span class="lineCov">       1136 :     MemoryContextReset(prunestate-&gt;prune_context);</span>
<span class="lineNum">    2032 </span>            : 
<span class="lineNum">    2033 </span><span class="lineCov">       1136 :     return result;</span>
<span class="lineNum">    2034 </span>            : }
<span class="lineNum">    2035 </span>            : 
<span class="lineNum">    2036 </span>            : /*
<span class="lineNum">    2037 </span>            :  * find_matching_subplans_recurse
<span class="lineNum">    2038 </span>            :  *      Recursive worker function for ExecFindMatchingSubPlans and
<span class="lineNum">    2039 </span>            :  *      ExecFindInitialMatchingSubPlans
<span class="lineNum">    2040 </span>            :  *
<span class="lineNum">    2041 </span>            :  * Adds valid (non-prunable) subplan IDs to *validsubplans
<a name="2042"><span class="lineNum">    2042 </span>            :  */</a>
<span class="lineNum">    2043 </span>            : static void
<span class="lineNum">    2044 </span><span class="lineCov">       1370 : find_matching_subplans_recurse(PartitionPruningData *prunedata,</span>
<span class="lineNum">    2045 </span>            :                                PartitionedRelPruningData *pprune,
<span class="lineNum">    2046 </span>            :                                bool initial_prune,
<span class="lineNum">    2047 </span>            :                                Bitmapset **validsubplans)
<span class="lineNum">    2048 </span>            : {
<span class="lineNum">    2049 </span>            :     Bitmapset  *partset;
<span class="lineNum">    2050 </span>            :     int         i;
<span class="lineNum">    2051 </span>            : 
<span class="lineNum">    2052 </span>            :     /* Guard against stack overflow due to overly deep partition hierarchy. */
<span class="lineNum">    2053 </span><span class="lineCov">       1370 :     check_stack_depth();</span>
<span class="lineNum">    2054 </span>            : 
<span class="lineNum">    2055 </span>            :     /* Only prune if pruning would be useful at this level. */
<span class="lineNum">    2056 </span><span class="lineCov">       1370 :     if (initial_prune &amp;&amp; pprune-&gt;initial_pruning_steps)</span>
<span class="lineNum">    2057 </span>            :     {
<span class="lineNum">    2058 </span><span class="lineCov">        110 :         partset = get_matching_partitions(&amp;pprune-&gt;initial_context,</span>
<span class="lineNum">    2059 </span>            :                                           pprune-&gt;initial_pruning_steps);
<span class="lineNum">    2060 </span>            :     }
<span class="lineNum">    2061 </span><span class="lineCov">       1260 :     else if (!initial_prune &amp;&amp; pprune-&gt;exec_pruning_steps)</span>
<span class="lineNum">    2062 </span>            :     {
<span class="lineNum">    2063 </span><span class="lineCov">       1146 :         partset = get_matching_partitions(&amp;pprune-&gt;exec_context,</span>
<span class="lineNum">    2064 </span>            :                                           pprune-&gt;exec_pruning_steps);
<span class="lineNum">    2065 </span>            :     }
<span class="lineNum">    2066 </span>            :     else
<span class="lineNum">    2067 </span>            :     {
<span class="lineNum">    2068 </span>            :         /*
<span class="lineNum">    2069 </span>            :          * If no pruning is to be done, just include all partitions at this
<span class="lineNum">    2070 </span>            :          * level.
<span class="lineNum">    2071 </span>            :          */
<span class="lineNum">    2072 </span><span class="lineCov">        114 :         partset = pprune-&gt;present_parts;</span>
<span class="lineNum">    2073 </span>            :     }
<span class="lineNum">    2074 </span>            : 
<span class="lineNum">    2075 </span>            :     /* Translate partset into subplan indexes */
<span class="lineNum">    2076 </span><span class="lineCov">       1370 :     i = -1;</span>
<span class="lineNum">    2077 </span><span class="lineCov">       3268 :     while ((i = bms_next_member(partset, i)) &gt;= 0)</span>
<span class="lineNum">    2078 </span>            :     {
<span class="lineNum">    2079 </span><span class="lineCov">        528 :         if (pprune-&gt;subplan_map[i] &gt;= 0)</span>
<span class="lineNum">    2080 </span><span class="lineCov">        390 :             *validsubplans = bms_add_member(*validsubplans,</span>
<span class="lineNum">    2081 </span><span class="lineCov">        390 :                                             pprune-&gt;subplan_map[i]);</span>
<span class="lineNum">    2082 </span>            :         else
<span class="lineNum">    2083 </span>            :         {
<span class="lineNum">    2084 </span><span class="lineCov">        138 :             int         partidx = pprune-&gt;subpart_map[i];</span>
<span class="lineNum">    2085 </span>            : 
<span class="lineNum">    2086 </span><span class="lineCov">        138 :             if (partidx &gt;= 0)</span>
<span class="lineNum">    2087 </span><span class="lineCov">        138 :                 find_matching_subplans_recurse(prunedata,</span>
<span class="lineNum">    2088 </span>            :                                                &amp;prunedata-&gt;partrelprunedata[partidx],
<span class="lineNum">    2089 </span>            :                                                initial_prune, validsubplans);
<span class="lineNum">    2090 </span>            :             else
<span class="lineNum">    2091 </span>            :             {
<span class="lineNum">    2092 </span>            :                 /*
<span class="lineNum">    2093 </span>            :                  * We get here if the planner already pruned all the sub-
<span class="lineNum">    2094 </span>            :                  * partitions for this partition.  Silently ignore this
<span class="lineNum">    2095 </span>            :                  * partition in this case.  The end result is the same: we
<span class="lineNum">    2096 </span>            :                  * would have pruned all partitions just the same, but we
<span class="lineNum">    2097 </span>            :                  * don't have any pruning steps to execute to verify this.
<span class="lineNum">    2098 </span>            :                  */
<span class="lineNum">    2099 </span>            :             }
<span class="lineNum">    2100 </span>            :         }
<span class="lineNum">    2101 </span>            :     }
<span class="lineNum">    2102 </span><span class="lineCov">       1370 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
