<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/executor/functions.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/backend/executor</a> - functions.c<span style="font-size: 80%;"> (source / <a href="functions.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">509</td>
            <td class="headerCovTableEntry">581</td>
            <td class="headerCovTableEntryMed">87.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">22</td>
            <td class="headerCovTableEntry">23</td>
            <td class="headerCovTableEntryHi">95.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * functions.c
<span class="lineNum">       4 </span>            :  *    Execution of SQL-language functions
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * IDENTIFICATION
<span class="lineNum">      11 </span>            :  *    src/backend/executor/functions.c
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      14 </span>            :  */
<span class="lineNum">      15 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &quot;access/htup_details.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;access/xact.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;catalog/pg_proc.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;catalog/pg_type.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;executor/functions.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;funcapi.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;miscadmin.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nodes/makefuncs.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;nodes/nodeFuncs.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;parser/parse_coerce.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;parser/parse_func.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;storage/proc.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;tcop/utility.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;utils/builtins.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;utils/datum.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;utils/lsyscache.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;utils/memutils.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;utils/snapmgr.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;utils/syscache.h&quot;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : /*
<span class="lineNum">      39 </span>            :  * Specialized DestReceiver for collecting query output in a SQL function
<span class="lineNum">      40 </span>            :  */
<span class="lineNum">      41 </span>            : typedef struct
<span class="lineNum">      42 </span>            : {
<span class="lineNum">      43 </span>            :     DestReceiver pub;           /* publicly-known function pointers */
<span class="lineNum">      44 </span>            :     Tuplestorestate *tstore;    /* where to put result tuples */
<span class="lineNum">      45 </span>            :     MemoryContext cxt;          /* context containing tstore */
<span class="lineNum">      46 </span>            :     JunkFilter *filter;         /* filter to convert tuple type */
<span class="lineNum">      47 </span>            : } DR_sqlfunction;
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : /*
<span class="lineNum">      50 </span>            :  * We have an execution_state record for each query in a function.  Each
<span class="lineNum">      51 </span>            :  * record contains a plantree for its query.  If the query is currently in
<span class="lineNum">      52 </span>            :  * F_EXEC_RUN state then there's a QueryDesc too.
<span class="lineNum">      53 </span>            :  *
<span class="lineNum">      54 </span>            :  * The &quot;next&quot; fields chain together all the execution_state records generated
<span class="lineNum">      55 </span>            :  * from a single original parsetree.  (There will only be more than one in
<span class="lineNum">      56 </span>            :  * case of rule expansion of the original parsetree.)
<span class="lineNum">      57 </span>            :  */
<span class="lineNum">      58 </span>            : typedef enum
<span class="lineNum">      59 </span>            : {
<span class="lineNum">      60 </span>            :     F_EXEC_START, F_EXEC_RUN, F_EXEC_DONE
<span class="lineNum">      61 </span>            : } ExecStatus;
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : typedef struct execution_state
<span class="lineNum">      64 </span>            : {
<span class="lineNum">      65 </span>            :     struct execution_state *next;
<span class="lineNum">      66 </span>            :     ExecStatus  status;
<span class="lineNum">      67 </span>            :     bool        setsResult;     /* true if this query produces func's result */
<span class="lineNum">      68 </span>            :     bool        lazyEval;       /* true if should fetch one row at a time */
<span class="lineNum">      69 </span>            :     PlannedStmt *stmt;          /* plan for this query */
<span class="lineNum">      70 </span>            :     QueryDesc  *qd;             /* null unless status == RUN */
<span class="lineNum">      71 </span>            : } execution_state;
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : /*
<span class="lineNum">      75 </span>            :  * An SQLFunctionCache record is built during the first call,
<span class="lineNum">      76 </span>            :  * and linked to from the fn_extra field of the FmgrInfo struct.
<span class="lineNum">      77 </span>            :  *
<span class="lineNum">      78 </span>            :  * Note that currently this has only the lifespan of the calling query.
<span class="lineNum">      79 </span>            :  * Someday we should rewrite this code to use plancache.c to save parse/plan
<span class="lineNum">      80 </span>            :  * results for longer than that.
<span class="lineNum">      81 </span>            :  *
<span class="lineNum">      82 </span>            :  * Physically, though, the data has the lifespan of the FmgrInfo that's used
<span class="lineNum">      83 </span>            :  * to call the function, and there are cases (particularly with indexes)
<span class="lineNum">      84 </span>            :  * where the FmgrInfo might survive across transactions.  We cannot assume
<span class="lineNum">      85 </span>            :  * that the parse/plan trees are good for longer than the (sub)transaction in
<span class="lineNum">      86 </span>            :  * which parsing was done, so we must mark the record with the LXID/subxid of
<span class="lineNum">      87 </span>            :  * its creation time, and regenerate everything if that's obsolete.  To avoid
<span class="lineNum">      88 </span>            :  * memory leakage when we do have to regenerate things, all the data is kept
<span class="lineNum">      89 </span>            :  * in a sub-context of the FmgrInfo's fn_mcxt.
<span class="lineNum">      90 </span>            :  */
<span class="lineNum">      91 </span>            : typedef struct
<span class="lineNum">      92 </span>            : {
<span class="lineNum">      93 </span>            :     char       *fname;          /* function name (for error msgs) */
<span class="lineNum">      94 </span>            :     char       *src;            /* function body text (for error msgs) */
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            :     SQLFunctionParseInfoPtr pinfo;  /* data for parser callback hooks */
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :     Oid         rettype;        /* actual return type */
<span class="lineNum">      99 </span>            :     int16       typlen;         /* length of the return type */
<span class="lineNum">     100 </span>            :     bool        typbyval;       /* true if return type is pass by value */
<span class="lineNum">     101 </span>            :     bool        returnsSet;     /* true if returning multiple rows */
<span class="lineNum">     102 </span>            :     bool        returnsTuple;   /* true if returning whole tuple result */
<span class="lineNum">     103 </span>            :     bool        shutdown_reg;   /* true if registered shutdown callback */
<span class="lineNum">     104 </span>            :     bool        readonly_func;  /* true to run in &quot;read only&quot; mode */
<span class="lineNum">     105 </span>            :     bool        lazyEval;       /* true if using lazyEval for result query */
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            :     ParamListInfo paramLI;      /* Param list representing current args */
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            :     Tuplestorestate *tstore;    /* where we accumulate result tuples */
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :     JunkFilter *junkFilter;     /* will be NULL if function returns VOID */
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            :     /*
<span class="lineNum">     114 </span>            :      * func_state is a List of execution_state records, each of which is the
<span class="lineNum">     115 </span>            :      * first for its original parsetree, with any additional records chained
<span class="lineNum">     116 </span>            :      * to it via the &quot;next&quot; fields.  This sublist structure is needed to keep
<span class="lineNum">     117 </span>            :      * track of where the original query boundaries are.
<span class="lineNum">     118 </span>            :      */
<span class="lineNum">     119 </span>            :     List       *func_state;
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :     MemoryContext fcontext;     /* memory context holding this struct and all
<span class="lineNum">     122 </span>            :                                  * subsidiary data */
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            :     LocalTransactionId lxid;    /* lxid in which cache was made */
<span class="lineNum">     125 </span>            :     SubTransactionId subxid;    /* subxid in which cache was made */
<span class="lineNum">     126 </span>            : } SQLFunctionCache;
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            : typedef SQLFunctionCache *SQLFunctionCachePtr;
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : /*
<span class="lineNum">     131 </span>            :  * Data structure needed by the parser callback hooks to resolve parameter
<span class="lineNum">     132 </span>            :  * references during parsing of a SQL function's body.  This is separate from
<span class="lineNum">     133 </span>            :  * SQLFunctionCache since we sometimes do parsing separately from execution.
<span class="lineNum">     134 </span>            :  */
<span class="lineNum">     135 </span>            : typedef struct SQLFunctionParseInfo
<span class="lineNum">     136 </span>            : {
<span class="lineNum">     137 </span>            :     char       *fname;          /* function's name */
<span class="lineNum">     138 </span>            :     int         nargs;          /* number of input arguments */
<span class="lineNum">     139 </span>            :     Oid        *argtypes;       /* resolved types of input arguments */
<span class="lineNum">     140 </span>            :     char      **argnames;       /* names of input arguments; NULL if none */
<span class="lineNum">     141 </span>            :     /* Note that argnames[i] can be NULL, if some args are unnamed */
<span class="lineNum">     142 </span>            :     Oid         collation;      /* function's input collation, if known */
<span class="lineNum">     143 </span>            : }           SQLFunctionParseInfo;
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : /* non-export function prototypes */
<span class="lineNum">     147 </span>            : static Node *sql_fn_param_ref(ParseState *pstate, ParamRef *pref);
<span class="lineNum">     148 </span>            : static Node *sql_fn_post_column_ref(ParseState *pstate,
<span class="lineNum">     149 </span>            :                                     ColumnRef *cref, Node *var);
<span class="lineNum">     150 </span>            : static Node *sql_fn_make_param(SQLFunctionParseInfoPtr pinfo,
<span class="lineNum">     151 </span>            :                                int paramno, int location);
<span class="lineNum">     152 </span>            : static Node *sql_fn_resolve_param_name(SQLFunctionParseInfoPtr pinfo,
<span class="lineNum">     153 </span>            :                                        const char *paramname, int location);
<span class="lineNum">     154 </span>            : static List *init_execution_state(List *queryTree_list,
<span class="lineNum">     155 </span>            :                                   SQLFunctionCachePtr fcache,
<span class="lineNum">     156 </span>            :                                   bool lazyEvalOK);
<span class="lineNum">     157 </span>            : static void init_sql_fcache(FmgrInfo *finfo, Oid collation, bool lazyEvalOK);
<span class="lineNum">     158 </span>            : static void postquel_start(execution_state *es, SQLFunctionCachePtr fcache);
<span class="lineNum">     159 </span>            : static bool postquel_getnext(execution_state *es, SQLFunctionCachePtr fcache);
<span class="lineNum">     160 </span>            : static void postquel_end(execution_state *es);
<span class="lineNum">     161 </span>            : static void postquel_sub_params(SQLFunctionCachePtr fcache,
<span class="lineNum">     162 </span>            :                                 FunctionCallInfo fcinfo);
<span class="lineNum">     163 </span>            : static Datum postquel_get_single_result(TupleTableSlot *slot,
<span class="lineNum">     164 </span>            :                                         FunctionCallInfo fcinfo,
<span class="lineNum">     165 </span>            :                                         SQLFunctionCachePtr fcache,
<span class="lineNum">     166 </span>            :                                         MemoryContext resultcontext);
<span class="lineNum">     167 </span>            : static void sql_exec_error_callback(void *arg);
<span class="lineNum">     168 </span>            : static void ShutdownSQLFunction(Datum arg);
<span class="lineNum">     169 </span>            : static void sqlfunction_startup(DestReceiver *self, int operation, TupleDesc typeinfo);
<span class="lineNum">     170 </span>            : static bool sqlfunction_receive(TupleTableSlot *slot, DestReceiver *self);
<span class="lineNum">     171 </span>            : static void sqlfunction_shutdown(DestReceiver *self);
<span class="lineNum">     172 </span>            : static void sqlfunction_destroy(DestReceiver *self);
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            : /*
<span class="lineNum">     176 </span>            :  * Prepare the SQLFunctionParseInfo struct for parsing a SQL function body
<span class="lineNum">     177 </span>            :  *
<span class="lineNum">     178 </span>            :  * This includes resolving actual types of polymorphic arguments.
<span class="lineNum">     179 </span>            :  *
<span class="lineNum">     180 </span>            :  * call_expr can be passed as NULL, but then we will fail if there are any
<span class="lineNum">     181 </span>            :  * polymorphic arguments.
<a name="182"><span class="lineNum">     182 </span>            :  */</a>
<span class="lineNum">     183 </span>            : SQLFunctionParseInfoPtr
<span class="lineNum">     184 </span><span class="lineCov">       8906 : prepare_sql_fn_parse_info(HeapTuple procedureTuple,</span>
<span class="lineNum">     185 </span>            :                           Node *call_expr,
<span class="lineNum">     186 </span>            :                           Oid inputCollation)
<span class="lineNum">     187 </span>            : {
<span class="lineNum">     188 </span>            :     SQLFunctionParseInfoPtr pinfo;
<span class="lineNum">     189 </span><span class="lineCov">       8906 :     Form_pg_proc procedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);</span>
<span class="lineNum">     190 </span>            :     int         nargs;
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span><span class="lineCov">       8906 :     pinfo = (SQLFunctionParseInfoPtr) palloc0(sizeof(SQLFunctionParseInfo));</span>
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :     /* Function's name (only) can be used to qualify argument names */
<span class="lineNum">     195 </span><span class="lineCov">       8906 :     pinfo-&gt;fname = pstrdup(NameStr(procedureStruct-&gt;proname));</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            :     /* Save the function's input collation */
<span class="lineNum">     198 </span><span class="lineCov">       8906 :     pinfo-&gt;collation = inputCollation;</span>
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :     /*
<span class="lineNum">     201 </span>            :      * Copy input argument types from the pg_proc entry, then resolve any
<span class="lineNum">     202 </span>            :      * polymorphic types.
<span class="lineNum">     203 </span>            :      */
<span class="lineNum">     204 </span><span class="lineCov">       8906 :     pinfo-&gt;nargs = nargs = procedureStruct-&gt;pronargs;</span>
<span class="lineNum">     205 </span><span class="lineCov">       8906 :     if (nargs &gt; 0)</span>
<span class="lineNum">     206 </span>            :     {
<span class="lineNum">     207 </span>            :         Oid        *argOidVect;
<span class="lineNum">     208 </span>            :         int         argnum;
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span><span class="lineCov">       2498 :         argOidVect = (Oid *) palloc(nargs * sizeof(Oid));</span>
<span class="lineNum">     211 </span><span class="lineCov">       4996 :         memcpy(argOidVect,</span>
<span class="lineNum">     212 </span><span class="lineCov">       2498 :                procedureStruct-&gt;proargtypes.values,</span>
<span class="lineNum">     213 </span>            :                nargs * sizeof(Oid));
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span><span class="lineCov">       6910 :         for (argnum = 0; argnum &lt; nargs; argnum++)</span>
<span class="lineNum">     216 </span>            :         {
<span class="lineNum">     217 </span><span class="lineCov">       4412 :             Oid         argtype = argOidVect[argnum];</span>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span><span class="lineCov">       4412 :             if (IsPolymorphicType(argtype))</span>
<span class="lineNum">     220 </span>            :             {
<span class="lineNum">     221 </span><span class="lineCov">        488 :                 argtype = get_call_expr_argtype(call_expr, argnum);</span>
<span class="lineNum">     222 </span><span class="lineCov">        488 :                 if (argtype == InvalidOid)</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :                     ereport(ERROR,</span>
<span class="lineNum">     224 </span>            :                             (errcode(ERRCODE_DATATYPE_MISMATCH),
<span class="lineNum">     225 </span>            :                              errmsg(&quot;could not determine actual type of argument declared %s&quot;,
<span class="lineNum">     226 </span>            :                                     format_type_be(argOidVect[argnum]))));
<span class="lineNum">     227 </span><span class="lineCov">        488 :                 argOidVect[argnum] = argtype;</span>
<span class="lineNum">     228 </span>            :             }
<span class="lineNum">     229 </span>            :         }
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineCov">       2498 :         pinfo-&gt;argtypes = argOidVect;</span>
<span class="lineNum">     232 </span>            :     }
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            :     /*
<span class="lineNum">     235 </span>            :      * Collect names of arguments, too, if any
<span class="lineNum">     236 </span>            :      */
<span class="lineNum">     237 </span><span class="lineCov">       8906 :     if (nargs &gt; 0)</span>
<span class="lineNum">     238 </span>            :     {
<span class="lineNum">     239 </span>            :         Datum       proargnames;
<span class="lineNum">     240 </span>            :         Datum       proargmodes;
<span class="lineNum">     241 </span>            :         int         n_arg_names;
<span class="lineNum">     242 </span>            :         bool        isNull;
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span><span class="lineCov">       2498 :         proargnames = SysCacheGetAttr(PROCNAMEARGSNSP, procedureTuple,</span>
<span class="lineNum">     245 </span>            :                                       Anum_pg_proc_proargnames,
<span class="lineNum">     246 </span>            :                                       &amp;isNull);
<span class="lineNum">     247 </span><span class="lineCov">       2498 :         if (isNull)</span>
<span class="lineNum">     248 </span><span class="lineCov">       1934 :             proargnames = PointerGetDatum(NULL);    /* just to be sure */</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineCov">       2498 :         proargmodes = SysCacheGetAttr(PROCNAMEARGSNSP, procedureTuple,</span>
<span class="lineNum">     251 </span>            :                                       Anum_pg_proc_proargmodes,
<span class="lineNum">     252 </span>            :                                       &amp;isNull);
<span class="lineNum">     253 </span><span class="lineCov">       2498 :         if (isNull)</span>
<span class="lineNum">     254 </span><span class="lineCov">       2302 :             proargmodes = PointerGetDatum(NULL);    /* just to be sure */</span>
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span><span class="lineCov">       2498 :         n_arg_names = get_func_input_arg_names(proargnames, proargmodes,</span>
<span class="lineNum">     257 </span>            :                                                &amp;pinfo-&gt;argnames);
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            :         /* Paranoia: ignore the result if too few array entries */
<span class="lineNum">     260 </span><span class="lineCov">       2498 :         if (n_arg_names &lt; nargs)</span>
<span class="lineNum">     261 </span><span class="lineCov">       1934 :             pinfo-&gt;argnames = NULL;</span>
<span class="lineNum">     262 </span>            :     }
<span class="lineNum">     263 </span>            :     else
<span class="lineNum">     264 </span><span class="lineCov">       6408 :         pinfo-&gt;argnames = NULL;</span>
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span><span class="lineCov">       8906 :     return pinfo;</span>
<span class="lineNum">     267 </span>            : }
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            : /*
<span class="lineNum">     270 </span>            :  * Parser setup hook for parsing a SQL function body.
<a name="271"><span class="lineNum">     271 </span>            :  */</a>
<span class="lineNum">     272 </span>            : void
<span class="lineNum">     273 </span><span class="lineCov">       8918 : sql_fn_parser_setup(struct ParseState *pstate, SQLFunctionParseInfoPtr pinfo)</span>
<span class="lineNum">     274 </span>            : {
<span class="lineNum">     275 </span><span class="lineCov">       8918 :     pstate-&gt;p_pre_columnref_hook = NULL;</span>
<span class="lineNum">     276 </span><span class="lineCov">       8918 :     pstate-&gt;p_post_columnref_hook = sql_fn_post_column_ref;</span>
<span class="lineNum">     277 </span><span class="lineCov">       8918 :     pstate-&gt;p_paramref_hook = sql_fn_param_ref;</span>
<span class="lineNum">     278 </span>            :     /* no need to use p_coerce_param_hook */
<span class="lineNum">     279 </span><span class="lineCov">       8918 :     pstate-&gt;p_ref_hook_state = (void *) pinfo;</span>
<span class="lineNum">     280 </span><span class="lineCov">       8918 : }</span>
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            : /*
<span class="lineNum">     283 </span>            :  * sql_fn_post_column_ref       parser callback for ColumnRefs
<a name="284"><span class="lineNum">     284 </span>            :  */</a>
<span class="lineNum">     285 </span>            : static Node *
<span class="lineNum">     286 </span><span class="lineCov">       4368 : sql_fn_post_column_ref(ParseState *pstate, ColumnRef *cref, Node *var)</span>
<span class="lineNum">     287 </span>            : {
<span class="lineNum">     288 </span><span class="lineCov">       4368 :     SQLFunctionParseInfoPtr pinfo = (SQLFunctionParseInfoPtr) pstate-&gt;p_ref_hook_state;</span>
<span class="lineNum">     289 </span>            :     int         nnames;
<span class="lineNum">     290 </span>            :     Node       *field1;
<span class="lineNum">     291 </span><span class="lineCov">       4368 :     Node       *subfield = NULL;</span>
<span class="lineNum">     292 </span>            :     const char *name1;
<span class="lineNum">     293 </span><span class="lineCov">       4368 :     const char *name2 = NULL;</span>
<span class="lineNum">     294 </span>            :     Node       *param;
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :     /*
<span class="lineNum">     297 </span>            :      * Never override a table-column reference.  This corresponds to
<span class="lineNum">     298 </span>            :      * considering the parameter names to appear in a scope outside the
<span class="lineNum">     299 </span>            :      * individual SQL commands, which is what we want.
<span class="lineNum">     300 </span>            :      */
<span class="lineNum">     301 </span><span class="lineCov">       4368 :     if (var != NULL)</span>
<span class="lineNum">     302 </span><span class="lineCov">       3994 :         return NULL;</span>
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            :     /*----------
<span class="lineNum">     305 </span>            :      * The allowed syntaxes are:
<span class="lineNum">     306 </span>            :      *
<span class="lineNum">     307 </span>            :      * A        A = parameter name
<span class="lineNum">     308 </span>            :      * A.B      A = function name, B = parameter name
<span class="lineNum">     309 </span>            :      *          OR: A = record-typed parameter name, B = field name
<span class="lineNum">     310 </span>            :      *          (the first possibility takes precedence)
<span class="lineNum">     311 </span>            :      * A.B.C    A = function name, B = record-typed parameter name,
<span class="lineNum">     312 </span>            :      *          C = field name
<span class="lineNum">     313 </span>            :      * A.*      Whole-row reference to composite parameter A.
<span class="lineNum">     314 </span>            :      * A.B.*    Same, with A = function name, B = parameter name
<span class="lineNum">     315 </span>            :      *
<span class="lineNum">     316 </span>            :      * Here, it's sufficient to ignore the &quot;*&quot; in the last two cases --- the
<span class="lineNum">     317 </span>            :      * main parser will take care of expanding the whole-row reference.
<span class="lineNum">     318 </span>            :      *----------
<span class="lineNum">     319 </span>            :      */
<span class="lineNum">     320 </span><span class="lineCov">        374 :     nnames = list_length(cref-&gt;fields);</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span><span class="lineCov">        374 :     if (nnames &gt; 3)</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span><span class="lineCov">        374 :     if (IsA(llast(cref-&gt;fields), A_Star))</span>
<span class="lineNum">     326 </span><span class="lineCov">         18 :         nnames--;</span>
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span><span class="lineCov">        374 :     field1 = (Node *) linitial(cref-&gt;fields);</span>
<span class="lineNum">     329 </span><span class="lineCov">        374 :     Assert(IsA(field1, String));</span>
<span class="lineNum">     330 </span><span class="lineCov">        374 :     name1 = strVal(field1);</span>
<span class="lineNum">     331 </span><span class="lineCov">        374 :     if (nnames &gt; 1)</span>
<span class="lineNum">     332 </span>            :     {
<span class="lineNum">     333 </span><span class="lineCov">         48 :         subfield = (Node *) lsecond(cref-&gt;fields);</span>
<span class="lineNum">     334 </span><span class="lineCov">         48 :         Assert(IsA(subfield, String));</span>
<span class="lineNum">     335 </span><span class="lineCov">         48 :         name2 = strVal(subfield);</span>
<span class="lineNum">     336 </span>            :     }
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span><span class="lineCov">        374 :     if (nnames == 3)</span>
<span class="lineNum">     339 </span>            :     {
<span class="lineNum">     340 </span>            :         /*
<span class="lineNum">     341 </span>            :          * Three-part name: if the first part doesn't match the function name,
<span class="lineNum">     342 </span>            :          * we can fail immediately. Otherwise, look up the second part, and
<span class="lineNum">     343 </span>            :          * take the third part to be a field reference.
<span class="lineNum">     344 </span>            :          */
<span class="lineNum">     345 </span><span class="lineCov">          8 :         if (strcmp(name1, pinfo-&gt;fname) != 0)</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span><span class="lineCov">          8 :         param = sql_fn_resolve_param_name(pinfo, name2, cref-&gt;location);</span>
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span><span class="lineCov">          8 :         subfield = (Node *) lthird(cref-&gt;fields);</span>
<span class="lineNum">     351 </span><span class="lineCov">          8 :         Assert(IsA(subfield, String));</span>
<span class="lineNum">     352 </span>            :     }
<span class="lineNum">     353 </span><span class="lineCov">        366 :     else if (nnames == 2 &amp;&amp; strcmp(name1, pinfo-&gt;fname) == 0)</span>
<span class="lineNum">     354 </span>            :     {
<span class="lineNum">     355 </span>            :         /*
<span class="lineNum">     356 </span>            :          * Two-part name with first part matching function name: first see if
<span class="lineNum">     357 </span>            :          * second part matches any parameter name.
<span class="lineNum">     358 </span>            :          */
<span class="lineNum">     359 </span><span class="lineCov">          8 :         param = sql_fn_resolve_param_name(pinfo, name2, cref-&gt;location);</span>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span><span class="lineCov">         16 :         if (param)</span>
<span class="lineNum">     362 </span>            :         {
<span class="lineNum">     363 </span>            :             /* Yes, so this is a parameter reference, no subfield */
<span class="lineNum">     364 </span><span class="lineCov">          8 :             subfield = NULL;</span>
<span class="lineNum">     365 </span>            :         }
<span class="lineNum">     366 </span>            :         else
<span class="lineNum">     367 </span>            :         {
<span class="lineNum">     368 </span>            :             /* No, so try to match as parameter name and subfield */
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :             param = sql_fn_resolve_param_name(pinfo, name1, cref-&gt;location);</span>
<span class="lineNum">     370 </span>            :         }
<span class="lineNum">     371 </span>            :     }
<span class="lineNum">     372 </span>            :     else
<span class="lineNum">     373 </span>            :     {
<span class="lineNum">     374 </span>            :         /* Single name, or parameter name followed by subfield */
<span class="lineNum">     375 </span><span class="lineCov">        358 :         param = sql_fn_resolve_param_name(pinfo, name1, cref-&gt;location);</span>
<span class="lineNum">     376 </span>            :     }
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineCov">        374 :     if (!param)</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :         return NULL;            /* No match */</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineCov">        374 :     if (subfield)</span>
<span class="lineNum">     382 </span>            :     {
<span class="lineNum">     383 </span>            :         /*
<span class="lineNum">     384 </span>            :          * Must be a reference to a field of a composite parameter; otherwise
<span class="lineNum">     385 </span>            :          * ParseFuncOrColumn will return NULL, and we'll fail back at the
<span class="lineNum">     386 </span>            :          * caller.
<span class="lineNum">     387 </span>            :          */
<span class="lineNum">     388 </span><span class="lineCov">        120 :         param = ParseFuncOrColumn(pstate,</span>
<span class="lineNum">     389 </span><span class="lineCov">         40 :                                   list_make1(subfield),</span>
<span class="lineNum">     390 </span><span class="lineCov">         40 :                                   list_make1(param),</span>
<span class="lineNum">     391 </span>            :                                   pstate-&gt;p_last_srf,
<span class="lineNum">     392 </span>            :                                   NULL,
<span class="lineNum">     393 </span>            :                                   false,
<span class="lineNum">     394 </span>            :                                   cref-&gt;location);
<span class="lineNum">     395 </span>            :     }
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span><span class="lineCov">        374 :     return param;</span>
<span class="lineNum">     398 </span>            : }
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            : /*
<span class="lineNum">     401 </span>            :  * sql_fn_param_ref     parser callback for ParamRefs ($n symbols)
<a name="402"><span class="lineNum">     402 </span>            :  */</a>
<span class="lineNum">     403 </span>            : static Node *
<span class="lineNum">     404 </span><span class="lineCov">       4158 : sql_fn_param_ref(ParseState *pstate, ParamRef *pref)</span>
<span class="lineNum">     405 </span>            : {
<span class="lineNum">     406 </span><span class="lineCov">       4158 :     SQLFunctionParseInfoPtr pinfo = (SQLFunctionParseInfoPtr) pstate-&gt;p_ref_hook_state;</span>
<span class="lineNum">     407 </span><span class="lineCov">       4158 :     int         paramno = pref-&gt;number;</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :     /* Check parameter number is valid */
<span class="lineNum">     410 </span><span class="lineCov">       4158 :     if (paramno &lt;= 0 || paramno &gt; pinfo-&gt;nargs)</span>
<span class="lineNum">     411 </span><span class="lineCov">          2 :         return NULL;            /* unknown parameter number */</span>
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineCov">       4156 :     return sql_fn_make_param(pinfo, paramno, pref-&gt;location);</span>
<span class="lineNum">     414 </span>            : }
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            : /*
<span class="lineNum">     417 </span>            :  * sql_fn_make_param        construct a Param node for the given paramno
<a name="418"><span class="lineNum">     418 </span>            :  */</a>
<span class="lineNum">     419 </span>            : static Node *
<span class="lineNum">     420 </span><span class="lineCov">       4530 : sql_fn_make_param(SQLFunctionParseInfoPtr pinfo,</span>
<span class="lineNum">     421 </span>            :                   int paramno, int location)
<span class="lineNum">     422 </span>            : {
<span class="lineNum">     423 </span>            :     Param      *param;
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span><span class="lineCov">       4530 :     param = makeNode(Param);</span>
<span class="lineNum">     426 </span><span class="lineCov">       4530 :     param-&gt;paramkind = PARAM_EXTERN;</span>
<span class="lineNum">     427 </span><span class="lineCov">       4530 :     param-&gt;paramid = paramno;</span>
<span class="lineNum">     428 </span><span class="lineCov">       4530 :     param-&gt;paramtype = pinfo-&gt;argtypes[paramno - 1];</span>
<span class="lineNum">     429 </span><span class="lineCov">       4530 :     param-&gt;paramtypmod = -1;</span>
<span class="lineNum">     430 </span><span class="lineCov">       4530 :     param-&gt;paramcollid = get_typcollation(param-&gt;paramtype);</span>
<span class="lineNum">     431 </span><span class="lineCov">       4530 :     param-&gt;location = location;</span>
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            :     /*
<span class="lineNum">     434 </span>            :      * If we have a function input collation, allow it to override the
<span class="lineNum">     435 </span>            :      * type-derived collation for parameter symbols.  (XXX perhaps this should
<span class="lineNum">     436 </span>            :      * not happen if the type collation is not default?)
<span class="lineNum">     437 </span>            :      */
<span class="lineNum">     438 </span><span class="lineCov">       4530 :     if (OidIsValid(pinfo-&gt;collation) &amp;&amp; OidIsValid(param-&gt;paramcollid))</span>
<span class="lineNum">     439 </span><span class="lineCov">        892 :         param-&gt;paramcollid = pinfo-&gt;collation;</span>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineCov">       4530 :     return (Node *) param;</span>
<span class="lineNum">     442 </span>            : }
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            : /*
<span class="lineNum">     445 </span>            :  * Search for a function parameter of the given name; if there is one,
<span class="lineNum">     446 </span>            :  * construct and return a Param node for it.  If not, return NULL.
<span class="lineNum">     447 </span>            :  * Helper function for sql_fn_post_column_ref.
<a name="448"><span class="lineNum">     448 </span>            :  */</a>
<span class="lineNum">     449 </span>            : static Node *
<span class="lineNum">     450 </span><span class="lineCov">        374 : sql_fn_resolve_param_name(SQLFunctionParseInfoPtr pinfo,</span>
<span class="lineNum">     451 </span>            :                           const char *paramname, int location)
<span class="lineNum">     452 </span>            : {
<span class="lineNum">     453 </span>            :     int         i;
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span><span class="lineCov">        374 :     if (pinfo-&gt;argnames == NULL)</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineCov">        490 :     for (i = 0; i &lt; pinfo-&gt;nargs; i++)</span>
<span class="lineNum">     459 </span>            :     {
<span class="lineNum">     460 </span><span class="lineCov">        490 :         if (pinfo-&gt;argnames[i] &amp;&amp; strcmp(pinfo-&gt;argnames[i], paramname) == 0)</span>
<span class="lineNum">     461 </span><span class="lineCov">        374 :             return sql_fn_make_param(pinfo, i + 1, location);</span>
<span class="lineNum">     462 </span>            :     }
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     465 </span>            : }
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            : /*
<span class="lineNum">     468 </span>            :  * Set up the per-query execution_state records for a SQL function.
<span class="lineNum">     469 </span>            :  *
<span class="lineNum">     470 </span>            :  * The input is a List of Lists of parsed and rewritten, but not planned,
<span class="lineNum">     471 </span>            :  * querytrees.  The sublist structure denotes the original query boundaries.
<a name="472"><span class="lineNum">     472 </span>            :  */</a>
<span class="lineNum">     473 </span>            : static List *
<span class="lineNum">     474 </span><span class="lineCov">       4414 : init_execution_state(List *queryTree_list,</span>
<span class="lineNum">     475 </span>            :                      SQLFunctionCachePtr fcache,
<span class="lineNum">     476 </span>            :                      bool lazyEvalOK)
<span class="lineNum">     477 </span>            : {
<span class="lineNum">     478 </span><span class="lineCov">       4414 :     List       *eslist = NIL;</span>
<span class="lineNum">     479 </span><span class="lineCov">       4414 :     execution_state *lasttages = NULL;</span>
<span class="lineNum">     480 </span>            :     ListCell   *lc1;
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span><span class="lineCov">       8836 :     foreach(lc1, queryTree_list)</span>
<span class="lineNum">     483 </span>            :     {
<span class="lineNum">     484 </span><span class="lineCov">       4424 :         List       *qtlist = lfirst_node(List, lc1);</span>
<span class="lineNum">     485 </span><span class="lineCov">       4424 :         execution_state *firstes = NULL;</span>
<span class="lineNum">     486 </span><span class="lineCov">       4424 :         execution_state *preves = NULL;</span>
<span class="lineNum">     487 </span>            :         ListCell   *lc2;
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span><span class="lineCov">       8848 :         foreach(lc2, qtlist)</span>
<span class="lineNum">     490 </span>            :         {
<span class="lineNum">     491 </span><span class="lineCov">       4426 :             Query      *queryTree = lfirst_node(Query, lc2);</span>
<span class="lineNum">     492 </span>            :             PlannedStmt *stmt;
<span class="lineNum">     493 </span>            :             execution_state *newes;
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            :             /* Plan the query if needed */
<span class="lineNum">     496 </span><span class="lineCov">       4426 :             if (queryTree-&gt;commandType == CMD_UTILITY)</span>
<span class="lineNum">     497 </span>            :             {
<span class="lineNum">     498 </span>            :                 /* Utility commands require no planning. */
<span class="lineNum">     499 </span><span class="lineCov">         20 :                 stmt = makeNode(PlannedStmt);</span>
<span class="lineNum">     500 </span><span class="lineCov">         20 :                 stmt-&gt;commandType = CMD_UTILITY;</span>
<span class="lineNum">     501 </span><span class="lineCov">         20 :                 stmt-&gt;canSetTag = queryTree-&gt;canSetTag;</span>
<span class="lineNum">     502 </span><span class="lineCov">         20 :                 stmt-&gt;utilityStmt = queryTree-&gt;utilityStmt;</span>
<span class="lineNum">     503 </span><span class="lineCov">         20 :                 stmt-&gt;stmt_location = queryTree-&gt;stmt_location;</span>
<span class="lineNum">     504 </span><span class="lineCov">         20 :                 stmt-&gt;stmt_len = queryTree-&gt;stmt_len;</span>
<span class="lineNum">     505 </span>            :             }
<span class="lineNum">     506 </span>            :             else
<span class="lineNum">     507 </span><span class="lineCov">       4406 :                 stmt = pg_plan_query(queryTree,</span>
<span class="lineNum">     508 </span>            :                                      CURSOR_OPT_PARALLEL_OK,
<span class="lineNum">     509 </span>            :                                      NULL);
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            :             /*
<span class="lineNum">     512 </span>            :              * Precheck all commands for validity in a function.  This should
<span class="lineNum">     513 </span>            :              * generally match the restrictions spi.c applies.
<span class="lineNum">     514 </span>            :              */
<span class="lineNum">     515 </span><span class="lineCov">       4424 :             if (stmt-&gt;commandType == CMD_UTILITY)</span>
<span class="lineNum">     516 </span>            :             {
<span class="lineNum">     517 </span><span class="lineCov">         20 :                 if (IsA(stmt-&gt;utilityStmt, CopyStmt) &amp;&amp;</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :                     ((CopyStmt *) stmt-&gt;utilityStmt)-&gt;filename == NULL)</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :                     ereport(ERROR,</span>
<span class="lineNum">     520 </span>            :                             (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">     521 </span>            :                              errmsg(&quot;cannot COPY to/from client in a SQL function&quot;)));
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span><span class="lineCov">         20 :                 if (IsA(stmt-&gt;utilityStmt, TransactionStmt))</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :                     ereport(ERROR,</span>
<span class="lineNum">     525 </span>            :                             (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">     526 </span>            :                     /* translator: %s is a SQL statement name */
<span class="lineNum">     527 </span>            :                              errmsg(&quot;%s is not allowed in a SQL function&quot;,
<span class="lineNum">     528 </span>            :                                     CreateCommandTag(stmt-&gt;utilityStmt))));
<span class="lineNum">     529 </span>            :             }
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span><span class="lineCov">       4424 :             if (fcache-&gt;readonly_func &amp;&amp; !CommandIsReadOnly(stmt))</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :                 ereport(ERROR,</span>
<span class="lineNum">     533 </span>            :                         (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">     534 </span>            :                 /* translator: %s is a SQL statement name */
<span class="lineNum">     535 </span>            :                          errmsg(&quot;%s is not allowed in a non-volatile function&quot;,
<span class="lineNum">     536 </span>            :                                 CreateCommandTag((Node *) stmt))));
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineCov">       4424 :             if (IsInParallelMode() &amp;&amp; !CommandIsReadOnly(stmt))</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :                 PreventCommandIfParallelMode(CreateCommandTag((Node *) stmt));</span>
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span>            :             /* OK, build the execution_state for this query */
<span class="lineNum">     542 </span><span class="lineCov">       4424 :             newes = (execution_state *) palloc(sizeof(execution_state));</span>
<span class="lineNum">     543 </span><span class="lineCov">       4424 :             if (preves)</span>
<span class="lineNum">     544 </span><span class="lineCov">          2 :                 preves-&gt;next = newes;</span>
<span class="lineNum">     545 </span>            :             else
<span class="lineNum">     546 </span><span class="lineCov">       4422 :                 firstes = newes;</span>
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span><span class="lineCov">       4424 :             newes-&gt;next = NULL;</span>
<span class="lineNum">     549 </span><span class="lineCov">       4424 :             newes-&gt;status = F_EXEC_START;</span>
<span class="lineNum">     550 </span><span class="lineCov">       4424 :             newes-&gt;setsResult = false;   /* might change below */</span>
<span class="lineNum">     551 </span><span class="lineCov">       4424 :             newes-&gt;lazyEval = false; /* might change below */</span>
<span class="lineNum">     552 </span><span class="lineCov">       4424 :             newes-&gt;stmt = stmt;</span>
<span class="lineNum">     553 </span><span class="lineCov">       4424 :             newes-&gt;qd = NULL;</span>
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span><span class="lineCov">       4424 :             if (queryTree-&gt;canSetTag)</span>
<span class="lineNum">     556 </span><span class="lineCov">       4422 :                 lasttages = newes;</span>
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span><span class="lineCov">       4424 :             preves = newes;</span>
<span class="lineNum">     559 </span>            :         }
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span><span class="lineCov">       4422 :         eslist = lappend(eslist, firstes);</span>
<span class="lineNum">     562 </span>            :     }
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :     /*
<span class="lineNum">     565 </span>            :      * Mark the last canSetTag query as delivering the function result; then,
<span class="lineNum">     566 </span>            :      * if it is a plain SELECT, mark it for lazy evaluation. If it's not a
<span class="lineNum">     567 </span>            :      * SELECT we must always run it to completion.
<span class="lineNum">     568 </span>            :      *
<span class="lineNum">     569 </span>            :      * Note: at some point we might add additional criteria for whether to use
<span class="lineNum">     570 </span>            :      * lazy eval.  However, we should prefer to use it whenever the function
<span class="lineNum">     571 </span>            :      * doesn't return set, since fetching more than one row is useless in that
<span class="lineNum">     572 </span>            :      * case.
<span class="lineNum">     573 </span>            :      *
<span class="lineNum">     574 </span>            :      * Note: don't set setsResult if the function returns VOID, as evidenced
<span class="lineNum">     575 </span>            :      * by not having made a junkfilter.  This ensures we'll throw away any
<span class="lineNum">     576 </span>            :      * output from the last statement in such a function.
<span class="lineNum">     577 </span>            :      */
<span class="lineNum">     578 </span><span class="lineCov">       4412 :     if (lasttages &amp;&amp; fcache-&gt;junkFilter)</span>
<span class="lineNum">     579 </span>            :     {
<span class="lineNum">     580 </span><span class="lineCov">       4348 :         lasttages-&gt;setsResult = true;</span>
<span class="lineNum">     581 </span><span class="lineCov">       8522 :         if (lazyEvalOK &amp;&amp;</span>
<span class="lineNum">     582 </span><span class="lineCov">       8328 :             lasttages-&gt;stmt-&gt;commandType == CMD_SELECT &amp;&amp;</span>
<span class="lineNum">     583 </span><span class="lineCov">       4154 :             !lasttages-&gt;stmt-&gt;hasModifyingCTE)</span>
<span class="lineNum">     584 </span><span class="lineCov">       4154 :             fcache-&gt;lazyEval = lasttages-&gt;lazyEval = true;</span>
<span class="lineNum">     585 </span>            :     }
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span><span class="lineCov">       4412 :     return eslist;</span>
<span class="lineNum">     588 </span>            : }
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            : /*
<span class="lineNum">     591 </span>            :  * Initialize the SQLFunctionCache for a SQL function
<a name="592"><span class="lineNum">     592 </span>            :  */</a>
<span class="lineNum">     593 </span>            : static void
<span class="lineNum">     594 </span><span class="lineCov">       4414 : init_sql_fcache(FmgrInfo *finfo, Oid collation, bool lazyEvalOK)</span>
<span class="lineNum">     595 </span>            : {
<span class="lineNum">     596 </span><span class="lineCov">       4414 :     Oid         foid = finfo-&gt;fn_oid;</span>
<span class="lineNum">     597 </span>            :     MemoryContext fcontext;
<span class="lineNum">     598 </span>            :     MemoryContext oldcontext;
<span class="lineNum">     599 </span>            :     Oid         rettype;
<span class="lineNum">     600 </span>            :     HeapTuple   procedureTuple;
<span class="lineNum">     601 </span>            :     Form_pg_proc procedureStruct;
<span class="lineNum">     602 </span>            :     SQLFunctionCachePtr fcache;
<span class="lineNum">     603 </span>            :     List       *raw_parsetree_list;
<span class="lineNum">     604 </span>            :     List       *queryTree_list;
<span class="lineNum">     605 </span>            :     List       *flat_query_list;
<span class="lineNum">     606 </span>            :     ListCell   *lc;
<span class="lineNum">     607 </span>            :     Datum       tmp;
<span class="lineNum">     608 </span>            :     bool        isNull;
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span>            :     /*
<span class="lineNum">     611 </span>            :      * Create memory context that holds all the SQLFunctionCache data.  It
<span class="lineNum">     612 </span>            :      * must be a child of whatever context holds the FmgrInfo.
<span class="lineNum">     613 </span>            :      */
<span class="lineNum">     614 </span><span class="lineCov">       4414 :     fcontext = AllocSetContextCreate(finfo-&gt;fn_mcxt,</span>
<span class="lineNum">     615 </span>            :                                      &quot;SQL function&quot;,
<span class="lineNum">     616 </span>            :                                      ALLOCSET_DEFAULT_SIZES);
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span><span class="lineCov">       4414 :     oldcontext = MemoryContextSwitchTo(fcontext);</span>
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span>            :     /*
<span class="lineNum">     621 </span>            :      * Create the struct proper, link it to fcontext and fn_extra.  Once this
<span class="lineNum">     622 </span>            :      * is done, we'll be able to recover the memory after failure, even if the
<span class="lineNum">     623 </span>            :      * FmgrInfo is long-lived.
<span class="lineNum">     624 </span>            :      */
<span class="lineNum">     625 </span><span class="lineCov">       4414 :     fcache = (SQLFunctionCachePtr) palloc0(sizeof(SQLFunctionCache));</span>
<span class="lineNum">     626 </span><span class="lineCov">       4414 :     fcache-&gt;fcontext = fcontext;</span>
<span class="lineNum">     627 </span><span class="lineCov">       4414 :     finfo-&gt;fn_extra = (void *) fcache;</span>
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            :     /*
<span class="lineNum">     630 </span>            :      * get the procedure tuple corresponding to the given function Oid
<span class="lineNum">     631 </span>            :      */
<span class="lineNum">     632 </span><span class="lineCov">       4414 :     procedureTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(foid));</span>
<span class="lineNum">     633 </span><span class="lineCov">       4414 :     if (!HeapTupleIsValid(procedureTuple))</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cache lookup failed for function %u&quot;, foid);</span>
<span class="lineNum">     635 </span><span class="lineCov">       4414 :     procedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);</span>
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :     /*
<span class="lineNum">     638 </span>            :      * copy function name immediately for use by error reporting callback, and
<span class="lineNum">     639 </span>            :      * for use as memory context identifier
<span class="lineNum">     640 </span>            :      */
<span class="lineNum">     641 </span><span class="lineCov">       4414 :     fcache-&gt;fname = pstrdup(NameStr(procedureStruct-&gt;proname));</span>
<span class="lineNum">     642 </span><span class="lineCov">       4414 :     MemoryContextSetIdentifier(fcontext, fcache-&gt;fname);</span>
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            :     /*
<span class="lineNum">     645 </span>            :      * get the result type from the procedure tuple, and check for polymorphic
<span class="lineNum">     646 </span>            :      * result type; if so, find out the actual result type.
<span class="lineNum">     647 </span>            :      */
<span class="lineNum">     648 </span><span class="lineCov">       4414 :     rettype = procedureStruct-&gt;prorettype;</span>
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span><span class="lineCov">       4414 :     if (IsPolymorphicType(rettype))</span>
<span class="lineNum">     651 </span>            :     {
<span class="lineNum">     652 </span><span class="lineCov">         70 :         rettype = get_fn_expr_rettype(finfo);</span>
<span class="lineNum">     653 </span><span class="lineCov">         70 :         if (rettype == InvalidOid)  /* this probably should not happen */</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">     655 </span>            :                     (errcode(ERRCODE_DATATYPE_MISMATCH),
<span class="lineNum">     656 </span>            :                      errmsg(&quot;could not determine actual result type for function declared to return type %s&quot;,
<span class="lineNum">     657 </span>            :                             format_type_be(procedureStruct-&gt;prorettype))));
<span class="lineNum">     658 </span>            :     }
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineCov">       4414 :     fcache-&gt;rettype = rettype;</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            :     /* Fetch the typlen and byval info for the result type */
<span class="lineNum">     663 </span><span class="lineCov">       4414 :     get_typlenbyval(rettype, &amp;fcache-&gt;typlen, &amp;fcache-&gt;typbyval);</span>
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            :     /* Remember whether we're returning setof something */
<span class="lineNum">     666 </span><span class="lineCov">       4414 :     fcache-&gt;returnsSet = procedureStruct-&gt;proretset;</span>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            :     /* Remember if function is STABLE/IMMUTABLE */
<span class="lineNum">     669 </span><span class="lineCov">       4414 :     fcache-&gt;readonly_func =</span>
<span class="lineNum">     670 </span><span class="lineCov">       4414 :         (procedureStruct-&gt;provolatile != PROVOLATILE_VOLATILE);</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            :     /*
<span class="lineNum">     673 </span>            :      * We need the actual argument types to pass to the parser.  Also make
<span class="lineNum">     674 </span>            :      * sure that parameter symbols are considered to have the function's
<span class="lineNum">     675 </span>            :      * resolved input collation.
<span class="lineNum">     676 </span>            :      */
<span class="lineNum">     677 </span><span class="lineCov">       4414 :     fcache-&gt;pinfo = prepare_sql_fn_parse_info(procedureTuple,</span>
<span class="lineNum">     678 </span><span class="lineCov">       4414 :                                               finfo-&gt;fn_expr,</span>
<span class="lineNum">     679 </span>            :                                               collation);
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span>            :     /*
<span class="lineNum">     682 </span>            :      * And of course we need the function body text.
<span class="lineNum">     683 </span>            :      */
<span class="lineNum">     684 </span><span class="lineCov">       4414 :     tmp = SysCacheGetAttr(PROCOID,</span>
<span class="lineNum">     685 </span>            :                           procedureTuple,
<span class="lineNum">     686 </span>            :                           Anum_pg_proc_prosrc,
<span class="lineNum">     687 </span>            :                           &amp;isNull);
<span class="lineNum">     688 </span><span class="lineCov">       4414 :     if (isNull)</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;null prosrc for function %u&quot;, foid);</span>
<span class="lineNum">     690 </span><span class="lineCov">       4414 :     fcache-&gt;src = TextDatumGetCString(tmp);</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :     /*
<span class="lineNum">     693 </span>            :      * Parse and rewrite the queries in the function text.  Use sublists to
<span class="lineNum">     694 </span>            :      * keep track of the original query boundaries.  But we also build a
<span class="lineNum">     695 </span>            :      * &quot;flat&quot; list of the rewritten queries to pass to check_sql_fn_retval.
<span class="lineNum">     696 </span>            :      * This is because the last canSetTag query determines the result type
<span class="lineNum">     697 </span>            :      * independently of query boundaries --- and it might not be in the last
<span class="lineNum">     698 </span>            :      * sublist, for example if the last query rewrites to DO INSTEAD NOTHING.
<span class="lineNum">     699 </span>            :      * (It might not be unreasonable to throw an error in such a case, but
<span class="lineNum">     700 </span>            :      * this is the historical behavior and it doesn't seem worth changing.)
<span class="lineNum">     701 </span>            :      *
<span class="lineNum">     702 </span>            :      * Note: since parsing and planning is done in fcontext, we will generate
<span class="lineNum">     703 </span>            :      * a lot of cruft that lives as long as the fcache does.  This is annoying
<span class="lineNum">     704 </span>            :      * but we'll not worry about it until the module is rewritten to use
<span class="lineNum">     705 </span>            :      * plancache.c.
<span class="lineNum">     706 </span>            :      */
<span class="lineNum">     707 </span><span class="lineCov">       4414 :     raw_parsetree_list = pg_parse_query(fcache-&gt;src);</span>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineCov">       4414 :     queryTree_list = NIL;</span>
<span class="lineNum">     710 </span><span class="lineCov">       4414 :     flat_query_list = NIL;</span>
<span class="lineNum">     711 </span><span class="lineCov">       8838 :     foreach(lc, raw_parsetree_list)</span>
<span class="lineNum">     712 </span>            :     {
<span class="lineNum">     713 </span><span class="lineCov">       4424 :         RawStmt    *parsetree = lfirst_node(RawStmt, lc);</span>
<span class="lineNum">     714 </span>            :         List       *queryTree_sublist;
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span><span class="lineCov">       4424 :         queryTree_sublist = pg_analyze_and_rewrite_params(parsetree,</span>
<span class="lineNum">     717 </span><span class="lineCov">       4424 :                                                           fcache-&gt;src,</span>
<span class="lineNum">     718 </span>            :                                                           (ParserSetupHook) sql_fn_parser_setup,
<span class="lineNum">     719 </span><span class="lineCov">       4424 :                                                           fcache-&gt;pinfo,</span>
<span class="lineNum">     720 </span>            :                                                           NULL);
<span class="lineNum">     721 </span><span class="lineCov">       4424 :         queryTree_list = lappend(queryTree_list, queryTree_sublist);</span>
<span class="lineNum">     722 </span><span class="lineCov">       4424 :         flat_query_list = list_concat(flat_query_list, queryTree_sublist);</span>
<span class="lineNum">     723 </span>            :     }
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span><span class="lineCov">       4414 :     check_sql_fn_statements(flat_query_list);</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            :     /*
<span class="lineNum">     728 </span>            :      * Check that the function returns the type it claims to.  Although in
<span class="lineNum">     729 </span>            :      * simple cases this was already done when the function was defined, we
<span class="lineNum">     730 </span>            :      * have to recheck because database objects used in the function's queries
<span class="lineNum">     731 </span>            :      * might have changed type.  We'd have to do it anyway if the function had
<span class="lineNum">     732 </span>            :      * any polymorphic arguments.
<span class="lineNum">     733 </span>            :      *
<span class="lineNum">     734 </span>            :      * Note: we set fcache-&gt;returnsTuple according to whether we are returning
<span class="lineNum">     735 </span>            :      * the whole tuple result or just a single column.  In the latter case we
<span class="lineNum">     736 </span>            :      * clear returnsTuple because we need not act different from the scalar
<span class="lineNum">     737 </span>            :      * result case, even if it's a rowtype column.  (However, we have to force
<span class="lineNum">     738 </span>            :      * lazy eval mode in that case; otherwise we'd need extra code to expand
<span class="lineNum">     739 </span>            :      * the rowtype column into multiple columns, since we have no way to
<span class="lineNum">     740 </span>            :      * notify the caller that it should do that.)
<span class="lineNum">     741 </span>            :      *
<span class="lineNum">     742 </span>            :      * check_sql_fn_retval will also construct a JunkFilter we can use to
<span class="lineNum">     743 </span>            :      * coerce the returned rowtype to the desired form (unless the result type
<span class="lineNum">     744 </span>            :      * is VOID, in which case there's nothing to coerce to).
<span class="lineNum">     745 </span>            :      */
<span class="lineNum">     746 </span><span class="lineCov">       4414 :     fcache-&gt;returnsTuple = check_sql_fn_retval(foid,</span>
<span class="lineNum">     747 </span>            :                                                rettype,
<span class="lineNum">     748 </span>            :                                                flat_query_list,
<span class="lineNum">     749 </span>            :                                                NULL,
<span class="lineNum">     750 </span>            :                                                &amp;fcache-&gt;junkFilter);
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span><span class="lineCov">       4414 :     if (fcache-&gt;returnsTuple)</span>
<span class="lineNum">     753 </span>            :     {
<span class="lineNum">     754 </span>            :         /* Make sure output rowtype is properly blessed */
<span class="lineNum">     755 </span><span class="lineCov">        302 :         BlessTupleDesc(fcache-&gt;junkFilter-&gt;jf_resultSlot-&gt;tts_tupleDescriptor);</span>
<span class="lineNum">     756 </span>            :     }
<span class="lineNum">     757 </span><span class="lineCov">       4112 :     else if (fcache-&gt;returnsSet &amp;&amp; type_is_rowtype(fcache-&gt;rettype))</span>
<span class="lineNum">     758 </span>            :     {
<span class="lineNum">     759 </span>            :         /*
<span class="lineNum">     760 </span>            :          * Returning rowtype as if it were scalar --- materialize won't work.
<span class="lineNum">     761 </span>            :          * Right now it's sufficient to override any caller preference for
<span class="lineNum">     762 </span>            :          * materialize mode, but to add more smarts in init_execution_state
<span class="lineNum">     763 </span>            :          * about this, we'd probably need a three-way flag instead of bool.
<span class="lineNum">     764 </span>            :          */
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :         lazyEvalOK = true;</span>
<span class="lineNum">     766 </span>            :     }
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span>            :     /* Finally, plan the queries */
<span class="lineNum">     769 </span><span class="lineCov">       4414 :     fcache-&gt;func_state = init_execution_state(queryTree_list,</span>
<span class="lineNum">     770 </span>            :                                               fcache,
<span class="lineNum">     771 </span>            :                                               lazyEvalOK);
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            :     /* Mark fcache with time of creation to show it's valid */
<span class="lineNum">     774 </span><span class="lineCov">       4412 :     fcache-&gt;lxid = MyProc-&gt;lxid;</span>
<span class="lineNum">     775 </span><span class="lineCov">       4412 :     fcache-&gt;subxid = GetCurrentSubTransactionId();</span>
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span><span class="lineCov">       4412 :     ReleaseSysCache(procedureTuple);</span>
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span><span class="lineCov">       4412 :     MemoryContextSwitchTo(oldcontext);</span>
<span class="lineNum">     780 </span><span class="lineCov">       4412 : }</span>
<span class="lineNum">     781 </span>            : 
<a name="782"><span class="lineNum">     782 </span>            : /* Start up execution of one execution_state node */</a>
<span class="lineNum">     783 </span>            : static void
<span class="lineNum">     784 </span><span class="lineCov">       7666 : postquel_start(execution_state *es, SQLFunctionCachePtr fcache)</span>
<span class="lineNum">     785 </span>            : {
<span class="lineNum">     786 </span>            :     DestReceiver *dest;
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span><span class="lineCov">       7666 :     Assert(es-&gt;qd == NULL);</span>
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            :     /* Caller should have ensured a suitable snapshot is active */
<span class="lineNum">     791 </span><span class="lineCov">       7666 :     Assert(ActiveSnapshotSet());</span>
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span>            :     /*
<span class="lineNum">     794 </span>            :      * If this query produces the function result, send its output to the
<span class="lineNum">     795 </span>            :      * tuplestore; else discard any output.
<span class="lineNum">     796 </span>            :      */
<span class="lineNum">     797 </span><span class="lineCov">       7666 :     if (es-&gt;setsResult)</span>
<span class="lineNum">     798 </span>            :     {
<span class="lineNum">     799 </span>            :         DR_sqlfunction *myState;
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span><span class="lineCov">       7590 :         dest = CreateDestReceiver(DestSQLFunction);</span>
<span class="lineNum">     802 </span>            :         /* pass down the needed info to the dest receiver routines */
<span class="lineNum">     803 </span><span class="lineCov">       7590 :         myState = (DR_sqlfunction *) dest;</span>
<span class="lineNum">     804 </span><span class="lineCov">       7590 :         Assert(myState-&gt;pub.mydest == DestSQLFunction);</span>
<span class="lineNum">     805 </span><span class="lineCov">       7590 :         myState-&gt;tstore = fcache-&gt;tstore;</span>
<span class="lineNum">     806 </span><span class="lineCov">       7590 :         myState-&gt;cxt = CurrentMemoryContext;</span>
<span class="lineNum">     807 </span><span class="lineCov">       7590 :         myState-&gt;filter = fcache-&gt;junkFilter;</span>
<span class="lineNum">     808 </span>            :     }
<span class="lineNum">     809 </span>            :     else
<span class="lineNum">     810 </span><span class="lineCov">         76 :         dest = None_Receiver;</span>
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span><span class="lineCov">      15332 :     es-&gt;qd = CreateQueryDesc(es-&gt;stmt,</span>
<span class="lineNum">     813 </span><span class="lineCov">       7666 :                              fcache-&gt;src,</span>
<span class="lineNum">     814 </span>            :                              GetActiveSnapshot(),
<span class="lineNum">     815 </span>            :                              InvalidSnapshot,
<span class="lineNum">     816 </span>            :                              dest,
<span class="lineNum">     817 </span>            :                              fcache-&gt;paramLI,
<span class="lineNum">     818 </span><span class="lineCov">       7666 :                              es-&gt;qd ? es-&gt;qd-&gt;queryEnv : NULL,</span>
<span class="lineNum">     819 </span>            :                              0);
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span>            :     /* Utility commands don't need Executor. */
<span class="lineNum">     822 </span><span class="lineCov">       7666 :     if (es-&gt;qd-&gt;operation != CMD_UTILITY)</span>
<span class="lineNum">     823 </span>            :     {
<span class="lineNum">     824 </span>            :         /*
<span class="lineNum">     825 </span>            :          * In lazyEval mode, do not let the executor set up an AfterTrigger
<span class="lineNum">     826 </span>            :          * context.  This is necessary not just an optimization, because we
<span class="lineNum">     827 </span>            :          * mustn't exit from the function execution with a stacked
<span class="lineNum">     828 </span>            :          * AfterTrigger level still active.  We are careful not to select
<span class="lineNum">     829 </span>            :          * lazyEval mode for any statement that could possibly queue triggers.
<span class="lineNum">     830 </span>            :          */
<span class="lineNum">     831 </span>            :         int         eflags;
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span><span class="lineCov">       7646 :         if (es-&gt;lazyEval)</span>
<span class="lineNum">     834 </span><span class="lineCov">       7340 :             eflags = EXEC_FLAG_SKIP_TRIGGERS;</span>
<span class="lineNum">     835 </span>            :         else
<span class="lineNum">     836 </span><span class="lineCov">        306 :             eflags = 0;         /* default run-to-completion flags */</span>
<span class="lineNum">     837 </span><span class="lineCov">       7646 :         ExecutorStart(es-&gt;qd, eflags);</span>
<span class="lineNum">     838 </span>            :     }
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span><span class="lineCov">       7666 :     es-&gt;status = F_EXEC_RUN;</span>
<span class="lineNum">     841 </span><span class="lineCov">       7666 : }</span>
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            : /* Run one execution_state; either to completion or to first result row */
<a name="844"><span class="lineNum">     844 </span>            : /* Returns true if we ran to completion */</a>
<span class="lineNum">     845 </span>            : static bool
<span class="lineNum">     846 </span><span class="lineCov">       7946 : postquel_getnext(execution_state *es, SQLFunctionCachePtr fcache)</span>
<span class="lineNum">     847 </span>            : {
<span class="lineNum">     848 </span>            :     bool        result;
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span><span class="lineCov">       7946 :     if (es-&gt;qd-&gt;operation == CMD_UTILITY)</span>
<span class="lineNum">     851 </span>            :     {
<span class="lineNum">     852 </span><span class="lineCov">         80 :         ProcessUtility(es-&gt;qd-&gt;plannedstmt,</span>
<span class="lineNum">     853 </span><span class="lineCov">         20 :                        fcache-&gt;src,</span>
<span class="lineNum">     854 </span>            :                        PROCESS_UTILITY_QUERY,
<span class="lineNum">     855 </span><span class="lineCov">         20 :                        es-&gt;qd-&gt;params,</span>
<span class="lineNum">     856 </span><span class="lineCov">         20 :                        es-&gt;qd-&gt;queryEnv,</span>
<span class="lineNum">     857 </span><span class="lineCov">         20 :                        es-&gt;qd-&gt;dest,</span>
<span class="lineNum">     858 </span>            :                        NULL);
<span class="lineNum">     859 </span><span class="lineCov">         14 :         result = true;          /* never stops early */</span>
<span class="lineNum">     860 </span>            :     }
<span class="lineNum">     861 </span>            :     else
<span class="lineNum">     862 </span>            :     {
<span class="lineNum">     863 </span>            :         /* Run regular commands to completion unless lazyEval */
<span class="lineNum">     864 </span><span class="lineCov">       7926 :         uint64      count = (es-&gt;lazyEval) ? 1 : 0;</span>
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span><span class="lineCov">       7926 :         ExecutorRun(es-&gt;qd, ForwardScanDirection, count, !fcache-&gt;returnsSet || !es-&gt;lazyEval);</span>
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            :         /*
<span class="lineNum">     869 </span>            :          * If we requested run to completion OR there was no tuple returned,
<span class="lineNum">     870 </span>            :          * command must be complete.
<span class="lineNum">     871 </span>            :          */
<span class="lineNum">     872 </span><span class="lineCov">       4806 :         result = (count == 0 || es-&gt;qd-&gt;estate-&gt;es_processed == 0);</span>
<span class="lineNum">     873 </span>            :     }
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span><span class="lineCov">       4820 :     return result;</span>
<span class="lineNum">     876 </span>            : }
<span class="lineNum">     877 </span>            : 
<a name="878"><span class="lineNum">     878 </span>            : /* Shut down execution of one execution_state node */</a>
<span class="lineNum">     879 </span>            : static void
<span class="lineNum">     880 </span><span class="lineCov">       4540 : postquel_end(execution_state *es)</span>
<span class="lineNum">     881 </span>            : {
<span class="lineNum">     882 </span>            :     /* mark status done to ensure we don't do ExecutorEnd twice */
<span class="lineNum">     883 </span><span class="lineCov">       4540 :     es-&gt;status = F_EXEC_DONE;</span>
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            :     /* Utility commands don't need Executor. */
<span class="lineNum">     886 </span><span class="lineCov">       4540 :     if (es-&gt;qd-&gt;operation != CMD_UTILITY)</span>
<span class="lineNum">     887 </span>            :     {
<span class="lineNum">     888 </span><span class="lineCov">       4526 :         ExecutorFinish(es-&gt;qd);</span>
<span class="lineNum">     889 </span><span class="lineCov">       4526 :         ExecutorEnd(es-&gt;qd);</span>
<span class="lineNum">     890 </span>            :     }
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span><span class="lineCov">       4540 :     es-&gt;qd-&gt;dest-&gt;rDestroy(es-&gt;qd-&gt;dest);</span>
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span><span class="lineCov">       4540 :     FreeQueryDesc(es-&gt;qd);</span>
<span class="lineNum">     895 </span><span class="lineCov">       4540 :     es-&gt;qd = NULL;</span>
<span class="lineNum">     896 </span><span class="lineCov">       4540 : }</span>
<span class="lineNum">     897 </span>            : 
<a name="898"><span class="lineNum">     898 </span>            : /* Build ParamListInfo array representing current arguments */</a>
<span class="lineNum">     899 </span>            : static void
<span class="lineNum">     900 </span><span class="lineCov">       7654 : postquel_sub_params(SQLFunctionCachePtr fcache,</span>
<span class="lineNum">     901 </span>            :                     FunctionCallInfo fcinfo)
<span class="lineNum">     902 </span>            : {
<span class="lineNum">     903 </span><span class="lineCov">       7654 :     int         nargs = fcinfo-&gt;nargs;</span>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span><span class="lineCov">       7654 :     if (nargs &gt; 0)</span>
<span class="lineNum">     906 </span>            :     {
<span class="lineNum">     907 </span>            :         ParamListInfo paramLI;
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span><span class="lineCov">       4462 :         if (fcache-&gt;paramLI == NULL)</span>
<span class="lineNum">     910 </span>            :         {
<span class="lineNum">     911 </span><span class="lineCov">       1232 :             paramLI = makeParamList(nargs);</span>
<span class="lineNum">     912 </span><span class="lineCov">       1232 :             fcache-&gt;paramLI = paramLI;</span>
<span class="lineNum">     913 </span>            :         }
<span class="lineNum">     914 </span>            :         else
<span class="lineNum">     915 </span>            :         {
<span class="lineNum">     916 </span><span class="lineCov">       3230 :             paramLI = fcache-&gt;paramLI;</span>
<span class="lineNum">     917 </span><span class="lineCov">       3230 :             Assert(paramLI-&gt;numParams == nargs);</span>
<span class="lineNum">     918 </span>            :         }
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span><span class="lineCov">      12192 :         for (int i = 0; i &lt; nargs; i++)</span>
<span class="lineNum">     921 </span>            :         {
<span class="lineNum">     922 </span><span class="lineCov">       7730 :             ParamExternData *prm = &amp;paramLI-&gt;params[i];</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span><span class="lineCov">       7730 :             prm-&gt;value = fcinfo-&gt;args[i].value;</span>
<span class="lineNum">     925 </span><span class="lineCov">       7730 :             prm-&gt;isnull = fcinfo-&gt;args[i].isnull;</span>
<span class="lineNum">     926 </span><span class="lineCov">       7730 :             prm-&gt;pflags = 0;</span>
<span class="lineNum">     927 </span><span class="lineCov">       7730 :             prm-&gt;ptype = fcache-&gt;pinfo-&gt;argtypes[i];</span>
<span class="lineNum">     928 </span>            :         }
<span class="lineNum">     929 </span>            :     }
<span class="lineNum">     930 </span>            :     else
<span class="lineNum">     931 </span><span class="lineCov">       3192 :         fcache-&gt;paramLI = NULL;</span>
<span class="lineNum">     932 </span><span class="lineCov">       7654 : }</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            : /*
<span class="lineNum">     935 </span>            :  * Extract the SQL function's value from a single result row.  This is used
<span class="lineNum">     936 </span>            :  * both for scalar (non-set) functions and for each row of a lazy-eval set
<span class="lineNum">     937 </span>            :  * result.
<a name="938"><span class="lineNum">     938 </span>            :  */</a>
<span class="lineNum">     939 </span>            : static Datum
<span class="lineNum">     940 </span><span class="lineCov">       2604 : postquel_get_single_result(TupleTableSlot *slot,</span>
<span class="lineNum">     941 </span>            :                            FunctionCallInfo fcinfo,
<span class="lineNum">     942 </span>            :                            SQLFunctionCachePtr fcache,
<span class="lineNum">     943 </span>            :                            MemoryContext resultcontext)
<span class="lineNum">     944 </span>            : {
<span class="lineNum">     945 </span>            :     Datum       value;
<span class="lineNum">     946 </span>            :     MemoryContext oldcontext;
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span>            :     /*
<span class="lineNum">     949 </span>            :      * Set up to return the function value.  For pass-by-reference datatypes,
<span class="lineNum">     950 </span>            :      * be sure to allocate the result in resultcontext, not the current memory
<span class="lineNum">     951 </span>            :      * context (which has query lifespan).  We can't leave the data in the
<span class="lineNum">     952 </span>            :      * TupleTableSlot because we intend to clear the slot before returning.
<span class="lineNum">     953 </span>            :      */
<span class="lineNum">     954 </span><span class="lineCov">       2604 :     oldcontext = MemoryContextSwitchTo(resultcontext);</span>
<span class="lineNum">     955 </span>            : 
<span class="lineNum">     956 </span><span class="lineCov">       2604 :     if (fcache-&gt;returnsTuple)</span>
<span class="lineNum">     957 </span>            :     {
<span class="lineNum">     958 </span>            :         /* We must return the whole tuple as a Datum. */
<span class="lineNum">     959 </span><span class="lineCov">        384 :         fcinfo-&gt;isnull = false;</span>
<span class="lineNum">     960 </span><span class="lineCov">        384 :         value = ExecFetchSlotHeapTupleDatum(slot);</span>
<span class="lineNum">     961 </span>            :     }
<span class="lineNum">     962 </span>            :     else
<span class="lineNum">     963 </span>            :     {
<span class="lineNum">     964 </span>            :         /*
<span class="lineNum">     965 </span>            :          * Returning a scalar, which we have to extract from the first column
<span class="lineNum">     966 </span>            :          * of the SELECT result, and then copy into result context if needed.
<span class="lineNum">     967 </span>            :          */
<span class="lineNum">     968 </span><span class="lineCov">       2220 :         value = slot_getattr(slot, 1, &amp;(fcinfo-&gt;isnull));</span>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span><span class="lineCov">       2220 :         if (!fcinfo-&gt;isnull)</span>
<span class="lineNum">     971 </span><span class="lineCov">       2100 :             value = datumCopy(value, fcache-&gt;typbyval, fcache-&gt;typlen);</span>
<span class="lineNum">     972 </span>            :     }
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span><span class="lineCov">       2604 :     MemoryContextSwitchTo(oldcontext);</span>
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span><span class="lineCov">       2604 :     return value;</span>
<span class="lineNum">     977 </span>            : }
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span>            : /*
<span class="lineNum">     980 </span>            :  * fmgr_sql: function call manager for SQL functions
<a name="981"><span class="lineNum">     981 </span>            :  */</a>
<span class="lineNum">     982 </span>            : Datum
<span class="lineNum">     983 </span><span class="lineCov">       7936 : fmgr_sql(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     984 </span>            : {
<span class="lineNum">     985 </span>            :     SQLFunctionCachePtr fcache;
<span class="lineNum">     986 </span>            :     ErrorContextCallback sqlerrcontext;
<span class="lineNum">     987 </span>            :     MemoryContext oldcontext;
<span class="lineNum">     988 </span>            :     bool        randomAccess;
<span class="lineNum">     989 </span>            :     bool        lazyEvalOK;
<span class="lineNum">     990 </span>            :     bool        is_first;
<span class="lineNum">     991 </span>            :     bool        pushed_snapshot;
<span class="lineNum">     992 </span>            :     execution_state *es;
<span class="lineNum">     993 </span>            :     TupleTableSlot *slot;
<span class="lineNum">     994 </span>            :     Datum       result;
<span class="lineNum">     995 </span>            :     List       *eslist;
<span class="lineNum">     996 </span>            :     ListCell   *eslc;
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            :     /*
<span class="lineNum">     999 </span>            :      * Setup error traceback support for ereport()
<span class="lineNum">    1000 </span>            :      */
<span class="lineNum">    1001 </span><span class="lineCov">       7936 :     sqlerrcontext.callback = sql_exec_error_callback;</span>
<span class="lineNum">    1002 </span><span class="lineCov">       7936 :     sqlerrcontext.arg = fcinfo-&gt;flinfo;</span>
<span class="lineNum">    1003 </span><span class="lineCov">       7936 :     sqlerrcontext.previous = error_context_stack;</span>
<span class="lineNum">    1004 </span><span class="lineCov">       7936 :     error_context_stack = &amp;sqlerrcontext;</span>
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span>            :     /* Check call context */
<span class="lineNum">    1007 </span><span class="lineCov">       7936 :     if (fcinfo-&gt;flinfo-&gt;fn_retset)</span>
<span class="lineNum">    1008 </span>            :     {
<span class="lineNum">    1009 </span><span class="lineCov">       1542 :         ReturnSetInfo *rsi = (ReturnSetInfo *) fcinfo-&gt;resultinfo;</span>
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            :         /*
<span class="lineNum">    1012 </span>            :          * For simplicity, we require callers to support both set eval modes.
<span class="lineNum">    1013 </span>            :          * There are cases where we must use one or must use the other, and
<span class="lineNum">    1014 </span>            :          * it's not really worthwhile to postpone the check till we know. But
<span class="lineNum">    1015 </span>            :          * note we do not require caller to provide an expectedDesc.
<span class="lineNum">    1016 </span>            :          */
<span class="lineNum">    1017 </span><span class="lineCov">       3084 :         if (!rsi || !IsA(rsi, ReturnSetInfo) ||</span>
<span class="lineNum">    1018 </span><span class="lineCov">       3084 :             (rsi-&gt;allowedModes &amp; SFRM_ValuePerCall) == 0 ||</span>
<span class="lineNum">    1019 </span><span class="lineCov">       1542 :             (rsi-&gt;allowedModes &amp; SFRM_Materialize) == 0)</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">    1021 </span>            :                     (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">    1022 </span>            :                      errmsg(&quot;set-valued function called in context that cannot accept a set&quot;)));
<span class="lineNum">    1023 </span><span class="lineCov">       1542 :         randomAccess = rsi-&gt;allowedModes &amp; SFRM_Materialize_Random;</span>
<span class="lineNum">    1024 </span><span class="lineCov">       1542 :         lazyEvalOK = !(rsi-&gt;allowedModes &amp; SFRM_Materialize_Preferred);</span>
<span class="lineNum">    1025 </span>            :     }
<span class="lineNum">    1026 </span>            :     else
<span class="lineNum">    1027 </span>            :     {
<span class="lineNum">    1028 </span><span class="lineCov">       6394 :         randomAccess = false;</span>
<span class="lineNum">    1029 </span><span class="lineCov">       6394 :         lazyEvalOK = true;</span>
<span class="lineNum">    1030 </span>            :     }
<span class="lineNum">    1031 </span>            : 
<span class="lineNum">    1032 </span>            :     /*
<span class="lineNum">    1033 </span>            :      * Initialize fcache (build plans) if first time through; or re-initialize
<span class="lineNum">    1034 </span>            :      * if the cache is stale.
<span class="lineNum">    1035 </span>            :      */
<span class="lineNum">    1036 </span><span class="lineCov">       7936 :     fcache = (SQLFunctionCachePtr) fcinfo-&gt;flinfo-&gt;fn_extra;</span>
<span class="lineNum">    1037 </span>            : 
<span class="lineNum">    1038 </span><span class="lineCov">       7936 :     if (fcache != NULL)</span>
<span class="lineNum">    1039 </span>            :     {
<span class="lineNum">    1040 </span><span class="lineCov">       7058 :         if (fcache-&gt;lxid != MyProc-&gt;lxid ||</span>
<span class="lineNum">    1041 </span><span class="lineCov">       3522 :             !SubTransactionIsActive(fcache-&gt;subxid))</span>
<span class="lineNum">    1042 </span>            :         {
<span class="lineNum">    1043 </span>            :             /* It's stale; unlink and delete */
<span class="lineNum">    1044 </span><span class="lineCov">         14 :             fcinfo-&gt;flinfo-&gt;fn_extra = NULL;</span>
<span class="lineNum">    1045 </span><span class="lineCov">         14 :             MemoryContextDelete(fcache-&gt;fcontext);</span>
<span class="lineNum">    1046 </span><span class="lineCov">         14 :             fcache = NULL;</span>
<span class="lineNum">    1047 </span>            :         }
<span class="lineNum">    1048 </span>            :     }
<span class="lineNum">    1049 </span>            : 
<span class="lineNum">    1050 </span><span class="lineCov">       7936 :     if (fcache == NULL)</span>
<span class="lineNum">    1051 </span>            :     {
<span class="lineNum">    1052 </span><span class="lineCov">       4414 :         init_sql_fcache(fcinfo-&gt;flinfo, PG_GET_COLLATION(), lazyEvalOK);</span>
<span class="lineNum">    1053 </span><span class="lineCov">       4412 :         fcache = (SQLFunctionCachePtr) fcinfo-&gt;flinfo-&gt;fn_extra;</span>
<span class="lineNum">    1054 </span>            :     }
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span>            :     /*
<span class="lineNum">    1057 </span>            :      * Switch to context in which the fcache lives.  This ensures that our
<span class="lineNum">    1058 </span>            :      * tuplestore etc will have sufficient lifetime.  The sub-executor is
<span class="lineNum">    1059 </span>            :      * responsible for deleting per-tuple information.  (XXX in the case of a
<span class="lineNum">    1060 </span>            :      * long-lived FmgrInfo, this policy represents more memory leakage, but
<span class="lineNum">    1061 </span>            :      * it's not entirely clear where to keep stuff instead.)
<span class="lineNum">    1062 </span>            :      */
<span class="lineNum">    1063 </span><span class="lineCov">       7934 :     oldcontext = MemoryContextSwitchTo(fcache-&gt;fcontext);</span>
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span>            :     /*
<span class="lineNum">    1066 </span>            :      * Find first unfinished query in function, and note whether it's the
<span class="lineNum">    1067 </span>            :      * first query.
<span class="lineNum">    1068 </span>            :      */
<span class="lineNum">    1069 </span><span class="lineCov">       7934 :     eslist = fcache-&gt;func_state;</span>
<span class="lineNum">    1070 </span><span class="lineCov">       7934 :     es = NULL;</span>
<span class="lineNum">    1071 </span><span class="lineCov">       7934 :     is_first = true;</span>
<span class="lineNum">    1072 </span><span class="lineCov">       7934 :     foreach(eslc, eslist)</span>
<span class="lineNum">    1073 </span>            :     {
<span class="lineNum">    1074 </span><span class="lineCov">       7934 :         es = (execution_state *) lfirst(eslc);</span>
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span><span class="lineCov">      15868 :         while (es &amp;&amp; es-&gt;status == F_EXEC_DONE)</span>
<span class="lineNum">    1077 </span>            :         {
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :             is_first = false;</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :             es = es-&gt;next;</span>
<span class="lineNum">    1080 </span>            :         }
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span><span class="lineCov">       7934 :         if (es)</span>
<span class="lineNum">    1083 </span><span class="lineCov">       7934 :             break;</span>
<span class="lineNum">    1084 </span>            :     }
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span>            :     /*
<span class="lineNum">    1087 </span>            :      * Convert params to appropriate format if starting a fresh execution. (If
<span class="lineNum">    1088 </span>            :      * continuing execution, we can re-use prior params.)
<span class="lineNum">    1089 </span>            :      */
<span class="lineNum">    1090 </span><span class="lineCov">       7934 :     if (is_first &amp;&amp; es &amp;&amp; es-&gt;status == F_EXEC_START)</span>
<span class="lineNum">    1091 </span><span class="lineCov">       7654 :         postquel_sub_params(fcache, fcinfo);</span>
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span>            :     /*
<span class="lineNum">    1094 </span>            :      * Build tuplestore to hold results, if we don't have one already. Note
<span class="lineNum">    1095 </span>            :      * it's in the query-lifespan context.
<span class="lineNum">    1096 </span>            :      */
<span class="lineNum">    1097 </span><span class="lineCov">       7934 :     if (!fcache-&gt;tstore)</span>
<span class="lineNum">    1098 </span><span class="lineCov">       4468 :         fcache-&gt;tstore = tuplestore_begin_heap(randomAccess, false, work_mem);</span>
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span>            :     /*
<span class="lineNum">    1101 </span>            :      * Execute each command in the function one after another until we either
<span class="lineNum">    1102 </span>            :      * run out of commands or get a result row from a lazily-evaluated SELECT.
<span class="lineNum">    1103 </span>            :      *
<span class="lineNum">    1104 </span>            :      * Notes about snapshot management:
<span class="lineNum">    1105 </span>            :      *
<span class="lineNum">    1106 </span>            :      * In a read-only function, we just use the surrounding query's snapshot.
<span class="lineNum">    1107 </span>            :      *
<span class="lineNum">    1108 </span>            :      * In a non-read-only function, we rely on the fact that we'll never
<span class="lineNum">    1109 </span>            :      * suspend execution between queries of the function: the only reason to
<span class="lineNum">    1110 </span>            :      * suspend execution before completion is if we are returning a row from a
<span class="lineNum">    1111 </span>            :      * lazily-evaluated SELECT.  So, when first entering this loop, we'll
<span class="lineNum">    1112 </span>            :      * either start a new query (and push a fresh snapshot) or re-establish
<span class="lineNum">    1113 </span>            :      * the active snapshot from the existing query descriptor.  If we need to
<span class="lineNum">    1114 </span>            :      * start a new query in a subsequent execution of the loop, either we need
<span class="lineNum">    1115 </span>            :      * a fresh snapshot (and pushed_snapshot is false) or the existing
<span class="lineNum">    1116 </span>            :      * snapshot is on the active stack and we can just bump its command ID.
<span class="lineNum">    1117 </span>            :      */
<span class="lineNum">    1118 </span><span class="lineCov">       7934 :     pushed_snapshot = false;</span>
<span class="lineNum">    1119 </span><span class="lineCov">      20408 :     while (es)</span>
<span class="lineNum">    1120 </span>            :     {
<span class="lineNum">    1121 </span>            :         bool        completed;
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span><span class="lineCov">       7946 :         if (es-&gt;status == F_EXEC_START)</span>
<span class="lineNum">    1124 </span>            :         {
<span class="lineNum">    1125 </span>            :             /*
<span class="lineNum">    1126 </span>            :              * If not read-only, be sure to advance the command counter for
<span class="lineNum">    1127 </span>            :              * each command, so that all work to date in this transaction is
<span class="lineNum">    1128 </span>            :              * visible.  Take a new snapshot if we don't have one yet,
<span class="lineNum">    1129 </span>            :              * otherwise just bump the command ID in the existing snapshot.
<span class="lineNum">    1130 </span>            :              */
<span class="lineNum">    1131 </span><span class="lineCov">       7666 :             if (!fcache-&gt;readonly_func)</span>
<span class="lineNum">    1132 </span>            :             {
<span class="lineNum">    1133 </span><span class="lineCov">       5556 :                 CommandCounterIncrement();</span>
<span class="lineNum">    1134 </span><span class="lineCov">       5556 :                 if (!pushed_snapshot)</span>
<span class="lineNum">    1135 </span>            :                 {
<span class="lineNum">    1136 </span><span class="lineCov">       5554 :                     PushActiveSnapshot(GetTransactionSnapshot());</span>
<span class="lineNum">    1137 </span><span class="lineCov">       5554 :                     pushed_snapshot = true;</span>
<span class="lineNum">    1138 </span>            :                 }
<span class="lineNum">    1139 </span>            :                 else
<span class="lineNum">    1140 </span><span class="lineCov">          2 :                     UpdateActiveSnapshotCommandId();</span>
<span class="lineNum">    1141 </span>            :             }
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span><span class="lineCov">       7666 :             postquel_start(es, fcache);</span>
<span class="lineNum">    1144 </span>            :         }
<span class="lineNum">    1145 </span><span class="lineCov">        280 :         else if (!fcache-&gt;readonly_func &amp;&amp; !pushed_snapshot)</span>
<span class="lineNum">    1146 </span>            :         {
<span class="lineNum">    1147 </span>            :             /* Re-establish active snapshot when re-entering function */
<span class="lineNum">    1148 </span><span class="lineCov">        202 :             PushActiveSnapshot(es-&gt;qd-&gt;snapshot);</span>
<span class="lineNum">    1149 </span><span class="lineCov">        202 :             pushed_snapshot = true;</span>
<span class="lineNum">    1150 </span>            :         }
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span><span class="lineCov">       7946 :         completed = postquel_getnext(es, fcache);</span>
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span>            :         /*
<span class="lineNum">    1155 </span>            :          * If we ran the command to completion, we can shut it down now. Any
<span class="lineNum">    1156 </span>            :          * row(s) we need to return are safely stashed in the tuplestore, and
<span class="lineNum">    1157 </span>            :          * we want to be sure that, for example, AFTER triggers get fired
<span class="lineNum">    1158 </span>            :          * before we return anything.  Also, if the function doesn't return
<span class="lineNum">    1159 </span>            :          * set, we can shut it down anyway because it must be a SELECT and we
<span class="lineNum">    1160 </span>            :          * don't care about fetching any more result rows.
<span class="lineNum">    1161 </span>            :          */
<span class="lineNum">    1162 </span><span class="lineCov">       4820 :         if (completed || !fcache-&gt;returnsSet)</span>
<span class="lineNum">    1163 </span><span class="lineCov">       4540 :             postquel_end(es);</span>
<span class="lineNum">    1164 </span>            : 
<span class="lineNum">    1165 </span>            :         /*
<span class="lineNum">    1166 </span>            :          * Break from loop if we didn't shut down (implying we got a
<span class="lineNum">    1167 </span>            :          * lazily-evaluated row).  Otherwise we'll press on till the whole
<span class="lineNum">    1168 </span>            :          * function is done, relying on the tuplestore to keep hold of the
<span class="lineNum">    1169 </span>            :          * data to eventually be returned.  This is necessary since an
<span class="lineNum">    1170 </span>            :          * INSERT/UPDATE/DELETE RETURNING that sets the result might be
<span class="lineNum">    1171 </span>            :          * followed by additional rule-inserted commands, and we want to
<span class="lineNum">    1172 </span>            :          * finish doing all those commands before we return anything.
<span class="lineNum">    1173 </span>            :          */
<span class="lineNum">    1174 </span><span class="lineCov">       4820 :         if (es-&gt;status != F_EXEC_DONE)</span>
<span class="lineNum">    1175 </span><span class="lineCov">        280 :             break;</span>
<span class="lineNum">    1176 </span>            : 
<span class="lineNum">    1177 </span>            :         /*
<span class="lineNum">    1178 </span>            :          * Advance to next execution_state, which might be in the next list.
<span class="lineNum">    1179 </span>            :          */
<span class="lineNum">    1180 </span><span class="lineCov">       4540 :         es = es-&gt;next;</span>
<span class="lineNum">    1181 </span><span class="lineCov">       9090 :         while (!es)</span>
<span class="lineNum">    1182 </span>            :         {
<span class="lineNum">    1183 </span><span class="lineCov">       4538 :             eslc = lnext(eslist, eslc);</span>
<span class="lineNum">    1184 </span><span class="lineCov">       4538 :             if (!eslc)</span>
<span class="lineNum">    1185 </span><span class="lineCov">       4528 :                 break;          /* end of function */</span>
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span><span class="lineCov">         10 :             es = (execution_state *) lfirst(eslc);</span>
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span>            :             /*
<span class="lineNum">    1190 </span>            :              * Flush the current snapshot so that we will take a new one for
<span class="lineNum">    1191 </span>            :              * the new query list.  This ensures that new snaps are taken at
<span class="lineNum">    1192 </span>            :              * original-query boundaries, matching the behavior of interactive
<span class="lineNum">    1193 </span>            :              * execution.
<span class="lineNum">    1194 </span>            :              */
<span class="lineNum">    1195 </span><span class="lineCov">         10 :             if (pushed_snapshot)</span>
<span class="lineNum">    1196 </span>            :             {
<span class="lineNum">    1197 </span><span class="lineCov">         10 :                 PopActiveSnapshot();</span>
<span class="lineNum">    1198 </span><span class="lineCov">         10 :                 pushed_snapshot = false;</span>
<span class="lineNum">    1199 </span>            :             }
<span class="lineNum">    1200 </span>            :         }
<span class="lineNum">    1201 </span>            :     }
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span>            :     /*
<span class="lineNum">    1204 </span>            :      * The tuplestore now contains whatever row(s) we are supposed to return.
<span class="lineNum">    1205 </span>            :      */
<span class="lineNum">    1206 </span><span class="lineCov">       4808 :     if (fcache-&gt;returnsSet)</span>
<span class="lineNum">    1207 </span>            :     {
<span class="lineNum">    1208 </span><span class="lineCov">       1542 :         ReturnSetInfo *rsi = (ReturnSetInfo *) fcinfo-&gt;resultinfo;</span>
<span class="lineNum">    1209 </span>            : 
<span class="lineNum">    1210 </span><span class="lineCov">       1542 :         if (es)</span>
<span class="lineNum">    1211 </span>            :         {
<span class="lineNum">    1212 </span>            :             /*
<span class="lineNum">    1213 </span>            :              * If we stopped short of being done, we must have a lazy-eval
<span class="lineNum">    1214 </span>            :              * row.
<span class="lineNum">    1215 </span>            :              */
<span class="lineNum">    1216 </span><span class="lineCov">        280 :             Assert(es-&gt;lazyEval);</span>
<span class="lineNum">    1217 </span>            :             /* Re-use the junkfilter's output slot to fetch back the tuple */
<span class="lineNum">    1218 </span><span class="lineCov">        280 :             Assert(fcache-&gt;junkFilter);</span>
<span class="lineNum">    1219 </span><span class="lineCov">        280 :             slot = fcache-&gt;junkFilter-&gt;jf_resultSlot;</span>
<span class="lineNum">    1220 </span><span class="lineCov">        280 :             if (!tuplestore_gettupleslot(fcache-&gt;tstore, true, false, slot))</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :                 elog(ERROR, &quot;failed to fetch lazy-eval tuple&quot;);</span>
<span class="lineNum">    1222 </span>            :             /* Extract the result as a datum, and copy out from the slot */
<span class="lineNum">    1223 </span><span class="lineCov">        280 :             result = postquel_get_single_result(slot, fcinfo,</span>
<span class="lineNum">    1224 </span>            :                                                 fcache, oldcontext);
<span class="lineNum">    1225 </span>            :             /* Clear the tuplestore, but keep it for next time */
<span class="lineNum">    1226 </span>            :             /* NB: this might delete the slot's content, but we don't care */
<span class="lineNum">    1227 </span><span class="lineCov">        280 :             tuplestore_clear(fcache-&gt;tstore);</span>
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            :             /*
<span class="lineNum">    1230 </span>            :              * Let caller know we're not finished.
<span class="lineNum">    1231 </span>            :              */
<span class="lineNum">    1232 </span><span class="lineCov">        280 :             rsi-&gt;isDone = ExprMultipleResult;</span>
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span>            :             /*
<span class="lineNum">    1235 </span>            :              * Ensure we will get shut down cleanly if the exprcontext is not
<span class="lineNum">    1236 </span>            :              * run to completion.
<span class="lineNum">    1237 </span>            :              */
<span class="lineNum">    1238 </span><span class="lineCov">        280 :             if (!fcache-&gt;shutdown_reg)</span>
<span class="lineNum">    1239 </span>            :             {
<span class="lineNum">    1240 </span><span class="lineCov">        210 :                 RegisterExprContextCallback(rsi-&gt;econtext,</span>
<span class="lineNum">    1241 </span>            :                                             ShutdownSQLFunction,
<span class="lineNum">    1242 </span>            :                                             PointerGetDatum(fcache));
<span class="lineNum">    1243 </span><span class="lineCov">        210 :                 fcache-&gt;shutdown_reg = true;</span>
<span class="lineNum">    1244 </span>            :             }
<span class="lineNum">    1245 </span>            :         }
<span class="lineNum">    1246 </span><span class="lineCov">       1262 :         else if (fcache-&gt;lazyEval)</span>
<span class="lineNum">    1247 </span>            :         {
<span class="lineNum">    1248 </span>            :             /*
<span class="lineNum">    1249 </span>            :              * We are done with a lazy evaluation.  Clean up.
<span class="lineNum">    1250 </span>            :              */
<span class="lineNum">    1251 </span><span class="lineCov">       1020 :             tuplestore_clear(fcache-&gt;tstore);</span>
<span class="lineNum">    1252 </span>            : 
<span class="lineNum">    1253 </span>            :             /*
<span class="lineNum">    1254 </span>            :              * Let caller know we're finished.
<span class="lineNum">    1255 </span>            :              */
<span class="lineNum">    1256 </span><span class="lineCov">       1020 :             rsi-&gt;isDone = ExprEndResult;</span>
<span class="lineNum">    1257 </span>            : 
<span class="lineNum">    1258 </span><span class="lineCov">       1020 :             fcinfo-&gt;isnull = true;</span>
<span class="lineNum">    1259 </span><span class="lineCov">       1020 :             result = (Datum) 0;</span>
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span>            :             /* Deregister shutdown callback, if we made one */
<span class="lineNum">    1262 </span><span class="lineCov">       1020 :             if (fcache-&gt;shutdown_reg)</span>
<span class="lineNum">    1263 </span>            :             {
<span class="lineNum">    1264 </span><span class="lineCov">        210 :                 UnregisterExprContextCallback(rsi-&gt;econtext,</span>
<span class="lineNum">    1265 </span>            :                                               ShutdownSQLFunction,
<span class="lineNum">    1266 </span>            :                                               PointerGetDatum(fcache));
<span class="lineNum">    1267 </span><span class="lineCov">        210 :                 fcache-&gt;shutdown_reg = false;</span>
<span class="lineNum">    1268 </span>            :             }
<span class="lineNum">    1269 </span>            :         }
<span class="lineNum">    1270 </span>            :         else
<span class="lineNum">    1271 </span>            :         {
<span class="lineNum">    1272 </span>            :             /*
<span class="lineNum">    1273 </span>            :              * We are done with a non-lazy evaluation.  Return whatever is in
<span class="lineNum">    1274 </span>            :              * the tuplestore.  (It is now caller's responsibility to free the
<span class="lineNum">    1275 </span>            :              * tuplestore when done.)
<span class="lineNum">    1276 </span>            :              */
<span class="lineNum">    1277 </span><span class="lineCov">        242 :             rsi-&gt;returnMode = SFRM_Materialize;</span>
<span class="lineNum">    1278 </span><span class="lineCov">        242 :             rsi-&gt;setResult = fcache-&gt;tstore;</span>
<span class="lineNum">    1279 </span><span class="lineCov">        242 :             fcache-&gt;tstore = NULL;</span>
<span class="lineNum">    1280 </span>            :             /* must copy desc because execSRF.c will free it */
<span class="lineNum">    1281 </span><span class="lineCov">        242 :             if (fcache-&gt;junkFilter)</span>
<span class="lineNum">    1282 </span><span class="lineCov">        240 :                 rsi-&gt;setDesc = CreateTupleDescCopy(fcache-&gt;junkFilter-&gt;jf_cleanTupType);</span>
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span><span class="lineCov">        242 :             fcinfo-&gt;isnull = true;</span>
<span class="lineNum">    1285 </span><span class="lineCov">        242 :             result = (Datum) 0;</span>
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            :             /* Deregister shutdown callback, if we made one */
<span class="lineNum">    1288 </span><span class="lineCov">        242 :             if (fcache-&gt;shutdown_reg)</span>
<span class="lineNum">    1289 </span>            :             {
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :                 UnregisterExprContextCallback(rsi-&gt;econtext,</span>
<span class="lineNum">    1291 </span>            :                                               ShutdownSQLFunction,
<span class="lineNum">    1292 </span>            :                                               PointerGetDatum(fcache));
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :                 fcache-&gt;shutdown_reg = false;</span>
<span class="lineNum">    1294 </span>            :             }
<span class="lineNum">    1295 </span>            :         }
<span class="lineNum">    1296 </span>            :     }
<span class="lineNum">    1297 </span>            :     else
<span class="lineNum">    1298 </span>            :     {
<span class="lineNum">    1299 </span>            :         /*
<span class="lineNum">    1300 </span>            :          * Non-set function.  If we got a row, return it; else return NULL.
<span class="lineNum">    1301 </span>            :          */
<span class="lineNum">    1302 </span><span class="lineCov">       3266 :         if (fcache-&gt;junkFilter)</span>
<span class="lineNum">    1303 </span>            :         {
<span class="lineNum">    1304 </span>            :             /* Re-use the junkfilter's output slot to fetch back the tuple */
<span class="lineNum">    1305 </span><span class="lineCov">       3210 :             slot = fcache-&gt;junkFilter-&gt;jf_resultSlot;</span>
<span class="lineNum">    1306 </span><span class="lineCov">       3210 :             if (tuplestore_gettupleslot(fcache-&gt;tstore, true, false, slot))</span>
<span class="lineNum">    1307 </span><span class="lineCov">       2324 :                 result = postquel_get_single_result(slot, fcinfo,</span>
<span class="lineNum">    1308 </span>            :                                                     fcache, oldcontext);
<span class="lineNum">    1309 </span>            :             else
<span class="lineNum">    1310 </span>            :             {
<span class="lineNum">    1311 </span><span class="lineCov">        886 :                 fcinfo-&gt;isnull = true;</span>
<span class="lineNum">    1312 </span><span class="lineCov">        886 :                 result = (Datum) 0;</span>
<span class="lineNum">    1313 </span>            :             }
<span class="lineNum">    1314 </span>            :         }
<span class="lineNum">    1315 </span>            :         else
<span class="lineNum">    1316 </span>            :         {
<span class="lineNum">    1317 </span>            :             /* Should only get here for VOID functions and procedures */
<span class="lineNum">    1318 </span><span class="lineCov">         56 :             Assert(fcache-&gt;rettype == VOIDOID);</span>
<span class="lineNum">    1319 </span><span class="lineCov">         56 :             fcinfo-&gt;isnull = true;</span>
<span class="lineNum">    1320 </span><span class="lineCov">         56 :             result = (Datum) 0;</span>
<span class="lineNum">    1321 </span>            :         }
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span>            :         /* Clear the tuplestore, but keep it for next time */
<span class="lineNum">    1324 </span><span class="lineCov">       3266 :         tuplestore_clear(fcache-&gt;tstore);</span>
<span class="lineNum">    1325 </span>            :     }
<span class="lineNum">    1326 </span>            : 
<span class="lineNum">    1327 </span>            :     /* Pop snapshot if we have pushed one */
<span class="lineNum">    1328 </span><span class="lineCov">       4808 :     if (pushed_snapshot)</span>
<span class="lineNum">    1329 </span><span class="lineCov">       2634 :         PopActiveSnapshot();</span>
<span class="lineNum">    1330 </span>            : 
<span class="lineNum">    1331 </span>            :     /*
<span class="lineNum">    1332 </span>            :      * If we've gone through every command in the function, we are done. Reset
<span class="lineNum">    1333 </span>            :      * the execution states to start over again on next call.
<span class="lineNum">    1334 </span>            :      */
<span class="lineNum">    1335 </span><span class="lineCov">       4808 :     if (es == NULL)</span>
<span class="lineNum">    1336 </span>            :     {
<span class="lineNum">    1337 </span><span class="lineCov">       9066 :         foreach(eslc, fcache-&gt;func_state)</span>
<span class="lineNum">    1338 </span>            :         {
<span class="lineNum">    1339 </span><span class="lineCov">       4538 :             es = (execution_state *) lfirst(eslc);</span>
<span class="lineNum">    1340 </span><span class="lineCov">      13616 :             while (es)</span>
<span class="lineNum">    1341 </span>            :             {
<span class="lineNum">    1342 </span><span class="lineCov">       4540 :                 es-&gt;status = F_EXEC_START;</span>
<span class="lineNum">    1343 </span><span class="lineCov">       4540 :                 es = es-&gt;next;</span>
<span class="lineNum">    1344 </span>            :             }
<span class="lineNum">    1345 </span>            :         }
<span class="lineNum">    1346 </span>            :     }
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span><span class="lineCov">       4808 :     error_context_stack = sqlerrcontext.previous;</span>
<span class="lineNum">    1349 </span>            : 
<span class="lineNum">    1350 </span><span class="lineCov">       4808 :     MemoryContextSwitchTo(oldcontext);</span>
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span><span class="lineCov">       4808 :     return result;</span>
<span class="lineNum">    1353 </span>            : }
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span>            : 
<span class="lineNum">    1356 </span>            : /*
<span class="lineNum">    1357 </span>            :  * error context callback to let us supply a call-stack traceback
<a name="1358"><span class="lineNum">    1358 </span>            :  */</a>
<span class="lineNum">    1359 </span>            : static void
<span class="lineNum">    1360 </span><span class="lineCov">       3140 : sql_exec_error_callback(void *arg)</span>
<span class="lineNum">    1361 </span>            : {
<span class="lineNum">    1362 </span><span class="lineCov">       3140 :     FmgrInfo   *flinfo = (FmgrInfo *) arg;</span>
<span class="lineNum">    1363 </span><span class="lineCov">       3140 :     SQLFunctionCachePtr fcache = (SQLFunctionCachePtr) flinfo-&gt;fn_extra;</span>
<span class="lineNum">    1364 </span>            :     int         syntaxerrposition;
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span>            :     /*
<span class="lineNum">    1367 </span>            :      * We can do nothing useful if init_sql_fcache() didn't get as far as
<span class="lineNum">    1368 </span>            :      * saving the function name
<span class="lineNum">    1369 </span>            :      */
<span class="lineNum">    1370 </span><span class="lineCov">       3140 :     if (fcache == NULL || fcache-&gt;fname == NULL)</span>
<span class="lineNum">    1371 </span><span class="lineCov">       3140 :         return;</span>
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            :     /*
<span class="lineNum">    1374 </span>            :      * If there is a syntax error position, convert to internal syntax error
<span class="lineNum">    1375 </span>            :      */
<span class="lineNum">    1376 </span><span class="lineCov">       3140 :     syntaxerrposition = geterrposition();</span>
<span class="lineNum">    1377 </span><span class="lineCov">       3140 :     if (syntaxerrposition &gt; 0 &amp;&amp; fcache-&gt;src != NULL)</span>
<span class="lineNum">    1378 </span>            :     {
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :         errposition(0);</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :         internalerrposition(syntaxerrposition);</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :         internalerrquery(fcache-&gt;src);</span>
<span class="lineNum">    1382 </span>            :     }
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span>            :     /*
<span class="lineNum">    1385 </span>            :      * Try to determine where in the function we failed.  If there is a query
<span class="lineNum">    1386 </span>            :      * with non-null QueryDesc, finger it.  (We check this rather than looking
<span class="lineNum">    1387 </span>            :      * for F_EXEC_RUN state, so that errors during ExecutorStart or
<span class="lineNum">    1388 </span>            :      * ExecutorEnd are blamed on the appropriate query; see postquel_start and
<span class="lineNum">    1389 </span>            :      * postquel_end.)
<span class="lineNum">    1390 </span>            :      */
<span class="lineNum">    1391 </span><span class="lineCov">       3140 :     if (fcache-&gt;func_state)</span>
<span class="lineNum">    1392 </span>            :     {
<span class="lineNum">    1393 </span>            :         execution_state *es;
<span class="lineNum">    1394 </span>            :         int         query_num;
<span class="lineNum">    1395 </span>            :         ListCell   *lc;
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span><span class="lineCov">       3138 :         es = NULL;</span>
<span class="lineNum">    1398 </span><span class="lineCov">       3138 :         query_num = 1;</span>
<span class="lineNum">    1399 </span><span class="lineCov">       3138 :         foreach(lc, fcache-&gt;func_state)</span>
<span class="lineNum">    1400 </span>            :         {
<span class="lineNum">    1401 </span><span class="lineCov">       3138 :             es = (execution_state *) lfirst(lc);</span>
<span class="lineNum">    1402 </span><span class="lineCov">       6276 :             while (es)</span>
<span class="lineNum">    1403 </span>            :             {
<span class="lineNum">    1404 </span><span class="lineCov">       3138 :                 if (es-&gt;qd)</span>
<span class="lineNum">    1405 </span>            :                 {
<span class="lineNum">    1406 </span><span class="lineCov">       3138 :                     errcontext(&quot;SQL function \&quot;%s\&quot; statement %d&quot;,</span>
<span class="lineNum">    1407 </span>            :                                fcache-&gt;fname, query_num);
<span class="lineNum">    1408 </span><span class="lineCov">       3138 :                     break;</span>
<span class="lineNum">    1409 </span>            :                 }
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :                 es = es-&gt;next;</span>
<span class="lineNum">    1411 </span>            :             }
<span class="lineNum">    1412 </span><span class="lineCov">       3138 :             if (es)</span>
<span class="lineNum">    1413 </span><span class="lineCov">       3138 :                 break;</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :             query_num++;</span>
<span class="lineNum">    1415 </span>            :         }
<span class="lineNum">    1416 </span><span class="lineCov">       3138 :         if (es == NULL)</span>
<span class="lineNum">    1417 </span>            :         {
<span class="lineNum">    1418 </span>            :             /*
<span class="lineNum">    1419 </span>            :              * couldn't identify a running query; might be function entry,
<span class="lineNum">    1420 </span>            :              * function exit, or between queries.
<span class="lineNum">    1421 </span>            :              */
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :             errcontext(&quot;SQL function \&quot;%s\&quot;&quot;, fcache-&gt;fname);</span>
<span class="lineNum">    1423 </span>            :         }
<span class="lineNum">    1424 </span>            :     }
<span class="lineNum">    1425 </span>            :     else
<span class="lineNum">    1426 </span>            :     {
<span class="lineNum">    1427 </span>            :         /*
<span class="lineNum">    1428 </span>            :          * Assume we failed during init_sql_fcache().  (It's possible that the
<span class="lineNum">    1429 </span>            :          * function actually has an empty body, but in that case we may as
<span class="lineNum">    1430 </span>            :          * well report all errors as being &quot;during startup&quot;.)
<span class="lineNum">    1431 </span>            :          */
<span class="lineNum">    1432 </span><span class="lineCov">          2 :         errcontext(&quot;SQL function \&quot;%s\&quot; during startup&quot;, fcache-&gt;fname);</span>
<span class="lineNum">    1433 </span>            :     }
<span class="lineNum">    1434 </span>            : }
<span class="lineNum">    1435 </span>            : 
<span class="lineNum">    1436 </span>            : 
<span class="lineNum">    1437 </span>            : /*
<span class="lineNum">    1438 </span>            :  * callback function in case a function-returning-set needs to be shut down
<span class="lineNum">    1439 </span>            :  * before it has been run to completion
<a name="1440"><span class="lineNum">    1440 </span>            :  */</a>
<span class="lineNum">    1441 </span>            : static void
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 : ShutdownSQLFunction(Datum arg)</span>
<span class="lineNum">    1443 </span>            : {
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :     SQLFunctionCachePtr fcache = (SQLFunctionCachePtr) DatumGetPointer(arg);</span>
<span class="lineNum">    1445 </span>            :     execution_state *es;
<span class="lineNum">    1446 </span>            :     ListCell   *lc;
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :     foreach(lc, fcache-&gt;func_state)</span>
<span class="lineNum">    1449 </span>            :     {
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :         es = (execution_state *) lfirst(lc);</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :         while (es)</span>
<span class="lineNum">    1452 </span>            :         {
<span class="lineNum">    1453 </span>            :             /* Shut down anything still running */
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :             if (es-&gt;status == F_EXEC_RUN)</span>
<span class="lineNum">    1455 </span>            :             {
<span class="lineNum">    1456 </span>            :                 /* Re-establish active snapshot for any called functions */
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :                 if (!fcache-&gt;readonly_func)</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :                     PushActiveSnapshot(es-&gt;qd-&gt;snapshot);</span>
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :                 postquel_end(es);</span>
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :                 if (!fcache-&gt;readonly_func)</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :                     PopActiveSnapshot();</span>
<span class="lineNum">    1464 </span>            :             }
<span class="lineNum">    1465 </span>            : 
<span class="lineNum">    1466 </span>            :             /* Reset states to START in case we're called again */
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :             es-&gt;status = F_EXEC_START;</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :             es = es-&gt;next;</span>
<span class="lineNum">    1469 </span>            :         }
<span class="lineNum">    1470 </span>            :     }
<span class="lineNum">    1471 </span>            : 
<span class="lineNum">    1472 </span>            :     /* Release tuplestore if we have one */
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :     if (fcache-&gt;tstore)</span>
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :         tuplestore_end(fcache-&gt;tstore);</span>
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :     fcache-&gt;tstore = NULL;</span>
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span>            :     /* execUtils will deregister the callback... */
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :     fcache-&gt;shutdown_reg = false;</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1480 </span>            : 
<span class="lineNum">    1481 </span>            : /*
<span class="lineNum">    1482 </span>            :  * check_sql_fn_statements
<span class="lineNum">    1483 </span>            :  *
<span class="lineNum">    1484 </span>            :  * Check statements in an SQL function.  Error out if there is anything that
<span class="lineNum">    1485 </span>            :  * is not acceptable.
<a name="1486"><span class="lineNum">    1486 </span>            :  */</a>
<span class="lineNum">    1487 </span>            : void
<span class="lineNum">    1488 </span><span class="lineCov">       4826 : check_sql_fn_statements(List *queryTreeList)</span>
<span class="lineNum">    1489 </span>            : {
<span class="lineNum">    1490 </span>            :     ListCell   *lc;
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span><span class="lineCov">       9664 :     foreach(lc, queryTreeList)</span>
<span class="lineNum">    1493 </span>            :     {
<span class="lineNum">    1494 </span><span class="lineCov">       4840 :         Query      *query = lfirst_node(Query, lc);</span>
<span class="lineNum">    1495 </span>            : 
<span class="lineNum">    1496 </span>            :         /*
<span class="lineNum">    1497 </span>            :          * Disallow procedures with output arguments.  The current
<span class="lineNum">    1498 </span>            :          * implementation would just throw the output values away, unless the
<span class="lineNum">    1499 </span>            :          * statement is the last one.  Per SQL standard, we should assign the
<span class="lineNum">    1500 </span>            :          * output values by name.  By disallowing this here, we preserve an
<span class="lineNum">    1501 </span>            :          * opportunity for future improvement.
<span class="lineNum">    1502 </span>            :          */
<span class="lineNum">    1503 </span><span class="lineCov">       4876 :         if (query-&gt;commandType == CMD_UTILITY &amp;&amp;</span>
<span class="lineNum">    1504 </span><span class="lineCov">         36 :             IsA(query-&gt;utilityStmt, CallStmt))</span>
<span class="lineNum">    1505 </span>            :         {
<span class="lineNum">    1506 </span><span class="lineCov">         10 :             CallStmt   *stmt = castNode(CallStmt, query-&gt;utilityStmt);</span>
<span class="lineNum">    1507 </span>            :             HeapTuple   tuple;
<span class="lineNum">    1508 </span>            :             int         numargs;
<span class="lineNum">    1509 </span>            :             Oid        *argtypes;
<span class="lineNum">    1510 </span>            :             char      **argnames;
<span class="lineNum">    1511 </span>            :             char       *argmodes;
<span class="lineNum">    1512 </span>            :             int         i;
<span class="lineNum">    1513 </span>            : 
<span class="lineNum">    1514 </span><span class="lineCov">         10 :             tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(stmt-&gt;funcexpr-&gt;funcid));</span>
<span class="lineNum">    1515 </span><span class="lineCov">         10 :             if (!HeapTupleIsValid(tuple))</span>
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :                 elog(ERROR, &quot;cache lookup failed for function %u&quot;, stmt-&gt;funcexpr-&gt;funcid);</span>
<span class="lineNum">    1517 </span><span class="lineCov">         10 :             numargs = get_func_arg_info(tuple, &amp;argtypes, &amp;argnames, &amp;argmodes);</span>
<span class="lineNum">    1518 </span><span class="lineCov">         10 :             ReleaseSysCache(tuple);</span>
<span class="lineNum">    1519 </span>            : 
<span class="lineNum">    1520 </span><span class="lineCov">         18 :             for (i = 0; i &lt; numargs; i++)</span>
<span class="lineNum">    1521 </span>            :             {
<span class="lineNum">    1522 </span><span class="lineCov">         10 :                 if (argmodes &amp;&amp; (argmodes[i] == PROARGMODE_INOUT || argmodes[i] == PROARGMODE_OUT))</span>
<span class="lineNum">    1523 </span><span class="lineCov">          2 :                     ereport(ERROR,</span>
<span class="lineNum">    1524 </span>            :                             (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">    1525 </span>            :                              errmsg(&quot;calling procedures with output arguments is not supported in SQL functions&quot;)));
<span class="lineNum">    1526 </span>            :             }
<span class="lineNum">    1527 </span>            :         }
<span class="lineNum">    1528 </span>            :     }
<span class="lineNum">    1529 </span><span class="lineCov">       4824 : }</span>
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span>            : /*
<span class="lineNum">    1532 </span>            :  * check_sql_fn_retval() -- check return value of a list of sql parse trees.
<span class="lineNum">    1533 </span>            :  *
<span class="lineNum">    1534 </span>            :  * The return value of a sql function is the value returned by the last
<span class="lineNum">    1535 </span>            :  * canSetTag query in the function.  We do some ad-hoc type checking here
<span class="lineNum">    1536 </span>            :  * to be sure that the user is returning the type he claims.  There are
<span class="lineNum">    1537 </span>            :  * also a couple of strange-looking features to assist callers in dealing
<span class="lineNum">    1538 </span>            :  * with allowed special cases, such as binary-compatible result types.
<span class="lineNum">    1539 </span>            :  *
<span class="lineNum">    1540 </span>            :  * For a polymorphic function the passed rettype must be the actual resolved
<span class="lineNum">    1541 </span>            :  * output type of the function; we should never see a polymorphic pseudotype
<span class="lineNum">    1542 </span>            :  * such as ANYELEMENT as rettype.  (This means we can't check the type during
<span class="lineNum">    1543 </span>            :  * function definition of a polymorphic function.)
<span class="lineNum">    1544 </span>            :  *
<span class="lineNum">    1545 </span>            :  * This function returns true if the sql function returns the entire tuple
<span class="lineNum">    1546 </span>            :  * result of its final statement, or false if it returns just the first column
<span class="lineNum">    1547 </span>            :  * result of that statement.  It throws an error if the final statement doesn't
<span class="lineNum">    1548 </span>            :  * return the right type at all.
<span class="lineNum">    1549 </span>            :  *
<span class="lineNum">    1550 </span>            :  * Note that because we allow &quot;SELECT rowtype_expression&quot;, the result can be
<span class="lineNum">    1551 </span>            :  * false even when the declared function return type is a rowtype.
<span class="lineNum">    1552 </span>            :  *
<span class="lineNum">    1553 </span>            :  * If modifyTargetList isn't NULL, the function will modify the final
<span class="lineNum">    1554 </span>            :  * statement's targetlist in two cases:
<span class="lineNum">    1555 </span>            :  * (1) if the tlist returns values that are binary-coercible to the expected
<span class="lineNum">    1556 </span>            :  * type rather than being exactly the expected type.  RelabelType nodes will
<span class="lineNum">    1557 </span>            :  * be inserted to make the result types match exactly.
<span class="lineNum">    1558 </span>            :  * (2) if there are dropped columns in the declared result rowtype.  NULL
<span class="lineNum">    1559 </span>            :  * output columns will be inserted in the tlist to match them.
<span class="lineNum">    1560 </span>            :  * (Obviously the caller must pass a parsetree that is okay to modify when
<span class="lineNum">    1561 </span>            :  * using this flag.)  Note that this flag does not affect whether the tlist is
<span class="lineNum">    1562 </span>            :  * considered to be a legal match to the result type, only how we react to
<span class="lineNum">    1563 </span>            :  * allowed not-exact-match cases.  *modifyTargetList will be set true iff
<span class="lineNum">    1564 </span>            :  * we had to make any &quot;dangerous&quot; changes that could modify the semantics of
<span class="lineNum">    1565 </span>            :  * the statement.  If it is set true, the caller should not use the modified
<span class="lineNum">    1566 </span>            :  * statement, but for simplicity we apply the changes anyway.
<span class="lineNum">    1567 </span>            :  *
<span class="lineNum">    1568 </span>            :  * If junkFilter isn't NULL, then *junkFilter is set to a JunkFilter defined
<span class="lineNum">    1569 </span>            :  * to convert the function's tuple result to the correct output tuple type.
<span class="lineNum">    1570 </span>            :  * Exception: if the function is defined to return VOID then *junkFilter is
<span class="lineNum">    1571 </span>            :  * set to NULL.
<a name="1572"><span class="lineNum">    1572 </span>            :  */</a>
<span class="lineNum">    1573 </span>            : bool
<span class="lineNum">    1574 </span><span class="lineCov">       8424 : check_sql_fn_retval(Oid func_id, Oid rettype, List *queryTreeList,</span>
<span class="lineNum">    1575 </span>            :                     bool *modifyTargetList,
<span class="lineNum">    1576 </span>            :                     JunkFilter **junkFilter)
<span class="lineNum">    1577 </span>            : {
<span class="lineNum">    1578 </span>            :     Query      *parse;
<span class="lineNum">    1579 </span>            :     List      **tlist_ptr;
<span class="lineNum">    1580 </span>            :     List       *tlist;
<span class="lineNum">    1581 </span>            :     int         tlistlen;
<span class="lineNum">    1582 </span>            :     char        fn_typtype;
<span class="lineNum">    1583 </span>            :     Oid         restype;
<span class="lineNum">    1584 </span>            :     ListCell   *lc;
<span class="lineNum">    1585 </span>            : 
<span class="lineNum">    1586 </span><span class="lineCov">       8424 :     AssertArg(!IsPolymorphicType(rettype));</span>
<span class="lineNum">    1587 </span>            : 
<span class="lineNum">    1588 </span><span class="lineCov">       8424 :     if (modifyTargetList)</span>
<span class="lineNum">    1589 </span><span class="lineCov">       3600 :         *modifyTargetList = false;  /* initialize for no change */</span>
<span class="lineNum">    1590 </span><span class="lineCov">       8424 :     if (junkFilter)</span>
<span class="lineNum">    1591 </span><span class="lineCov">       4414 :         *junkFilter = NULL;     /* initialize in case of VOID result */</span>
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span>            :     /*
<span class="lineNum">    1594 </span>            :      * If it's declared to return VOID, we don't care what's in the function.
<span class="lineNum">    1595 </span>            :      * (This takes care of the procedure case, as well.)
<span class="lineNum">    1596 </span>            :      */
<span class="lineNum">    1597 </span><span class="lineCov">       8424 :     if (rettype == VOIDOID)</span>
<span class="lineNum">    1598 </span><span class="lineCov">        130 :         return false;</span>
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span>            :     /*
<span class="lineNum">    1601 </span>            :      * Find the last canSetTag query in the list.  This isn't necessarily the
<span class="lineNum">    1602 </span>            :      * last parsetree, because rule rewriting can insert queries after what
<span class="lineNum">    1603 </span>            :      * the user wrote.
<span class="lineNum">    1604 </span>            :      */
<span class="lineNum">    1605 </span><span class="lineCov">       8294 :     parse = NULL;</span>
<span class="lineNum">    1606 </span><span class="lineCov">      16590 :     foreach(lc, queryTreeList)</span>
<span class="lineNum">    1607 </span>            :     {
<span class="lineNum">    1608 </span><span class="lineCov">       8296 :         Query      *q = lfirst_node(Query, lc);</span>
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span><span class="lineCov">       8296 :         if (q-&gt;canSetTag)</span>
<span class="lineNum">    1611 </span><span class="lineCov">       8294 :             parse = q;</span>
<span class="lineNum">    1612 </span>            :     }
<span class="lineNum">    1613 </span>            : 
<span class="lineNum">    1614 </span>            :     /*
<span class="lineNum">    1615 </span>            :      * If it's a plain SELECT, it returns whatever the targetlist says.
<span class="lineNum">    1616 </span>            :      * Otherwise, if it's INSERT/UPDATE/DELETE with RETURNING, it returns
<span class="lineNum">    1617 </span>            :      * that. Otherwise, the function return type must be VOID.
<span class="lineNum">    1618 </span>            :      *
<span class="lineNum">    1619 </span>            :      * Note: eventually replace this test with QueryReturnsTuples?  We'd need
<span class="lineNum">    1620 </span>            :      * a more general method of determining the output type, though.  Also, it
<span class="lineNum">    1621 </span>            :      * seems too dangerous to consider FETCH or EXECUTE as returning a
<span class="lineNum">    1622 </span>            :      * determinable rowtype, since they depend on relatively short-lived
<span class="lineNum">    1623 </span>            :      * entities.
<span class="lineNum">    1624 </span>            :      */
<span class="lineNum">    1625 </span><span class="lineCov">      16588 :     if (parse &amp;&amp;</span>
<span class="lineNum">    1626 </span><span class="lineCov">       8294 :         parse-&gt;commandType == CMD_SELECT)</span>
<span class="lineNum">    1627 </span>            :     {
<span class="lineNum">    1628 </span><span class="lineCov">       8260 :         tlist_ptr = &amp;parse-&gt;targetList;</span>
<span class="lineNum">    1629 </span><span class="lineCov">       8260 :         tlist = parse-&gt;targetList;</span>
<span class="lineNum">    1630 </span>            :     }
<span class="lineNum">    1631 </span><span class="lineCov">         68 :     else if (parse &amp;&amp;</span>
<span class="lineNum">    1632 </span><span class="lineCov">         34 :              (parse-&gt;commandType == CMD_INSERT ||</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :               parse-&gt;commandType == CMD_UPDATE ||</span>
<span class="lineNum">    1634 </span><span class="lineCov">         34 :               parse-&gt;commandType == CMD_DELETE) &amp;&amp;</span>
<span class="lineNum">    1635 </span><span class="lineCov">         34 :              parse-&gt;returningList)</span>
<span class="lineNum">    1636 </span>            :     {
<span class="lineNum">    1637 </span><span class="lineCov">         34 :         tlist_ptr = &amp;parse-&gt;returningList;</span>
<span class="lineNum">    1638 </span><span class="lineCov">         34 :         tlist = parse-&gt;returningList;</span>
<span class="lineNum">    1639 </span>            :     }
<span class="lineNum">    1640 </span>            :     else
<span class="lineNum">    1641 </span>            :     {
<span class="lineNum">    1642 </span>            :         /* Empty function body, or last statement is a utility command */
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1644 </span>            :                 (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">    1645 </span>            :                  errmsg(&quot;return type mismatch in function declared to return %s&quot;,
<span class="lineNum">    1646 </span>            :                         format_type_be(rettype)),
<span class="lineNum">    1647 </span>            :                  errdetail(&quot;Function's final statement must be SELECT or INSERT/UPDATE/DELETE RETURNING.&quot;)));
<span class="lineNum">    1648 </span>            :         return false;           /* keep compiler quiet */
<span class="lineNum">    1649 </span>            :     }
<span class="lineNum">    1650 </span>            : 
<span class="lineNum">    1651 </span>            :     /*
<span class="lineNum">    1652 </span>            :      * OK, check that the targetlist returns something matching the declared
<span class="lineNum">    1653 </span>            :      * type.
<span class="lineNum">    1654 </span>            :      */
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span>            :     /*
<span class="lineNum">    1657 </span>            :      * Count the non-junk entries in the result targetlist.
<span class="lineNum">    1658 </span>            :      */
<span class="lineNum">    1659 </span><span class="lineCov">       8294 :     tlistlen = ExecCleanTargetListLength(tlist);</span>
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span><span class="lineCov">       8294 :     fn_typtype = get_typtype(rettype);</span>
<span class="lineNum">    1662 </span>            : 
<span class="lineNum">    1663 </span><span class="lineCov">       8294 :     if (fn_typtype == TYPTYPE_BASE ||</span>
<span class="lineNum">    1664 </span><span class="lineCov">        402 :         fn_typtype == TYPTYPE_DOMAIN ||</span>
<span class="lineNum">    1665 </span><span class="lineCov">        400 :         fn_typtype == TYPTYPE_ENUM ||</span>
<span class="lineNum">    1666 </span>            :         fn_typtype == TYPTYPE_RANGE)
<span class="lineNum">    1667 </span><span class="lineCov">       7890 :     {</span>
<span class="lineNum">    1668 </span>            :         /*
<span class="lineNum">    1669 </span>            :          * For scalar-type returns, the target list must have exactly one
<span class="lineNum">    1670 </span>            :          * non-junk entry, and its type must agree with what the user
<span class="lineNum">    1671 </span>            :          * declared; except we allow binary-compatible types too.
<span class="lineNum">    1672 </span>            :          */
<span class="lineNum">    1673 </span>            :         TargetEntry *tle;
<span class="lineNum">    1674 </span>            : 
<span class="lineNum">    1675 </span><span class="lineCov">       7894 :         if (tlistlen != 1)</span>
<span class="lineNum">    1676 </span><span class="lineCov">          2 :             ereport(ERROR,</span>
<span class="lineNum">    1677 </span>            :                     (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">    1678 </span>            :                      errmsg(&quot;return type mismatch in function declared to return %s&quot;,
<span class="lineNum">    1679 </span>            :                             format_type_be(rettype)),
<span class="lineNum">    1680 </span>            :                      errdetail(&quot;Final statement must return exactly one column.&quot;)));
<span class="lineNum">    1681 </span>            : 
<span class="lineNum">    1682 </span>            :         /* We assume here that non-junk TLEs must come first in tlists */
<span class="lineNum">    1683 </span><span class="lineCov">       7892 :         tle = (TargetEntry *) linitial(tlist);</span>
<span class="lineNum">    1684 </span><span class="lineCov">       7892 :         Assert(!tle-&gt;resjunk);</span>
<span class="lineNum">    1685 </span>            : 
<span class="lineNum">    1686 </span><span class="lineCov">       7892 :         restype = exprType((Node *) tle-&gt;expr);</span>
<span class="lineNum">    1687 </span><span class="lineCov">       7892 :         if (!IsBinaryCoercible(restype, rettype))</span>
<span class="lineNum">    1688 </span><span class="lineCov">          2 :             ereport(ERROR,</span>
<span class="lineNum">    1689 </span>            :                     (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">    1690 </span>            :                      errmsg(&quot;return type mismatch in function declared to return %s&quot;,
<span class="lineNum">    1691 </span>            :                             format_type_be(rettype)),
<span class="lineNum">    1692 </span>            :                      errdetail(&quot;Actual return type is %s.&quot;,
<span class="lineNum">    1693 </span>            :                                format_type_be(restype))));
<span class="lineNum">    1694 </span><span class="lineCov">       7890 :         if (modifyTargetList &amp;&amp; restype != rettype)</span>
<span class="lineNum">    1695 </span>            :         {
<span class="lineNum">    1696 </span><span class="lineCov">          2 :             tle-&gt;expr = (Expr *) makeRelabelType(tle-&gt;expr,</span>
<span class="lineNum">    1697 </span>            :                                                  rettype,
<span class="lineNum">    1698 </span>            :                                                  -1,
<span class="lineNum">    1699 </span>            :                                                  get_typcollation(rettype),
<span class="lineNum">    1700 </span>            :                                                  COERCE_IMPLICIT_CAST);
<span class="lineNum">    1701 </span>            :             /* Relabel is dangerous if TLE is a sort/group or setop column */
<span class="lineNum">    1702 </span><span class="lineCov">          2 :             if (tle-&gt;ressortgroupref != 0 || parse-&gt;setOperations)</span>
<span class="lineNum">    1703 </span><span class="lineCov">          2 :                 *modifyTargetList = true;</span>
<span class="lineNum">    1704 </span>            :         }
<span class="lineNum">    1705 </span>            : 
<span class="lineNum">    1706 </span>            :         /* Set up junk filter if needed */
<span class="lineNum">    1707 </span><span class="lineCov">       7890 :         if (junkFilter)</span>
<span class="lineNum">    1708 </span><span class="lineCov">       4042 :             *junkFilter = ExecInitJunkFilter(tlist,</span>
<span class="lineNum">    1709 </span>            :                                              MakeSingleTupleTableSlot(NULL, &amp;TTSOpsMinimalTuple));
<span class="lineNum">    1710 </span>            :     }
<span class="lineNum">    1711 </span><span class="lineCov">        400 :     else if (fn_typtype == TYPTYPE_COMPOSITE || rettype == RECORDOID)</span>
<span class="lineNum">    1712 </span>            :     {
<span class="lineNum">    1713 </span>            :         /*
<span class="lineNum">    1714 </span>            :          * Returns a rowtype.
<span class="lineNum">    1715 </span>            :          *
<span class="lineNum">    1716 </span>            :          * Note that we will not consider a domain over composite to be a
<span class="lineNum">    1717 </span>            :          * &quot;rowtype&quot; return type; it goes through the scalar case above.  This
<span class="lineNum">    1718 </span>            :          * is because SQL functions don't provide any implicit casting to the
<span class="lineNum">    1719 </span>            :          * result type, so there is no way to produce a domain-over-composite
<span class="lineNum">    1720 </span>            :          * result except by computing it as an explicit single-column result.
<span class="lineNum">    1721 </span>            :          */
<span class="lineNum">    1722 </span>            :         TupleDesc   tupdesc;
<span class="lineNum">    1723 </span>            :         int         tupnatts;   /* physical number of columns in tuple */
<span class="lineNum">    1724 </span>            :         int         tuplogcols; /* # of nondeleted columns in tuple */
<span class="lineNum">    1725 </span>            :         int         colindex;   /* physical column index */
<span class="lineNum">    1726 </span>            :         List       *newtlist;   /* new non-junk tlist entries */
<span class="lineNum">    1727 </span>            :         List       *junkattrs;  /* new junk tlist entries */
<span class="lineNum">    1728 </span>            : 
<span class="lineNum">    1729 </span>            :         /*
<span class="lineNum">    1730 </span>            :          * If the target list is of length 1, and the type of the varnode in
<span class="lineNum">    1731 </span>            :          * the target list matches the declared return type, this is okay.
<span class="lineNum">    1732 </span>            :          * This can happen, for example, where the body of the function is
<span class="lineNum">    1733 </span>            :          * 'SELECT func2()', where func2 has the same composite return type as
<span class="lineNum">    1734 </span>            :          * the function that's calling it.
<span class="lineNum">    1735 </span>            :          *
<span class="lineNum">    1736 </span>            :          * XXX Note that if rettype is RECORD, the IsBinaryCoercible check
<span class="lineNum">    1737 </span>            :          * will succeed for any composite restype.  For the moment we rely on
<span class="lineNum">    1738 </span>            :          * runtime type checking to catch any discrepancy, but it'd be nice to
<span class="lineNum">    1739 </span>            :          * do better at parse time.
<span class="lineNum">    1740 </span>            :          */
<span class="lineNum">    1741 </span><span class="lineCov">        400 :         if (tlistlen == 1)</span>
<span class="lineNum">    1742 </span>            :         {
<span class="lineNum">    1743 </span><span class="lineCov">         36 :             TargetEntry *tle = (TargetEntry *) linitial(tlist);</span>
<span class="lineNum">    1744 </span>            : 
<span class="lineNum">    1745 </span><span class="lineCov">         36 :             Assert(!tle-&gt;resjunk);</span>
<span class="lineNum">    1746 </span><span class="lineCov">         36 :             restype = exprType((Node *) tle-&gt;expr);</span>
<span class="lineNum">    1747 </span><span class="lineCov">         36 :             if (IsBinaryCoercible(restype, rettype))</span>
<span class="lineNum">    1748 </span>            :             {
<span class="lineNum">    1749 </span><span class="lineCov">         24 :                 if (modifyTargetList &amp;&amp; restype != rettype)</span>
<span class="lineNum">    1750 </span>            :                 {
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :                     tle-&gt;expr = (Expr *) makeRelabelType(tle-&gt;expr,</span>
<span class="lineNum">    1752 </span>            :                                                          rettype,
<span class="lineNum">    1753 </span>            :                                                          -1,
<span class="lineNum">    1754 </span>            :                                                          get_typcollation(rettype),
<span class="lineNum">    1755 </span>            :                                                          COERCE_IMPLICIT_CAST);
<span class="lineNum">    1756 </span>            :                     /* Relabel is dangerous if sort/group or setop column */
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :                     if (tle-&gt;ressortgroupref != 0 || parse-&gt;setOperations)</span>
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :                         *modifyTargetList = true;</span>
<span class="lineNum">    1759 </span>            :                 }
<span class="lineNum">    1760 </span>            :                 /* Set up junk filter if needed */
<span class="lineNum">    1761 </span><span class="lineCov">         24 :                 if (junkFilter)</span>
<span class="lineNum">    1762 </span>            :                 {
<span class="lineNum">    1763 </span><span class="lineCov">          6 :                     TupleTableSlot *slot =</span>
<span class="lineNum">    1764 </span>            :                     MakeSingleTupleTableSlot(NULL, &amp;TTSOpsMinimalTuple);
<span class="lineNum">    1765 </span>            : 
<span class="lineNum">    1766 </span><span class="lineCov">          6 :                     *junkFilter = ExecInitJunkFilter(tlist, slot);</span>
<span class="lineNum">    1767 </span>            :                 }
<span class="lineNum">    1768 </span><span class="lineCov">         24 :                 return false;   /* NOT returning whole tuple */</span>
<span class="lineNum">    1769 </span>            :             }
<span class="lineNum">    1770 </span>            :         }
<span class="lineNum">    1771 </span>            : 
<span class="lineNum">    1772 </span>            :         /*
<span class="lineNum">    1773 </span>            :          * Is the rowtype fixed, or determined only at runtime?  (Note we
<span class="lineNum">    1774 </span>            :          * cannot see TYPEFUNC_COMPOSITE_DOMAIN here.)
<span class="lineNum">    1775 </span>            :          */
<span class="lineNum">    1776 </span><span class="lineCov">        376 :         if (get_func_result_type(func_id, NULL, &amp;tupdesc) != TYPEFUNC_COMPOSITE)</span>
<span class="lineNum">    1777 </span>            :         {
<span class="lineNum">    1778 </span>            :             /*
<span class="lineNum">    1779 </span>            :              * Assume we are returning the whole tuple. Crosschecking against
<span class="lineNum">    1780 </span>            :              * what the caller expects will happen at runtime.
<span class="lineNum">    1781 </span>            :              */
<span class="lineNum">    1782 </span><span class="lineCov">         62 :             if (junkFilter)</span>
<span class="lineNum">    1783 </span>            :             {
<span class="lineNum">    1784 </span>            :                 TupleTableSlot *slot;
<span class="lineNum">    1785 </span>            : 
<span class="lineNum">    1786 </span><span class="lineCov">         54 :                 slot = MakeSingleTupleTableSlot(NULL, &amp;TTSOpsMinimalTuple);</span>
<span class="lineNum">    1787 </span><span class="lineCov">         54 :                 *junkFilter = ExecInitJunkFilter(tlist, slot);</span>
<span class="lineNum">    1788 </span>            :             }
<span class="lineNum">    1789 </span><span class="lineCov">         62 :             return true;</span>
<span class="lineNum">    1790 </span>            :         }
<span class="lineNum">    1791 </span><span class="lineCov">        314 :         Assert(tupdesc);</span>
<span class="lineNum">    1792 </span>            : 
<span class="lineNum">    1793 </span>            :         /*
<span class="lineNum">    1794 </span>            :          * Verify that the targetlist matches the return tuple type. We scan
<span class="lineNum">    1795 </span>            :          * the non-deleted attributes to ensure that they match the datatypes
<span class="lineNum">    1796 </span>            :          * of the non-resjunk columns.  For deleted attributes, insert NULL
<span class="lineNum">    1797 </span>            :          * result columns if the caller asked for that.
<span class="lineNum">    1798 </span>            :          */
<span class="lineNum">    1799 </span><span class="lineCov">        314 :         tupnatts = tupdesc-&gt;natts;</span>
<span class="lineNum">    1800 </span><span class="lineCov">        314 :         tuplogcols = 0;         /* we'll count nondeleted cols as we go */</span>
<span class="lineNum">    1801 </span><span class="lineCov">        314 :         colindex = 0;</span>
<span class="lineNum">    1802 </span><span class="lineCov">        314 :         newtlist = NIL;         /* these are only used if modifyTargetList */</span>
<span class="lineNum">    1803 </span><span class="lineCov">        314 :         junkattrs = NIL;</span>
<span class="lineNum">    1804 </span>            : 
<span class="lineNum">    1805 </span><span class="lineCov">       1148 :         foreach(lc, tlist)</span>
<span class="lineNum">    1806 </span>            :         {
<span class="lineNum">    1807 </span><span class="lineCov">        834 :             TargetEntry *tle = (TargetEntry *) lfirst(lc);</span>
<span class="lineNum">    1808 </span>            :             Form_pg_attribute attr;
<span class="lineNum">    1809 </span>            :             Oid         tletype;
<span class="lineNum">    1810 </span>            :             Oid         atttype;
<span class="lineNum">    1811 </span>            : 
<span class="lineNum">    1812 </span><span class="lineCov">        834 :             if (tle-&gt;resjunk)</span>
<span class="lineNum">    1813 </span>            :             {
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :                 if (modifyTargetList)</span>
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :                     junkattrs = lappend(junkattrs, tle);</span>
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1817 </span>            :             }
<span class="lineNum">    1818 </span>            : 
<span class="lineNum">    1819 </span>            :             do
<span class="lineNum">    1820 </span>            :             {
<span class="lineNum">    1821 </span><span class="lineCov">        862 :                 colindex++;</span>
<span class="lineNum">    1822 </span><span class="lineCov">        862 :                 if (colindex &gt; tupnatts)</span>
<span class="lineNum">    1823 </span><span class="lineNoCov">          0 :                     ereport(ERROR,</span>
<span class="lineNum">    1824 </span>            :                             (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">    1825 </span>            :                              errmsg(&quot;return type mismatch in function declared to return %s&quot;,
<span class="lineNum">    1826 </span>            :                                     format_type_be(rettype)),
<span class="lineNum">    1827 </span>            :                              errdetail(&quot;Final statement returns too many columns.&quot;)));
<span class="lineNum">    1828 </span><span class="lineCov">        862 :                 attr = TupleDescAttr(tupdesc, colindex - 1);</span>
<span class="lineNum">    1829 </span><span class="lineCov">        862 :                 if (attr-&gt;attisdropped &amp;&amp; modifyTargetList)</span>
<span class="lineNum">    1830 </span>            :                 {
<span class="lineNum">    1831 </span>            :                     Expr       *null_expr;
<span class="lineNum">    1832 </span>            : 
<span class="lineNum">    1833 </span>            :                     /* The type of the null we insert isn't important */
<span class="lineNum">    1834 </span><span class="lineCov">          2 :                     null_expr = (Expr *) makeConst(INT4OID,</span>
<span class="lineNum">    1835 </span>            :                                                    -1,
<span class="lineNum">    1836 </span>            :                                                    InvalidOid,
<span class="lineNum">    1837 </span>            :                                                    sizeof(int32),
<span class="lineNum">    1838 </span>            :                                                    (Datum) 0,
<span class="lineNum">    1839 </span>            :                                                    true,    /* isnull */
<span class="lineNum">    1840 </span>            :                                                    true /* byval */ );
<span class="lineNum">    1841 </span><span class="lineCov">          2 :                     newtlist = lappend(newtlist,</span>
<span class="lineNum">    1842 </span><span class="lineCov">          2 :                                        makeTargetEntry(null_expr,</span>
<span class="lineNum">    1843 </span>            :                                                        colindex,
<span class="lineNum">    1844 </span>            :                                                        NULL,
<span class="lineNum">    1845 </span>            :                                                        false));
<span class="lineNum">    1846 </span>            :                     /* NULL insertion is dangerous in a setop */
<span class="lineNum">    1847 </span><span class="lineCov">          2 :                     if (parse-&gt;setOperations)</span>
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :                         *modifyTargetList = true;</span>
<span class="lineNum">    1849 </span>            :                 }
<span class="lineNum">    1850 </span><span class="lineCov">        862 :             } while (attr-&gt;attisdropped);</span>
<span class="lineNum">    1851 </span><span class="lineCov">        834 :             tuplogcols++;</span>
<span class="lineNum">    1852 </span>            : 
<span class="lineNum">    1853 </span><span class="lineCov">        834 :             tletype = exprType((Node *) tle-&gt;expr);</span>
<span class="lineNum">    1854 </span><span class="lineCov">        834 :             atttype = attr-&gt;atttypid;</span>
<span class="lineNum">    1855 </span><span class="lineCov">        834 :             if (!IsBinaryCoercible(tletype, atttype))</span>
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :                 ereport(ERROR,</span>
<span class="lineNum">    1857 </span>            :                         (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">    1858 </span>            :                          errmsg(&quot;return type mismatch in function declared to return %s&quot;,
<span class="lineNum">    1859 </span>            :                                 format_type_be(rettype)),
<span class="lineNum">    1860 </span>            :                          errdetail(&quot;Final statement returns %s instead of %s at column %d.&quot;,
<span class="lineNum">    1861 </span>            :                                    format_type_be(tletype),
<span class="lineNum">    1862 </span>            :                                    format_type_be(atttype),
<span class="lineNum">    1863 </span>            :                                    tuplogcols)));
<span class="lineNum">    1864 </span><span class="lineCov">        834 :             if (modifyTargetList)</span>
<span class="lineNum">    1865 </span>            :             {
<span class="lineNum">    1866 </span><span class="lineCov">         14 :                 if (tletype != atttype)</span>
<span class="lineNum">    1867 </span>            :                 {
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :                     tle-&gt;expr = (Expr *) makeRelabelType(tle-&gt;expr,</span>
<span class="lineNum">    1869 </span>            :                                                          atttype,
<span class="lineNum">    1870 </span>            :                                                          -1,
<span class="lineNum">    1871 </span>            :                                                          get_typcollation(atttype),
<span class="lineNum">    1872 </span>            :                                                          COERCE_IMPLICIT_CAST);
<span class="lineNum">    1873 </span>            :                     /* Relabel is dangerous if sort/group or setop column */
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :                     if (tle-&gt;ressortgroupref != 0 || parse-&gt;setOperations)</span>
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :                         *modifyTargetList = true;</span>
<span class="lineNum">    1876 </span>            :                 }
<span class="lineNum">    1877 </span><span class="lineCov">         14 :                 tle-&gt;resno = colindex;</span>
<span class="lineNum">    1878 </span><span class="lineCov">         14 :                 newtlist = lappend(newtlist, tle);</span>
<span class="lineNum">    1879 </span>            :             }
<span class="lineNum">    1880 </span>            :         }
<span class="lineNum">    1881 </span>            : 
<span class="lineNum">    1882 </span>            :         /* remaining columns in tupdesc had better all be dropped */
<span class="lineNum">    1883 </span><span class="lineCov">        314 :         for (colindex++; colindex &lt;= tupnatts; colindex++)</span>
<span class="lineNum">    1884 </span>            :         {
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :             if (!TupleDescAttr(tupdesc, colindex - 1)-&gt;attisdropped)</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :                 ereport(ERROR,</span>
<span class="lineNum">    1887 </span>            :                         (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">    1888 </span>            :                          errmsg(&quot;return type mismatch in function declared to return %s&quot;,
<span class="lineNum">    1889 </span>            :                                 format_type_be(rettype)),
<span class="lineNum">    1890 </span>            :                          errdetail(&quot;Final statement returns too few columns.&quot;)));
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :             if (modifyTargetList)</span>
<span class="lineNum">    1892 </span>            :             {
<span class="lineNum">    1893 </span>            :                 Expr       *null_expr;
<span class="lineNum">    1894 </span>            : 
<span class="lineNum">    1895 </span>            :                 /* The type of the null we insert isn't important */
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :                 null_expr = (Expr *) makeConst(INT4OID,</span>
<span class="lineNum">    1897 </span>            :                                                -1,
<span class="lineNum">    1898 </span>            :                                                InvalidOid,
<span class="lineNum">    1899 </span>            :                                                sizeof(int32),
<span class="lineNum">    1900 </span>            :                                                (Datum) 0,
<span class="lineNum">    1901 </span>            :                                                true,    /* isnull */
<span class="lineNum">    1902 </span>            :                                                true /* byval */ );
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :                 newtlist = lappend(newtlist,</span>
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :                                    makeTargetEntry(null_expr,</span>
<span class="lineNum">    1905 </span>            :                                                    colindex,
<span class="lineNum">    1906 </span>            :                                                    NULL,
<span class="lineNum">    1907 </span>            :                                                    false));
<span class="lineNum">    1908 </span>            :                 /* NULL insertion is dangerous in a setop */
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :                 if (parse-&gt;setOperations)</span>
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :                     *modifyTargetList = true;</span>
<span class="lineNum">    1911 </span>            :             }
<span class="lineNum">    1912 </span>            :         }
<span class="lineNum">    1913 </span>            : 
<span class="lineNum">    1914 </span><span class="lineCov">        314 :         if (modifyTargetList)</span>
<span class="lineNum">    1915 </span>            :         {
<span class="lineNum">    1916 </span>            :             /* ensure resjunk columns are numbered correctly */
<span class="lineNum">    1917 </span><span class="lineCov">          6 :             foreach(lc, junkattrs)</span>
<span class="lineNum">    1918 </span>            :             {
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :                 TargetEntry *tle = (TargetEntry *) lfirst(lc);</span>
<span class="lineNum">    1920 </span>            : 
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :                 tle-&gt;resno = colindex++;</span>
<span class="lineNum">    1922 </span>            :             }
<span class="lineNum">    1923 </span>            :             /* replace the tlist with the modified one */
<span class="lineNum">    1924 </span><span class="lineCov">          6 :             *tlist_ptr = list_concat(newtlist, junkattrs);</span>
<span class="lineNum">    1925 </span>            :         }
<span class="lineNum">    1926 </span>            : 
<span class="lineNum">    1927 </span>            :         /* Set up junk filter if needed */
<span class="lineNum">    1928 </span><span class="lineCov">        314 :         if (junkFilter)</span>
<span class="lineNum">    1929 </span>            :         {
<span class="lineNum">    1930 </span><span class="lineCov">        248 :             TupleTableSlot *slot =</span>
<span class="lineNum">    1931 </span>            :             MakeSingleTupleTableSlot(NULL, &amp;TTSOpsMinimalTuple);
<span class="lineNum">    1932 </span>            : 
<span class="lineNum">    1933 </span><span class="lineCov">        248 :             *junkFilter = ExecInitJunkFilterConversion(tlist,</span>
<span class="lineNum">    1934 </span>            :                                                        CreateTupleDescCopy(tupdesc),
<span class="lineNum">    1935 </span>            :                                                        slot);
<span class="lineNum">    1936 </span>            :         }
<span class="lineNum">    1937 </span>            : 
<span class="lineNum">    1938 </span>            :         /* Report that we are returning entire tuple result */
<span class="lineNum">    1939 </span><span class="lineCov">        314 :         return true;</span>
<span class="lineNum">    1940 </span>            :     }
<span class="lineNum">    1941 </span>            :     else
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1943 </span>            :                 (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">    1944 </span>            :                  errmsg(&quot;return type %s is not supported for SQL functions&quot;,
<span class="lineNum">    1945 </span>            :                         format_type_be(rettype))));
<span class="lineNum">    1946 </span>            : 
<span class="lineNum">    1947 </span><span class="lineCov">       7890 :     return false;</span>
<span class="lineNum">    1948 </span>            : }
<span class="lineNum">    1949 </span>            : 
<span class="lineNum">    1950 </span>            : 
<span class="lineNum">    1951 </span>            : /*
<span class="lineNum">    1952 </span>            :  * CreateSQLFunctionDestReceiver -- create a suitable DestReceiver object
<a name="1953"><span class="lineNum">    1953 </span>            :  */</a>
<span class="lineNum">    1954 </span>            : DestReceiver *
<span class="lineNum">    1955 </span><span class="lineCov">       7590 : CreateSQLFunctionDestReceiver(void)</span>
<span class="lineNum">    1956 </span>            : {
<span class="lineNum">    1957 </span><span class="lineCov">       7590 :     DR_sqlfunction *self = (DR_sqlfunction *) palloc0(sizeof(DR_sqlfunction));</span>
<span class="lineNum">    1958 </span>            : 
<span class="lineNum">    1959 </span><span class="lineCov">       7590 :     self-&gt;pub.receiveSlot = sqlfunction_receive;</span>
<span class="lineNum">    1960 </span><span class="lineCov">       7590 :     self-&gt;pub.rStartup = sqlfunction_startup;</span>
<span class="lineNum">    1961 </span><span class="lineCov">       7590 :     self-&gt;pub.rShutdown = sqlfunction_shutdown;</span>
<span class="lineNum">    1962 </span><span class="lineCov">       7590 :     self-&gt;pub.rDestroy = sqlfunction_destroy;</span>
<span class="lineNum">    1963 </span><span class="lineCov">       7590 :     self-&gt;pub.mydest = DestSQLFunction;</span>
<span class="lineNum">    1964 </span>            : 
<span class="lineNum">    1965 </span>            :     /* private fields will be set by postquel_start */
<span class="lineNum">    1966 </span>            : 
<span class="lineNum">    1967 </span><span class="lineCov">       7590 :     return (DestReceiver *) self;</span>
<span class="lineNum">    1968 </span>            : }
<span class="lineNum">    1969 </span>            : 
<span class="lineNum">    1970 </span>            : /*
<span class="lineNum">    1971 </span>            :  * sqlfunction_startup --- executor startup
<a name="1972"><span class="lineNum">    1972 </span>            :  */</a>
<span class="lineNum">    1973 </span>            : static void
<span class="lineNum">    1974 </span><span class="lineCov">       7870 : sqlfunction_startup(DestReceiver *self, int operation, TupleDesc typeinfo)</span>
<span class="lineNum">    1975 </span>            : {
<span class="lineNum">    1976 </span>            :     /* no-op */
<span class="lineNum">    1977 </span><span class="lineCov">       7870 : }</span>
<span class="lineNum">    1978 </span>            : 
<span class="lineNum">    1979 </span>            : /*
<span class="lineNum">    1980 </span>            :  * sqlfunction_receive --- receive one tuple
<a name="1981"><span class="lineNum">    1981 </span>            :  */</a>
<span class="lineNum">    1982 </span>            : static bool
<span class="lineNum">    1983 </span><span class="lineCov">      43116 : sqlfunction_receive(TupleTableSlot *slot, DestReceiver *self)</span>
<span class="lineNum">    1984 </span>            : {
<span class="lineNum">    1985 </span><span class="lineCov">      43116 :     DR_sqlfunction *myState = (DR_sqlfunction *) self;</span>
<span class="lineNum">    1986 </span>            : 
<span class="lineNum">    1987 </span>            :     /* Filter tuple as needed */
<span class="lineNum">    1988 </span><span class="lineCov">      43116 :     slot = ExecFilterJunk(myState-&gt;filter, slot);</span>
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span>            :     /* Store the filtered tuple into the tuplestore */
<span class="lineNum">    1991 </span><span class="lineCov">      43116 :     tuplestore_puttupleslot(myState-&gt;tstore, slot);</span>
<span class="lineNum">    1992 </span>            : 
<span class="lineNum">    1993 </span><span class="lineCov">      43116 :     return true;</span>
<span class="lineNum">    1994 </span>            : }
<span class="lineNum">    1995 </span>            : 
<span class="lineNum">    1996 </span>            : /*
<span class="lineNum">    1997 </span>            :  * sqlfunction_shutdown --- executor end
<a name="1998"><span class="lineNum">    1998 </span>            :  */</a>
<span class="lineNum">    1999 </span>            : static void
<span class="lineNum">    2000 </span><span class="lineCov">       4750 : sqlfunction_shutdown(DestReceiver *self)</span>
<span class="lineNum">    2001 </span>            : {
<span class="lineNum">    2002 </span>            :     /* no-op */
<span class="lineNum">    2003 </span><span class="lineCov">       4750 : }</span>
<span class="lineNum">    2004 </span>            : 
<span class="lineNum">    2005 </span>            : /*
<span class="lineNum">    2006 </span>            :  * sqlfunction_destroy --- release DestReceiver object
<a name="2007"><span class="lineNum">    2007 </span>            :  */</a>
<span class="lineNum">    2008 </span>            : static void
<span class="lineNum">    2009 </span><span class="lineCov">       4470 : sqlfunction_destroy(DestReceiver *self)</span>
<span class="lineNum">    2010 </span>            : {
<span class="lineNum">    2011 </span><span class="lineCov">       4470 :     pfree(self);</span>
<span class="lineNum">    2012 </span><span class="lineCov">       4470 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
