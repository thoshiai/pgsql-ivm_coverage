<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/replication/logical/decode.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/backend/replication/logical</a> - decode.c<span style="font-size: 80%;"> (source / <a href="decode.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">353</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * decode.c
<span class="lineNum">       4 </span>            :  *      This module decodes WAL records read using xlogreader.h's APIs for the
<span class="lineNum">       5 </span>            :  *      purpose of logical decoding by passing information to the
<span class="lineNum">       6 </span>            :  *      reorderbuffer module (containing the actual changes) and to the
<span class="lineNum">       7 </span>            :  *      snapbuild module to build a fitting catalog snapshot (to be able to
<span class="lineNum">       8 </span>            :  *      properly decode the changes in the reorderbuffer).
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * NOTE:
<span class="lineNum">      11 </span>            :  *      This basically tries to handle all low level xlog stuff for
<span class="lineNum">      12 </span>            :  *      reorderbuffer.c and snapbuild.c. There's some minor leakage where a
<span class="lineNum">      13 </span>            :  *      specific record's struct is used to pass data along, but those just
<span class="lineNum">      14 </span>            :  *      happen to contain the right amount of data in a convenient
<span class="lineNum">      15 </span>            :  *      format. There isn't and shouldn't be much intelligence about the
<span class="lineNum">      16 </span>            :  *      contents of records in here except turning them into a more usable
<span class="lineNum">      17 </span>            :  *      format.
<span class="lineNum">      18 </span>            :  *
<span class="lineNum">      19 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">      20 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">      21 </span>            :  *
<span class="lineNum">      22 </span>            :  * IDENTIFICATION
<span class="lineNum">      23 </span>            :  *    src/backend/replication/logical/decode.c
<span class="lineNum">      24 </span>            :  *
<span class="lineNum">      25 </span>            :  * -------------------------------------------------------------------------
<span class="lineNum">      26 </span>            :  */
<span class="lineNum">      27 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #include &quot;access/heapam.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;access/heapam_xlog.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;access/transam.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;access/xact.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;access/xlog_internal.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;access/xlogreader.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;access/xlogrecord.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;access/xlogutils.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;catalog/pg_control.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;replication/decode.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;replication/logical.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;replication/message.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;replication/origin.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;replication/reorderbuffer.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;replication/snapbuild.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;storage/standby.h&quot;
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : typedef struct XLogRecordBuffer
<span class="lineNum">      47 </span>            : {
<span class="lineNum">      48 </span>            :     XLogRecPtr  origptr;
<span class="lineNum">      49 </span>            :     XLogRecPtr  endptr;
<span class="lineNum">      50 </span>            :     XLogReaderState *record;
<span class="lineNum">      51 </span>            : } XLogRecordBuffer;
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : /* RMGR Handlers */
<span class="lineNum">      54 </span>            : static void DecodeXLogOp(LogicalDecodingContext *ctx, XLogRecordBuffer *buf);
<span class="lineNum">      55 </span>            : static void DecodeHeapOp(LogicalDecodingContext *ctx, XLogRecordBuffer *buf);
<span class="lineNum">      56 </span>            : static void DecodeHeap2Op(LogicalDecodingContext *ctx, XLogRecordBuffer *buf);
<span class="lineNum">      57 </span>            : static void DecodeXactOp(LogicalDecodingContext *ctx, XLogRecordBuffer *buf);
<span class="lineNum">      58 </span>            : static void DecodeStandbyOp(LogicalDecodingContext *ctx, XLogRecordBuffer *buf);
<span class="lineNum">      59 </span>            : static void DecodeLogicalMsgOp(LogicalDecodingContext *ctx, XLogRecordBuffer *buf);
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : /* individual record(group)'s handlers */
<span class="lineNum">      62 </span>            : static void DecodeInsert(LogicalDecodingContext *ctx, XLogRecordBuffer *buf);
<span class="lineNum">      63 </span>            : static void DecodeUpdate(LogicalDecodingContext *ctx, XLogRecordBuffer *buf);
<span class="lineNum">      64 </span>            : static void DecodeDelete(LogicalDecodingContext *ctx, XLogRecordBuffer *buf);
<span class="lineNum">      65 </span>            : static void DecodeTruncate(LogicalDecodingContext *ctx, XLogRecordBuffer *buf);
<span class="lineNum">      66 </span>            : static void DecodeMultiInsert(LogicalDecodingContext *ctx, XLogRecordBuffer *buf);
<span class="lineNum">      67 </span>            : static void DecodeSpecConfirm(LogicalDecodingContext *ctx, XLogRecordBuffer *buf);
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : static void DecodeCommit(LogicalDecodingContext *ctx, XLogRecordBuffer *buf,
<span class="lineNum">      70 </span>            :                          xl_xact_parsed_commit *parsed, TransactionId xid);
<span class="lineNum">      71 </span>            : static void DecodeAbort(LogicalDecodingContext *ctx, XLogRecordBuffer *buf,
<span class="lineNum">      72 </span>            :                         xl_xact_parsed_abort *parsed, TransactionId xid);
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : /* common function to decode tuples */
<span class="lineNum">      75 </span>            : static void DecodeXLogTuple(char *data, Size len, ReorderBufferTupleBuf *tup);
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : /*
<span class="lineNum">      78 </span>            :  * Take every XLogReadRecord()ed record and perform the actions required to
<span class="lineNum">      79 </span>            :  * decode it using the output plugin already setup in the logical decoding
<span class="lineNum">      80 </span>            :  * context.
<span class="lineNum">      81 </span>            :  *
<span class="lineNum">      82 </span>            :  * NB: Note that every record's xid needs to be processed by reorderbuffer
<span class="lineNum">      83 </span>            :  * (xids contained in the content of records are not relevant for this rule).
<span class="lineNum">      84 </span>            :  * That means that for records which'd otherwise not go through the
<span class="lineNum">      85 </span>            :  * reorderbuffer ReorderBufferProcessXid() has to be called. We don't want to
<span class="lineNum">      86 </span>            :  * call ReorderBufferProcessXid for each record type by default, because
<span class="lineNum">      87 </span>            :  * e.g. empty xacts can be handled more efficiently if there's no previous
<span class="lineNum">      88 </span>            :  * state for them.
<span class="lineNum">      89 </span>            :  *
<span class="lineNum">      90 </span>            :  * We also support the ability to fast forward thru records, skipping some
<span class="lineNum">      91 </span>            :  * record types completely - see individual record types for details.
<a name="92"><span class="lineNum">      92 </span>            :  */</a>
<span class="lineNum">      93 </span>            : void
<span class="lineNum">      94 </span><span class="lineNoCov">          0 : LogicalDecodingProcessRecord(LogicalDecodingContext *ctx, XLogReaderState *record)</span>
<span class="lineNum">      95 </span>            : {
<span class="lineNum">      96 </span>            :     XLogRecordBuffer buf;
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :     buf.origptr = ctx-&gt;reader-&gt;ReadRecPtr;</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :     buf.endptr = ctx-&gt;reader-&gt;EndRecPtr;</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :     buf.record = record;</span>
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :     /* cast so we get a warning when new rmgrs are added */
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :     switch ((RmgrIds) XLogRecGetRmid(record))</span>
<span class="lineNum">     104 </span>            :     {
<span class="lineNum">     105 </span>            :             /*
<span class="lineNum">     106 </span>            :              * Rmgrs we care about for logical decoding. Add new rmgrs in
<span class="lineNum">     107 </span>            :              * rmgrlist.h's order.
<span class="lineNum">     108 </span>            :              */
<span class="lineNum">     109 </span>            :         case RM_XLOG_ID:
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :             DecodeXLogOp(ctx, &amp;buf);</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            :         case RM_XACT_ID:
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :             DecodeXactOp(ctx, &amp;buf);</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :         case RM_STANDBY_ID:
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :             DecodeStandbyOp(ctx, &amp;buf);</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :         case RM_HEAP2_ID:
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :             DecodeHeap2Op(ctx, &amp;buf);</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            :         case RM_HEAP_ID:
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :             DecodeHeapOp(ctx, &amp;buf);</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            :         case RM_LOGICALMSG_ID:
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :             DecodeLogicalMsgOp(ctx, &amp;buf);</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :             /*
<span class="lineNum">     134 </span>            :              * Rmgrs irrelevant for logical decoding; they describe stuff not
<span class="lineNum">     135 </span>            :              * represented in logical decoding. Add new rmgrs in rmgrlist.h's
<span class="lineNum">     136 </span>            :              * order.
<span class="lineNum">     137 </span>            :              */
<span class="lineNum">     138 </span>            :         case RM_SMGR_ID:
<span class="lineNum">     139 </span>            :         case RM_CLOG_ID:
<span class="lineNum">     140 </span>            :         case RM_DBASE_ID:
<span class="lineNum">     141 </span>            :         case RM_TBLSPC_ID:
<span class="lineNum">     142 </span>            :         case RM_MULTIXACT_ID:
<span class="lineNum">     143 </span>            :         case RM_RELMAP_ID:
<span class="lineNum">     144 </span>            :         case RM_BTREE_ID:
<span class="lineNum">     145 </span>            :         case RM_HASH_ID:
<span class="lineNum">     146 </span>            :         case RM_GIN_ID:
<span class="lineNum">     147 </span>            :         case RM_GIST_ID:
<span class="lineNum">     148 </span>            :         case RM_SEQ_ID:
<span class="lineNum">     149 </span>            :         case RM_SPGIST_ID:
<span class="lineNum">     150 </span>            :         case RM_BRIN_ID:
<span class="lineNum">     151 </span>            :         case RM_COMMIT_TS_ID:
<span class="lineNum">     152 </span>            :         case RM_REPLORIGIN_ID:
<span class="lineNum">     153 </span>            :         case RM_GENERIC_ID:
<span class="lineNum">     154 </span>            :             /* just deal with xid, and done */
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :             ReorderBufferProcessXid(ctx-&gt;reorder, XLogRecGetXid(record),</span>
<span class="lineNum">     156 </span>            :                                     buf.origptr);
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     158 </span>            :         case RM_NEXT_ID:
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;unexpected RM_NEXT_ID rmgr_id: %u&quot;, (RmgrIds) XLogRecGetRmid(buf.record));</span>
<span class="lineNum">     160 </span>            :     }
<span class="lineNum">     161 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : /*
<span class="lineNum">     164 </span>            :  * Handle rmgr XLOG_ID records for DecodeRecordIntoReorderBuffer().
<a name="165"><span class="lineNum">     165 </span>            :  */</a>
<span class="lineNum">     166 </span>            : static void
<span class="lineNum">     167 </span><span class="lineNoCov">          0 : DecodeXLogOp(LogicalDecodingContext *ctx, XLogRecordBuffer *buf)</span>
<span class="lineNum">     168 </span>            : {
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     SnapBuild  *builder = ctx-&gt;snapshot_builder;</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     uint8       info = XLogRecGetInfo(buf-&gt;record) &amp; ~XLR_INFO_MASK;</span>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :     ReorderBufferProcessXid(ctx-&gt;reorder, XLogRecGetXid(buf-&gt;record),</span>
<span class="lineNum">     173 </span>            :                             buf-&gt;origptr);
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :     switch (info)</span>
<span class="lineNum">     176 </span>            :     {
<span class="lineNum">     177 </span>            :             /* this is also used in END_OF_RECOVERY checkpoints */
<span class="lineNum">     178 </span>            :         case XLOG_CHECKPOINT_SHUTDOWN:
<span class="lineNum">     179 </span>            :         case XLOG_END_OF_RECOVERY:
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :             SnapBuildSerializationPoint(builder, buf-&gt;origptr);</span>
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     183 </span>            :         case XLOG_CHECKPOINT_ONLINE:
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            :             /*
<span class="lineNum">     186 </span>            :              * a RUNNING_XACTS record will have been logged near to this, we
<span class="lineNum">     187 </span>            :              * can restart from there.
<span class="lineNum">     188 </span>            :              */
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     190 </span>            :         case XLOG_NOOP:
<span class="lineNum">     191 </span>            :         case XLOG_NEXTOID:
<span class="lineNum">     192 </span>            :         case XLOG_SWITCH:
<span class="lineNum">     193 </span>            :         case XLOG_BACKUP_END:
<span class="lineNum">     194 </span>            :         case XLOG_PARAMETER_CHANGE:
<span class="lineNum">     195 </span>            :         case XLOG_RESTORE_POINT:
<span class="lineNum">     196 </span>            :         case XLOG_FPW_CHANGE:
<span class="lineNum">     197 </span>            :         case XLOG_FPI_FOR_HINT:
<span class="lineNum">     198 </span>            :         case XLOG_FPI:
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     200 </span>            :         default:
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;unexpected RM_XLOG_ID record type: %u&quot;, info);</span>
<span class="lineNum">     202 </span>            :     }
<span class="lineNum">     203 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            : /*
<span class="lineNum">     206 </span>            :  * Handle rmgr XACT_ID records for DecodeRecordIntoReorderBuffer().
<a name="207"><span class="lineNum">     207 </span>            :  */</a>
<span class="lineNum">     208 </span>            : static void
<span class="lineNum">     209 </span><span class="lineNoCov">          0 : DecodeXactOp(LogicalDecodingContext *ctx, XLogRecordBuffer *buf)</span>
<span class="lineNum">     210 </span>            : {
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     SnapBuild  *builder = ctx-&gt;snapshot_builder;</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     ReorderBuffer *reorder = ctx-&gt;reorder;</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     XLogReaderState *r = buf-&gt;record;</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :     uint8       info = XLogRecGetInfo(r) &amp; XLOG_XACT_OPMASK;</span>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :     /*
<span class="lineNum">     217 </span>            :      * If the snapshot isn't yet fully built, we cannot decode anything, so
<span class="lineNum">     218 </span>            :      * bail out.
<span class="lineNum">     219 </span>            :      *
<span class="lineNum">     220 </span>            :      * However, it's critical to process XLOG_XACT_ASSIGNMENT records even
<span class="lineNum">     221 </span>            :      * when the snapshot is being built: it is possible to get later records
<span class="lineNum">     222 </span>            :      * that require subxids to be properly assigned.
<span class="lineNum">     223 </span>            :      */
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     if (SnapBuildCurrentState(builder) &lt; SNAPBUILD_FULL_SNAPSHOT &amp;&amp;</span>
<span class="lineNum">     225 </span>            :         info != XLOG_XACT_ASSIGNMENT)
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     switch (info)</span>
<span class="lineNum">     229 </span>            :     {
<span class="lineNum">     230 </span>            :         case XLOG_XACT_COMMIT:
<span class="lineNum">     231 </span>            :         case XLOG_XACT_COMMIT_PREPARED:
<span class="lineNum">     232 </span>            :             {
<span class="lineNum">     233 </span>            :                 xl_xact_commit *xlrec;
<span class="lineNum">     234 </span>            :                 xl_xact_parsed_commit parsed;
<span class="lineNum">     235 </span>            :                 TransactionId xid;
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :                 xlrec = (xl_xact_commit *) XLogRecGetData(r);</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :                 ParseCommitRecord(XLogRecGetInfo(buf-&gt;record), xlrec, &amp;parsed);</span>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :                 if (!TransactionIdIsValid(parsed.twophase_xid))</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :                     xid = XLogRecGetXid(r);</span>
<span class="lineNum">     242 </span>            :                 else
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :                     xid = parsed.twophase_xid;</span>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :                 DecodeCommit(ctx, buf, &amp;parsed, xid);</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     247 </span>            :             }
<span class="lineNum">     248 </span>            :         case XLOG_XACT_ABORT:
<span class="lineNum">     249 </span>            :         case XLOG_XACT_ABORT_PREPARED:
<span class="lineNum">     250 </span>            :             {
<span class="lineNum">     251 </span>            :                 xl_xact_abort *xlrec;
<span class="lineNum">     252 </span>            :                 xl_xact_parsed_abort parsed;
<span class="lineNum">     253 </span>            :                 TransactionId xid;
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :                 xlrec = (xl_xact_abort *) XLogRecGetData(r);</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :                 ParseAbortRecord(XLogRecGetInfo(buf-&gt;record), xlrec, &amp;parsed);</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :                 if (!TransactionIdIsValid(parsed.twophase_xid))</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :                     xid = XLogRecGetXid(r);</span>
<span class="lineNum">     260 </span>            :                 else
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :                     xid = parsed.twophase_xid;</span>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :                 DecodeAbort(ctx, buf, &amp;parsed, xid);</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     265 </span>            :             }
<span class="lineNum">     266 </span>            :         case XLOG_XACT_ASSIGNMENT:
<span class="lineNum">     267 </span>            :             {
<span class="lineNum">     268 </span>            :                 xl_xact_assignment *xlrec;
<span class="lineNum">     269 </span>            :                 int         i;
<span class="lineNum">     270 </span>            :                 TransactionId *sub_xid;
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :                 xlrec = (xl_xact_assignment *) XLogRecGetData(r);</span>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :                 sub_xid = &amp;xlrec-&gt;xsub[0];</span>
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :                 for (i = 0; i &lt; xlrec-&gt;nsubxacts; i++)</span>
<span class="lineNum">     277 </span>            :                 {
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :                     ReorderBufferAssignChild(reorder, xlrec-&gt;xtop,</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :                                              *(sub_xid++), buf-&gt;origptr);</span>
<span class="lineNum">     280 </span>            :                 }
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     282 </span>            :             }
<span class="lineNum">     283 </span>            :         case XLOG_XACT_PREPARE:
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :             /*
<span class="lineNum">     286 </span>            :              * Currently decoding ignores PREPARE TRANSACTION and will just
<span class="lineNum">     287 </span>            :              * decode the transaction when the COMMIT PREPARED is sent or
<span class="lineNum">     288 </span>            :              * throw away the transaction's contents when a ROLLBACK PREPARED
<span class="lineNum">     289 </span>            :              * is received. In the future we could add code to expose prepared
<span class="lineNum">     290 </span>            :              * transactions in the changestream allowing for a kind of
<span class="lineNum">     291 </span>            :              * distributed 2PC.
<span class="lineNum">     292 </span>            :              */
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :             ReorderBufferProcessXid(reorder, XLogRecGetXid(r), buf-&gt;origptr);</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     295 </span>            :         default:
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;unexpected RM_XACT_ID record type: %u&quot;, info);</span>
<span class="lineNum">     297 </span>            :     }
<span class="lineNum">     298 </span>            : }
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            : /*
<span class="lineNum">     301 </span>            :  * Handle rmgr STANDBY_ID records for DecodeRecordIntoReorderBuffer().
<a name="302"><span class="lineNum">     302 </span>            :  */</a>
<span class="lineNum">     303 </span>            : static void
<span class="lineNum">     304 </span><span class="lineNoCov">          0 : DecodeStandbyOp(LogicalDecodingContext *ctx, XLogRecordBuffer *buf)</span>
<span class="lineNum">     305 </span>            : {
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     SnapBuild  *builder = ctx-&gt;snapshot_builder;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     XLogReaderState *r = buf-&gt;record;</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     uint8       info = XLogRecGetInfo(r) &amp; ~XLR_INFO_MASK;</span>
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     ReorderBufferProcessXid(ctx-&gt;reorder, XLogRecGetXid(r), buf-&gt;origptr);</span>
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     switch (info)</span>
<span class="lineNum">     313 </span>            :     {
<span class="lineNum">     314 </span>            :         case XLOG_RUNNING_XACTS:
<span class="lineNum">     315 </span>            :             {
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :                 xl_running_xacts *running = (xl_running_xacts *) XLogRecGetData(r);</span>
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :                 SnapBuildProcessRunningXacts(builder, buf-&gt;origptr, running);</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :                 /*
<span class="lineNum">     321 </span>            :                  * Abort all transactions that we keep track of, that are
<span class="lineNum">     322 </span>            :                  * older than the record's oldestRunningXid. This is the most
<span class="lineNum">     323 </span>            :                  * convenient spot for doing so since, in contrast to shutdown
<span class="lineNum">     324 </span>            :                  * or end-of-recovery checkpoints, we have information about
<span class="lineNum">     325 </span>            :                  * all running transactions which includes prepared ones,
<span class="lineNum">     326 </span>            :                  * while shutdown checkpoints just know that no non-prepared
<span class="lineNum">     327 </span>            :                  * transactions are in progress.
<span class="lineNum">     328 </span>            :                  */
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :                 ReorderBufferAbortOld(ctx-&gt;reorder, running-&gt;oldestRunningXid);</span>
<span class="lineNum">     330 </span>            :             }
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     332 </span>            :         case XLOG_STANDBY_LOCK:
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     334 </span>            :         case XLOG_INVALIDATIONS:
<span class="lineNum">     335 </span>            :             {
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :                 xl_invalidations *invalidations =</span>
<span class="lineNum">     337 </span>            :                 (xl_invalidations *) XLogRecGetData(r);
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :                 if (!ctx-&gt;fast_forward)</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :                     ReorderBufferImmediateInvalidation(ctx-&gt;reorder,</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :                                                        invalidations-&gt;nmsgs,</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :                                                        invalidations-&gt;msgs);</span>
<span class="lineNum">     343 </span>            :             }
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     345 </span>            :         default:
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;unexpected RM_STANDBY_ID record type: %u&quot;, info);</span>
<span class="lineNum">     347 </span>            :     }
<span class="lineNum">     348 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            : /*
<span class="lineNum">     351 </span>            :  * Handle rmgr HEAP2_ID records for DecodeRecordIntoReorderBuffer().
<a name="352"><span class="lineNum">     352 </span>            :  */</a>
<span class="lineNum">     353 </span>            : static void
<span class="lineNum">     354 </span><span class="lineNoCov">          0 : DecodeHeap2Op(LogicalDecodingContext *ctx, XLogRecordBuffer *buf)</span>
<span class="lineNum">     355 </span>            : {
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     uint8       info = XLogRecGetInfo(buf-&gt;record) &amp; XLOG_HEAP_OPMASK;</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     TransactionId xid = XLogRecGetXid(buf-&gt;record);</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     SnapBuild  *builder = ctx-&gt;snapshot_builder;</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     ReorderBufferProcessXid(ctx-&gt;reorder, xid, buf-&gt;origptr);</span>
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            :     /*
<span class="lineNum">     363 </span>            :      * If we don't have snapshot or we are just fast-forwarding, there is no
<span class="lineNum">     364 </span>            :      * point in decoding changes.
<span class="lineNum">     365 </span>            :      */
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     if (SnapBuildCurrentState(builder) &lt; SNAPBUILD_FULL_SNAPSHOT ||</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :         ctx-&gt;fast_forward)</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     switch (info)</span>
<span class="lineNum">     371 </span>            :     {
<span class="lineNum">     372 </span>            :         case XLOG_HEAP2_MULTI_INSERT:
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :             if (!ctx-&gt;fast_forward &amp;&amp;</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :                 SnapBuildProcessChange(builder, xid, buf-&gt;origptr))</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :                 DecodeMultiInsert(ctx, buf);</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     377 </span>            :         case XLOG_HEAP2_NEW_CID:
<span class="lineNum">     378 </span>            :             {
<span class="lineNum">     379 </span>            :                 xl_heap_new_cid *xlrec;
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :                 xlrec = (xl_heap_new_cid *) XLogRecGetData(buf-&gt;record);</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :                 SnapBuildProcessNewCid(builder, xid, buf-&gt;origptr, xlrec);</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     385 </span>            :             }
<span class="lineNum">     386 </span>            :         case XLOG_HEAP2_REWRITE:
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            :             /*
<span class="lineNum">     389 </span>            :              * Although these records only exist to serve the needs of logical
<span class="lineNum">     390 </span>            :              * decoding, all the work happens as part of crash or archive
<span class="lineNum">     391 </span>            :              * recovery, so we don't need to do anything here.
<span class="lineNum">     392 </span>            :              */
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            :             /*
<span class="lineNum">     396 </span>            :              * Everything else here is just low level physical stuff we're not
<span class="lineNum">     397 </span>            :              * interested in.
<span class="lineNum">     398 </span>            :              */
<span class="lineNum">     399 </span>            :         case XLOG_HEAP2_FREEZE_PAGE:
<span class="lineNum">     400 </span>            :         case XLOG_HEAP2_CLEAN:
<span class="lineNum">     401 </span>            :         case XLOG_HEAP2_CLEANUP_INFO:
<span class="lineNum">     402 </span>            :         case XLOG_HEAP2_VISIBLE:
<span class="lineNum">     403 </span>            :         case XLOG_HEAP2_LOCK_UPDATED:
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     405 </span>            :         default:
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;unexpected RM_HEAP2_ID record type: %u&quot;, info);</span>
<span class="lineNum">     407 </span>            :     }
<span class="lineNum">     408 </span>            : }
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            : /*
<span class="lineNum">     411 </span>            :  * Handle rmgr HEAP_ID records for DecodeRecordIntoReorderBuffer().
<a name="412"><span class="lineNum">     412 </span>            :  */</a>
<span class="lineNum">     413 </span>            : static void
<span class="lineNum">     414 </span><span class="lineNoCov">          0 : DecodeHeapOp(LogicalDecodingContext *ctx, XLogRecordBuffer *buf)</span>
<span class="lineNum">     415 </span>            : {
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     uint8       info = XLogRecGetInfo(buf-&gt;record) &amp; XLOG_HEAP_OPMASK;</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :     TransactionId xid = XLogRecGetXid(buf-&gt;record);</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :     SnapBuild  *builder = ctx-&gt;snapshot_builder;</span>
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :     ReorderBufferProcessXid(ctx-&gt;reorder, xid, buf-&gt;origptr);</span>
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :     /*
<span class="lineNum">     423 </span>            :      * If we don't have snapshot or we are just fast-forwarding, there is no
<span class="lineNum">     424 </span>            :      * point in decoding data changes.
<span class="lineNum">     425 </span>            :      */
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     if (SnapBuildCurrentState(builder) &lt; SNAPBUILD_FULL_SNAPSHOT ||</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :         ctx-&gt;fast_forward)</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     switch (info)</span>
<span class="lineNum">     431 </span>            :     {
<span class="lineNum">     432 </span>            :         case XLOG_HEAP_INSERT:
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :             if (SnapBuildProcessChange(builder, xid, buf-&gt;origptr))</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :                 DecodeInsert(ctx, buf);</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            :             /*
<span class="lineNum">     438 </span>            :              * Treat HOT update as normal updates. There is no useful
<span class="lineNum">     439 </span>            :              * information in the fact that we could make it a HOT update
<span class="lineNum">     440 </span>            :              * locally and the WAL layout is compatible.
<span class="lineNum">     441 </span>            :              */
<span class="lineNum">     442 </span>            :         case XLOG_HEAP_HOT_UPDATE:
<span class="lineNum">     443 </span>            :         case XLOG_HEAP_UPDATE:
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :             if (SnapBuildProcessChange(builder, xid, buf-&gt;origptr))</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :                 DecodeUpdate(ctx, buf);</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :         case XLOG_HEAP_DELETE:
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :             if (SnapBuildProcessChange(builder, xid, buf-&gt;origptr))</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :                 DecodeDelete(ctx, buf);</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :         case XLOG_HEAP_TRUNCATE:
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :             if (SnapBuildProcessChange(builder, xid, buf-&gt;origptr))</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :                 DecodeTruncate(ctx, buf);</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            :         case XLOG_HEAP_INPLACE:
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            :             /*
<span class="lineNum">     461 </span>            :              * Inplace updates are only ever performed on catalog tuples and
<span class="lineNum">     462 </span>            :              * can, per definition, not change tuple visibility.  Since we
<span class="lineNum">     463 </span>            :              * don't decode catalog tuples, we're not interested in the
<span class="lineNum">     464 </span>            :              * record's contents.
<span class="lineNum">     465 </span>            :              *
<span class="lineNum">     466 </span>            :              * In-place updates can be used either by XID-bearing transactions
<span class="lineNum">     467 </span>            :              * (e.g.  in CREATE INDEX CONCURRENTLY) or by XID-less
<span class="lineNum">     468 </span>            :              * transactions (e.g.  VACUUM).  In the former case, the commit
<span class="lineNum">     469 </span>            :              * record will include cache invalidations, so we mark the
<span class="lineNum">     470 </span>            :              * transaction as catalog modifying here. Currently that's
<span class="lineNum">     471 </span>            :              * redundant because the commit will do that as well, but once we
<span class="lineNum">     472 </span>            :              * support decoding in-progress relations, this will be important.
<span class="lineNum">     473 </span>            :              */
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :             if (!TransactionIdIsValid(xid))</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :             SnapBuildProcessChange(builder, xid, buf-&gt;origptr);</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :             ReorderBufferXidSetCatalogChanges(ctx-&gt;reorder, xid, buf-&gt;origptr);</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            :         case XLOG_HEAP_CONFIRM:
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :             if (SnapBuildProcessChange(builder, xid, buf-&gt;origptr))</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :                 DecodeSpecConfirm(ctx, buf);</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :         case XLOG_HEAP_LOCK:
<span class="lineNum">     487 </span>            :             /* we don't care about row level locks for now */
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            :         default:
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;unexpected RM_HEAP_ID record type: %u&quot;, info);</span>
<span class="lineNum">     492 </span>            :             break;
<span class="lineNum">     493 </span>            :     }
<span class="lineNum">     494 </span>            : }
<a name="495"><span class="lineNum">     495 </span>            : </a>
<span class="lineNum">     496 </span>            : static inline bool
<span class="lineNum">     497 </span><span class="lineNoCov">          0 : FilterByOrigin(LogicalDecodingContext *ctx, RepOriginId origin_id)</span>
<span class="lineNum">     498 </span>            : {
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     if (ctx-&gt;callbacks.filter_by_origin_cb == NULL)</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :     return filter_by_origin_cb_wrapper(ctx, origin_id);</span>
<span class="lineNum">     503 </span>            : }
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            : /*
<span class="lineNum">     506 </span>            :  * Handle rmgr LOGICALMSG_ID records for DecodeRecordIntoReorderBuffer().
<a name="507"><span class="lineNum">     507 </span>            :  */</a>
<span class="lineNum">     508 </span>            : static void
<span class="lineNum">     509 </span><span class="lineNoCov">          0 : DecodeLogicalMsgOp(LogicalDecodingContext *ctx, XLogRecordBuffer *buf)</span>
<span class="lineNum">     510 </span>            : {
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     SnapBuild  *builder = ctx-&gt;snapshot_builder;</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :     XLogReaderState *r = buf-&gt;record;</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :     TransactionId xid = XLogRecGetXid(r);</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :     uint8       info = XLogRecGetInfo(r) &amp; ~XLR_INFO_MASK;</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :     RepOriginId origin_id = XLogRecGetOrigin(r);</span>
<span class="lineNum">     516 </span>            :     Snapshot    snapshot;
<span class="lineNum">     517 </span>            :     xl_logical_message *message;
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     if (info != XLOG_LOGICAL_MESSAGE)</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;unexpected RM_LOGICALMSG_ID record type: %u&quot;, info);</span>
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :     ReorderBufferProcessXid(ctx-&gt;reorder, XLogRecGetXid(r), buf-&gt;origptr);</span>
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            :     /*
<span class="lineNum">     525 </span>            :      * If we don't have snapshot or we are just fast-forwarding, there is no
<span class="lineNum">     526 </span>            :      * point in decoding messages.
<span class="lineNum">     527 </span>            :      */
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :     if (SnapBuildCurrentState(builder) &lt; SNAPBUILD_FULL_SNAPSHOT ||</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :         ctx-&gt;fast_forward)</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :     message = (xl_logical_message *) XLogRecGetData(r);</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :     if (message-&gt;dbId != ctx-&gt;slot-&gt;data.database ||</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :         FilterByOrigin(ctx, origin_id))</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :     if (message-&gt;transactional &amp;&amp;</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :         !SnapBuildProcessChange(builder, xid, buf-&gt;origptr))</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :     else if (!message-&gt;transactional &amp;&amp;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :              (SnapBuildCurrentState(builder) != SNAPBUILD_CONSISTENT ||</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :               SnapBuildXactNeedsSkip(builder, buf-&gt;origptr)))</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     snapshot = SnapBuildGetOrBuildSnapshot(builder, xid);</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :     ReorderBufferQueueMessage(ctx-&gt;reorder, xid, snapshot, buf-&gt;endptr,</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :                               message-&gt;transactional,</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :                               message-&gt;message, /* first part of message is</span>
<span class="lineNum">     550 </span>            :                                                  * prefix */
<span class="lineNum">     551 </span>            :                               message-&gt;message_size,
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :                               message-&gt;message + message-&gt;prefix_size);</span>
<span class="lineNum">     553 </span>            : }
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span>            : /*
<span class="lineNum">     556 </span>            :  * Consolidated commit record handling between the different form of commit
<span class="lineNum">     557 </span>            :  * records.
<a name="558"><span class="lineNum">     558 </span>            :  */</a>
<span class="lineNum">     559 </span>            : static void
<span class="lineNum">     560 </span><span class="lineNoCov">          0 : DecodeCommit(LogicalDecodingContext *ctx, XLogRecordBuffer *buf,</span>
<span class="lineNum">     561 </span>            :              xl_xact_parsed_commit *parsed, TransactionId xid)
<span class="lineNum">     562 </span>            : {
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     XLogRecPtr  origin_lsn = InvalidXLogRecPtr;</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :     TimestampTz commit_time = parsed-&gt;xact_time;</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :     RepOriginId origin_id = XLogRecGetOrigin(buf-&gt;record);</span>
<span class="lineNum">     566 </span>            :     int         i;
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :     if (parsed-&gt;xinfo &amp; XACT_XINFO_HAS_ORIGIN)</span>
<span class="lineNum">     569 </span>            :     {
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :         origin_lsn = parsed-&gt;origin_lsn;</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :         commit_time = parsed-&gt;origin_timestamp;</span>
<span class="lineNum">     572 </span>            :     }
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span>            :     /*
<span class="lineNum">     575 </span>            :      * Process invalidation messages, even if we're not interested in the
<span class="lineNum">     576 </span>            :      * transaction's contents, since the various caches need to always be
<span class="lineNum">     577 </span>            :      * consistent.
<span class="lineNum">     578 </span>            :      */
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :     if (parsed-&gt;nmsgs &gt; 0)</span>
<span class="lineNum">     580 </span>            :     {
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :         if (!ctx-&gt;fast_forward)</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :             ReorderBufferAddInvalidations(ctx-&gt;reorder, xid, buf-&gt;origptr,</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :                                           parsed-&gt;nmsgs, parsed-&gt;msgs);</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :         ReorderBufferXidSetCatalogChanges(ctx-&gt;reorder, xid, buf-&gt;origptr);</span>
<span class="lineNum">     585 </span>            :     }
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     SnapBuildCommitTxn(ctx-&gt;snapshot_builder, buf-&gt;origptr, xid,</span>
<span class="lineNum">     588 </span>            :                        parsed-&gt;nsubxacts, parsed-&gt;subxacts);
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :     /* ----
<span class="lineNum">     591 </span>            :      * Check whether we are interested in this specific transaction, and tell
<span class="lineNum">     592 </span>            :      * the reorderbuffer to forget the content of the (sub-)transactions
<span class="lineNum">     593 </span>            :      * if not.
<span class="lineNum">     594 </span>            :      *
<span class="lineNum">     595 </span>            :      * There can be several reasons we might not be interested in this
<span class="lineNum">     596 </span>            :      * transaction:
<span class="lineNum">     597 </span>            :      * 1) We might not be interested in decoding transactions up to this
<span class="lineNum">     598 </span>            :      *    LSN. This can happen because we previously decoded it and now just
<span class="lineNum">     599 </span>            :      *    are restarting or if we haven't assembled a consistent snapshot yet.
<span class="lineNum">     600 </span>            :      * 2) The transaction happened in another database.
<span class="lineNum">     601 </span>            :      * 3) The output plugin is not interested in the origin.
<span class="lineNum">     602 </span>            :      * 4) We are doing fast-forwarding
<span class="lineNum">     603 </span>            :      *
<span class="lineNum">     604 </span>            :      * We can't just use ReorderBufferAbort() here, because we need to execute
<span class="lineNum">     605 </span>            :      * the transaction's invalidations.  This currently won't be needed if
<span class="lineNum">     606 </span>            :      * we're just skipping over the transaction because currently we only do
<span class="lineNum">     607 </span>            :      * so during startup, to get to the first transaction the client needs. As
<span class="lineNum">     608 </span>            :      * we have reset the catalog caches before starting to read WAL, and we
<span class="lineNum">     609 </span>            :      * haven't yet touched any catalogs, there can't be anything to invalidate.
<span class="lineNum">     610 </span>            :      * But if we're &quot;forgetting&quot; this commit because it's it happened in
<span class="lineNum">     611 </span>            :      * another database, the invalidations might be important, because they
<span class="lineNum">     612 </span>            :      * could be for shared catalogs and we might have loaded data into the
<span class="lineNum">     613 </span>            :      * relevant syscaches.
<span class="lineNum">     614 </span>            :      * ---
<span class="lineNum">     615 </span>            :      */
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :     if (SnapBuildXactNeedsSkip(ctx-&gt;snapshot_builder, buf-&gt;origptr) ||</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :         (parsed-&gt;dbId != InvalidOid &amp;&amp; parsed-&gt;dbId != ctx-&gt;slot-&gt;data.database) ||</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :         ctx-&gt;fast_forward || FilterByOrigin(ctx, origin_id))</span>
<span class="lineNum">     619 </span>            :     {
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; parsed-&gt;nsubxacts; i++)</span>
<span class="lineNum">     621 </span>            :         {
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :             ReorderBufferForget(ctx-&gt;reorder, parsed-&gt;subxacts[i], buf-&gt;origptr);</span>
<span class="lineNum">     623 </span>            :         }
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :         ReorderBufferForget(ctx-&gt;reorder, xid, buf-&gt;origptr);</span>
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     627 </span>            :     }
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            :     /* tell the reorderbuffer about the surviving subtransactions */
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; parsed-&gt;nsubxacts; i++)</span>
<span class="lineNum">     631 </span>            :     {
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :         ReorderBufferCommitChild(ctx-&gt;reorder, xid, parsed-&gt;subxacts[i],</span>
<span class="lineNum">     633 </span>            :                                  buf-&gt;origptr, buf-&gt;endptr);
<span class="lineNum">     634 </span>            :     }
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            :     /* replay actions of all transaction + subtransactions in order */
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     ReorderBufferCommit(ctx-&gt;reorder, xid, buf-&gt;origptr, buf-&gt;endptr,</span>
<span class="lineNum">     638 </span>            :                         commit_time, origin_id, origin_lsn);
<span class="lineNum">     639 </span>            : }
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            : /*
<span class="lineNum">     642 </span>            :  * Get the data from the various forms of abort records and pass it on to
<span class="lineNum">     643 </span>            :  * snapbuild.c and reorderbuffer.c
<a name="644"><span class="lineNum">     644 </span>            :  */</a>
<span class="lineNum">     645 </span>            : static void
<span class="lineNum">     646 </span><span class="lineNoCov">          0 : DecodeAbort(LogicalDecodingContext *ctx, XLogRecordBuffer *buf,</span>
<span class="lineNum">     647 </span>            :             xl_xact_parsed_abort *parsed, TransactionId xid)
<span class="lineNum">     648 </span>            : {
<span class="lineNum">     649 </span>            :     int         i;
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; parsed-&gt;nsubxacts; i++)</span>
<span class="lineNum">     652 </span>            :     {
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :         ReorderBufferAbort(ctx-&gt;reorder, parsed-&gt;subxacts[i],</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :                            buf-&gt;record-&gt;EndRecPtr);</span>
<span class="lineNum">     655 </span>            :     }
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :     ReorderBufferAbort(ctx-&gt;reorder, xid, buf-&gt;record-&gt;EndRecPtr);</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            : /*
<span class="lineNum">     661 </span>            :  * Parse XLOG_HEAP_INSERT (not MULTI_INSERT!) records into tuplebufs.
<span class="lineNum">     662 </span>            :  *
<span class="lineNum">     663 </span>            :  * Deletes can contain the new tuple.
<a name="664"><span class="lineNum">     664 </span>            :  */</a>
<span class="lineNum">     665 </span>            : static void
<span class="lineNum">     666 </span><span class="lineNoCov">          0 : DecodeInsert(LogicalDecodingContext *ctx, XLogRecordBuffer *buf)</span>
<span class="lineNum">     667 </span>            : {
<span class="lineNum">     668 </span>            :     Size        datalen;
<span class="lineNum">     669 </span>            :     char       *tupledata;
<span class="lineNum">     670 </span>            :     Size        tuplelen;
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :     XLogReaderState *r = buf-&gt;record;</span>
<span class="lineNum">     672 </span>            :     xl_heap_insert *xlrec;
<span class="lineNum">     673 </span>            :     ReorderBufferChange *change;
<span class="lineNum">     674 </span>            :     RelFileNode target_node;
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :     xlrec = (xl_heap_insert *) XLogRecGetData(r);</span>
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            :     /*
<span class="lineNum">     679 </span>            :      * Ignore insert records without new tuples (this does happen when
<span class="lineNum">     680 </span>            :      * raw_heap_insert marks the TOAST record as HEAP_INSERT_NO_LOGICAL).
<span class="lineNum">     681 </span>            :      */
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :     if (!(xlrec-&gt;flags &amp; XLH_INSERT_CONTAINS_NEW_TUPLE))</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span>            :     /* only interested in our database */
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :     XLogRecGetBlockTag(r, 0, &amp;target_node, NULL, NULL);</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     if (target_node.dbNode != ctx-&gt;slot-&gt;data.database)</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            :     /* output plugin doesn't look for this origin, no need to queue */
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :     if (FilterByOrigin(ctx, XLogRecGetOrigin(r)))</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     change = ReorderBufferGetChange(ctx-&gt;reorder);</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     if (!(xlrec-&gt;flags &amp; XLH_INSERT_IS_SPECULATIVE))</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :         change-&gt;action = REORDER_BUFFER_CHANGE_INSERT;</span>
<span class="lineNum">     697 </span>            :     else
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :         change-&gt;action = REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT;</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     change-&gt;origin_id = XLogRecGetOrigin(r);</span>
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :     memcpy(&amp;change-&gt;data.tp.relnode, &amp;target_node, sizeof(RelFileNode));</span>
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :     tupledata = XLogRecGetBlockData(r, 0, &amp;datalen);</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :     tuplelen = datalen - SizeOfHeapHeader;</span>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     change-&gt;data.tp.newtuple =</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :         ReorderBufferGetTupleBuf(ctx-&gt;reorder, tuplelen);</span>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :     DecodeXLogTuple(tupledata, datalen, change-&gt;data.tp.newtuple);</span>
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :     change-&gt;data.tp.clear_toast_afterwards = true;</span>
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     ReorderBufferQueueChange(ctx-&gt;reorder, XLogRecGetXid(r), buf-&gt;origptr, change);</span>
<span class="lineNum">     714 </span>            : }
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            : /*
<span class="lineNum">     717 </span>            :  * Parse XLOG_HEAP_UPDATE and XLOG_HEAP_HOT_UPDATE, which have the same layout
<span class="lineNum">     718 </span>            :  * in the record, from wal into proper tuplebufs.
<span class="lineNum">     719 </span>            :  *
<span class="lineNum">     720 </span>            :  * Updates can possibly contain a new tuple and the old primary key.
<a name="721"><span class="lineNum">     721 </span>            :  */</a>
<span class="lineNum">     722 </span>            : static void
<span class="lineNum">     723 </span><span class="lineNoCov">          0 : DecodeUpdate(LogicalDecodingContext *ctx, XLogRecordBuffer *buf)</span>
<span class="lineNum">     724 </span>            : {
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :     XLogReaderState *r = buf-&gt;record;</span>
<span class="lineNum">     726 </span>            :     xl_heap_update *xlrec;
<span class="lineNum">     727 </span>            :     ReorderBufferChange *change;
<span class="lineNum">     728 </span>            :     char       *data;
<span class="lineNum">     729 </span>            :     RelFileNode target_node;
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :     xlrec = (xl_heap_update *) XLogRecGetData(r);</span>
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span>            :     /* only interested in our database */
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :     XLogRecGetBlockTag(r, 0, &amp;target_node, NULL, NULL);</span>
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :     if (target_node.dbNode != ctx-&gt;slot-&gt;data.database)</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            :     /* output plugin doesn't look for this origin, no need to queue */
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :     if (FilterByOrigin(ctx, XLogRecGetOrigin(r)))</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :     change = ReorderBufferGetChange(ctx-&gt;reorder);</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :     change-&gt;action = REORDER_BUFFER_CHANGE_UPDATE;</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :     change-&gt;origin_id = XLogRecGetOrigin(r);</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     memcpy(&amp;change-&gt;data.tp.relnode, &amp;target_node, sizeof(RelFileNode));</span>
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     if (xlrec-&gt;flags &amp; XLH_UPDATE_CONTAINS_NEW_TUPLE)</span>
<span class="lineNum">     748 </span>            :     {
<span class="lineNum">     749 </span>            :         Size        datalen;
<span class="lineNum">     750 </span>            :         Size        tuplelen;
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :         data = XLogRecGetBlockData(r, 0, &amp;datalen);</span>
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :         tuplelen = datalen - SizeOfHeapHeader;</span>
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :         change-&gt;data.tp.newtuple =</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :             ReorderBufferGetTupleBuf(ctx-&gt;reorder, tuplelen);</span>
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :         DecodeXLogTuple(data, datalen, change-&gt;data.tp.newtuple);</span>
<span class="lineNum">     760 </span>            :     }
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :     if (xlrec-&gt;flags &amp; XLH_UPDATE_CONTAINS_OLD)</span>
<span class="lineNum">     763 </span>            :     {
<span class="lineNum">     764 </span>            :         Size        datalen;
<span class="lineNum">     765 </span>            :         Size        tuplelen;
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span>            :         /* caution, remaining data in record is not aligned */
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :         data = XLogRecGetData(r) + SizeOfHeapUpdate;</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :         datalen = XLogRecGetDataLen(r) - SizeOfHeapUpdate;</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :         tuplelen = datalen - SizeOfHeapHeader;</span>
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :         change-&gt;data.tp.oldtuple =</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :             ReorderBufferGetTupleBuf(ctx-&gt;reorder, tuplelen);</span>
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :         DecodeXLogTuple(data, datalen, change-&gt;data.tp.oldtuple);</span>
<span class="lineNum">     776 </span>            :     }
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :     change-&gt;data.tp.clear_toast_afterwards = true;</span>
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :     ReorderBufferQueueChange(ctx-&gt;reorder, XLogRecGetXid(r), buf-&gt;origptr, change);</span>
<span class="lineNum">     781 </span>            : }
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            : /*
<span class="lineNum">     784 </span>            :  * Parse XLOG_HEAP_DELETE from wal into proper tuplebufs.
<span class="lineNum">     785 </span>            :  *
<span class="lineNum">     786 </span>            :  * Deletes can possibly contain the old primary key.
<a name="787"><span class="lineNum">     787 </span>            :  */</a>
<span class="lineNum">     788 </span>            : static void
<span class="lineNum">     789 </span><span class="lineNoCov">          0 : DecodeDelete(LogicalDecodingContext *ctx, XLogRecordBuffer *buf)</span>
<span class="lineNum">     790 </span>            : {
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     XLogReaderState *r = buf-&gt;record;</span>
<span class="lineNum">     792 </span>            :     xl_heap_delete *xlrec;
<span class="lineNum">     793 </span>            :     ReorderBufferChange *change;
<span class="lineNum">     794 </span>            :     RelFileNode target_node;
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :     xlrec = (xl_heap_delete *) XLogRecGetData(r);</span>
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            :     /* only interested in our database */
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :     XLogRecGetBlockTag(r, 0, &amp;target_node, NULL, NULL);</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     if (target_node.dbNode != ctx-&gt;slot-&gt;data.database)</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            :     /*
<span class="lineNum">     804 </span>            :      * Super deletions are irrelevant for logical decoding, it's driven by the
<span class="lineNum">     805 </span>            :      * confirmation records.
<span class="lineNum">     806 </span>            :      */
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     if (xlrec-&gt;flags &amp; XLH_DELETE_IS_SUPER)</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            :     /* output plugin doesn't look for this origin, no need to queue */
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     if (FilterByOrigin(ctx, XLogRecGetOrigin(r)))</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :     change = ReorderBufferGetChange(ctx-&gt;reorder);</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :     change-&gt;action = REORDER_BUFFER_CHANGE_DELETE;</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     change-&gt;origin_id = XLogRecGetOrigin(r);</span>
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :     memcpy(&amp;change-&gt;data.tp.relnode, &amp;target_node, sizeof(RelFileNode));</span>
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            :     /* old primary key stored */
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :     if (xlrec-&gt;flags &amp; XLH_DELETE_CONTAINS_OLD)</span>
<span class="lineNum">     822 </span>            :     {
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :         Size        datalen = XLogRecGetDataLen(r) - SizeOfHeapDelete;</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :         Size        tuplelen = datalen - SizeOfHeapHeader;</span>
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :         Assert(XLogRecGetDataLen(r) &gt; (SizeOfHeapDelete + SizeOfHeapHeader));</span>
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :         change-&gt;data.tp.oldtuple =</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :             ReorderBufferGetTupleBuf(ctx-&gt;reorder, tuplelen);</span>
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :         DecodeXLogTuple((char *) xlrec + SizeOfHeapDelete,</span>
<span class="lineNum">     832 </span>            :                         datalen, change-&gt;data.tp.oldtuple);
<span class="lineNum">     833 </span>            :     }
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :     change-&gt;data.tp.clear_toast_afterwards = true;</span>
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :     ReorderBufferQueueChange(ctx-&gt;reorder, XLogRecGetXid(r), buf-&gt;origptr, change);</span>
<span class="lineNum">     838 </span>            : }
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span>            : /*
<span class="lineNum">     841 </span>            :  * Parse XLOG_HEAP_TRUNCATE from wal
<a name="842"><span class="lineNum">     842 </span>            :  */</a>
<span class="lineNum">     843 </span>            : static void
<span class="lineNum">     844 </span><span class="lineNoCov">          0 : DecodeTruncate(LogicalDecodingContext *ctx, XLogRecordBuffer *buf)</span>
<span class="lineNum">     845 </span>            : {
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :     XLogReaderState *r = buf-&gt;record;</span>
<span class="lineNum">     847 </span>            :     xl_heap_truncate *xlrec;
<span class="lineNum">     848 </span>            :     ReorderBufferChange *change;
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :     xlrec = (xl_heap_truncate *) XLogRecGetData(r);</span>
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span>            :     /* only interested in our database */
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :     if (xlrec-&gt;dbId != ctx-&gt;slot-&gt;data.database)</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            :     /* output plugin doesn't look for this origin, no need to queue */
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :     if (FilterByOrigin(ctx, XLogRecGetOrigin(r)))</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :     change = ReorderBufferGetChange(ctx-&gt;reorder);</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :     change-&gt;action = REORDER_BUFFER_CHANGE_TRUNCATE;</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :     change-&gt;origin_id = XLogRecGetOrigin(r);</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :     if (xlrec-&gt;flags &amp; XLH_TRUNCATE_CASCADE)</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :         change-&gt;data.truncate.cascade = true;</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :     if (xlrec-&gt;flags &amp; XLH_TRUNCATE_RESTART_SEQS)</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :         change-&gt;data.truncate.restart_seqs = true;</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :     change-&gt;data.truncate.nrelids = xlrec-&gt;nrelids;</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     change-&gt;data.truncate.relids = ReorderBufferGetRelids(ctx-&gt;reorder,</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :                                                           xlrec-&gt;nrelids);</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :     memcpy(change-&gt;data.truncate.relids, xlrec-&gt;relids,</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :            xlrec-&gt;nrelids * sizeof(Oid));</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :     ReorderBufferQueueChange(ctx-&gt;reorder, XLogRecGetXid(r),</span>
<span class="lineNum">     873 </span>            :                              buf-&gt;origptr, change);
<span class="lineNum">     874 </span>            : }
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span>            : /*
<span class="lineNum">     877 </span>            :  * Decode XLOG_HEAP2_MULTI_INSERT_insert record into multiple tuplebufs.
<span class="lineNum">     878 </span>            :  *
<span class="lineNum">     879 </span>            :  * Currently MULTI_INSERT will always contain the full tuples.
<a name="880"><span class="lineNum">     880 </span>            :  */</a>
<span class="lineNum">     881 </span>            : static void
<span class="lineNum">     882 </span><span class="lineNoCov">          0 : DecodeMultiInsert(LogicalDecodingContext *ctx, XLogRecordBuffer *buf)</span>
<span class="lineNum">     883 </span>            : {
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     XLogReaderState *r = buf-&gt;record;</span>
<span class="lineNum">     885 </span>            :     xl_heap_multi_insert *xlrec;
<span class="lineNum">     886 </span>            :     int         i;
<span class="lineNum">     887 </span>            :     char       *data;
<span class="lineNum">     888 </span>            :     char       *tupledata;
<span class="lineNum">     889 </span>            :     Size        tuplelen;
<span class="lineNum">     890 </span>            :     RelFileNode rnode;
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :     xlrec = (xl_heap_multi_insert *) XLogRecGetData(r);</span>
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            :     /* only interested in our database */
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :     XLogRecGetBlockTag(r, 0, &amp;rnode, NULL, NULL);</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     if (rnode.dbNode != ctx-&gt;slot-&gt;data.database)</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            :     /* output plugin doesn't look for this origin, no need to queue */
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     if (FilterByOrigin(ctx, XLogRecGetOrigin(r)))</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            :     /*
<span class="lineNum">     904 </span>            :      * As multi_insert is not used for catalogs yet, the block should always
<span class="lineNum">     905 </span>            :      * have data even if a full-page write of it is taken.
<span class="lineNum">     906 </span>            :      */
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :     tupledata = XLogRecGetBlockData(r, 0, &amp;tuplelen);</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :     Assert(tupledata != NULL);</span>
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :     data = tupledata;</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; xlrec-&gt;ntuples; i++)</span>
<span class="lineNum">     912 </span>            :     {
<span class="lineNum">     913 </span>            :         ReorderBufferChange *change;
<span class="lineNum">     914 </span>            :         xl_multi_insert_tuple *xlhdr;
<span class="lineNum">     915 </span>            :         int         datalen;
<span class="lineNum">     916 </span>            :         ReorderBufferTupleBuf *tuple;
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :         change = ReorderBufferGetChange(ctx-&gt;reorder);</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :         change-&gt;action = REORDER_BUFFER_CHANGE_INSERT;</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :         change-&gt;origin_id = XLogRecGetOrigin(r);</span>
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :         memcpy(&amp;change-&gt;data.tp.relnode, &amp;rnode, sizeof(RelFileNode));</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :         xlhdr = (xl_multi_insert_tuple *) SHORTALIGN(data);</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :         data = ((char *) xlhdr) + SizeOfMultiInsertTuple;</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :         datalen = xlhdr-&gt;datalen;</span>
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span>            :         /*
<span class="lineNum">     929 </span>            :          * CONTAINS_NEW_TUPLE will always be set currently as multi_insert
<span class="lineNum">     930 </span>            :          * isn't used for catalogs, but better be future proof.
<span class="lineNum">     931 </span>            :          *
<span class="lineNum">     932 </span>            :          * We decode the tuple in pretty much the same way as DecodeXLogTuple,
<span class="lineNum">     933 </span>            :          * but since the layout is slightly different, we can't use it here.
<span class="lineNum">     934 </span>            :          */
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :         if (xlrec-&gt;flags &amp; XLH_INSERT_CONTAINS_NEW_TUPLE)</span>
<span class="lineNum">     936 </span>            :         {
<span class="lineNum">     937 </span>            :             HeapTupleHeader header;
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :             change-&gt;data.tp.newtuple =</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :                 ReorderBufferGetTupleBuf(ctx-&gt;reorder, datalen);</span>
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :             tuple = change-&gt;data.tp.newtuple;</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :             header = tuple-&gt;tuple.t_data;</span>
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            :             /* not a disk based tuple */
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :             ItemPointerSetInvalid(&amp;tuple-&gt;tuple.t_self);</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span>            :             /*
<span class="lineNum">     949 </span>            :              * We can only figure this out after reassembling the
<span class="lineNum">     950 </span>            :              * transactions.
<span class="lineNum">     951 </span>            :              */
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :             tuple-&gt;tuple.t_tableOid = InvalidOid;</span>
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :             tuple-&gt;tuple.t_len = datalen + SizeofHeapTupleHeader;</span>
<span class="lineNum">     955 </span>            : 
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :             memset(header, 0, SizeofHeapTupleHeader);</span>
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :             memcpy((char *) tuple-&gt;tuple.t_data + SizeofHeapTupleHeader,</span>
<span class="lineNum">     959 </span>            :                    (char *) data,
<span class="lineNum">     960 </span>            :                    datalen);
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :             header-&gt;t_infomask = xlhdr-&gt;t_infomask;</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :             header-&gt;t_infomask2 = xlhdr-&gt;t_infomask2;</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :             header-&gt;t_hoff = xlhdr-&gt;t_hoff;</span>
<span class="lineNum">     964 </span>            :         }
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span>            :         /*
<span class="lineNum">     967 </span>            :          * Reset toast reassembly state only after the last row in the last
<span class="lineNum">     968 </span>            :          * xl_multi_insert_tuple record emitted by one heap_multi_insert()
<span class="lineNum">     969 </span>            :          * call.
<span class="lineNum">     970 </span>            :          */
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :         if (xlrec-&gt;flags &amp; XLH_INSERT_LAST_IN_MULTI &amp;&amp;</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :             (i + 1) == xlrec-&gt;ntuples)</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :             change-&gt;data.tp.clear_toast_afterwards = true;</span>
<span class="lineNum">     974 </span>            :         else
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :             change-&gt;data.tp.clear_toast_afterwards = false;</span>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :         ReorderBufferQueueChange(ctx-&gt;reorder, XLogRecGetXid(r),</span>
<span class="lineNum">     978 </span>            :                                  buf-&gt;origptr, change);
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            :         /* move to the next xl_multi_insert_tuple entry */
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :         data += datalen;</span>
<span class="lineNum">     982 </span>            :     }
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :     Assert(data == tupledata + tuplelen);</span>
<span class="lineNum">     984 </span>            : }
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span>            : /*
<span class="lineNum">     987 </span>            :  * Parse XLOG_HEAP_CONFIRM from wal into a confirmation change.
<span class="lineNum">     988 </span>            :  *
<span class="lineNum">     989 </span>            :  * This is pretty trivial, all the state essentially already setup by the
<span class="lineNum">     990 </span>            :  * speculative insertion.
<a name="991"><span class="lineNum">     991 </span>            :  */</a>
<span class="lineNum">     992 </span>            : static void
<span class="lineNum">     993 </span><span class="lineNoCov">          0 : DecodeSpecConfirm(LogicalDecodingContext *ctx, XLogRecordBuffer *buf)</span>
<span class="lineNum">     994 </span>            : {
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :     XLogReaderState *r = buf-&gt;record;</span>
<span class="lineNum">     996 </span>            :     ReorderBufferChange *change;
<span class="lineNum">     997 </span>            :     RelFileNode target_node;
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span>            :     /* only interested in our database */
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :     XLogRecGetBlockTag(r, 0, &amp;target_node, NULL, NULL);</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :     if (target_node.dbNode != ctx-&gt;slot-&gt;data.database)</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            :     /* output plugin doesn't look for this origin, no need to queue */
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :     if (FilterByOrigin(ctx, XLogRecGetOrigin(r)))</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :     change = ReorderBufferGetChange(ctx-&gt;reorder);</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :     change-&gt;action = REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM;</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :     change-&gt;origin_id = XLogRecGetOrigin(r);</span>
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     memcpy(&amp;change-&gt;data.tp.relnode, &amp;target_node, sizeof(RelFileNode));</span>
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :     change-&gt;data.tp.clear_toast_afterwards = true;</span>
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :     ReorderBufferQueueChange(ctx-&gt;reorder, XLogRecGetXid(r), buf-&gt;origptr, change);</span>
<span class="lineNum">    1017 </span>            : }
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span>            : /*
<span class="lineNum">    1021 </span>            :  * Read a HeapTuple as WAL logged by heap_insert, heap_update and heap_delete
<span class="lineNum">    1022 </span>            :  * (but not by heap_multi_insert) into a tuplebuf.
<span class="lineNum">    1023 </span>            :  *
<span class="lineNum">    1024 </span>            :  * The size 'len' and the pointer 'data' in the record need to be
<span class="lineNum">    1025 </span>            :  * computed outside as they are record specific.
<a name="1026"><span class="lineNum">    1026 </span>            :  */</a>
<span class="lineNum">    1027 </span>            : static void
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 : DecodeXLogTuple(char *data, Size len, ReorderBufferTupleBuf *tuple)</span>
<span class="lineNum">    1029 </span>            : {
<span class="lineNum">    1030 </span>            :     xl_heap_header xlhdr;
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     int         datalen = len - SizeOfHeapHeader;</span>
<span class="lineNum">    1032 </span>            :     HeapTupleHeader header;
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :     Assert(datalen &gt;= 0);</span>
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :     tuple-&gt;tuple.t_len = datalen + SizeofHeapTupleHeader;</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :     header = tuple-&gt;tuple.t_data;</span>
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span>            :     /* not a disk based tuple */
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :     ItemPointerSetInvalid(&amp;tuple-&gt;tuple.t_self);</span>
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span>            :     /* we can only figure this out after reassembling the transactions */
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :     tuple-&gt;tuple.t_tableOid = InvalidOid;</span>
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            :     /* data is not stored aligned, copy to aligned storage */
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :     memcpy((char *) &amp;xlhdr,</span>
<span class="lineNum">    1047 </span>            :            data,
<span class="lineNum">    1048 </span>            :            SizeOfHeapHeader);
<span class="lineNum">    1049 </span>            : 
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :     memset(header, 0, SizeofHeapTupleHeader);</span>
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :     memcpy(((char *) tuple-&gt;tuple.t_data) + SizeofHeapTupleHeader,</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :            data + SizeOfHeapHeader,</span>
<span class="lineNum">    1054 </span>            :            datalen);
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :     header-&gt;t_infomask = xlhdr.t_infomask;</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :     header-&gt;t_infomask2 = xlhdr.t_infomask2;</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :     header-&gt;t_hoff = xlhdr.t_hoff;</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
