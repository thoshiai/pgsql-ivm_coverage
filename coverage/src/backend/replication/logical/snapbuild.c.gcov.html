<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/replication/logical/snapbuild.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/backend/replication/logical</a> - snapbuild.c<span style="font-size: 80%;"> (source / <a href="snapbuild.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntry">532</td>
            <td class="headerCovTableEntryLo">2.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntryLo">3.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * snapbuild.c
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  *    Infrastructure for building historic catalog snapshots based on contents
<span class="lineNum">       6 </span>            :  *    of the WAL, for the purpose of decoding heapam.c style values in the
<span class="lineNum">       7 </span>            :  *    WAL.
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  * NOTES:
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  * We build snapshots which can *only* be used to read catalog contents and we
<span class="lineNum">      12 </span>            :  * do so by reading and interpreting the WAL stream. The aim is to build a
<span class="lineNum">      13 </span>            :  * snapshot that behaves the same as a freshly taken MVCC snapshot would have
<span class="lineNum">      14 </span>            :  * at the time the XLogRecord was generated.
<span class="lineNum">      15 </span>            :  *
<span class="lineNum">      16 </span>            :  * To build the snapshots we reuse the infrastructure built for Hot
<span class="lineNum">      17 </span>            :  * Standby. The in-memory snapshots we build look different than HS' because
<span class="lineNum">      18 </span>            :  * we have different needs. To successfully decode data from the WAL we only
<span class="lineNum">      19 </span>            :  * need to access catalog tables and (sys|rel|cat)cache, not the actual user
<span class="lineNum">      20 </span>            :  * tables since the data we decode is wholly contained in the WAL
<span class="lineNum">      21 </span>            :  * records. Also, our snapshots need to be different in comparison to normal
<span class="lineNum">      22 </span>            :  * MVCC ones because in contrast to those we cannot fully rely on the clog and
<span class="lineNum">      23 </span>            :  * pg_subtrans for information about committed transactions because they might
<span class="lineNum">      24 </span>            :  * commit in the future from the POV of the WAL entry we're currently
<span class="lineNum">      25 </span>            :  * decoding. This definition has the advantage that we only need to prevent
<span class="lineNum">      26 </span>            :  * removal of catalog rows, while normal table's rows can still be
<span class="lineNum">      27 </span>            :  * removed. This is achieved by using the replication slot mechanism.
<span class="lineNum">      28 </span>            :  *
<span class="lineNum">      29 </span>            :  * As the percentage of transactions modifying the catalog normally is fairly
<span class="lineNum">      30 </span>            :  * small in comparisons to ones only manipulating user data, we keep track of
<span class="lineNum">      31 </span>            :  * the committed catalog modifying ones inside [xmin, xmax) instead of keeping
<span class="lineNum">      32 </span>            :  * track of all running transactions like it's done in a normal snapshot. Note
<span class="lineNum">      33 </span>            :  * that we're generally only looking at transactions that have acquired an
<span class="lineNum">      34 </span>            :  * xid. That is we keep a list of transactions between snapshot-&gt;(xmin, xmax)
<span class="lineNum">      35 </span>            :  * that we consider committed, everything else is considered aborted/in
<span class="lineNum">      36 </span>            :  * progress. That also allows us not to care about subtransactions before they
<span class="lineNum">      37 </span>            :  * have committed which means this module, in contrast to HS, doesn't have to
<span class="lineNum">      38 </span>            :  * care about suboverflowed subtransactions and similar.
<span class="lineNum">      39 </span>            :  *
<span class="lineNum">      40 </span>            :  * One complexity of doing this is that to e.g. handle mixed DDL/DML
<span class="lineNum">      41 </span>            :  * transactions we need Snapshots that see intermediate versions of the
<span class="lineNum">      42 </span>            :  * catalog in a transaction. During normal operation this is achieved by using
<span class="lineNum">      43 </span>            :  * CommandIds/cmin/cmax. The problem with that however is that for space
<span class="lineNum">      44 </span>            :  * efficiency reasons only one value of that is stored
<span class="lineNum">      45 </span>            :  * (cf. combocid.c). Since ComboCids are only available in memory we log
<span class="lineNum">      46 </span>            :  * additional information which allows us to get the original (cmin, cmax)
<span class="lineNum">      47 </span>            :  * pair during visibility checks. Check the reorderbuffer.c's comment above
<span class="lineNum">      48 </span>            :  * ResolveCminCmaxDuringDecoding() for details.
<span class="lineNum">      49 </span>            :  *
<span class="lineNum">      50 </span>            :  * To facilitate all this we need our own visibility routine, as the normal
<span class="lineNum">      51 </span>            :  * ones are optimized for different usecases.
<span class="lineNum">      52 </span>            :  *
<span class="lineNum">      53 </span>            :  * To replace the normal catalog snapshots with decoding ones use the
<span class="lineNum">      54 </span>            :  * SetupHistoricSnapshot() and TeardownHistoricSnapshot() functions.
<span class="lineNum">      55 </span>            :  *
<span class="lineNum">      56 </span>            :  *
<span class="lineNum">      57 </span>            :  *
<span class="lineNum">      58 </span>            :  * The snapbuild machinery is starting up in several stages, as illustrated
<span class="lineNum">      59 </span>            :  * by the following graph describing the SnapBuild-&gt;state transitions:
<span class="lineNum">      60 </span>            :  *
<span class="lineNum">      61 </span>            :  *         +-------------------------+
<span class="lineNum">      62 </span>            :  *    +----|         START           |-------------+
<span class="lineNum">      63 </span>            :  *    |    +-------------------------+             |
<span class="lineNum">      64 </span>            :  *    |                 |                          |
<span class="lineNum">      65 </span>            :  *    |                 |                          |
<span class="lineNum">      66 </span>            :  *    |        running_xacts #1                    |
<span class="lineNum">      67 </span>            :  *    |                 |                          |
<span class="lineNum">      68 </span>            :  *    |                 |                          |
<span class="lineNum">      69 </span>            :  *    |                 v                          |
<span class="lineNum">      70 </span>            :  *    |    +-------------------------+             v
<span class="lineNum">      71 </span>            :  *    |    |   BUILDING_SNAPSHOT     |------------&gt;|
<span class="lineNum">      72 </span>            :  *    |    +-------------------------+             |
<span class="lineNum">      73 </span>            :  *    |                 |                          |
<span class="lineNum">      74 </span>            :  *    |                 |                          |
<span class="lineNum">      75 </span>            :  *    | running_xacts #2, xacts from #1 finished   |
<span class="lineNum">      76 </span>            :  *    |                 |                          |
<span class="lineNum">      77 </span>            :  *    |                 |                          |
<span class="lineNum">      78 </span>            :  *    |                 v                          |
<span class="lineNum">      79 </span>            :  *    |    +-------------------------+             v
<span class="lineNum">      80 </span>            :  *    |    |       FULL_SNAPSHOT     |------------&gt;|
<span class="lineNum">      81 </span>            :  *    |    +-------------------------+             |
<span class="lineNum">      82 </span>            :  *    |                 |                          |
<span class="lineNum">      83 </span>            :  * running_xacts        |                      saved snapshot
<span class="lineNum">      84 </span>            :  * with zero xacts      |                 at running_xacts's lsn
<span class="lineNum">      85 </span>            :  *    |                 |                          |
<span class="lineNum">      86 </span>            :  *    | running_xacts with xacts from #2 finished  |
<span class="lineNum">      87 </span>            :  *    |                 |                          |
<span class="lineNum">      88 </span>            :  *    |                 v                          |
<span class="lineNum">      89 </span>            :  *    |    +-------------------------+             |
<span class="lineNum">      90 </span>            :  *    +---&gt;|SNAPBUILD_CONSISTENT  |&lt;------------+
<span class="lineNum">      91 </span>            :  *         +-------------------------+
<span class="lineNum">      92 </span>            :  *
<span class="lineNum">      93 </span>            :  * Initially the machinery is in the START stage. When an xl_running_xacts
<span class="lineNum">      94 </span>            :  * record is read that is sufficiently new (above the safe xmin horizon),
<span class="lineNum">      95 </span>            :  * there's a state transition. If there were no running xacts when the
<span class="lineNum">      96 </span>            :  * running_xacts record was generated, we'll directly go into CONSISTENT
<span class="lineNum">      97 </span>            :  * state, otherwise we'll switch to the BUILDING_SNAPSHOT state. Having a full
<span class="lineNum">      98 </span>            :  * snapshot means that all transactions that start henceforth can be decoded
<span class="lineNum">      99 </span>            :  * in their entirety, but transactions that started previously can't. In
<span class="lineNum">     100 </span>            :  * FULL_SNAPSHOT we'll switch into CONSISTENT once all those previously
<span class="lineNum">     101 </span>            :  * running transactions have committed or aborted.
<span class="lineNum">     102 </span>            :  *
<span class="lineNum">     103 </span>            :  * Only transactions that commit after CONSISTENT state has been reached will
<span class="lineNum">     104 </span>            :  * be replayed, even though they might have started while still in
<span class="lineNum">     105 </span>            :  * FULL_SNAPSHOT. That ensures that we'll reach a point where no previous
<span class="lineNum">     106 </span>            :  * changes has been exported, but all the following ones will be. That point
<span class="lineNum">     107 </span>            :  * is a convenient point to initialize replication from, which is why we
<span class="lineNum">     108 </span>            :  * export a snapshot at that point, which *can* be used to read normal data.
<span class="lineNum">     109 </span>            :  *
<span class="lineNum">     110 </span>            :  * Copyright (c) 2012-2019, PostgreSQL Global Development Group
<span class="lineNum">     111 </span>            :  *
<span class="lineNum">     112 </span>            :  * IDENTIFICATION
<span class="lineNum">     113 </span>            :  *    src/backend/replication/snapbuild.c
<span class="lineNum">     114 </span>            :  *
<span class="lineNum">     115 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">     116 </span>            :  */
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : #include &lt;sys/stat.h&gt;
<span class="lineNum">     121 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : #include &quot;access/heapam_xlog.h&quot;
<span class="lineNum">     124 </span>            : #include &quot;access/transam.h&quot;
<span class="lineNum">     125 </span>            : #include &quot;access/xact.h&quot;
<span class="lineNum">     126 </span>            : #include &quot;miscadmin.h&quot;
<span class="lineNum">     127 </span>            : #include &quot;pgstat.h&quot;
<span class="lineNum">     128 </span>            : #include &quot;replication/logical.h&quot;
<span class="lineNum">     129 </span>            : #include &quot;replication/reorderbuffer.h&quot;
<span class="lineNum">     130 </span>            : #include &quot;replication/snapbuild.h&quot;
<span class="lineNum">     131 </span>            : #include &quot;storage/block.h&quot;        /* debugging output */
<span class="lineNum">     132 </span>            : #include &quot;storage/fd.h&quot;
<span class="lineNum">     133 </span>            : #include &quot;storage/lmgr.h&quot;
<span class="lineNum">     134 </span>            : #include &quot;storage/proc.h&quot;
<span class="lineNum">     135 </span>            : #include &quot;storage/procarray.h&quot;
<span class="lineNum">     136 </span>            : #include &quot;storage/standby.h&quot;
<span class="lineNum">     137 </span>            : #include &quot;utils/builtins.h&quot;
<span class="lineNum">     138 </span>            : #include &quot;utils/memutils.h&quot;
<span class="lineNum">     139 </span>            : #include &quot;utils/snapmgr.h&quot;
<span class="lineNum">     140 </span>            : #include &quot;utils/snapshot.h&quot;
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : /*
<span class="lineNum">     143 </span>            :  * This struct contains the current state of the snapshot building
<span class="lineNum">     144 </span>            :  * machinery. Besides a forward declaration in the header, it is not exposed
<span class="lineNum">     145 </span>            :  * to the public, so we can easily change its contents.
<span class="lineNum">     146 </span>            :  */
<span class="lineNum">     147 </span>            : struct SnapBuild
<span class="lineNum">     148 </span>            : {
<span class="lineNum">     149 </span>            :     /* how far are we along building our first full snapshot */
<span class="lineNum">     150 </span>            :     SnapBuildState state;
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :     /* private memory context used to allocate memory for this module. */
<span class="lineNum">     153 </span>            :     MemoryContext context;
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            :     /* all transactions &lt; than this have committed/aborted */
<span class="lineNum">     156 </span>            :     TransactionId xmin;
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            :     /* all transactions &gt;= than this are uncommitted */
<span class="lineNum">     159 </span>            :     TransactionId xmax;
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :     /*
<span class="lineNum">     162 </span>            :      * Don't replay commits from an LSN &lt; this LSN. This can be set externally
<span class="lineNum">     163 </span>            :      * but it will also be advanced (never retreat) from within snapbuild.c.
<span class="lineNum">     164 </span>            :      */
<span class="lineNum">     165 </span>            :     XLogRecPtr  start_decoding_at;
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :     /*
<span class="lineNum">     168 </span>            :      * Don't start decoding WAL until the &quot;xl_running_xacts&quot; information
<span class="lineNum">     169 </span>            :      * indicates there are no running xids with an xid smaller than this.
<span class="lineNum">     170 </span>            :      */
<span class="lineNum">     171 </span>            :     TransactionId initial_xmin_horizon;
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            :     /* Indicates if we are building full snapshot or just catalog one. */
<span class="lineNum">     174 </span>            :     bool        building_full_snapshot;
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :     /*
<span class="lineNum">     177 </span>            :      * Snapshot that's valid to see the catalog state seen at this moment.
<span class="lineNum">     178 </span>            :      */
<span class="lineNum">     179 </span>            :     Snapshot    snapshot;
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            :     /*
<span class="lineNum">     182 </span>            :      * LSN of the last location we are sure a snapshot has been serialized to.
<span class="lineNum">     183 </span>            :      */
<span class="lineNum">     184 </span>            :     XLogRecPtr  last_serialized_snapshot;
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            :     /*
<span class="lineNum">     187 </span>            :      * The reorderbuffer we need to update with usable snapshots et al.
<span class="lineNum">     188 </span>            :      */
<span class="lineNum">     189 </span>            :     ReorderBuffer *reorder;
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :     /*
<span class="lineNum">     192 </span>            :      * Outdated: This struct isn't used for its original purpose anymore, but
<span class="lineNum">     193 </span>            :      * can't be removed / changed in a minor version, because it's stored
<span class="lineNum">     194 </span>            :      * on-disk.
<span class="lineNum">     195 </span>            :      */
<span class="lineNum">     196 </span>            :     struct
<span class="lineNum">     197 </span>            :     {
<span class="lineNum">     198 </span>            :         /*
<span class="lineNum">     199 </span>            :          * NB: This field is misused, until a major version can break on-disk
<span class="lineNum">     200 </span>            :          * compatibility. See SnapBuildNextPhaseAt() /
<span class="lineNum">     201 </span>            :          * SnapBuildStartNextPhaseAt().
<span class="lineNum">     202 </span>            :          */
<span class="lineNum">     203 </span>            :         TransactionId was_xmin;
<span class="lineNum">     204 </span>            :         TransactionId was_xmax;
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :         size_t      was_xcnt;   /* number of used xip entries */
<span class="lineNum">     207 </span>            :         size_t      was_xcnt_space; /* allocated size of xip */
<span class="lineNum">     208 </span>            :         TransactionId *was_xip; /* running xacts array, xidComparator-sorted */
<span class="lineNum">     209 </span>            :     }           was_running;
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :     /*
<span class="lineNum">     212 </span>            :      * Array of transactions which could have catalog changes that committed
<span class="lineNum">     213 </span>            :      * between xmin and xmax.
<span class="lineNum">     214 </span>            :      */
<span class="lineNum">     215 </span>            :     struct
<span class="lineNum">     216 </span>            :     {
<span class="lineNum">     217 </span>            :         /* number of committed transactions */
<span class="lineNum">     218 </span>            :         size_t      xcnt;
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :         /* available space for committed transactions */
<span class="lineNum">     221 </span>            :         size_t      xcnt_space;
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :         /*
<span class="lineNum">     224 </span>            :          * Until we reach a CONSISTENT state, we record commits of all
<span class="lineNum">     225 </span>            :          * transactions, not just the catalog changing ones. Record when that
<span class="lineNum">     226 </span>            :          * changes so we know we cannot export a snapshot safely anymore.
<span class="lineNum">     227 </span>            :          */
<span class="lineNum">     228 </span>            :         bool        includes_all_transactions;
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            :         /*
<span class="lineNum">     231 </span>            :          * Array of committed transactions that have modified the catalog.
<span class="lineNum">     232 </span>            :          *
<span class="lineNum">     233 </span>            :          * As this array is frequently modified we do *not* keep it in
<span class="lineNum">     234 </span>            :          * xidComparator order. Instead we sort the array when building &amp;
<span class="lineNum">     235 </span>            :          * distributing a snapshot.
<span class="lineNum">     236 </span>            :          *
<span class="lineNum">     237 </span>            :          * TODO: It's unclear whether that reasoning has much merit. Every
<span class="lineNum">     238 </span>            :          * time we add something here after becoming consistent will also
<span class="lineNum">     239 </span>            :          * require distributing a snapshot. Storing them sorted would
<span class="lineNum">     240 </span>            :          * potentially also make it easier to purge (but more complicated wrt
<span class="lineNum">     241 </span>            :          * wraparound?). Should be improved if sorting while building the
<span class="lineNum">     242 </span>            :          * snapshot shows up in profiles.
<span class="lineNum">     243 </span>            :          */
<span class="lineNum">     244 </span>            :         TransactionId *xip;
<span class="lineNum">     245 </span>            :     }           committed;
<span class="lineNum">     246 </span>            : };
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            : /*
<span class="lineNum">     249 </span>            :  * Starting a transaction -- which we need to do while exporting a snapshot --
<span class="lineNum">     250 </span>            :  * removes knowledge about the previously used resowner, so we save it here.
<span class="lineNum">     251 </span>            :  */
<span class="lineNum">     252 </span>            : static ResourceOwner SavedResourceOwnerDuringExport = NULL;
<span class="lineNum">     253 </span>            : static bool ExportInProgress = false;
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : /* -&gt;committed manipulation */
<span class="lineNum">     256 </span>            : static void SnapBuildPurgeCommittedTxn(SnapBuild *builder);
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : /* snapshot building/manipulation/distribution functions */
<span class="lineNum">     259 </span>            : static Snapshot SnapBuildBuildSnapshot(SnapBuild *builder);
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            : static void SnapBuildFreeSnapshot(Snapshot snap);
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : static void SnapBuildSnapIncRefcount(Snapshot snap);
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : static void SnapBuildDistributeNewCatalogSnapshot(SnapBuild *builder, XLogRecPtr lsn);
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            : /* xlog reading helper functions for SnapBuildProcessRunningXacts */
<span class="lineNum">     268 </span>            : static bool SnapBuildFindSnapshot(SnapBuild *builder, XLogRecPtr lsn, xl_running_xacts *running);
<span class="lineNum">     269 </span>            : static void SnapBuildWaitSnapshot(xl_running_xacts *running, TransactionId cutoff);
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : /* serialization functions */
<span class="lineNum">     272 </span>            : static void SnapBuildSerialize(SnapBuild *builder, XLogRecPtr lsn);
<span class="lineNum">     273 </span>            : static bool SnapBuildRestore(SnapBuild *builder, XLogRecPtr lsn);
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            : /*
<span class="lineNum">     276 </span>            :  * Return TransactionId after which the next phase of initial snapshot
<span class="lineNum">     277 </span>            :  * building will happen.
<a name="278"><span class="lineNum">     278 </span>            :  */</a>
<span class="lineNum">     279 </span>            : static inline TransactionId
<span class="lineNum">     280 </span><span class="lineNoCov">          0 : SnapBuildNextPhaseAt(SnapBuild *builder)</span>
<span class="lineNum">     281 </span>            : {
<span class="lineNum">     282 </span>            :     /*
<span class="lineNum">     283 </span>            :      * For backward compatibility reasons this has to be stored in the wrongly
<span class="lineNum">     284 </span>            :      * named field.  Will be fixed in next major version.
<span class="lineNum">     285 </span>            :      */
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     return builder-&gt;was_running.was_xmax;</span>
<span class="lineNum">     287 </span>            : }
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            : /*
<span class="lineNum">     290 </span>            :  * Set TransactionId after which the next phase of initial snapshot building
<span class="lineNum">     291 </span>            :  * will happen.
<a name="292"><span class="lineNum">     292 </span>            :  */</a>
<span class="lineNum">     293 </span>            : static inline void
<span class="lineNum">     294 </span><span class="lineNoCov">          0 : SnapBuildStartNextPhaseAt(SnapBuild *builder, TransactionId at)</span>
<span class="lineNum">     295 </span>            : {
<span class="lineNum">     296 </span>            :     /*
<span class="lineNum">     297 </span>            :      * For backward compatibility reasons this has to be stored in the wrongly
<span class="lineNum">     298 </span>            :      * named field.  Will be fixed in next major version.
<span class="lineNum">     299 </span>            :      */
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     builder-&gt;was_running.was_xmax = at;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            : /*
<span class="lineNum">     304 </span>            :  * Allocate a new snapshot builder.
<span class="lineNum">     305 </span>            :  *
<span class="lineNum">     306 </span>            :  * xmin_horizon is the xid &gt;= which we can be sure no catalog rows have been
<span class="lineNum">     307 </span>            :  * removed, start_lsn is the LSN &gt;= we want to replay commits.
<a name="308"><span class="lineNum">     308 </span>            :  */</a>
<span class="lineNum">     309 </span>            : SnapBuild *
<span class="lineNum">     310 </span><span class="lineNoCov">          0 : AllocateSnapshotBuilder(ReorderBuffer *reorder,</span>
<span class="lineNum">     311 </span>            :                         TransactionId xmin_horizon,
<span class="lineNum">     312 </span>            :                         XLogRecPtr start_lsn,
<span class="lineNum">     313 </span>            :                         bool need_full_snapshot)
<span class="lineNum">     314 </span>            : {
<span class="lineNum">     315 </span>            :     MemoryContext context;
<span class="lineNum">     316 </span>            :     MemoryContext oldcontext;
<span class="lineNum">     317 </span>            :     SnapBuild  *builder;
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :     /* allocate memory in own context, to have better accountability */
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     context = AllocSetContextCreate(CurrentMemoryContext,</span>
<span class="lineNum">     321 </span>            :                                     &quot;snapshot builder context&quot;,
<span class="lineNum">     322 </span>            :                                     ALLOCSET_DEFAULT_SIZES);
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :     oldcontext = MemoryContextSwitchTo(context);</span>
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     builder = palloc0(sizeof(SnapBuild));</span>
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     builder-&gt;state = SNAPBUILD_START;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     builder-&gt;context = context;</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     builder-&gt;reorder = reorder;</span>
<span class="lineNum">     330 </span>            :     /* Other struct members initialized by zeroing via palloc0 above */
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     builder-&gt;committed.xcnt = 0;</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     builder-&gt;committed.xcnt_space = 128; /* arbitrary number */</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     builder-&gt;committed.xip =</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :         palloc0(builder-&gt;committed.xcnt_space * sizeof(TransactionId));</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     builder-&gt;committed.includes_all_transactions = true;</span>
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :     builder-&gt;initial_xmin_horizon = xmin_horizon;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     builder-&gt;start_decoding_at = start_lsn;</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :     builder-&gt;building_full_snapshot = need_full_snapshot;</span>
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     MemoryContextSwitchTo(oldcontext);</span>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :     return builder;</span>
<span class="lineNum">     345 </span>            : }
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            : /*
<span class="lineNum">     348 </span>            :  * Free a snapshot builder.
<a name="349"><span class="lineNum">     349 </span>            :  */</a>
<span class="lineNum">     350 </span>            : void
<span class="lineNum">     351 </span><span class="lineNoCov">          0 : FreeSnapshotBuilder(SnapBuild *builder)</span>
<span class="lineNum">     352 </span>            : {
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     MemoryContext context = builder-&gt;context;</span>
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            :     /* free snapshot explicitly, that contains some error checking */
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     if (builder-&gt;snapshot != NULL)</span>
<span class="lineNum">     357 </span>            :     {
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :         SnapBuildSnapDecRefcount(builder-&gt;snapshot);</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :         builder-&gt;snapshot = NULL;</span>
<span class="lineNum">     360 </span>            :     }
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            :     /* other resources are deallocated via memory context reset */
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     MemoryContextDelete(context);</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            : /*
<span class="lineNum">     367 </span>            :  * Free an unreferenced snapshot that has previously been built by us.
<a name="368"><span class="lineNum">     368 </span>            :  */</a>
<span class="lineNum">     369 </span>            : static void
<span class="lineNum">     370 </span><span class="lineNoCov">          0 : SnapBuildFreeSnapshot(Snapshot snap)</span>
<span class="lineNum">     371 </span>            : {
<span class="lineNum">     372 </span>            :     /* make sure we don't get passed an external snapshot */
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     Assert(snap-&gt;snapshot_type == SNAPSHOT_HISTORIC_MVCC);</span>
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            :     /* make sure nobody modified our snapshot */
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     Assert(snap-&gt;curcid == FirstCommandId);</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :     Assert(!snap-&gt;suboverflowed);</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     Assert(!snap-&gt;takenDuringRecovery);</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     Assert(snap-&gt;regd_count == 0);</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            :     /* slightly more likely, so it's checked even without c-asserts */
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     if (snap-&gt;copied)</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cannot free a copied snapshot&quot;);</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :     if (snap-&gt;active_count)</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cannot free an active snapshot&quot;);</span>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :     pfree(snap);</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            : /*
<span class="lineNum">     392 </span>            :  * In which state of snapshot building are we?
<a name="393"><span class="lineNum">     393 </span>            :  */</a>
<span class="lineNum">     394 </span>            : SnapBuildState
<span class="lineNum">     395 </span><span class="lineNoCov">          0 : SnapBuildCurrentState(SnapBuild *builder)</span>
<span class="lineNum">     396 </span>            : {
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     return builder-&gt;state;</span>
<span class="lineNum">     398 </span>            : }
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            : /*
<span class="lineNum">     401 </span>            :  * Should the contents of transaction ending at 'ptr' be decoded?
<a name="402"><span class="lineNum">     402 </span>            :  */</a>
<span class="lineNum">     403 </span>            : bool
<span class="lineNum">     404 </span><span class="lineNoCov">          0 : SnapBuildXactNeedsSkip(SnapBuild *builder, XLogRecPtr ptr)</span>
<span class="lineNum">     405 </span>            : {
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     return ptr &lt; builder-&gt;start_decoding_at;</span>
<span class="lineNum">     407 </span>            : }
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            : /*
<span class="lineNum">     410 </span>            :  * Increase refcount of a snapshot.
<span class="lineNum">     411 </span>            :  *
<span class="lineNum">     412 </span>            :  * This is used when handing out a snapshot to some external resource or when
<span class="lineNum">     413 </span>            :  * adding a Snapshot as builder-&gt;snapshot.
<a name="414"><span class="lineNum">     414 </span>            :  */</a>
<span class="lineNum">     415 </span>            : static void
<span class="lineNum">     416 </span><span class="lineNoCov">          0 : SnapBuildSnapIncRefcount(Snapshot snap)</span>
<span class="lineNum">     417 </span>            : {
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :     snap-&gt;active_count++;</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            : /*
<span class="lineNum">     422 </span>            :  * Decrease refcount of a snapshot and free if the refcount reaches zero.
<span class="lineNum">     423 </span>            :  *
<span class="lineNum">     424 </span>            :  * Externally visible, so that external resources that have been handed an
<span class="lineNum">     425 </span>            :  * IncRef'ed Snapshot can adjust its refcount easily.
<a name="426"><span class="lineNum">     426 </span>            :  */</a>
<span class="lineNum">     427 </span>            : void
<span class="lineNum">     428 </span><span class="lineNoCov">          0 : SnapBuildSnapDecRefcount(Snapshot snap)</span>
<span class="lineNum">     429 </span>            : {
<span class="lineNum">     430 </span>            :     /* make sure we don't get passed an external snapshot */
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     Assert(snap-&gt;snapshot_type == SNAPSHOT_HISTORIC_MVCC);</span>
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            :     /* make sure nobody modified our snapshot */
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :     Assert(snap-&gt;curcid == FirstCommandId);</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     Assert(!snap-&gt;suboverflowed);</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     Assert(!snap-&gt;takenDuringRecovery);</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     Assert(snap-&gt;regd_count == 0);</span>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     Assert(snap-&gt;active_count &gt; 0);</span>
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :     /* slightly more likely, so it's checked even without casserts */
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     if (snap-&gt;copied)</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cannot free a copied snapshot&quot;);</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     snap-&gt;active_count--;</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :     if (snap-&gt;active_count == 0)</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :         SnapBuildFreeSnapshot(snap);</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            : /*
<span class="lineNum">     452 </span>            :  * Build a new snapshot, based on currently committed catalog-modifying
<span class="lineNum">     453 </span>            :  * transactions.
<span class="lineNum">     454 </span>            :  *
<span class="lineNum">     455 </span>            :  * In-progress transactions with catalog access are *not* allowed to modify
<span class="lineNum">     456 </span>            :  * these snapshots; they have to copy them and fill in appropriate -&gt;curcid
<span class="lineNum">     457 </span>            :  * and -&gt;subxip/subxcnt values.
<a name="458"><span class="lineNum">     458 </span>            :  */</a>
<span class="lineNum">     459 </span>            : static Snapshot
<span class="lineNum">     460 </span><span class="lineNoCov">          0 : SnapBuildBuildSnapshot(SnapBuild *builder)</span>
<span class="lineNum">     461 </span>            : {
<span class="lineNum">     462 </span>            :     Snapshot    snapshot;
<span class="lineNum">     463 </span>            :     Size        ssize;
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     Assert(builder-&gt;state &gt;= SNAPBUILD_FULL_SNAPSHOT);</span>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :     ssize = sizeof(SnapshotData)</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :         + sizeof(TransactionId) * builder-&gt;committed.xcnt</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :         + sizeof(TransactionId) * 1 /* toplevel xid */ ;</span>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     snapshot = MemoryContextAllocZero(builder-&gt;context, ssize);</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     snapshot-&gt;snapshot_type = SNAPSHOT_HISTORIC_MVCC;</span>
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            :     /*
<span class="lineNum">     476 </span>            :      * We misuse the original meaning of SnapshotData's xip and subxip fields
<span class="lineNum">     477 </span>            :      * to make the more fitting for our needs.
<span class="lineNum">     478 </span>            :      *
<span class="lineNum">     479 </span>            :      * In the 'xip' array we store transactions that have to be treated as
<span class="lineNum">     480 </span>            :      * committed. Since we will only ever look at tuples from transactions
<span class="lineNum">     481 </span>            :      * that have modified the catalog it's more efficient to store those few
<span class="lineNum">     482 </span>            :      * that exist between xmin and xmax (frequently there are none).
<span class="lineNum">     483 </span>            :      *
<span class="lineNum">     484 </span>            :      * Snapshots that are used in transactions that have modified the catalog
<span class="lineNum">     485 </span>            :      * also use the 'subxip' array to store their toplevel xid and all the
<span class="lineNum">     486 </span>            :      * subtransaction xids so we can recognize when we need to treat rows as
<span class="lineNum">     487 </span>            :      * visible that are not in xip but still need to be visible. Subxip only
<span class="lineNum">     488 </span>            :      * gets filled when the transaction is copied into the context of a
<span class="lineNum">     489 </span>            :      * catalog modifying transaction since we otherwise share a snapshot
<span class="lineNum">     490 </span>            :      * between transactions. As long as a txn hasn't modified the catalog it
<span class="lineNum">     491 </span>            :      * doesn't need to treat any uncommitted rows as visible, so there is no
<span class="lineNum">     492 </span>            :      * need for those xids.
<span class="lineNum">     493 </span>            :      *
<span class="lineNum">     494 </span>            :      * Both arrays are qsort'ed so that we can use bsearch() on them.
<span class="lineNum">     495 </span>            :      */
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     Assert(TransactionIdIsNormal(builder-&gt;xmin));</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     Assert(TransactionIdIsNormal(builder-&gt;xmax));</span>
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     snapshot-&gt;xmin = builder-&gt;xmin;</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :     snapshot-&gt;xmax = builder-&gt;xmax;</span>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            :     /* store all transactions to be treated as committed by this snapshot */
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :     snapshot-&gt;xip =</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :         (TransactionId *) ((char *) snapshot + sizeof(SnapshotData));</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     snapshot-&gt;xcnt = builder-&gt;committed.xcnt;</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :     memcpy(snapshot-&gt;xip,</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :            builder-&gt;committed.xip,</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :            builder-&gt;committed.xcnt * sizeof(TransactionId));</span>
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span>            :     /* sort so we can bsearch() */
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     qsort(snapshot-&gt;xip, snapshot-&gt;xcnt, sizeof(TransactionId), xidComparator);</span>
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span>            :     /*
<span class="lineNum">     514 </span>            :      * Initially, subxip is empty, i.e. it's a snapshot to be used by
<span class="lineNum">     515 </span>            :      * transactions that don't modify the catalog. Will be filled by
<span class="lineNum">     516 </span>            :      * ReorderBufferCopySnap() if necessary.
<span class="lineNum">     517 </span>            :      */
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :     snapshot-&gt;subxcnt = 0;</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     snapshot-&gt;subxip = NULL;</span>
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :     snapshot-&gt;suboverflowed = false;</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :     snapshot-&gt;takenDuringRecovery = false;</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     snapshot-&gt;copied = false;</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :     snapshot-&gt;curcid = FirstCommandId;</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     snapshot-&gt;active_count = 0;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     snapshot-&gt;regd_count = 0;</span>
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :     return snapshot;</span>
<span class="lineNum">     529 </span>            : }
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            : /*
<span class="lineNum">     532 </span>            :  * Build the initial slot snapshot and convert it to a normal snapshot that
<span class="lineNum">     533 </span>            :  * is understood by HeapTupleSatisfiesMVCC.
<span class="lineNum">     534 </span>            :  *
<span class="lineNum">     535 </span>            :  * The snapshot will be usable directly in current transaction or exported
<span class="lineNum">     536 </span>            :  * for loading in different transaction.
<a name="537"><span class="lineNum">     537 </span>            :  */</a>
<span class="lineNum">     538 </span>            : Snapshot
<span class="lineNum">     539 </span><span class="lineNoCov">          0 : SnapBuildInitialSnapshot(SnapBuild *builder)</span>
<span class="lineNum">     540 </span>            : {
<span class="lineNum">     541 </span>            :     Snapshot    snap;
<span class="lineNum">     542 </span>            :     TransactionId xid;
<span class="lineNum">     543 </span>            :     TransactionId *newxip;
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :     int         newxcnt = 0;</span>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     Assert(!FirstSnapshotSet);</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :     Assert(XactIsoLevel == XACT_REPEATABLE_READ);</span>
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     if (builder-&gt;state != SNAPBUILD_CONSISTENT)</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cannot build an initial slot snapshot before reaching a consistent state&quot;);</span>
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :     if (!builder-&gt;committed.includes_all_transactions)</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cannot build an initial slot snapshot, not all transactions are monitored anymore&quot;);</span>
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span>            :     /* so we don't overwrite the existing value */
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :     if (TransactionIdIsValid(MyPgXact-&gt;xmin))</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cannot build an initial slot snapshot when MyPgXact-&gt;xmin already is valid&quot;);</span>
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :     snap = SnapBuildBuildSnapshot(builder);</span>
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            :     /*
<span class="lineNum">     562 </span>            :      * We know that snap-&gt;xmin is alive, enforced by the logical xmin
<span class="lineNum">     563 </span>            :      * mechanism. Due to that we can do this without locks, we're only
<span class="lineNum">     564 </span>            :      * changing our own value.
<span class="lineNum">     565 </span>            :      */
<span class="lineNum">     566 </span>            : #ifdef USE_ASSERT_CHECKING
<span class="lineNum">     567 </span>            :     {
<span class="lineNum">     568 </span>            :         TransactionId safeXid;
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :         LWLockAcquire(ProcArrayLock, LW_SHARED);</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :         safeXid = GetOldestSafeDecodingTransactionId(false);</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :         LWLockRelease(ProcArrayLock);</span>
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :         Assert(TransactionIdPrecedesOrEquals(safeXid, snap-&gt;xmin));</span>
<span class="lineNum">     575 </span>            :     }
<span class="lineNum">     576 </span>            : #endif
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :     MyPgXact-&gt;xmin = snap-&gt;xmin;</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            :     /* allocate in transaction context */
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :     newxip = (TransactionId *)</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :         palloc(sizeof(TransactionId) * GetMaxSnapshotXidCount());</span>
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            :     /*
<span class="lineNum">     585 </span>            :      * snapbuild.c builds transactions in an &quot;inverted&quot; manner, which means it
<span class="lineNum">     586 </span>            :      * stores committed transactions in -&gt;xip, not ones in progress. Build a
<span class="lineNum">     587 </span>            :      * classical snapshot by marking all non-committed transactions as
<span class="lineNum">     588 </span>            :      * in-progress. This can be expensive.
<span class="lineNum">     589 </span>            :      */
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :     for (xid = snap-&gt;xmin; NormalTransactionIdPrecedes(xid, snap-&gt;xmax);)</span>
<span class="lineNum">     591 </span>            :     {
<span class="lineNum">     592 </span>            :         void       *test;
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span>            :         /*
<span class="lineNum">     595 </span>            :          * Check whether transaction committed using the decoding snapshot
<span class="lineNum">     596 </span>            :          * meaning of -&gt;xip.
<span class="lineNum">     597 </span>            :          */
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :         test = bsearch(&amp;xid, snap-&gt;xip, snap-&gt;xcnt,</span>
<span class="lineNum">     599 </span>            :                        sizeof(TransactionId), xidComparator);
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :         if (test == NULL)</span>
<span class="lineNum">     602 </span>            :         {
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :             if (newxcnt &gt;= GetMaxSnapshotXidCount())</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :                 ereport(ERROR,</span>
<span class="lineNum">     605 </span>            :                         (errcode(ERRCODE_T_R_SERIALIZATION_FAILURE),
<span class="lineNum">     606 </span>            :                          errmsg(&quot;initial slot snapshot too large&quot;)));
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :             newxip[newxcnt++] = xid;</span>
<span class="lineNum">     609 </span>            :         }
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :         TransactionIdAdvance(xid);</span>
<span class="lineNum">     612 </span>            :     }
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            :     /* adjust remaining snapshot fields as needed */
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :     snap-&gt;snapshot_type = SNAPSHOT_MVCC;</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :     snap-&gt;xcnt = newxcnt;</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :     snap-&gt;xip = newxip;</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :     return snap;</span>
<span class="lineNum">     620 </span>            : }
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            : /*
<span class="lineNum">     623 </span>            :  * Export a snapshot so it can be set in another session with SET TRANSACTION
<span class="lineNum">     624 </span>            :  * SNAPSHOT.
<span class="lineNum">     625 </span>            :  *
<span class="lineNum">     626 </span>            :  * For that we need to start a transaction in the current backend as the
<span class="lineNum">     627 </span>            :  * importing side checks whether the source transaction is still open to make
<span class="lineNum">     628 </span>            :  * sure the xmin horizon hasn't advanced since then.
<a name="629"><span class="lineNum">     629 </span>            :  */</a>
<span class="lineNum">     630 </span>            : const char *
<span class="lineNum">     631 </span><span class="lineNoCov">          0 : SnapBuildExportSnapshot(SnapBuild *builder)</span>
<span class="lineNum">     632 </span>            : {
<span class="lineNum">     633 </span>            :     Snapshot    snap;
<span class="lineNum">     634 </span>            :     char       *snapname;
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :     if (IsTransactionOrTransactionBlock())</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cannot export a snapshot from within a transaction&quot;);</span>
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :     if (SavedResourceOwnerDuringExport)</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;can only export one snapshot at a time&quot;);</span>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :     SavedResourceOwnerDuringExport = CurrentResourceOwner;</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     ExportInProgress = true;</span>
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :     StartTransactionCommand();</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            :     /* There doesn't seem to a nice API to set these */
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     XactIsoLevel = XACT_REPEATABLE_READ;</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :     XactReadOnly = true;</span>
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :     snap = SnapBuildInitialSnapshot(builder);</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span>            :     /*
<span class="lineNum">     654 </span>            :      * now that we've built a plain snapshot, make it active and use the
<span class="lineNum">     655 </span>            :      * normal mechanisms for exporting it
<span class="lineNum">     656 </span>            :      */
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :     snapname = ExportSnapshot(snap);</span>
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :     ereport(LOG,</span>
<span class="lineNum">     660 </span>            :             (errmsg_plural(&quot;exported logical decoding snapshot: \&quot;%s\&quot; with %u transaction ID&quot;,
<span class="lineNum">     661 </span>            :                            &quot;exported logical decoding snapshot: \&quot;%s\&quot; with %u transaction IDs&quot;,
<span class="lineNum">     662 </span>            :                            snap-&gt;xcnt,
<span class="lineNum">     663 </span>            :                            snapname, snap-&gt;xcnt)));
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :     return snapname;</span>
<span class="lineNum">     665 </span>            : }
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            : /*
<span class="lineNum">     668 </span>            :  * Ensure there is a snapshot and if not build one for current transaction.
<a name="669"><span class="lineNum">     669 </span>            :  */</a>
<span class="lineNum">     670 </span>            : Snapshot
<span class="lineNum">     671 </span><span class="lineNoCov">          0 : SnapBuildGetOrBuildSnapshot(SnapBuild *builder, TransactionId xid)</span>
<span class="lineNum">     672 </span>            : {
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     Assert(builder-&gt;state == SNAPBUILD_CONSISTENT);</span>
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :     /* only build a new snapshot if we don't have a prebuilt one */
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :     if (builder-&gt;snapshot == NULL)</span>
<span class="lineNum">     677 </span>            :     {
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :         builder-&gt;snapshot = SnapBuildBuildSnapshot(builder);</span>
<span class="lineNum">     679 </span>            :         /* increase refcount for the snapshot builder */
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :         SnapBuildSnapIncRefcount(builder-&gt;snapshot);</span>
<span class="lineNum">     681 </span>            :     }
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     return builder-&gt;snapshot;</span>
<span class="lineNum">     684 </span>            : }
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            : /*
<span class="lineNum">     687 </span>            :  * Reset a previously SnapBuildExportSnapshot()'ed snapshot if there is
<span class="lineNum">     688 </span>            :  * any. Aborts the previously started transaction and resets the resource
<span class="lineNum">     689 </span>            :  * owner back to its original value.
<a name="690"><span class="lineNum">     690 </span>            :  */</a>
<span class="lineNum">     691 </span>            : void
<span class="lineNum">     692 </span><span class="lineNoCov">          0 : SnapBuildClearExportedSnapshot(void)</span>
<span class="lineNum">     693 </span>            : {
<span class="lineNum">     694 </span>            :     /* nothing exported, that is the usual case */
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     if (!ExportInProgress)</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :     if (!IsTransactionState())</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;clearing exported snapshot in wrong transaction state&quot;);</span>
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            :     /* make sure nothing  could have ever happened */
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     AbortCurrentTransaction();</span>
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :     CurrentResourceOwner = SavedResourceOwnerDuringExport;</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     SavedResourceOwnerDuringExport = NULL;</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :     ExportInProgress = false;</span>
<span class="lineNum">     707 </span>            : }
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            : /*
<span class="lineNum">     710 </span>            :  * Handle the effects of a single heap change, appropriate to the current state
<span class="lineNum">     711 </span>            :  * of the snapshot builder and returns whether changes made at (xid, lsn) can
<span class="lineNum">     712 </span>            :  * be decoded.
<a name="713"><span class="lineNum">     713 </span>            :  */</a>
<span class="lineNum">     714 </span>            : bool
<span class="lineNum">     715 </span><span class="lineNoCov">          0 : SnapBuildProcessChange(SnapBuild *builder, TransactionId xid, XLogRecPtr lsn)</span>
<span class="lineNum">     716 </span>            : {
<span class="lineNum">     717 </span>            :     /*
<span class="lineNum">     718 </span>            :      * We can't handle data in transactions if we haven't built a snapshot
<span class="lineNum">     719 </span>            :      * yet, so don't store them.
<span class="lineNum">     720 </span>            :      */
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     if (builder-&gt;state &lt; SNAPBUILD_FULL_SNAPSHOT)</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            :     /*
<span class="lineNum">     725 </span>            :      * No point in keeping track of changes in transactions that we don't have
<span class="lineNum">     726 </span>            :      * enough information about to decode. This means that they started before
<span class="lineNum">     727 </span>            :      * we got into the SNAPBUILD_FULL_SNAPSHOT state.
<span class="lineNum">     728 </span>            :      */
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :     if (builder-&gt;state &lt; SNAPBUILD_CONSISTENT &amp;&amp;</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :         TransactionIdPrecedes(xid, SnapBuildNextPhaseAt(builder)))</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span>            :     /*
<span class="lineNum">     734 </span>            :      * If the reorderbuffer doesn't yet have a snapshot, add one now, it will
<span class="lineNum">     735 </span>            :      * be needed to decode the change we're currently processing.
<span class="lineNum">     736 </span>            :      */
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :     if (!ReorderBufferXidHasBaseSnapshot(builder-&gt;reorder, xid))</span>
<span class="lineNum">     738 </span>            :     {
<span class="lineNum">     739 </span>            :         /* only build a new snapshot if we don't have a prebuilt one */
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :         if (builder-&gt;snapshot == NULL)</span>
<span class="lineNum">     741 </span>            :         {
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :             builder-&gt;snapshot = SnapBuildBuildSnapshot(builder);</span>
<span class="lineNum">     743 </span>            :             /* increase refcount for the snapshot builder */
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :             SnapBuildSnapIncRefcount(builder-&gt;snapshot);</span>
<span class="lineNum">     745 </span>            :         }
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            :         /*
<span class="lineNum">     748 </span>            :          * Increase refcount for the transaction we're handing the snapshot
<span class="lineNum">     749 </span>            :          * out to.
<span class="lineNum">     750 </span>            :          */
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :         SnapBuildSnapIncRefcount(builder-&gt;snapshot);</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :         ReorderBufferSetBaseSnapshot(builder-&gt;reorder, xid, lsn,</span>
<span class="lineNum">     753 </span>            :                                      builder-&gt;snapshot);
<span class="lineNum">     754 </span>            :     }
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     757 </span>            : }
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span>            : /*
<span class="lineNum">     760 </span>            :  * Do CommandId/ComboCid handling after reading an xl_heap_new_cid record.
<span class="lineNum">     761 </span>            :  * This implies that a transaction has done some form of write to system
<span class="lineNum">     762 </span>            :  * catalogs.
<a name="763"><span class="lineNum">     763 </span>            :  */</a>
<span class="lineNum">     764 </span>            : void
<span class="lineNum">     765 </span><span class="lineNoCov">          0 : SnapBuildProcessNewCid(SnapBuild *builder, TransactionId xid,</span>
<span class="lineNum">     766 </span>            :                        XLogRecPtr lsn, xl_heap_new_cid *xlrec)
<span class="lineNum">     767 </span>            : {
<span class="lineNum">     768 </span>            :     CommandId   cid;
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            :     /*
<span class="lineNum">     771 </span>            :      * we only log new_cid's if a catalog tuple was modified, so mark the
<span class="lineNum">     772 </span>            :      * transaction as containing catalog modifications
<span class="lineNum">     773 </span>            :      */
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :     ReorderBufferXidSetCatalogChanges(builder-&gt;reorder, xid, lsn);</span>
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :     ReorderBufferAddNewTupleCids(builder-&gt;reorder, xlrec-&gt;top_xid, lsn,</span>
<span class="lineNum">     777 </span>            :                                  xlrec-&gt;target_node, xlrec-&gt;target_tid,
<span class="lineNum">     778 </span>            :                                  xlrec-&gt;cmin, xlrec-&gt;cmax,
<span class="lineNum">     779 </span>            :                                  xlrec-&gt;combocid);
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            :     /* figure out new command id */
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :     if (xlrec-&gt;cmin != InvalidCommandId &amp;&amp;</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :         xlrec-&gt;cmax != InvalidCommandId)</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :         cid = Max(xlrec-&gt;cmin, xlrec-&gt;cmax);</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :     else if (xlrec-&gt;cmax != InvalidCommandId)</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :         cid = xlrec-&gt;cmax;</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     else if (xlrec-&gt;cmin != InvalidCommandId)</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :         cid = xlrec-&gt;cmin;</span>
<span class="lineNum">     789 </span>            :     else
<span class="lineNum">     790 </span>            :     {
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :         cid = InvalidCommandId; /* silence compiler */</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;xl_heap_new_cid record without a valid CommandId&quot;);</span>
<span class="lineNum">     793 </span>            :     }
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :     ReorderBufferAddNewCommandId(builder-&gt;reorder, xid, lsn, cid + 1);</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            : /*
<span class="lineNum">     799 </span>            :  * Add a new Snapshot to all transactions we're decoding that currently are
<span class="lineNum">     800 </span>            :  * in-progress so they can see new catalog contents made by the transaction
<span class="lineNum">     801 </span>            :  * that just committed. This is necessary because those in-progress
<span class="lineNum">     802 </span>            :  * transactions will use the new catalog's contents from here on (at the very
<span class="lineNum">     803 </span>            :  * least everything they do needs to be compatible with newer catalog
<span class="lineNum">     804 </span>            :  * contents).
<a name="805"><span class="lineNum">     805 </span>            :  */</a>
<span class="lineNum">     806 </span>            : static void
<span class="lineNum">     807 </span><span class="lineNoCov">          0 : SnapBuildDistributeNewCatalogSnapshot(SnapBuild *builder, XLogRecPtr lsn)</span>
<span class="lineNum">     808 </span>            : {
<span class="lineNum">     809 </span>            :     dlist_iter  txn_i;
<span class="lineNum">     810 </span>            :     ReorderBufferTXN *txn;
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            :     /*
<span class="lineNum">     813 </span>            :      * Iterate through all toplevel transactions. This can include
<span class="lineNum">     814 </span>            :      * subtransactions which we just don't yet know to be that, but that's
<span class="lineNum">     815 </span>            :      * fine, they will just get an unnecessary snapshot queued.
<span class="lineNum">     816 </span>            :      */
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :     dlist_foreach(txn_i, &amp;builder-&gt;reorder-&gt;toplevel_by_lsn)</span>
<span class="lineNum">     818 </span>            :     {
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :         txn = dlist_container(ReorderBufferTXN, node, txn_i.cur);</span>
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :         Assert(TransactionIdIsValid(txn-&gt;xid));</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :         /*
<span class="lineNum">     824 </span>            :          * If we don't have a base snapshot yet, there are no changes in this
<span class="lineNum">     825 </span>            :          * transaction which in turn implies we don't yet need a snapshot at
<span class="lineNum">     826 </span>            :          * all. We'll add a snapshot when the first change gets queued.
<span class="lineNum">     827 </span>            :          *
<span class="lineNum">     828 </span>            :          * NB: This works correctly even for subtransactions because
<span class="lineNum">     829 </span>            :          * ReorderBufferAssignChild() takes care to transfer the base snapshot
<span class="lineNum">     830 </span>            :          * to the top-level transaction, and while iterating the changequeue
<span class="lineNum">     831 </span>            :          * we'll get the change from the subtxn.
<span class="lineNum">     832 </span>            :          */
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :         if (!ReorderBufferXidHasBaseSnapshot(builder-&gt;reorder, txn-&gt;xid))</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :         elog(DEBUG2, &quot;adding a new snapshot to %u at %X/%X&quot;,</span>
<span class="lineNum">     837 </span>            :              txn-&gt;xid, (uint32) (lsn &gt;&gt; 32), (uint32) lsn);
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :         /*
<span class="lineNum">     840 </span>            :          * increase the snapshot's refcount for the transaction we are handing
<span class="lineNum">     841 </span>            :          * it out to
<span class="lineNum">     842 </span>            :          */
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :         SnapBuildSnapIncRefcount(builder-&gt;snapshot);</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :         ReorderBufferAddSnapshot(builder-&gt;reorder, txn-&gt;xid, lsn,</span>
<span class="lineNum">     845 </span>            :                                  builder-&gt;snapshot);
<span class="lineNum">     846 </span>            :     }
<span class="lineNum">     847 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            : /*
<span class="lineNum">     850 </span>            :  * Keep track of a new catalog changing transaction that has committed.
<a name="851"><span class="lineNum">     851 </span>            :  */</a>
<span class="lineNum">     852 </span>            : static void
<span class="lineNum">     853 </span><span class="lineNoCov">          0 : SnapBuildAddCommittedTxn(SnapBuild *builder, TransactionId xid)</span>
<span class="lineNum">     854 </span>            : {
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :     Assert(TransactionIdIsValid(xid));</span>
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :     if (builder-&gt;committed.xcnt == builder-&gt;committed.xcnt_space)</span>
<span class="lineNum">     858 </span>            :     {
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :         builder-&gt;committed.xcnt_space = builder-&gt;committed.xcnt_space * 2 + 1;</span>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :         elog(DEBUG1, &quot;increasing space for committed transactions to %u&quot;,</span>
<span class="lineNum">     862 </span>            :              (uint32) builder-&gt;committed.xcnt_space);
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :         builder-&gt;committed.xip = repalloc(builder-&gt;committed.xip,</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :                                           builder-&gt;committed.xcnt_space * sizeof(TransactionId));</span>
<span class="lineNum">     866 </span>            :     }
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            :     /*
<span class="lineNum">     869 </span>            :      * TODO: It might make sense to keep the array sorted here instead of
<span class="lineNum">     870 </span>            :      * doing it every time we build a new snapshot. On the other hand this
<span class="lineNum">     871 </span>            :      * gets called repeatedly when a transaction with subtransactions commits.
<span class="lineNum">     872 </span>            :      */
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :     builder-&gt;committed.xip[builder-&gt;committed.xcnt++] = xid;</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span>            : /*
<span class="lineNum">     877 </span>            :  * Remove knowledge about transactions we treat as committed that are smaller
<span class="lineNum">     878 </span>            :  * than -&gt;xmin. Those won't ever get checked via the -&gt;committed array but via
<span class="lineNum">     879 </span>            :  * the clog machinery, so we don't need to waste memory on them.
<a name="880"><span class="lineNum">     880 </span>            :  */</a>
<span class="lineNum">     881 </span>            : static void
<span class="lineNum">     882 </span><span class="lineNoCov">          0 : SnapBuildPurgeCommittedTxn(SnapBuild *builder)</span>
<span class="lineNum">     883 </span>            : {
<span class="lineNum">     884 </span>            :     int         off;
<span class="lineNum">     885 </span>            :     TransactionId *workspace;
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     int         surviving_xids = 0;</span>
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span>            :     /* not ready yet */
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     if (!TransactionIdIsNormal(builder-&gt;xmin))</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span>            :     /* TODO: Neater algorithm than just copying and iterating? */
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     workspace =</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         MemoryContextAlloc(builder-&gt;context,</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :                            builder-&gt;committed.xcnt * sizeof(TransactionId));</span>
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span>            :     /* copy xids that still are interesting to workspace */
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :     for (off = 0; off &lt; builder-&gt;committed.xcnt; off++)</span>
<span class="lineNum">     899 </span>            :     {
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :         if (NormalTransactionIdPrecedes(builder-&gt;committed.xip[off],</span>
<span class="lineNum">     901 </span>            :                                         builder-&gt;xmin))
<span class="lineNum">     902 </span>            :             ;                   /* remove */
<span class="lineNum">     903 </span>            :         else
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :             workspace[surviving_xids++] = builder-&gt;committed.xip[off];</span>
<span class="lineNum">     905 </span>            :     }
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span>            :     /* copy workspace back to persistent state */
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :     memcpy(builder-&gt;committed.xip, workspace,</span>
<span class="lineNum">     909 </span>            :            surviving_xids * sizeof(TransactionId));
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :     elog(DEBUG3, &quot;purged committed transactions from %u to %u, xmin: %u, xmax: %u&quot;,</span>
<span class="lineNum">     912 </span>            :          (uint32) builder-&gt;committed.xcnt, (uint32) surviving_xids,
<span class="lineNum">     913 </span>            :          builder-&gt;xmin, builder-&gt;xmax);
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     builder-&gt;committed.xcnt = surviving_xids;</span>
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :     pfree(workspace);</span>
<span class="lineNum">     917 </span>            : }
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span>            : /*
<span class="lineNum">     920 </span>            :  * Handle everything that needs to be done when a transaction commits
<a name="921"><span class="lineNum">     921 </span>            :  */</a>
<span class="lineNum">     922 </span>            : void
<span class="lineNum">     923 </span><span class="lineNoCov">          0 : SnapBuildCommitTxn(SnapBuild *builder, XLogRecPtr lsn, TransactionId xid,</span>
<span class="lineNum">     924 </span>            :                    int nsubxacts, TransactionId *subxacts)
<span class="lineNum">     925 </span>            : {
<span class="lineNum">     926 </span>            :     int         nxact;
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :     bool        needs_snapshot = false;</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :     bool        needs_timetravel = false;</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :     bool        sub_needs_timetravel = false;</span>
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :     TransactionId xmax = xid;</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            :     /*
<span class="lineNum">     935 </span>            :      * Transactions preceding BUILDING_SNAPSHOT will neither be decoded, nor
<span class="lineNum">     936 </span>            :      * will they be part of a snapshot.  So we don't need to record anything.
<span class="lineNum">     937 </span>            :      */
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :     if (builder-&gt;state == SNAPBUILD_START ||</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :         (builder-&gt;state == SNAPBUILD_BUILDING_SNAPSHOT &amp;&amp;</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :          TransactionIdPrecedes(xid, SnapBuildNextPhaseAt(builder))))</span>
<span class="lineNum">     941 </span>            :     {
<span class="lineNum">     942 </span>            :         /* ensure that only commits after this are getting replayed */
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :         if (builder-&gt;start_decoding_at &lt;= lsn)</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :             builder-&gt;start_decoding_at = lsn + 1;</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     946 </span>            :     }
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     if (builder-&gt;state &lt; SNAPBUILD_CONSISTENT)</span>
<span class="lineNum">     949 </span>            :     {
<span class="lineNum">     950 </span>            :         /* ensure that only commits after this are getting replayed */
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :         if (builder-&gt;start_decoding_at &lt;= lsn)</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :             builder-&gt;start_decoding_at = lsn + 1;</span>
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span>            :         /*
<span class="lineNum">     955 </span>            :          * If building an exportable snapshot, force xid to be tracked, even
<span class="lineNum">     956 </span>            :          * if the transaction didn't modify the catalog.
<span class="lineNum">     957 </span>            :          */
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :         if (builder-&gt;building_full_snapshot)</span>
<span class="lineNum">     959 </span>            :         {
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :             needs_timetravel = true;</span>
<span class="lineNum">     961 </span>            :         }
<span class="lineNum">     962 </span>            :     }
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :     for (nxact = 0; nxact &lt; nsubxacts; nxact++)</span>
<span class="lineNum">     965 </span>            :     {
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :         TransactionId subxid = subxacts[nxact];</span>
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span>            :         /*
<span class="lineNum">     969 </span>            :          * Add subtransaction to base snapshot if catalog modifying, we don't
<span class="lineNum">     970 </span>            :          * distinguish to toplevel transactions there.
<span class="lineNum">     971 </span>            :          */
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :         if (ReorderBufferXidHasCatalogChanges(builder-&gt;reorder, subxid))</span>
<span class="lineNum">     973 </span>            :         {
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :             sub_needs_timetravel = true;</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :             needs_snapshot = true;</span>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :             elog(DEBUG1, &quot;found subtransaction %u:%u with catalog changes&quot;,</span>
<span class="lineNum">     978 </span>            :                  xid, subxid);
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :             SnapBuildAddCommittedTxn(builder, subxid);</span>
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :             if (NormalTransactionIdFollows(subxid, xmax))</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :                 xmax = subxid;</span>
<span class="lineNum">     984 </span>            :         }
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span>            :         /*
<span class="lineNum">     987 </span>            :          * If we're forcing timetravel we also need visibility information
<span class="lineNum">     988 </span>            :          * about subtransaction, so keep track of subtransaction's state, even
<span class="lineNum">     989 </span>            :          * if not catalog modifying.  Don't need to distribute a snapshot in
<span class="lineNum">     990 </span>            :          * that case.
<span class="lineNum">     991 </span>            :          */
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :         else if (needs_timetravel)</span>
<span class="lineNum">     993 </span>            :         {
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :             SnapBuildAddCommittedTxn(builder, subxid);</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :             if (NormalTransactionIdFollows(subxid, xmax))</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :                 xmax = subxid;</span>
<span class="lineNum">     997 </span>            :         }
<span class="lineNum">     998 </span>            :     }
<span class="lineNum">     999 </span>            : 
<span class="lineNum">    1000 </span>            :     /* if top-level modified catalog, it'll need a snapshot */
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :     if (ReorderBufferXidHasCatalogChanges(builder-&gt;reorder, xid))</span>
<span class="lineNum">    1002 </span>            :     {
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :         elog(DEBUG2, &quot;found top level transaction %u, with catalog changes&quot;,</span>
<span class="lineNum">    1004 </span>            :              xid);
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :         needs_snapshot = true;</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :         needs_timetravel = true;</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :         SnapBuildAddCommittedTxn(builder, xid);</span>
<span class="lineNum">    1008 </span>            :     }
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :     else if (sub_needs_timetravel)</span>
<span class="lineNum">    1010 </span>            :     {
<span class="lineNum">    1011 </span>            :         /* track toplevel txn as well, subxact alone isn't meaningful */
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :         SnapBuildAddCommittedTxn(builder, xid);</span>
<span class="lineNum">    1013 </span>            :     }
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :     else if (needs_timetravel)</span>
<span class="lineNum">    1015 </span>            :     {
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :         elog(DEBUG2, &quot;forced transaction %u to do timetravel&quot;, xid);</span>
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :         SnapBuildAddCommittedTxn(builder, xid);</span>
<span class="lineNum">    1019 </span>            :     }
<span class="lineNum">    1020 </span>            : 
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :     if (!needs_timetravel)</span>
<span class="lineNum">    1022 </span>            :     {
<span class="lineNum">    1023 </span>            :         /* record that we cannot export a general snapshot anymore */
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :         builder-&gt;committed.includes_all_transactions = false;</span>
<span class="lineNum">    1025 </span>            :     }
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :     Assert(!needs_snapshot || needs_timetravel);</span>
<span class="lineNum">    1028 </span>            : 
<span class="lineNum">    1029 </span>            :     /*
<span class="lineNum">    1030 </span>            :      * Adjust xmax of the snapshot builder, we only do that for committed,
<span class="lineNum">    1031 </span>            :      * catalog modifying, transactions, everything else isn't interesting for
<span class="lineNum">    1032 </span>            :      * us since we'll never look at the respective rows.
<span class="lineNum">    1033 </span>            :      */
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :     if (needs_timetravel &amp;&amp;</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :         (!TransactionIdIsValid(builder-&gt;xmax) ||</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :          TransactionIdFollowsOrEquals(xmax, builder-&gt;xmax)))</span>
<span class="lineNum">    1037 </span>            :     {
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :         builder-&gt;xmax = xmax;</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :         TransactionIdAdvance(builder-&gt;xmax);</span>
<span class="lineNum">    1040 </span>            :     }
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span>            :     /* if there's any reason to build a historic snapshot, do so now */
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :     if (needs_snapshot)</span>
<span class="lineNum">    1044 </span>            :     {
<span class="lineNum">    1045 </span>            :         /*
<span class="lineNum">    1046 </span>            :          * If we haven't built a complete snapshot yet there's no need to hand
<span class="lineNum">    1047 </span>            :          * it out, it wouldn't (and couldn't) be used anyway.
<span class="lineNum">    1048 </span>            :          */
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :         if (builder-&gt;state &lt; SNAPBUILD_FULL_SNAPSHOT)</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span>            :         /*
<span class="lineNum">    1053 </span>            :          * Decrease the snapshot builder's refcount of the old snapshot, note
<span class="lineNum">    1054 </span>            :          * that it still will be used if it has been handed out to the
<span class="lineNum">    1055 </span>            :          * reorderbuffer earlier.
<span class="lineNum">    1056 </span>            :          */
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :         if (builder-&gt;snapshot)</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :             SnapBuildSnapDecRefcount(builder-&gt;snapshot);</span>
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :         builder-&gt;snapshot = SnapBuildBuildSnapshot(builder);</span>
<span class="lineNum">    1061 </span>            : 
<span class="lineNum">    1062 </span>            :         /* we might need to execute invalidations, add snapshot */
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :         if (!ReorderBufferXidHasBaseSnapshot(builder-&gt;reorder, xid))</span>
<span class="lineNum">    1064 </span>            :         {
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :             SnapBuildSnapIncRefcount(builder-&gt;snapshot);</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :             ReorderBufferSetBaseSnapshot(builder-&gt;reorder, xid, lsn,</span>
<span class="lineNum">    1067 </span>            :                                          builder-&gt;snapshot);
<span class="lineNum">    1068 </span>            :         }
<span class="lineNum">    1069 </span>            : 
<span class="lineNum">    1070 </span>            :         /* refcount of the snapshot builder for the new snapshot */
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :         SnapBuildSnapIncRefcount(builder-&gt;snapshot);</span>
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span>            :         /* add a new catalog snapshot to all currently running transactions */
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :         SnapBuildDistributeNewCatalogSnapshot(builder, lsn);</span>
<span class="lineNum">    1075 </span>            :     }
<span class="lineNum">    1076 </span>            : }
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            : /* -----------------------------------
<span class="lineNum">    1080 </span>            :  * Snapshot building functions dealing with xlog records
<span class="lineNum">    1081 </span>            :  * -----------------------------------
<span class="lineNum">    1082 </span>            :  */
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span>            : /*
<span class="lineNum">    1085 </span>            :  * Process a running xacts record, and use its information to first build a
<span class="lineNum">    1086 </span>            :  * historic snapshot and later to release resources that aren't needed
<span class="lineNum">    1087 </span>            :  * anymore.
<a name="1088"><span class="lineNum">    1088 </span>            :  */</a>
<span class="lineNum">    1089 </span>            : void
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 : SnapBuildProcessRunningXacts(SnapBuild *builder, XLogRecPtr lsn, xl_running_xacts *running)</span>
<span class="lineNum">    1091 </span>            : {
<span class="lineNum">    1092 </span>            :     ReorderBufferTXN *txn;
<span class="lineNum">    1093 </span>            :     TransactionId xmin;
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span>            :     /*
<span class="lineNum">    1096 </span>            :      * If we're not consistent yet, inspect the record to see whether it
<span class="lineNum">    1097 </span>            :      * allows to get closer to being consistent. If we are consistent, dump
<span class="lineNum">    1098 </span>            :      * our snapshot so others or we, after a restart, can use it.
<span class="lineNum">    1099 </span>            :      */
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :     if (builder-&gt;state &lt; SNAPBUILD_CONSISTENT)</span>
<span class="lineNum">    1101 </span>            :     {
<span class="lineNum">    1102 </span>            :         /* returns false if there's no point in performing cleanup just yet */
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :         if (!SnapBuildFindSnapshot(builder, lsn, running))</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1105 </span>            :     }
<span class="lineNum">    1106 </span>            :     else
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :         SnapBuildSerialize(builder, lsn);</span>
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span>            :     /*
<span class="lineNum">    1110 </span>            :      * Update range of interesting xids based on the running xacts
<span class="lineNum">    1111 </span>            :      * information. We don't increase -&gt;xmax using it, because once we are in
<span class="lineNum">    1112 </span>            :      * a consistent state we can do that ourselves and much more efficiently
<span class="lineNum">    1113 </span>            :      * so, because we only need to do it for catalog transactions since we
<span class="lineNum">    1114 </span>            :      * only ever look at those.
<span class="lineNum">    1115 </span>            :      *
<span class="lineNum">    1116 </span>            :      * NB: We only increase xmax when a catalog modifying transaction commits
<span class="lineNum">    1117 </span>            :      * (see SnapBuildCommitTxn).  Because of this, xmax can be lower than
<span class="lineNum">    1118 </span>            :      * xmin, which looks odd but is correct and actually more efficient, since
<span class="lineNum">    1119 </span>            :      * we hit fast paths in heapam_visibility.c.
<span class="lineNum">    1120 </span>            :      */
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :     builder-&gt;xmin = running-&gt;oldestRunningXid;</span>
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span>            :     /* Remove transactions we don't need to keep track off anymore */
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :     SnapBuildPurgeCommittedTxn(builder);</span>
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            :     /*
<span class="lineNum">    1127 </span>            :      * Advance the xmin limit for the current replication slot, to allow
<span class="lineNum">    1128 </span>            :      * vacuum to clean up the tuples this slot has been protecting.
<span class="lineNum">    1129 </span>            :      *
<span class="lineNum">    1130 </span>            :      * The reorderbuffer might have an xmin among the currently running
<span class="lineNum">    1131 </span>            :      * snapshots; use it if so.  If not, we need only consider the snapshots
<span class="lineNum">    1132 </span>            :      * we'll produce later, which can't be less than the oldest running xid in
<span class="lineNum">    1133 </span>            :      * the record we're reading now.
<span class="lineNum">    1134 </span>            :      */
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :     xmin = ReorderBufferGetOldestXmin(builder-&gt;reorder);</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :     if (xmin == InvalidTransactionId)</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :         xmin = running-&gt;oldestRunningXid;</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :     elog(DEBUG3, &quot;xmin: %u, xmax: %u, oldest running: %u, oldest xmin: %u&quot;,</span>
<span class="lineNum">    1139 </span>            :          builder-&gt;xmin, builder-&gt;xmax, running-&gt;oldestRunningXid, xmin);
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :     LogicalIncreaseXminForSlot(lsn, xmin);</span>
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            :     /*
<span class="lineNum">    1143 </span>            :      * Also tell the slot where we can restart decoding from. We don't want to
<span class="lineNum">    1144 </span>            :      * do that after every commit because changing that implies an fsync of
<span class="lineNum">    1145 </span>            :      * the logical slot's state file, so we only do it every time we see a
<span class="lineNum">    1146 </span>            :      * running xacts record.
<span class="lineNum">    1147 </span>            :      *
<span class="lineNum">    1148 </span>            :      * Do so by looking for the oldest in progress transaction (determined by
<span class="lineNum">    1149 </span>            :      * the first LSN of any of its relevant records). Every transaction
<span class="lineNum">    1150 </span>            :      * remembers the last location we stored the snapshot to disk before its
<span class="lineNum">    1151 </span>            :      * beginning. That point is where we can restart from.
<span class="lineNum">    1152 </span>            :      */
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span>            :     /*
<span class="lineNum">    1155 </span>            :      * Can't know about a serialized snapshot's location if we're not
<span class="lineNum">    1156 </span>            :      * consistent.
<span class="lineNum">    1157 </span>            :      */
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :     if (builder-&gt;state &lt; SNAPBUILD_CONSISTENT)</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :     txn = ReorderBufferGetOldestTXN(builder-&gt;reorder);</span>
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span>            :     /*
<span class="lineNum">    1164 </span>            :      * oldest ongoing txn might have started when we didn't yet serialize
<span class="lineNum">    1165 </span>            :      * anything because we hadn't reached a consistent state yet.
<span class="lineNum">    1166 </span>            :      */
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :     if (txn != NULL &amp;&amp; txn-&gt;restart_decoding_lsn != InvalidXLogRecPtr)</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :         LogicalIncreaseRestartDecodingForSlot(lsn, txn-&gt;restart_decoding_lsn);</span>
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span>            :     /*
<span class="lineNum">    1171 </span>            :      * No in-progress transaction, can reuse the last serialized snapshot if
<span class="lineNum">    1172 </span>            :      * we have one.
<span class="lineNum">    1173 </span>            :      */
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :     else if (txn == NULL &amp;&amp;</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :              builder-&gt;reorder-&gt;current_restart_decoding_lsn != InvalidXLogRecPtr &amp;&amp;</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :              builder-&gt;last_serialized_snapshot != InvalidXLogRecPtr)</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :         LogicalIncreaseRestartDecodingForSlot(lsn,</span>
<span class="lineNum">    1178 </span>            :                                               builder-&gt;last_serialized_snapshot);
<span class="lineNum">    1179 </span>            : }
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span>            : /*
<span class="lineNum">    1183 </span>            :  * Build the start of a snapshot that's capable of decoding the catalog.
<span class="lineNum">    1184 </span>            :  *
<span class="lineNum">    1185 </span>            :  * Helper function for SnapBuildProcessRunningXacts() while we're not yet
<span class="lineNum">    1186 </span>            :  * consistent.
<span class="lineNum">    1187 </span>            :  *
<span class="lineNum">    1188 </span>            :  * Returns true if there is a point in performing internal maintenance/cleanup
<span class="lineNum">    1189 </span>            :  * using the xl_running_xacts record.
<a name="1190"><span class="lineNum">    1190 </span>            :  */</a>
<span class="lineNum">    1191 </span>            : static bool
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 : SnapBuildFindSnapshot(SnapBuild *builder, XLogRecPtr lsn, xl_running_xacts *running)</span>
<span class="lineNum">    1193 </span>            : {
<span class="lineNum">    1194 </span>            :     /* ---
<span class="lineNum">    1195 </span>            :      * Build catalog decoding snapshot incrementally using information about
<span class="lineNum">    1196 </span>            :      * the currently running transactions. There are several ways to do that:
<span class="lineNum">    1197 </span>            :      *
<span class="lineNum">    1198 </span>            :      * a) There were no running transactions when the xl_running_xacts record
<span class="lineNum">    1199 </span>            :      *    was inserted, jump to CONSISTENT immediately. We might find such a
<span class="lineNum">    1200 </span>            :      *    state while waiting on c)'s sub-states.
<span class="lineNum">    1201 </span>            :      *
<span class="lineNum">    1202 </span>            :      * b) This (in a previous run) or another decoding slot serialized a
<span class="lineNum">    1203 </span>            :      *    snapshot to disk that we can use.  Can't use this method for the
<span class="lineNum">    1204 </span>            :      *    initial snapshot when slot is being created and needs full snapshot
<span class="lineNum">    1205 </span>            :      *    for export or direct use, as that snapshot will only contain catalog
<span class="lineNum">    1206 </span>            :      *    modifying transactions.
<span class="lineNum">    1207 </span>            :      *
<span class="lineNum">    1208 </span>            :      * c) First incrementally build a snapshot for catalog tuples
<span class="lineNum">    1209 </span>            :      *    (BUILDING_SNAPSHOT), that requires all, already in-progress,
<span class="lineNum">    1210 </span>            :      *    transactions to finish.  Every transaction starting after that
<span class="lineNum">    1211 </span>            :      *    (FULL_SNAPSHOT state), has enough information to be decoded.  But
<span class="lineNum">    1212 </span>            :      *    for older running transactions no viable snapshot exists yet, so
<span class="lineNum">    1213 </span>            :      *    CONSISTENT will only be reached once all of those have finished.
<span class="lineNum">    1214 </span>            :      * ---
<span class="lineNum">    1215 </span>            :      */
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span>            :     /*
<span class="lineNum">    1218 </span>            :      * xl_running_xact record is older than what we can use, we might not have
<span class="lineNum">    1219 </span>            :      * all necessary catalog rows anymore.
<span class="lineNum">    1220 </span>            :      */
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :     if (TransactionIdIsNormal(builder-&gt;initial_xmin_horizon) &amp;&amp;</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :         NormalTransactionIdPrecedes(running-&gt;oldestRunningXid,</span>
<span class="lineNum">    1223 </span>            :                                     builder-&gt;initial_xmin_horizon))
<span class="lineNum">    1224 </span>            :     {
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :         ereport(DEBUG1,</span>
<span class="lineNum">    1226 </span>            :                 (errmsg_internal(&quot;skipping snapshot at %X/%X while building logical decoding snapshot, xmin horizon too low&quot;,
<span class="lineNum">    1227 </span>            :                                  (uint32) (lsn &gt;&gt; 32), (uint32) lsn),
<span class="lineNum">    1228 </span>            :                  errdetail_internal(&quot;initial xmin horizon of %u vs the snapshot's %u&quot;,
<span class="lineNum">    1229 </span>            :                                     builder-&gt;initial_xmin_horizon, running-&gt;oldestRunningXid)));
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span>            : 
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :         SnapBuildWaitSnapshot(running, builder-&gt;initial_xmin_horizon);</span>
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    1235 </span>            :     }
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span>            :     /*
<span class="lineNum">    1238 </span>            :      * a) No transaction were running, we can jump to consistent.
<span class="lineNum">    1239 </span>            :      *
<span class="lineNum">    1240 </span>            :      * This is not affected by races around xl_running_xacts, because we can
<span class="lineNum">    1241 </span>            :      * miss transaction commits, but currently not transactions starting.
<span class="lineNum">    1242 </span>            :      *
<span class="lineNum">    1243 </span>            :      * NB: We might have already started to incrementally assemble a snapshot,
<span class="lineNum">    1244 </span>            :      * so we need to be careful to deal with that.
<span class="lineNum">    1245 </span>            :      */
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :     if (running-&gt;oldestRunningXid == running-&gt;nextXid)</span>
<span class="lineNum">    1247 </span>            :     {
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :         if (builder-&gt;start_decoding_at == InvalidXLogRecPtr ||</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :             builder-&gt;start_decoding_at &lt;= lsn)</span>
<span class="lineNum">    1250 </span>            :             /* can decode everything after this */
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :             builder-&gt;start_decoding_at = lsn + 1;</span>
<span class="lineNum">    1252 </span>            : 
<span class="lineNum">    1253 </span>            :         /* As no transactions were running xmin/xmax can be trivially set. */
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :         builder-&gt;xmin = running-&gt;nextXid; /* &lt; are finished */</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :         builder-&gt;xmax = running-&gt;nextXid; /* &gt;= are running */</span>
<span class="lineNum">    1256 </span>            : 
<span class="lineNum">    1257 </span>            :         /* so we can safely use the faster comparisons */
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :         Assert(TransactionIdIsNormal(builder-&gt;xmin));</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :         Assert(TransactionIdIsNormal(builder-&gt;xmax));</span>
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :         builder-&gt;state = SNAPBUILD_CONSISTENT;</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :         SnapBuildStartNextPhaseAt(builder, InvalidTransactionId);</span>
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :         ereport(LOG,</span>
<span class="lineNum">    1265 </span>            :                 (errmsg(&quot;logical decoding found consistent point at %X/%X&quot;,
<span class="lineNum">    1266 </span>            :                         (uint32) (lsn &gt;&gt; 32), (uint32) lsn),
<span class="lineNum">    1267 </span>            :                  errdetail(&quot;There are no running transactions.&quot;)));
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1270 </span>            :     }
<span class="lineNum">    1271 </span>            :     /* b) valid on disk state and not building full snapshot */
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :     else if (!builder-&gt;building_full_snapshot &amp;&amp;</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :              SnapBuildRestore(builder, lsn))</span>
<span class="lineNum">    1274 </span>            :     {
<span class="lineNum">    1275 </span>            :         /* there won't be any state to cleanup */
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1277 </span>            :     }
<span class="lineNum">    1278 </span>            : 
<span class="lineNum">    1279 </span>            :     /*
<span class="lineNum">    1280 </span>            :      * c) transition from START to BUILDING_SNAPSHOT.
<span class="lineNum">    1281 </span>            :      *
<span class="lineNum">    1282 </span>            :      * In START state, and a xl_running_xacts record with running xacts is
<span class="lineNum">    1283 </span>            :      * encountered.  In that case, switch to BUILDING_SNAPSHOT state, and
<span class="lineNum">    1284 </span>            :      * record xl_running_xacts-&gt;nextXid.  Once all running xacts have finished
<span class="lineNum">    1285 </span>            :      * (i.e. they're all &gt;= nextXid), we have a complete catalog snapshot.  It
<span class="lineNum">    1286 </span>            :      * might look that we could use xl_running_xact's -&gt;xids information to
<span class="lineNum">    1287 </span>            :      * get there quicker, but that is problematic because transactions marked
<span class="lineNum">    1288 </span>            :      * as running, might already have inserted their commit record - it's
<span class="lineNum">    1289 </span>            :      * infeasible to change that with locking.
<span class="lineNum">    1290 </span>            :      */
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :     else if (builder-&gt;state == SNAPBUILD_START)</span>
<span class="lineNum">    1292 </span>            :     {
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :         builder-&gt;state = SNAPBUILD_BUILDING_SNAPSHOT;</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :         SnapBuildStartNextPhaseAt(builder, running-&gt;nextXid);</span>
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span>            :         /*
<span class="lineNum">    1297 </span>            :          * Start with an xmin/xmax that's correct for future, when all the
<span class="lineNum">    1298 </span>            :          * currently running transactions have finished. We'll update both
<span class="lineNum">    1299 </span>            :          * while waiting for the pending transactions to finish.
<span class="lineNum">    1300 </span>            :          */
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :         builder-&gt;xmin = running-&gt;nextXid; /* &lt; are finished */</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :         builder-&gt;xmax = running-&gt;nextXid; /* &gt;= are running */</span>
<span class="lineNum">    1303 </span>            : 
<span class="lineNum">    1304 </span>            :         /* so we can safely use the faster comparisons */
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :         Assert(TransactionIdIsNormal(builder-&gt;xmin));</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :         Assert(TransactionIdIsNormal(builder-&gt;xmax));</span>
<span class="lineNum">    1307 </span>            : 
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :         ereport(LOG,</span>
<span class="lineNum">    1309 </span>            :                 (errmsg(&quot;logical decoding found initial starting point at %X/%X&quot;,
<span class="lineNum">    1310 </span>            :                         (uint32) (lsn &gt;&gt; 32), (uint32) lsn),
<span class="lineNum">    1311 </span>            :                  errdetail(&quot;Waiting for transactions (approximately %d) older than %u to end.&quot;,
<span class="lineNum">    1312 </span>            :                            running-&gt;xcnt, running-&gt;nextXid)));
<span class="lineNum">    1313 </span>            : 
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :         SnapBuildWaitSnapshot(running, running-&gt;nextXid);</span>
<span class="lineNum">    1315 </span>            :     }
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span>            :     /*
<span class="lineNum">    1318 </span>            :      * c) transition from BUILDING_SNAPSHOT to FULL_SNAPSHOT.
<span class="lineNum">    1319 </span>            :      *
<span class="lineNum">    1320 </span>            :      * In BUILDING_SNAPSHOT state, and this xl_running_xacts' oldestRunningXid
<span class="lineNum">    1321 </span>            :      * is &gt;= than nextXid from when we switched to BUILDING_SNAPSHOT.  This
<span class="lineNum">    1322 </span>            :      * means all transactions starting afterwards have enough information to
<span class="lineNum">    1323 </span>            :      * be decoded.  Switch to FULL_SNAPSHOT.
<span class="lineNum">    1324 </span>            :      */
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :     else if (builder-&gt;state == SNAPBUILD_BUILDING_SNAPSHOT &amp;&amp;</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :              TransactionIdPrecedesOrEquals(SnapBuildNextPhaseAt(builder),</span>
<span class="lineNum">    1327 </span>            :                                            running-&gt;oldestRunningXid))
<span class="lineNum">    1328 </span>            :     {
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :         builder-&gt;state = SNAPBUILD_FULL_SNAPSHOT;</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :         SnapBuildStartNextPhaseAt(builder, running-&gt;nextXid);</span>
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :         ereport(LOG,</span>
<span class="lineNum">    1333 </span>            :                 (errmsg(&quot;logical decoding found initial consistent point at %X/%X&quot;,
<span class="lineNum">    1334 </span>            :                         (uint32) (lsn &gt;&gt; 32), (uint32) lsn),
<span class="lineNum">    1335 </span>            :                  errdetail(&quot;Waiting for transactions (approximately %d) older than %u to end.&quot;,
<span class="lineNum">    1336 </span>            :                            running-&gt;xcnt, running-&gt;nextXid)));
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :         SnapBuildWaitSnapshot(running, running-&gt;nextXid);</span>
<span class="lineNum">    1339 </span>            :     }
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span>            :     /*
<span class="lineNum">    1342 </span>            :      * c) transition from FULL_SNAPSHOT to CONSISTENT.
<span class="lineNum">    1343 </span>            :      *
<span class="lineNum">    1344 </span>            :      * In FULL_SNAPSHOT state (see d) ), and this xl_running_xacts'
<span class="lineNum">    1345 </span>            :      * oldestRunningXid is &gt;= than nextXid from when we switched to
<span class="lineNum">    1346 </span>            :      * FULL_SNAPSHOT.  This means all transactions that are currently in
<span class="lineNum">    1347 </span>            :      * progress have a catalog snapshot, and all their changes have been
<span class="lineNum">    1348 </span>            :      * collected.  Switch to CONSISTENT.
<span class="lineNum">    1349 </span>            :      */
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :     else if (builder-&gt;state == SNAPBUILD_FULL_SNAPSHOT &amp;&amp;</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :              TransactionIdPrecedesOrEquals(SnapBuildNextPhaseAt(builder),</span>
<span class="lineNum">    1352 </span>            :                                            running-&gt;oldestRunningXid))
<span class="lineNum">    1353 </span>            :     {
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :         builder-&gt;state = SNAPBUILD_CONSISTENT;</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :         SnapBuildStartNextPhaseAt(builder, InvalidTransactionId);</span>
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :         ereport(LOG,</span>
<span class="lineNum">    1358 </span>            :                 (errmsg(&quot;logical decoding found consistent point at %X/%X&quot;,
<span class="lineNum">    1359 </span>            :                         (uint32) (lsn &gt;&gt; 32), (uint32) lsn),
<span class="lineNum">    1360 </span>            :                  errdetail(&quot;There are no old transactions anymore.&quot;)));
<span class="lineNum">    1361 </span>            :     }
<span class="lineNum">    1362 </span>            : 
<span class="lineNum">    1363 </span>            :     /*
<span class="lineNum">    1364 </span>            :      * We already started to track running xacts and need to wait for all
<span class="lineNum">    1365 </span>            :      * in-progress ones to finish. We fall through to the normal processing of
<span class="lineNum">    1366 </span>            :      * records so incremental cleanup can be performed.
<span class="lineNum">    1367 </span>            :      */
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1369 </span>            : 
<span class="lineNum">    1370 </span>            : }
<span class="lineNum">    1371 </span>            : 
<span class="lineNum">    1372 </span>            : /* ---
<span class="lineNum">    1373 </span>            :  * Iterate through xids in record, wait for all older than the cutoff to
<span class="lineNum">    1374 </span>            :  * finish.  Then, if possible, log a new xl_running_xacts record.
<span class="lineNum">    1375 </span>            :  *
<span class="lineNum">    1376 </span>            :  * This isn't required for the correctness of decoding, but to:
<span class="lineNum">    1377 </span>            :  * a) allow isolationtester to notice that we're currently waiting for
<span class="lineNum">    1378 </span>            :  *    something.
<span class="lineNum">    1379 </span>            :  * b) log a new xl_running_xacts record where it'd be helpful, without having
<span class="lineNum">    1380 </span>            :  *    to write for bgwriter or checkpointer.
<span class="lineNum">    1381 </span>            :  * ---
<a name="1382"><span class="lineNum">    1382 </span>            :  */</a>
<span class="lineNum">    1383 </span>            : static void
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 : SnapBuildWaitSnapshot(xl_running_xacts *running, TransactionId cutoff)</span>
<span class="lineNum">    1385 </span>            : {
<span class="lineNum">    1386 </span>            :     int         off;
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :     for (off = 0; off &lt; running-&gt;xcnt; off++)</span>
<span class="lineNum">    1389 </span>            :     {
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :         TransactionId xid = running-&gt;xids[off];</span>
<span class="lineNum">    1391 </span>            : 
<span class="lineNum">    1392 </span>            :         /*
<span class="lineNum">    1393 </span>            :          * Upper layers should prevent that we ever need to wait on ourselves.
<span class="lineNum">    1394 </span>            :          * Check anyway, since failing to do so would either result in an
<span class="lineNum">    1395 </span>            :          * endless wait or an Assert() failure.
<span class="lineNum">    1396 </span>            :          */
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :         if (TransactionIdIsCurrentTransactionId(xid))</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;waiting for ourselves&quot;);</span>
<span class="lineNum">    1399 </span>            : 
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :         if (TransactionIdFollows(xid, cutoff))</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1402 </span>            : 
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :         XactLockTableWait(xid, NULL, NULL, XLTW_None);</span>
<span class="lineNum">    1404 </span>            :     }
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span>            :     /*
<span class="lineNum">    1407 </span>            :      * All transactions we needed to finish finished - try to ensure there is
<span class="lineNum">    1408 </span>            :      * another xl_running_xacts record in a timely manner, without having to
<span class="lineNum">    1409 </span>            :      * write for bgwriter or checkpointer to log one.  During recovery we
<span class="lineNum">    1410 </span>            :      * can't enforce that, so we'll have to wait.
<span class="lineNum">    1411 </span>            :      */
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :     if (!RecoveryInProgress())</span>
<span class="lineNum">    1413 </span>            :     {
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :         LogStandbySnapshot();</span>
<span class="lineNum">    1415 </span>            :     }
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span>            : /* -----------------------------------
<span class="lineNum">    1419 </span>            :  * Snapshot serialization support
<span class="lineNum">    1420 </span>            :  * -----------------------------------
<span class="lineNum">    1421 </span>            :  */
<span class="lineNum">    1422 </span>            : 
<span class="lineNum">    1423 </span>            : /*
<span class="lineNum">    1424 </span>            :  * We store current state of struct SnapBuild on disk in the following manner:
<span class="lineNum">    1425 </span>            :  *
<span class="lineNum">    1426 </span>            :  * struct SnapBuildOnDisk;
<span class="lineNum">    1427 </span>            :  * TransactionId * running.xcnt_space;
<span class="lineNum">    1428 </span>            :  * TransactionId * committed.xcnt; (*not xcnt_space*)
<span class="lineNum">    1429 </span>            :  *
<span class="lineNum">    1430 </span>            :  */
<span class="lineNum">    1431 </span>            : typedef struct SnapBuildOnDisk
<span class="lineNum">    1432 </span>            : {
<span class="lineNum">    1433 </span>            :     /* first part of this struct needs to be version independent */
<span class="lineNum">    1434 </span>            : 
<span class="lineNum">    1435 </span>            :     /* data not covered by checksum */
<span class="lineNum">    1436 </span>            :     uint32      magic;
<span class="lineNum">    1437 </span>            :     pg_crc32c   checksum;
<span class="lineNum">    1438 </span>            : 
<span class="lineNum">    1439 </span>            :     /* data covered by checksum */
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            :     /* version, in case we want to support pg_upgrade */
<span class="lineNum">    1442 </span>            :     uint32      version;
<span class="lineNum">    1443 </span>            :     /* how large is the on disk data, excluding the constant sized part */
<span class="lineNum">    1444 </span>            :     uint32      length;
<span class="lineNum">    1445 </span>            : 
<span class="lineNum">    1446 </span>            :     /* version dependent part */
<span class="lineNum">    1447 </span>            :     SnapBuild   builder;
<span class="lineNum">    1448 </span>            : 
<span class="lineNum">    1449 </span>            :     /* variable amount of TransactionIds follows */
<span class="lineNum">    1450 </span>            : } SnapBuildOnDisk;
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span>            : #define SnapBuildOnDiskConstantSize \
<span class="lineNum">    1453 </span>            :     offsetof(SnapBuildOnDisk, builder)
<span class="lineNum">    1454 </span>            : #define SnapBuildOnDiskNotChecksummedSize \
<span class="lineNum">    1455 </span>            :     offsetof(SnapBuildOnDisk, version)
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span>            : #define SNAPBUILD_MAGIC 0x51A1E001
<span class="lineNum">    1458 </span>            : #define SNAPBUILD_VERSION 2
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span>            : /*
<span class="lineNum">    1461 </span>            :  * Store/Load a snapshot from disk, depending on the snapshot builder's state.
<span class="lineNum">    1462 </span>            :  *
<span class="lineNum">    1463 </span>            :  * Supposed to be used by external (i.e. not snapbuild.c) code that just read
<span class="lineNum">    1464 </span>            :  * a record that's a potential location for a serialized snapshot.
<a name="1465"><span class="lineNum">    1465 </span>            :  */</a>
<span class="lineNum">    1466 </span>            : void
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 : SnapBuildSerializationPoint(SnapBuild *builder, XLogRecPtr lsn)</span>
<span class="lineNum">    1468 </span>            : {
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :     if (builder-&gt;state &lt; SNAPBUILD_CONSISTENT)</span>
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :         SnapBuildRestore(builder, lsn);</span>
<span class="lineNum">    1471 </span>            :     else
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :         SnapBuildSerialize(builder, lsn);</span>
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span>            : /*
<span class="lineNum">    1476 </span>            :  * Serialize the snapshot 'builder' at the location 'lsn' if it hasn't already
<span class="lineNum">    1477 </span>            :  * been done by another decoding process.
<a name="1478"><span class="lineNum">    1478 </span>            :  */</a>
<span class="lineNum">    1479 </span>            : static void
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 : SnapBuildSerialize(SnapBuild *builder, XLogRecPtr lsn)</span>
<span class="lineNum">    1481 </span>            : {
<span class="lineNum">    1482 </span>            :     Size        needed_length;
<span class="lineNum">    1483 </span>            :     SnapBuildOnDisk *ondisk;
<span class="lineNum">    1484 </span>            :     char       *ondisk_c;
<span class="lineNum">    1485 </span>            :     int         fd;
<span class="lineNum">    1486 </span>            :     char        tmppath[MAXPGPATH];
<span class="lineNum">    1487 </span>            :     char        path[MAXPGPATH];
<span class="lineNum">    1488 </span>            :     int         ret;
<span class="lineNum">    1489 </span>            :     struct stat stat_buf;
<span class="lineNum">    1490 </span>            :     Size        sz;
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :     Assert(lsn != InvalidXLogRecPtr);</span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :     Assert(builder-&gt;last_serialized_snapshot == InvalidXLogRecPtr ||</span>
<span class="lineNum">    1494 </span>            :            builder-&gt;last_serialized_snapshot &lt;= lsn);
<span class="lineNum">    1495 </span>            : 
<span class="lineNum">    1496 </span>            :     /*
<span class="lineNum">    1497 </span>            :      * no point in serializing if we cannot continue to work immediately after
<span class="lineNum">    1498 </span>            :      * restoring the snapshot
<span class="lineNum">    1499 </span>            :      */
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :     if (builder-&gt;state &lt; SNAPBUILD_CONSISTENT)</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span>            :     /*
<span class="lineNum">    1504 </span>            :      * We identify snapshots by the LSN they are valid for. We don't need to
<span class="lineNum">    1505 </span>            :      * include timelines in the name as each LSN maps to exactly one timeline
<span class="lineNum">    1506 </span>            :      * unless the user used pg_resetwal or similar. If a user did so, there's
<span class="lineNum">    1507 </span>            :      * no hope continuing to decode anyway.
<span class="lineNum">    1508 </span>            :      */
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :     sprintf(path, &quot;pg_logical/snapshots/%X-%X.snap&quot;,</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :             (uint32) (lsn &gt;&gt; 32), (uint32) lsn);</span>
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span>            :     /*
<span class="lineNum">    1513 </span>            :      * first check whether some other backend already has written the snapshot
<span class="lineNum">    1514 </span>            :      * for this LSN. It's perfectly fine if there's none, so we accept ENOENT
<span class="lineNum">    1515 </span>            :      * as a valid state. Everything else is an unexpected error.
<span class="lineNum">    1516 </span>            :      */
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :     ret = stat(path, &amp;stat_buf);</span>
<span class="lineNum">    1518 </span>            : 
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :     if (ret != 0 &amp;&amp; errno != ENOENT)</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1521 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1522 </span>            :                  errmsg(&quot;could not stat file \&quot;%s\&quot;: %m&quot;, path)));
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :     else if (ret == 0)</span>
<span class="lineNum">    1525 </span>            :     {
<span class="lineNum">    1526 </span>            :         /*
<span class="lineNum">    1527 </span>            :          * somebody else has already serialized to this point, don't overwrite
<span class="lineNum">    1528 </span>            :          * but remember location, so we don't need to read old data again.
<span class="lineNum">    1529 </span>            :          *
<span class="lineNum">    1530 </span>            :          * To be sure it has been synced to disk after the rename() from the
<span class="lineNum">    1531 </span>            :          * tempfile filename to the real filename, we just repeat the fsync.
<span class="lineNum">    1532 </span>            :          * That ought to be cheap because in most scenarios it should already
<span class="lineNum">    1533 </span>            :          * be safely on disk.
<span class="lineNum">    1534 </span>            :          */
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :         fsync_fname(path, false);</span>
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :         fsync_fname(&quot;pg_logical/snapshots&quot;, true);</span>
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :         builder-&gt;last_serialized_snapshot = lsn;</span>
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :         goto out;</span>
<span class="lineNum">    1540 </span>            :     }
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span>            :     /*
<span class="lineNum">    1543 </span>            :      * there is an obvious race condition here between the time we stat(2) the
<span class="lineNum">    1544 </span>            :      * file and us writing the file. But we rename the file into place
<span class="lineNum">    1545 </span>            :      * atomically and all files created need to contain the same data anyway,
<span class="lineNum">    1546 </span>            :      * so this is perfectly fine, although a bit of a resource waste. Locking
<span class="lineNum">    1547 </span>            :      * seems like pointless complication.
<span class="lineNum">    1548 </span>            :      */
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :     elog(DEBUG1, &quot;serializing snapshot to %s&quot;, path);</span>
<span class="lineNum">    1550 </span>            : 
<span class="lineNum">    1551 </span>            :     /* to make sure only we will write to this tempfile, include pid */
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :     sprintf(tmppath, &quot;pg_logical/snapshots/%X-%X.snap.%u.tmp&quot;,</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :             (uint32) (lsn &gt;&gt; 32), (uint32) lsn, MyProcPid);</span>
<span class="lineNum">    1554 </span>            : 
<span class="lineNum">    1555 </span>            :     /*
<span class="lineNum">    1556 </span>            :      * Unlink temporary file if it already exists, needs to have been before a
<span class="lineNum">    1557 </span>            :      * crash/error since we won't enter this function twice from within a
<span class="lineNum">    1558 </span>            :      * single decoding slot/backend and the temporary file contains the pid of
<span class="lineNum">    1559 </span>            :      * the current process.
<span class="lineNum">    1560 </span>            :      */
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :     if (unlink(tmppath) != 0 &amp;&amp; errno != ENOENT)</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1563 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1564 </span>            :                  errmsg(&quot;could not remove file \&quot;%s\&quot;: %m&quot;, tmppath)));
<span class="lineNum">    1565 </span>            : 
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :     needed_length = sizeof(SnapBuildOnDisk) +</span>
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :         sizeof(TransactionId) * builder-&gt;committed.xcnt;</span>
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :     ondisk_c = MemoryContextAllocZero(builder-&gt;context, needed_length);</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :     ondisk = (SnapBuildOnDisk *) ondisk_c;</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :     ondisk-&gt;magic = SNAPBUILD_MAGIC;</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :     ondisk-&gt;version = SNAPBUILD_VERSION;</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :     ondisk-&gt;length = needed_length;</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :     INIT_CRC32C(ondisk-&gt;checksum);</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :     COMP_CRC32C(ondisk-&gt;checksum,</span>
<span class="lineNum">    1576 </span>            :                 ((char *) ondisk) + SnapBuildOnDiskNotChecksummedSize,
<span class="lineNum">    1577 </span>            :                 SnapBuildOnDiskConstantSize - SnapBuildOnDiskNotChecksummedSize);
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :     ondisk_c += sizeof(SnapBuildOnDisk);</span>
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :     memcpy(&amp;ondisk-&gt;builder, builder, sizeof(SnapBuild));</span>
<span class="lineNum">    1581 </span>            :     /* NULL-ify memory-only data */
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :     ondisk-&gt;builder.context = NULL;</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :     ondisk-&gt;builder.snapshot = NULL;</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :     ondisk-&gt;builder.reorder = NULL;</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :     ondisk-&gt;builder.committed.xip = NULL;</span>
<span class="lineNum">    1586 </span>            : 
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :     COMP_CRC32C(ondisk-&gt;checksum,</span>
<span class="lineNum">    1588 </span>            :                 &amp;ondisk-&gt;builder,
<span class="lineNum">    1589 </span>            :                 sizeof(SnapBuild));
<span class="lineNum">    1590 </span>            : 
<span class="lineNum">    1591 </span>            :     /* there shouldn't be any running xacts */
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :     Assert(builder-&gt;was_running.was_xcnt == 0);</span>
<span class="lineNum">    1593 </span>            : 
<span class="lineNum">    1594 </span>            :     /* copy committed xacts */
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :     sz = sizeof(TransactionId) * builder-&gt;committed.xcnt;</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :     memcpy(ondisk_c, builder-&gt;committed.xip, sz);</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :     COMP_CRC32C(ondisk-&gt;checksum, ondisk_c, sz);</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :     ondisk_c += sz;</span>
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :     FIN_CRC32C(ondisk-&gt;checksum);</span>
<span class="lineNum">    1601 </span>            : 
<span class="lineNum">    1602 </span>            :     /* we have valid data now, open tempfile and write it there */
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :     fd = OpenTransientFile(tmppath,</span>
<span class="lineNum">    1604 </span>            :                            O_CREAT | O_EXCL | O_WRONLY | PG_BINARY);
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :     if (fd &lt; 0)</span>
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1607 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1608 </span>            :                  errmsg(&quot;could not open file \&quot;%s\&quot;: %m&quot;, tmppath)));
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :     errno = 0;</span>
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :     pgstat_report_wait_start(WAIT_EVENT_SNAPBUILD_WRITE);</span>
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :     if ((write(fd, ondisk, needed_length)) != needed_length)</span>
<span class="lineNum">    1613 </span>            :     {
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :         int         save_errno = errno;</span>
<span class="lineNum">    1615 </span>            : 
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :         CloseTransientFile(fd);</span>
<span class="lineNum">    1617 </span>            : 
<span class="lineNum">    1618 </span>            :         /* if write didn't set errno, assume problem is no disk space */
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :         errno = save_errno ? save_errno : ENOSPC;</span>
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1621 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1622 </span>            :                  errmsg(&quot;could not write to file \&quot;%s\&quot;: %m&quot;, tmppath)));
<span class="lineNum">    1623 </span>            :     }
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :     pgstat_report_wait_end();</span>
<span class="lineNum">    1625 </span>            : 
<span class="lineNum">    1626 </span>            :     /*
<span class="lineNum">    1627 </span>            :      * fsync the file before renaming so that even if we crash after this we
<span class="lineNum">    1628 </span>            :      * have either a fully valid file or nothing.
<span class="lineNum">    1629 </span>            :      *
<span class="lineNum">    1630 </span>            :      * It's safe to just ERROR on fsync() here because we'll retry the whole
<span class="lineNum">    1631 </span>            :      * operation including the writes.
<span class="lineNum">    1632 </span>            :      *
<span class="lineNum">    1633 </span>            :      * TODO: Do the fsync() via checkpoints/restartpoints, doing it here has
<span class="lineNum">    1634 </span>            :      * some noticeable overhead since it's performed synchronously during
<span class="lineNum">    1635 </span>            :      * decoding?
<span class="lineNum">    1636 </span>            :      */
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :     pgstat_report_wait_start(WAIT_EVENT_SNAPBUILD_SYNC);</span>
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :     if (pg_fsync(fd) != 0)</span>
<span class="lineNum">    1639 </span>            :     {
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :         int         save_errno = errno;</span>
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :         CloseTransientFile(fd);</span>
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :         errno = save_errno;</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1645 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1646 </span>            :                  errmsg(&quot;could not fsync file \&quot;%s\&quot;: %m&quot;, tmppath)));
<span class="lineNum">    1647 </span>            :     }
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :     pgstat_report_wait_end();</span>
<span class="lineNum">    1649 </span>            : 
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :     if (CloseTransientFile(fd) != 0)</span>
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1652 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1653 </span>            :                  errmsg(&quot;could not close file \&quot;%s\&quot;: %m&quot;, tmppath)));
<span class="lineNum">    1654 </span>            : 
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :     fsync_fname(&quot;pg_logical/snapshots&quot;, true);</span>
<span class="lineNum">    1656 </span>            : 
<span class="lineNum">    1657 </span>            :     /*
<span class="lineNum">    1658 </span>            :      * We may overwrite the work from some other backend, but that's ok, our
<span class="lineNum">    1659 </span>            :      * snapshot is valid as well, we'll just have done some superfluous work.
<span class="lineNum">    1660 </span>            :      */
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :     if (rename(tmppath, path) != 0)</span>
<span class="lineNum">    1662 </span>            :     {
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1664 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1665 </span>            :                  errmsg(&quot;could not rename file \&quot;%s\&quot; to \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">    1666 </span>            :                         tmppath, path)));
<span class="lineNum">    1667 </span>            :     }
<span class="lineNum">    1668 </span>            : 
<span class="lineNum">    1669 </span>            :     /* make sure we persist */
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :     fsync_fname(path, false);</span>
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :     fsync_fname(&quot;pg_logical/snapshots&quot;, true);</span>
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span>            :     /*
<span class="lineNum">    1674 </span>            :      * Now there's no way we can loose the dumped state anymore, remember this
<span class="lineNum">    1675 </span>            :      * as a serialization point.
<span class="lineNum">    1676 </span>            :      */
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :     builder-&gt;last_serialized_snapshot = lsn;</span>
<span class="lineNum">    1678 </span>            : 
<span class="lineNum">    1679 </span>            : out:
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :     ReorderBufferSetRestartPoint(builder-&gt;reorder,</span>
<span class="lineNum">    1681 </span>            :                                  builder-&gt;last_serialized_snapshot);
<span class="lineNum">    1682 </span>            : }
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span>            : /*
<span class="lineNum">    1685 </span>            :  * Restore a snapshot into 'builder' if previously one has been stored at the
<span class="lineNum">    1686 </span>            :  * location indicated by 'lsn'. Returns true if successful, false otherwise.
<a name="1687"><span class="lineNum">    1687 </span>            :  */</a>
<span class="lineNum">    1688 </span>            : static bool
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 : SnapBuildRestore(SnapBuild *builder, XLogRecPtr lsn)</span>
<span class="lineNum">    1690 </span>            : {
<span class="lineNum">    1691 </span>            :     SnapBuildOnDisk ondisk;
<span class="lineNum">    1692 </span>            :     int         fd;
<span class="lineNum">    1693 </span>            :     char        path[MAXPGPATH];
<span class="lineNum">    1694 </span>            :     Size        sz;
<span class="lineNum">    1695 </span>            :     int         readBytes;
<span class="lineNum">    1696 </span>            :     pg_crc32c   checksum;
<span class="lineNum">    1697 </span>            : 
<span class="lineNum">    1698 </span>            :     /* no point in loading a snapshot if we're already there */
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :     if (builder-&gt;state == SNAPBUILD_CONSISTENT)</span>
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1701 </span>            : 
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :     sprintf(path, &quot;pg_logical/snapshots/%X-%X.snap&quot;,</span>
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :             (uint32) (lsn &gt;&gt; 32), (uint32) lsn);</span>
<span class="lineNum">    1704 </span>            : 
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :     fd = OpenTransientFile(path, O_RDONLY | PG_BINARY);</span>
<span class="lineNum">    1706 </span>            : 
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :     if (fd &lt; 0 &amp;&amp; errno == ENOENT)</span>
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :     else if (fd &lt; 0)</span>
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1711 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1712 </span>            :                  errmsg(&quot;could not open file \&quot;%s\&quot;: %m&quot;, path)));
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span>            :     /* ----
<span class="lineNum">    1715 </span>            :      * Make sure the snapshot had been stored safely to disk, that's normally
<span class="lineNum">    1716 </span>            :      * cheap.
<span class="lineNum">    1717 </span>            :      * Note that we do not need PANIC here, nobody will be able to use the
<span class="lineNum">    1718 </span>            :      * slot without fsyncing, and saving it won't succeed without an fsync()
<span class="lineNum">    1719 </span>            :      * either...
<span class="lineNum">    1720 </span>            :      * ----
<span class="lineNum">    1721 </span>            :      */
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :     fsync_fname(path, false);</span>
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :     fsync_fname(&quot;pg_logical/snapshots&quot;, true);</span>
<span class="lineNum">    1724 </span>            : 
<span class="lineNum">    1725 </span>            : 
<span class="lineNum">    1726 </span>            :     /* read statically sized portion of snapshot */
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :     pgstat_report_wait_start(WAIT_EVENT_SNAPBUILD_READ);</span>
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :     readBytes = read(fd, &amp;ondisk, SnapBuildOnDiskConstantSize);</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :     pgstat_report_wait_end();</span>
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :     if (readBytes != SnapBuildOnDiskConstantSize)</span>
<span class="lineNum">    1731 </span>            :     {
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :         int         save_errno = errno;</span>
<span class="lineNum">    1733 </span>            : 
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :         CloseTransientFile(fd);</span>
<span class="lineNum">    1735 </span>            : 
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 :         if (readBytes &lt; 0)</span>
<span class="lineNum">    1737 </span>            :         {
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :             errno = save_errno;</span>
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">    1740 </span>            :                     (errcode_for_file_access(),
<span class="lineNum">    1741 </span>            :                      errmsg(&quot;could not read file \&quot;%s\&quot;: %m&quot;, path)));
<span class="lineNum">    1742 </span>            :         }
<span class="lineNum">    1743 </span>            :         else
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">    1745 </span>            :                     (errcode(ERRCODE_DATA_CORRUPTED),
<span class="lineNum">    1746 </span>            :                      errmsg(&quot;could not read file \&quot;%s\&quot;: read %d of %zu&quot;,
<span class="lineNum">    1747 </span>            :                             path, readBytes,
<span class="lineNum">    1748 </span>            :                             (Size) SnapBuildOnDiskConstantSize)));
<span class="lineNum">    1749 </span>            :     }
<span class="lineNum">    1750 </span>            : 
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :     if (ondisk.magic != SNAPBUILD_MAGIC)</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1753 </span>            :                 (errcode(ERRCODE_DATA_CORRUPTED),
<span class="lineNum">    1754 </span>            :                  errmsg(&quot;snapbuild state file \&quot;%s\&quot; has wrong magic number: %u instead of %u&quot;,
<span class="lineNum">    1755 </span>            :                         path, ondisk.magic, SNAPBUILD_MAGIC)));
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :     if (ondisk.version != SNAPBUILD_VERSION)</span>
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1759 </span>            :                 (errcode(ERRCODE_DATA_CORRUPTED),
<span class="lineNum">    1760 </span>            :                  errmsg(&quot;snapbuild state file \&quot;%s\&quot; has unsupported version: %u instead of %u&quot;,
<span class="lineNum">    1761 </span>            :                         path, ondisk.version, SNAPBUILD_VERSION)));
<span class="lineNum">    1762 </span>            : 
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :     INIT_CRC32C(checksum);</span>
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :     COMP_CRC32C(checksum,</span>
<span class="lineNum">    1765 </span>            :                 ((char *) &amp;ondisk) + SnapBuildOnDiskNotChecksummedSize,
<span class="lineNum">    1766 </span>            :                 SnapBuildOnDiskConstantSize - SnapBuildOnDiskNotChecksummedSize);
<span class="lineNum">    1767 </span>            : 
<span class="lineNum">    1768 </span>            :     /* read SnapBuild */
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :     pgstat_report_wait_start(WAIT_EVENT_SNAPBUILD_READ);</span>
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :     readBytes = read(fd, &amp;ondisk.builder, sizeof(SnapBuild));</span>
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :     pgstat_report_wait_end();</span>
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :     if (readBytes != sizeof(SnapBuild))</span>
<span class="lineNum">    1773 </span>            :     {
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :         int         save_errno = errno;</span>
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :         CloseTransientFile(fd);</span>
<span class="lineNum">    1777 </span>            : 
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 :         if (readBytes &lt; 0)</span>
<span class="lineNum">    1779 </span>            :         {
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 :             errno = save_errno;</span>
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">    1782 </span>            :                     (errcode_for_file_access(),
<span class="lineNum">    1783 </span>            :                      errmsg(&quot;could not read file \&quot;%s\&quot;: %m&quot;, path)));
<span class="lineNum">    1784 </span>            :         }
<span class="lineNum">    1785 </span>            :         else
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">    1787 </span>            :                     (errcode(ERRCODE_DATA_CORRUPTED),
<span class="lineNum">    1788 </span>            :                      errmsg(&quot;could not read file \&quot;%s\&quot;: read %d of %zu&quot;,
<span class="lineNum">    1789 </span>            :                             path, readBytes, sizeof(SnapBuild))));
<span class="lineNum">    1790 </span>            :     }
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :     COMP_CRC32C(checksum, &amp;ondisk.builder, sizeof(SnapBuild));</span>
<span class="lineNum">    1792 </span>            : 
<span class="lineNum">    1793 </span>            :     /* restore running xacts (dead, but kept for backward compat) */
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :     sz = sizeof(TransactionId) * ondisk.builder.was_running.was_xcnt_space;</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :     ondisk.builder.was_running.was_xip =</span>
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :         MemoryContextAllocZero(builder-&gt;context, sz);</span>
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :     pgstat_report_wait_start(WAIT_EVENT_SNAPBUILD_READ);</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :     readBytes = read(fd, ondisk.builder.was_running.was_xip, sz);</span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :     pgstat_report_wait_end();</span>
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :     if (readBytes != sz)</span>
<span class="lineNum">    1801 </span>            :     {
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :         int         save_errno = errno;</span>
<span class="lineNum">    1803 </span>            : 
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :         CloseTransientFile(fd);</span>
<span class="lineNum">    1805 </span>            : 
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :         if (readBytes &lt; 0)</span>
<span class="lineNum">    1807 </span>            :         {
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :             errno = save_errno;</span>
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">    1810 </span>            :                     (errcode_for_file_access(),
<span class="lineNum">    1811 </span>            :                      errmsg(&quot;could not read file \&quot;%s\&quot;: %m&quot;, path)));
<span class="lineNum">    1812 </span>            :         }
<span class="lineNum">    1813 </span>            :         else
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">    1815 </span>            :                     (errcode(ERRCODE_DATA_CORRUPTED),
<span class="lineNum">    1816 </span>            :                      errmsg(&quot;could not read file \&quot;%s\&quot;: read %d of %zu&quot;,
<span class="lineNum">    1817 </span>            :                             path, readBytes, sz)));
<span class="lineNum">    1818 </span>            :     }
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :     COMP_CRC32C(checksum, ondisk.builder.was_running.was_xip, sz);</span>
<span class="lineNum">    1820 </span>            : 
<span class="lineNum">    1821 </span>            :     /* restore committed xacts information */
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :     sz = sizeof(TransactionId) * ondisk.builder.committed.xcnt;</span>
<span class="lineNum">    1823 </span><span class="lineNoCov">          0 :     ondisk.builder.committed.xip = MemoryContextAllocZero(builder-&gt;context, sz);</span>
<span class="lineNum">    1824 </span><span class="lineNoCov">          0 :     pgstat_report_wait_start(WAIT_EVENT_SNAPBUILD_READ);</span>
<span class="lineNum">    1825 </span><span class="lineNoCov">          0 :     readBytes = read(fd, ondisk.builder.committed.xip, sz);</span>
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :     pgstat_report_wait_end();</span>
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :     if (readBytes != sz)</span>
<span class="lineNum">    1828 </span>            :     {
<span class="lineNum">    1829 </span><span class="lineNoCov">          0 :         int         save_errno = errno;</span>
<span class="lineNum">    1830 </span>            : 
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 :         CloseTransientFile(fd);</span>
<span class="lineNum">    1832 </span>            : 
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :         if (readBytes &lt; 0)</span>
<span class="lineNum">    1834 </span>            :         {
<span class="lineNum">    1835 </span><span class="lineNoCov">          0 :             errno = save_errno;</span>
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">    1837 </span>            :                     (errcode_for_file_access(),
<span class="lineNum">    1838 </span>            :                      errmsg(&quot;could not read file \&quot;%s\&quot;: %m&quot;, path)));
<span class="lineNum">    1839 </span>            :         }
<span class="lineNum">    1840 </span>            :         else
<span class="lineNum">    1841 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">    1842 </span>            :                     (errcode(ERRCODE_DATA_CORRUPTED),
<span class="lineNum">    1843 </span>            :                      errmsg(&quot;could not read file \&quot;%s\&quot;: read %d of %zu&quot;,
<span class="lineNum">    1844 </span>            :                             path, readBytes, sz)));
<span class="lineNum">    1845 </span>            :     }
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :     COMP_CRC32C(checksum, ondisk.builder.committed.xip, sz);</span>
<span class="lineNum">    1847 </span>            : 
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :     if (CloseTransientFile(fd) != 0)</span>
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1850 </span>            :                 (errcode_for_file_access(),
<span class="lineNum">    1851 </span>            :                  errmsg(&quot;could not close file \&quot;%s\&quot;: %m&quot;, path)));
<span class="lineNum">    1852 </span>            : 
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :     FIN_CRC32C(checksum);</span>
<span class="lineNum">    1854 </span>            : 
<span class="lineNum">    1855 </span>            :     /* verify checksum of what we've read */
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :     if (!EQ_CRC32C(checksum, ondisk.checksum))</span>
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1858 </span>            :                 (errcode(ERRCODE_DATA_CORRUPTED),
<span class="lineNum">    1859 </span>            :                  errmsg(&quot;checksum mismatch for snapbuild state file \&quot;%s\&quot;: is %u, should be %u&quot;,
<span class="lineNum">    1860 </span>            :                         path, checksum, ondisk.checksum)));
<span class="lineNum">    1861 </span>            : 
<span class="lineNum">    1862 </span>            :     /*
<span class="lineNum">    1863 </span>            :      * ok, we now have a sensible snapshot here, figure out if it has more
<span class="lineNum">    1864 </span>            :      * information than we have.
<span class="lineNum">    1865 </span>            :      */
<span class="lineNum">    1866 </span>            : 
<span class="lineNum">    1867 </span>            :     /*
<span class="lineNum">    1868 </span>            :      * We are only interested in consistent snapshots for now, comparing
<span class="lineNum">    1869 </span>            :      * whether one incomplete snapshot is more &quot;advanced&quot; seems to be
<span class="lineNum">    1870 </span>            :      * unnecessarily complex.
<span class="lineNum">    1871 </span>            :      */
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :     if (ondisk.builder.state &lt; SNAPBUILD_CONSISTENT)</span>
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :         goto snapshot_not_interesting;</span>
<span class="lineNum">    1874 </span>            : 
<span class="lineNum">    1875 </span>            :     /*
<span class="lineNum">    1876 </span>            :      * Don't use a snapshot that requires an xmin that we cannot guarantee to
<span class="lineNum">    1877 </span>            :      * be available.
<span class="lineNum">    1878 </span>            :      */
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :     if (TransactionIdPrecedes(ondisk.builder.xmin, builder-&gt;initial_xmin_horizon))</span>
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :         goto snapshot_not_interesting;</span>
<span class="lineNum">    1881 </span>            : 
<span class="lineNum">    1882 </span>            : 
<span class="lineNum">    1883 </span>            :     /* ok, we think the snapshot is sensible, copy over everything important */
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :     builder-&gt;xmin = ondisk.builder.xmin;</span>
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :     builder-&gt;xmax = ondisk.builder.xmax;</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :     builder-&gt;state = ondisk.builder.state;</span>
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :     builder-&gt;committed.xcnt = ondisk.builder.committed.xcnt;</span>
<span class="lineNum">    1889 </span>            :     /* We only allocated/stored xcnt, not xcnt_space xids ! */
<span class="lineNum">    1890 </span>            :     /* don't overwrite preallocated xip, if we don't have anything here */
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :     if (builder-&gt;committed.xcnt &gt; 0)</span>
<span class="lineNum">    1892 </span>            :     {
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :         pfree(builder-&gt;committed.xip);</span>
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :         builder-&gt;committed.xcnt_space = ondisk.builder.committed.xcnt;</span>
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :         builder-&gt;committed.xip = ondisk.builder.committed.xip;</span>
<span class="lineNum">    1896 </span>            :     }
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :     ondisk.builder.committed.xip = NULL;</span>
<span class="lineNum">    1898 </span>            : 
<span class="lineNum">    1899 </span>            :     /* our snapshot is not interesting anymore, build a new one */
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :     if (builder-&gt;snapshot != NULL)</span>
<span class="lineNum">    1901 </span>            :     {
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :         SnapBuildSnapDecRefcount(builder-&gt;snapshot);</span>
<span class="lineNum">    1903 </span>            :     }
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :     builder-&gt;snapshot = SnapBuildBuildSnapshot(builder);</span>
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :     SnapBuildSnapIncRefcount(builder-&gt;snapshot);</span>
<span class="lineNum">    1906 </span>            : 
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :     ReorderBufferSetRestartPoint(builder-&gt;reorder, lsn);</span>
<span class="lineNum">    1908 </span>            : 
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :     Assert(builder-&gt;state == SNAPBUILD_CONSISTENT);</span>
<span class="lineNum">    1910 </span>            : 
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :     ereport(LOG,</span>
<span class="lineNum">    1912 </span>            :             (errmsg(&quot;logical decoding found consistent point at %X/%X&quot;,
<span class="lineNum">    1913 </span>            :                     (uint32) (lsn &gt;&gt; 32), (uint32) lsn),
<span class="lineNum">    1914 </span>            :              errdetail(&quot;Logical decoding will begin using saved snapshot.&quot;)));
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1916 </span>            : 
<span class="lineNum">    1917 </span>            : snapshot_not_interesting:
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 :     if (ondisk.builder.committed.xip != NULL)</span>
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :         pfree(ondisk.builder.committed.xip);</span>
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1921 </span>            : }
<span class="lineNum">    1922 </span>            : 
<span class="lineNum">    1923 </span>            : /*
<span class="lineNum">    1924 </span>            :  * Remove all serialized snapshots that are not required anymore because no
<span class="lineNum">    1925 </span>            :  * slot can need them. This doesn't actually have to run during a checkpoint,
<span class="lineNum">    1926 </span>            :  * but it's a convenient point to schedule this.
<span class="lineNum">    1927 </span>            :  *
<span class="lineNum">    1928 </span>            :  * NB: We run this during checkpoints even if logical decoding is disabled so
<span class="lineNum">    1929 </span>            :  * we cleanup old slots at some point after it got disabled.
<a name="1930"><span class="lineNum">    1930 </span>            :  */</a>
<span class="lineNum">    1931 </span>            : void
<span class="lineNum">    1932 </span><span class="lineCov">         22 : CheckPointSnapBuild(void)</span>
<span class="lineNum">    1933 </span>            : {
<span class="lineNum">    1934 </span>            :     XLogRecPtr  cutoff;
<span class="lineNum">    1935 </span>            :     XLogRecPtr  redo;
<span class="lineNum">    1936 </span>            :     DIR        *snap_dir;
<span class="lineNum">    1937 </span>            :     struct dirent *snap_de;
<span class="lineNum">    1938 </span>            :     char        path[MAXPGPATH + 21];
<span class="lineNum">    1939 </span>            : 
<span class="lineNum">    1940 </span>            :     /*
<span class="lineNum">    1941 </span>            :      * We start off with a minimum of the last redo pointer. No new
<span class="lineNum">    1942 </span>            :      * replication slot will start before that, so that's a safe upper bound
<span class="lineNum">    1943 </span>            :      * for removal.
<span class="lineNum">    1944 </span>            :      */
<span class="lineNum">    1945 </span><span class="lineCov">         22 :     redo = GetRedoRecPtr();</span>
<span class="lineNum">    1946 </span>            : 
<span class="lineNum">    1947 </span>            :     /* now check for the restart ptrs from existing slots */
<span class="lineNum">    1948 </span><span class="lineCov">         22 :     cutoff = ReplicationSlotsComputeLogicalRestartLSN();</span>
<span class="lineNum">    1949 </span>            : 
<span class="lineNum">    1950 </span>            :     /* don't start earlier than the restart lsn */
<span class="lineNum">    1951 </span><span class="lineCov">         22 :     if (redo &lt; cutoff)</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :         cutoff = redo;</span>
<span class="lineNum">    1953 </span>            : 
<span class="lineNum">    1954 </span><span class="lineCov">         22 :     snap_dir = AllocateDir(&quot;pg_logical/snapshots&quot;);</span>
<span class="lineNum">    1955 </span><span class="lineCov">         88 :     while ((snap_de = ReadDir(snap_dir, &quot;pg_logical/snapshots&quot;)) != NULL)</span>
<span class="lineNum">    1956 </span>            :     {
<span class="lineNum">    1957 </span>            :         uint32      hi;
<span class="lineNum">    1958 </span>            :         uint32      lo;
<span class="lineNum">    1959 </span>            :         XLogRecPtr  lsn;
<span class="lineNum">    1960 </span>            :         struct stat statbuf;
<span class="lineNum">    1961 </span>            : 
<span class="lineNum">    1962 </span><span class="lineCov">         66 :         if (strcmp(snap_de-&gt;d_name, &quot;.&quot;) == 0 ||</span>
<span class="lineNum">    1963 </span><span class="lineCov">         22 :             strcmp(snap_de-&gt;d_name, &quot;..&quot;) == 0)</span>
<span class="lineNum">    1964 </span><span class="lineCov">         88 :             continue;</span>
<span class="lineNum">    1965 </span>            : 
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :         snprintf(path, sizeof(path), &quot;pg_logical/snapshots/%s&quot;, snap_de-&gt;d_name);</span>
<span class="lineNum">    1967 </span>            : 
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :         if (lstat(path, &amp;statbuf) == 0 &amp;&amp; !S_ISREG(statbuf.st_mode))</span>
<span class="lineNum">    1969 </span>            :         {
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :             elog(DEBUG1, &quot;only regular files expected: %s&quot;, path);</span>
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1972 </span>            :         }
<span class="lineNum">    1973 </span>            : 
<span class="lineNum">    1974 </span>            :         /*
<span class="lineNum">    1975 </span>            :          * temporary filenames from SnapBuildSerialize() include the LSN and
<span class="lineNum">    1976 </span>            :          * everything but are postfixed by .$pid.tmp. We can just remove them
<span class="lineNum">    1977 </span>            :          * the same as other files because there can be none that are
<span class="lineNum">    1978 </span>            :          * currently being written that are older than cutoff.
<span class="lineNum">    1979 </span>            :          *
<span class="lineNum">    1980 </span>            :          * We just log a message if a file doesn't fit the pattern, it's
<span class="lineNum">    1981 </span>            :          * probably some editors lock/state file or similar...
<span class="lineNum">    1982 </span>            :          */
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :         if (sscanf(snap_de-&gt;d_name, &quot;%X-%X.snap&quot;, &amp;hi, &amp;lo) != 2)</span>
<span class="lineNum">    1984 </span>            :         {
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :             ereport(LOG,</span>
<span class="lineNum">    1986 </span>            :                     (errmsg(&quot;could not parse file name \&quot;%s\&quot;&quot;, path)));
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1988 </span>            :         }
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :         lsn = ((uint64) hi) &lt;&lt; 32 | lo;</span>
<span class="lineNum">    1991 </span>            : 
<span class="lineNum">    1992 </span>            :         /* check whether we still need it */
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :         if (lsn &lt; cutoff || cutoff == InvalidXLogRecPtr)</span>
<span class="lineNum">    1994 </span>            :         {
<span class="lineNum">    1995 </span><span class="lineNoCov">          0 :             elog(DEBUG1, &quot;removing snapbuild snapshot %s&quot;, path);</span>
<span class="lineNum">    1996 </span>            : 
<span class="lineNum">    1997 </span>            :             /*
<span class="lineNum">    1998 </span>            :              * It's not particularly harmful, though strange, if we can't
<span class="lineNum">    1999 </span>            :              * remove the file here. Don't prevent the checkpoint from
<span class="lineNum">    2000 </span>            :              * completing, that'd be a cure worse than the disease.
<span class="lineNum">    2001 </span>            :              */
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :             if (unlink(path) &lt; 0)</span>
<span class="lineNum">    2003 </span>            :             {
<span class="lineNum">    2004 </span><span class="lineNoCov">          0 :                 ereport(LOG,</span>
<span class="lineNum">    2005 </span>            :                         (errcode_for_file_access(),
<span class="lineNum">    2006 </span>            :                          errmsg(&quot;could not remove file \&quot;%s\&quot;: %m&quot;,
<span class="lineNum">    2007 </span>            :                                 path)));
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    2009 </span>            :             }
<span class="lineNum">    2010 </span>            :         }
<span class="lineNum">    2011 </span>            :     }
<span class="lineNum">    2012 </span><span class="lineCov">         22 :     FreeDir(snap_dir);</span>
<span class="lineNum">    2013 </span><span class="lineCov">         22 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
