<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/optimizer/util/placeholder.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/backend/optimizer/util</a> - placeholder.c<span style="font-size: 80%;"> (source / <a href="placeholder.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">120</td>
            <td class="headerCovTableEntry">124</td>
            <td class="headerCovTableEntryHi">96.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * placeholder.c
<span class="lineNum">       4 </span>            :  *    PlaceHolderVar and PlaceHolderInfo manipulation routines
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       8 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  * IDENTIFICATION
<span class="lineNum">      12 </span>            :  *    src/backend/optimizer/util/placeholder.c
<span class="lineNum">      13 </span>            :  *
<span class="lineNum">      14 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      15 </span>            :  */
<span class="lineNum">      16 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &quot;nodes/nodeFuncs.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;optimizer/cost.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;optimizer/optimizer.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;optimizer/pathnode.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;optimizer/placeholder.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;optimizer/planmain.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;utils/lsyscache.h&quot;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : /* Local functions */
<span class="lineNum">      27 </span>            : static void find_placeholders_recurse(PlannerInfo *root, Node *jtnode);
<span class="lineNum">      28 </span>            : static void find_placeholders_in_expr(PlannerInfo *root, Node *expr);
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : /*
<span class="lineNum">      32 </span>            :  * make_placeholder_expr
<span class="lineNum">      33 </span>            :  *      Make a PlaceHolderVar for the given expression.
<span class="lineNum">      34 </span>            :  *
<span class="lineNum">      35 </span>            :  * phrels is the syntactic location (as a set of baserels) to attribute
<span class="lineNum">      36 </span>            :  * to the expression.
<a name="37"><span class="lineNum">      37 </span>            :  */</a>
<span class="lineNum">      38 </span>            : PlaceHolderVar *
<span class="lineNum">      39 </span><span class="lineCov">        286 : make_placeholder_expr(PlannerInfo *root, Expr *expr, Relids phrels)</span>
<span class="lineNum">      40 </span>            : {
<span class="lineNum">      41 </span><span class="lineCov">        286 :     PlaceHolderVar *phv = makeNode(PlaceHolderVar);</span>
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span><span class="lineCov">        286 :     phv-&gt;phexpr = expr;</span>
<span class="lineNum">      44 </span><span class="lineCov">        286 :     phv-&gt;phrels = phrels;</span>
<span class="lineNum">      45 </span><span class="lineCov">        286 :     phv-&gt;phid = ++(root-&gt;glob-&gt;lastPHId);</span>
<span class="lineNum">      46 </span><span class="lineCov">        286 :     phv-&gt;phlevelsup = 0;</span>
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span><span class="lineCov">        286 :     return phv;</span>
<span class="lineNum">      49 </span>            : }
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : /*
<span class="lineNum">      52 </span>            :  * find_placeholder_info
<span class="lineNum">      53 </span>            :  *      Fetch the PlaceHolderInfo for the given PHV
<span class="lineNum">      54 </span>            :  *
<span class="lineNum">      55 </span>            :  * If the PlaceHolderInfo doesn't exist yet, create it if create_new_ph is
<span class="lineNum">      56 </span>            :  * true, else throw an error.
<span class="lineNum">      57 </span>            :  *
<span class="lineNum">      58 </span>            :  * This is separate from make_placeholder_expr because subquery pullup has
<span class="lineNum">      59 </span>            :  * to make PlaceHolderVars for expressions that might not be used at all in
<span class="lineNum">      60 </span>            :  * the upper query, or might not remain after const-expression simplification.
<span class="lineNum">      61 </span>            :  * We build PlaceHolderInfos only for PHVs that are still present in the
<span class="lineNum">      62 </span>            :  * simplified query passed to query_planner().
<span class="lineNum">      63 </span>            :  *
<span class="lineNum">      64 </span>            :  * Note: this should only be called after query_planner() has started.  Also,
<span class="lineNum">      65 </span>            :  * create_new_ph must not be true after deconstruct_jointree begins, because
<span class="lineNum">      66 </span>            :  * make_outerjoininfo assumes that we already know about all placeholders.
<a name="67"><span class="lineNum">      67 </span>            :  */</a>
<span class="lineNum">      68 </span>            : PlaceHolderInfo *
<span class="lineNum">      69 </span><span class="lineCov">        734 : find_placeholder_info(PlannerInfo *root, PlaceHolderVar *phv,</span>
<span class="lineNum">      70 </span>            :                       bool create_new_ph)
<span class="lineNum">      71 </span>            : {
<span class="lineNum">      72 </span>            :     PlaceHolderInfo *phinfo;
<span class="lineNum">      73 </span>            :     Relids      rels_used;
<span class="lineNum">      74 </span>            :     ListCell   *lc;
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            :     /* if this ever isn't true, we'd need to be able to look in parent lists */
<span class="lineNum">      77 </span><span class="lineCov">        734 :     Assert(phv-&gt;phlevelsup == 0);</span>
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span><span class="lineCov">       1030 :     foreach(lc, root-&gt;placeholder_list)</span>
<span class="lineNum">      80 </span>            :     {
<span class="lineNum">      81 </span><span class="lineCov">        816 :         phinfo = (PlaceHolderInfo *) lfirst(lc);</span>
<span class="lineNum">      82 </span><span class="lineCov">        816 :         if (phinfo-&gt;phid == phv-&gt;phid)</span>
<span class="lineNum">      83 </span><span class="lineCov">        520 :             return phinfo;</span>
<span class="lineNum">      84 </span>            :     }
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            :     /* Not found, so create it */
<span class="lineNum">      87 </span><span class="lineCov">        214 :     if (!create_new_ph)</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;too late to create a new PlaceHolderInfo&quot;);</span>
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span><span class="lineCov">        214 :     phinfo = makeNode(PlaceHolderInfo);</span>
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span><span class="lineCov">        214 :     phinfo-&gt;phid = phv-&gt;phid;</span>
<span class="lineNum">      93 </span><span class="lineCov">        214 :     phinfo-&gt;ph_var = copyObject(phv);</span>
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            :     /*
<span class="lineNum">      96 </span>            :      * Any referenced rels that are outside the PHV's syntactic scope are
<span class="lineNum">      97 </span>            :      * LATERAL references, which should be included in ph_lateral but not in
<span class="lineNum">      98 </span>            :      * ph_eval_at.  If no referenced rels are within the syntactic scope,
<span class="lineNum">      99 </span>            :      * force evaluation at the syntactic location.
<span class="lineNum">     100 </span>            :      */
<span class="lineNum">     101 </span><span class="lineCov">        214 :     rels_used = pull_varnos((Node *) phv-&gt;phexpr);</span>
<span class="lineNum">     102 </span><span class="lineCov">        214 :     phinfo-&gt;ph_lateral = bms_difference(rels_used, phv-&gt;phrels);</span>
<span class="lineNum">     103 </span><span class="lineCov">        214 :     if (bms_is_empty(phinfo-&gt;ph_lateral))</span>
<span class="lineNum">     104 </span><span class="lineCov">        178 :         phinfo-&gt;ph_lateral = NULL;   /* make it exactly NULL if empty */</span>
<span class="lineNum">     105 </span><span class="lineCov">        214 :     phinfo-&gt;ph_eval_at = bms_int_members(rels_used, phv-&gt;phrels);</span>
<span class="lineNum">     106 </span>            :     /* If no contained vars, force evaluation at syntactic location */
<span class="lineNum">     107 </span><span class="lineCov">        214 :     if (bms_is_empty(phinfo-&gt;ph_eval_at))</span>
<span class="lineNum">     108 </span>            :     {
<span class="lineNum">     109 </span><span class="lineCov">        130 :         phinfo-&gt;ph_eval_at = bms_copy(phv-&gt;phrels);</span>
<span class="lineNum">     110 </span><span class="lineCov">        130 :         Assert(!bms_is_empty(phinfo-&gt;ph_eval_at));</span>
<span class="lineNum">     111 </span>            :     }
<span class="lineNum">     112 </span>            :     /* ph_eval_at may change later, see update_placeholder_eval_levels */
<span class="lineNum">     113 </span><span class="lineCov">        214 :     phinfo-&gt;ph_needed = NULL;    /* initially it's unused */</span>
<span class="lineNum">     114 </span>            :     /* for the moment, estimate width using just the datatype info */
<span class="lineNum">     115 </span><span class="lineCov">        214 :     phinfo-&gt;ph_width = get_typavgwidth(exprType((Node *) phv-&gt;phexpr),</span>
<span class="lineNum">     116 </span><span class="lineCov">        214 :                                        exprTypmod((Node *) phv-&gt;phexpr));</span>
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span><span class="lineCov">        214 :     root-&gt;placeholder_list = lappend(root-&gt;placeholder_list, phinfo);</span>
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            :     /*
<span class="lineNum">     121 </span>            :      * The PHV's contained expression may contain other, lower-level PHVs.  We
<span class="lineNum">     122 </span>            :      * now know we need to get those into the PlaceHolderInfo list, too, so we
<span class="lineNum">     123 </span>            :      * may as well do that immediately.
<span class="lineNum">     124 </span>            :      */
<span class="lineNum">     125 </span><span class="lineCov">        214 :     find_placeholders_in_expr(root, (Node *) phinfo-&gt;ph_var-&gt;phexpr);</span>
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span><span class="lineCov">        214 :     return phinfo;</span>
<span class="lineNum">     128 </span>            : }
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : /*
<span class="lineNum">     131 </span>            :  * find_placeholders_in_jointree
<span class="lineNum">     132 </span>            :  *      Search the jointree for PlaceHolderVars, and build PlaceHolderInfos
<span class="lineNum">     133 </span>            :  *
<span class="lineNum">     134 </span>            :  * We don't need to look at the targetlist because build_base_rel_tlists()
<span class="lineNum">     135 </span>            :  * will already have made entries for any PHVs in the tlist.
<span class="lineNum">     136 </span>            :  *
<span class="lineNum">     137 </span>            :  * This is called before we begin deconstruct_jointree.  Once we begin
<span class="lineNum">     138 </span>            :  * deconstruct_jointree, all active placeholders must be present in
<span class="lineNum">     139 </span>            :  * root-&gt;placeholder_list, because make_outerjoininfo and
<span class="lineNum">     140 </span>            :  * update_placeholder_eval_levels require this info to be available
<span class="lineNum">     141 </span>            :  * while we crawl up the join tree.
<a name="142"><span class="lineNum">     142 </span>            :  */</a>
<span class="lineNum">     143 </span>            : void
<span class="lineNum">     144 </span><span class="lineCov">      45166 : find_placeholders_in_jointree(PlannerInfo *root)</span>
<span class="lineNum">     145 </span>            : {
<span class="lineNum">     146 </span>            :     /* We need do nothing if the query contains no PlaceHolderVars */
<span class="lineNum">     147 </span><span class="lineCov">      45166 :     if (root-&gt;glob-&gt;lastPHId != 0)</span>
<span class="lineNum">     148 </span>            :     {
<span class="lineNum">     149 </span>            :         /* Start recursion at top of jointree */
<span class="lineNum">     150 </span><span class="lineCov">        182 :         Assert(root-&gt;parse-&gt;jointree != NULL &amp;&amp;</span>
<span class="lineNum">     151 </span>            :                IsA(root-&gt;parse-&gt;jointree, FromExpr));
<span class="lineNum">     152 </span><span class="lineCov">        182 :         find_placeholders_recurse(root, (Node *) root-&gt;parse-&gt;jointree);</span>
<span class="lineNum">     153 </span>            :     }
<span class="lineNum">     154 </span><span class="lineCov">      45166 : }</span>
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            : /*
<span class="lineNum">     157 </span>            :  * find_placeholders_recurse
<span class="lineNum">     158 </span>            :  *    One recursion level of find_placeholders_in_jointree.
<span class="lineNum">     159 </span>            :  *
<span class="lineNum">     160 </span>            :  * jtnode is the current jointree node to examine.
<a name="161"><span class="lineNum">     161 </span>            :  */</a>
<span class="lineNum">     162 </span>            : static void
<span class="lineNum">     163 </span><span class="lineCov">       1102 : find_placeholders_recurse(PlannerInfo *root, Node *jtnode)</span>
<span class="lineNum">     164 </span>            : {
<span class="lineNum">     165 </span><span class="lineCov">       1102 :     if (jtnode == NULL)</span>
<span class="lineNum">     166 </span><span class="lineCov">       1102 :         return;</span>
<span class="lineNum">     167 </span><span class="lineCov">       1102 :     if (IsA(jtnode, RangeTblRef))</span>
<span class="lineNum">     168 </span>            :     {
<span class="lineNum">     169 </span>            :         /* No quals to deal with here */
<span class="lineNum">     170 </span>            :     }
<span class="lineNum">     171 </span><span class="lineCov">        566 :     else if (IsA(jtnode, FromExpr))</span>
<span class="lineNum">     172 </span>            :     {
<span class="lineNum">     173 </span><span class="lineCov">        244 :         FromExpr   *f = (FromExpr *) jtnode;</span>
<span class="lineNum">     174 </span>            :         ListCell   *l;
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :         /*
<span class="lineNum">     177 </span>            :          * First, recurse to handle child joins.
<span class="lineNum">     178 </span>            :          */
<span class="lineNum">     179 </span><span class="lineCov">        520 :         foreach(l, f-&gt;fromlist)</span>
<span class="lineNum">     180 </span>            :         {
<span class="lineNum">     181 </span><span class="lineCov">        276 :             find_placeholders_recurse(root, lfirst(l));</span>
<span class="lineNum">     182 </span>            :         }
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :         /*
<span class="lineNum">     185 </span>            :          * Now process the top-level quals.
<span class="lineNum">     186 </span>            :          */
<span class="lineNum">     187 </span><span class="lineCov">        244 :         find_placeholders_in_expr(root, f-&gt;quals);</span>
<span class="lineNum">     188 </span>            :     }
<span class="lineNum">     189 </span><span class="lineCov">        322 :     else if (IsA(jtnode, JoinExpr))</span>
<span class="lineNum">     190 </span>            :     {
<span class="lineNum">     191 </span><span class="lineCov">        322 :         JoinExpr   *j = (JoinExpr *) jtnode;</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :         /*
<span class="lineNum">     194 </span>            :          * First, recurse to handle child joins.
<span class="lineNum">     195 </span>            :          */
<span class="lineNum">     196 </span><span class="lineCov">        322 :         find_placeholders_recurse(root, j-&gt;larg);</span>
<span class="lineNum">     197 </span><span class="lineCov">        322 :         find_placeholders_recurse(root, j-&gt;rarg);</span>
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :         /* Process the qual clauses */
<span class="lineNum">     200 </span><span class="lineCov">        322 :         find_placeholders_in_expr(root, j-&gt;quals);</span>
<span class="lineNum">     201 </span>            :     }
<span class="lineNum">     202 </span>            :     else
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;unrecognized node type: %d&quot;,</span>
<span class="lineNum">     204 </span>            :              (int) nodeTag(jtnode));
<span class="lineNum">     205 </span>            : }
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            : /*
<span class="lineNum">     208 </span>            :  * find_placeholders_in_expr
<span class="lineNum">     209 </span>            :  *      Find all PlaceHolderVars in the given expression, and create
<span class="lineNum">     210 </span>            :  *      PlaceHolderInfo entries for them.
<a name="211"><span class="lineNum">     211 </span>            :  */</a>
<span class="lineNum">     212 </span>            : static void
<span class="lineNum">     213 </span><span class="lineCov">        780 : find_placeholders_in_expr(PlannerInfo *root, Node *expr)</span>
<span class="lineNum">     214 </span>            : {
<span class="lineNum">     215 </span>            :     List       *vars;
<span class="lineNum">     216 </span>            :     ListCell   *vl;
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            :     /*
<span class="lineNum">     219 </span>            :      * pull_var_clause does more than we need here, but it'll do and it's
<span class="lineNum">     220 </span>            :      * convenient to use.
<span class="lineNum">     221 </span>            :      */
<span class="lineNum">     222 </span><span class="lineCov">        780 :     vars = pull_var_clause(expr,</span>
<span class="lineNum">     223 </span>            :                            PVC_RECURSE_AGGREGATES |
<span class="lineNum">     224 </span>            :                            PVC_RECURSE_WINDOWFUNCS |
<span class="lineNum">     225 </span>            :                            PVC_INCLUDE_PLACEHOLDERS);
<span class="lineNum">     226 </span><span class="lineCov">       1668 :     foreach(vl, vars)</span>
<span class="lineNum">     227 </span>            :     {
<span class="lineNum">     228 </span><span class="lineCov">        888 :         PlaceHolderVar *phv = (PlaceHolderVar *) lfirst(vl);</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            :         /* Ignore any plain Vars */
<span class="lineNum">     231 </span><span class="lineCov">        888 :         if (!IsA(phv, PlaceHolderVar))</span>
<span class="lineNum">     232 </span><span class="lineCov">        770 :             continue;</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            :         /* Create a PlaceHolderInfo entry if there's not one already */
<span class="lineNum">     235 </span><span class="lineCov">        118 :         (void) find_placeholder_info(root, phv, true);</span>
<span class="lineNum">     236 </span>            :     }
<span class="lineNum">     237 </span><span class="lineCov">        780 :     list_free(vars);</span>
<span class="lineNum">     238 </span><span class="lineCov">        780 : }</span>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            : /*
<span class="lineNum">     241 </span>            :  * update_placeholder_eval_levels
<span class="lineNum">     242 </span>            :  *      Adjust the target evaluation levels for placeholders
<span class="lineNum">     243 </span>            :  *
<span class="lineNum">     244 </span>            :  * The initial eval_at level set by find_placeholder_info was the set of
<span class="lineNum">     245 </span>            :  * rels used in the placeholder's expression (or the whole subselect below
<span class="lineNum">     246 </span>            :  * the placeholder's syntactic location, if the expr is variable-free).
<span class="lineNum">     247 </span>            :  * If the query contains any outer joins that can null any of those rels,
<span class="lineNum">     248 </span>            :  * we must delay evaluation to above those joins.
<span class="lineNum">     249 </span>            :  *
<span class="lineNum">     250 </span>            :  * We repeat this operation each time we add another outer join to
<span class="lineNum">     251 </span>            :  * root-&gt;join_info_list.  It's somewhat annoying to have to do that, but
<span class="lineNum">     252 </span>            :  * since we don't have very much information on the placeholders' locations,
<span class="lineNum">     253 </span>            :  * it's hard to avoid.  Each placeholder's eval_at level must be correct
<span class="lineNum">     254 </span>            :  * by the time it starts to figure in outer-join delay decisions for higher
<span class="lineNum">     255 </span>            :  * outer joins.
<span class="lineNum">     256 </span>            :  *
<span class="lineNum">     257 </span>            :  * In future we might want to put additional policy/heuristics here to
<span class="lineNum">     258 </span>            :  * try to determine an optimal evaluation level.  The current rules will
<span class="lineNum">     259 </span>            :  * result in evaluation at the lowest possible level.  However, pushing a
<span class="lineNum">     260 </span>            :  * placeholder eval up the tree is likely to further constrain evaluation
<span class="lineNum">     261 </span>            :  * order for outer joins, so it could easily be counterproductive; and we
<span class="lineNum">     262 </span>            :  * don't have enough information at this point to make an intelligent choice.
<a name="263"><span class="lineNum">     263 </span>            :  */</a>
<span class="lineNum">     264 </span>            : void
<span class="lineNum">     265 </span><span class="lineCov">       7508 : update_placeholder_eval_levels(PlannerInfo *root, SpecialJoinInfo *new_sjinfo)</span>
<span class="lineNum">     266 </span>            : {
<span class="lineNum">     267 </span>            :     ListCell   *lc1;
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span><span class="lineCov">       7810 :     foreach(lc1, root-&gt;placeholder_list)</span>
<span class="lineNum">     270 </span>            :     {
<span class="lineNum">     271 </span><span class="lineCov">        302 :         PlaceHolderInfo *phinfo = (PlaceHolderInfo *) lfirst(lc1);</span>
<span class="lineNum">     272 </span><span class="lineCov">        302 :         Relids      syn_level = phinfo-&gt;ph_var-&gt;phrels;</span>
<span class="lineNum">     273 </span>            :         Relids      eval_at;
<span class="lineNum">     274 </span>            :         bool        found_some;
<span class="lineNum">     275 </span>            :         ListCell   *lc2;
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :         /*
<span class="lineNum">     278 </span>            :          * We don't need to do any work on this placeholder unless the
<span class="lineNum">     279 </span>            :          * newly-added outer join is syntactically beneath its location.
<span class="lineNum">     280 </span>            :          */
<span class="lineNum">     281 </span><span class="lineCov">        360 :         if (!bms_is_subset(new_sjinfo-&gt;syn_lefthand, syn_level) ||</span>
<span class="lineNum">     282 </span><span class="lineCov">         58 :             !bms_is_subset(new_sjinfo-&gt;syn_righthand, syn_level))</span>
<span class="lineNum">     283 </span><span class="lineCov">        262 :             continue;</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :         /*
<span class="lineNum">     286 </span>            :          * Check for delays due to lower outer joins.  This is the same logic
<span class="lineNum">     287 </span>            :          * as in check_outerjoin_delay in initsplan.c, except that we don't
<span class="lineNum">     288 </span>            :          * have anything to do with the delay_upper_joins flags; delay of
<span class="lineNum">     289 </span>            :          * upper outer joins will be handled later, based on the eval_at
<span class="lineNum">     290 </span>            :          * values we compute now.
<span class="lineNum">     291 </span>            :          */
<span class="lineNum">     292 </span><span class="lineCov">         40 :         eval_at = phinfo-&gt;ph_eval_at;</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :         do
<span class="lineNum">     295 </span>            :         {
<span class="lineNum">     296 </span><span class="lineCov">         54 :             found_some = false;</span>
<span class="lineNum">     297 </span><span class="lineCov">        120 :             foreach(lc2, root-&gt;join_info_list)</span>
<span class="lineNum">     298 </span>            :             {
<span class="lineNum">     299 </span><span class="lineCov">         66 :                 SpecialJoinInfo *sjinfo = (SpecialJoinInfo *) lfirst(lc2);</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :                 /* disregard joins not within the PHV's sub-select */
<span class="lineNum">     302 </span><span class="lineCov">        132 :                 if (!bms_is_subset(sjinfo-&gt;syn_lefthand, syn_level) ||</span>
<span class="lineNum">     303 </span><span class="lineCov">         66 :                     !bms_is_subset(sjinfo-&gt;syn_righthand, syn_level))</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :                 /* do we reference any nullable rels of this OJ? */
<span class="lineNum">     307 </span><span class="lineCov">         70 :                 if (bms_overlap(eval_at, sjinfo-&gt;min_righthand) ||</span>
<span class="lineNum">     308 </span><span class="lineCov">          4 :                     (sjinfo-&gt;jointype == JOIN_FULL &amp;&amp;</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :                      bms_overlap(eval_at, sjinfo-&gt;min_lefthand)))</span>
<span class="lineNum">     310 </span>            :                 {
<span class="lineNum">     311 </span>            :                     /* yes; have we included all its rels in eval_at? */
<span class="lineNum">     312 </span><span class="lineCov">        110 :                     if (!bms_is_subset(sjinfo-&gt;min_lefthand, eval_at) ||</span>
<span class="lineNum">     313 </span><span class="lineCov">         48 :                         !bms_is_subset(sjinfo-&gt;min_righthand, eval_at))</span>
<span class="lineNum">     314 </span>            :                     {
<span class="lineNum">     315 </span>            :                         /* no, so add them in */
<span class="lineNum">     316 </span><span class="lineCov">         14 :                         eval_at = bms_add_members(eval_at,</span>
<span class="lineNum">     317 </span><span class="lineCov">         14 :                                                   sjinfo-&gt;min_lefthand);</span>
<span class="lineNum">     318 </span><span class="lineCov">         14 :                         eval_at = bms_add_members(eval_at,</span>
<span class="lineNum">     319 </span><span class="lineCov">         14 :                                                   sjinfo-&gt;min_righthand);</span>
<span class="lineNum">     320 </span>            :                         /* we'll need another iteration */
<span class="lineNum">     321 </span><span class="lineCov">         14 :                         found_some = true;</span>
<span class="lineNum">     322 </span>            :                     }
<span class="lineNum">     323 </span>            :                 }
<span class="lineNum">     324 </span>            :             }
<span class="lineNum">     325 </span><span class="lineCov">         54 :         } while (found_some);</span>
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :         /* Can't move the PHV's eval_at level to above its syntactic level */
<span class="lineNum">     328 </span><span class="lineCov">         40 :         Assert(bms_is_subset(eval_at, syn_level));</span>
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span><span class="lineCov">         40 :         phinfo-&gt;ph_eval_at = eval_at;</span>
<span class="lineNum">     331 </span>            :     }
<span class="lineNum">     332 </span><span class="lineCov">       7508 : }</span>
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            : /*
<span class="lineNum">     335 </span>            :  * fix_placeholder_input_needed_levels
<span class="lineNum">     336 </span>            :  *      Adjust the &quot;needed at&quot; levels for placeholder inputs
<span class="lineNum">     337 </span>            :  *
<span class="lineNum">     338 </span>            :  * This is called after we've finished determining the eval_at levels for
<span class="lineNum">     339 </span>            :  * all placeholders.  We need to make sure that all vars and placeholders
<span class="lineNum">     340 </span>            :  * needed to evaluate each placeholder will be available at the scan or join
<span class="lineNum">     341 </span>            :  * level where the evaluation will be done.  (It might seem that scan-level
<span class="lineNum">     342 </span>            :  * evaluations aren't interesting, but that's not so: a LATERAL reference
<span class="lineNum">     343 </span>            :  * within a placeholder's expression needs to cause the referenced var or
<span class="lineNum">     344 </span>            :  * placeholder to be marked as needed in the scan where it's evaluated.)
<span class="lineNum">     345 </span>            :  * Note that this loop can have side-effects on the ph_needed sets of other
<span class="lineNum">     346 </span>            :  * PlaceHolderInfos; that's okay because we don't examine ph_needed here, so
<span class="lineNum">     347 </span>            :  * there are no ordering issues to worry about.
<a name="348"><span class="lineNum">     348 </span>            :  */</a>
<span class="lineNum">     349 </span>            : void
<span class="lineNum">     350 </span><span class="lineCov">      45166 : fix_placeholder_input_needed_levels(PlannerInfo *root)</span>
<span class="lineNum">     351 </span>            : {
<span class="lineNum">     352 </span>            :     ListCell   *lc;
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span><span class="lineCov">      45380 :     foreach(lc, root-&gt;placeholder_list)</span>
<span class="lineNum">     355 </span>            :     {
<span class="lineNum">     356 </span><span class="lineCov">        214 :         PlaceHolderInfo *phinfo = (PlaceHolderInfo *) lfirst(lc);</span>
<span class="lineNum">     357 </span><span class="lineCov">        214 :         List       *vars = pull_var_clause((Node *) phinfo-&gt;ph_var-&gt;phexpr,</span>
<span class="lineNum">     358 </span>            :                                            PVC_RECURSE_AGGREGATES |
<span class="lineNum">     359 </span>            :                                            PVC_RECURSE_WINDOWFUNCS |
<span class="lineNum">     360 </span>            :                                            PVC_INCLUDE_PLACEHOLDERS);
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span><span class="lineCov">        214 :         add_vars_to_targetlist(root, vars, phinfo-&gt;ph_eval_at, false);</span>
<span class="lineNum">     363 </span><span class="lineCov">        214 :         list_free(vars);</span>
<span class="lineNum">     364 </span>            :     }
<span class="lineNum">     365 </span><span class="lineCov">      45166 : }</span>
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            : /*
<span class="lineNum">     368 </span>            :  * add_placeholders_to_base_rels
<span class="lineNum">     369 </span>            :  *      Add any required PlaceHolderVars to base rels' targetlists.
<span class="lineNum">     370 </span>            :  *
<span class="lineNum">     371 </span>            :  * If any placeholder can be computed at a base rel and is needed above it,
<span class="lineNum">     372 </span>            :  * add it to that rel's targetlist.  This might look like it could be merged
<span class="lineNum">     373 </span>            :  * with fix_placeholder_input_needed_levels, but it must be separate because
<span class="lineNum">     374 </span>            :  * join removal happens in between, and can change the ph_eval_at sets.  There
<span class="lineNum">     375 </span>            :  * is essentially the same logic in add_placeholders_to_joinrel, but we can't
<span class="lineNum">     376 </span>            :  * do that part until joinrels are formed.
<a name="377"><span class="lineNum">     377 </span>            :  */</a>
<span class="lineNum">     378 </span>            : void
<span class="lineNum">     379 </span><span class="lineCov">      45166 : add_placeholders_to_base_rels(PlannerInfo *root)</span>
<span class="lineNum">     380 </span>            : {
<span class="lineNum">     381 </span>            :     ListCell   *lc;
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span><span class="lineCov">      45378 :     foreach(lc, root-&gt;placeholder_list)</span>
<span class="lineNum">     384 </span>            :     {
<span class="lineNum">     385 </span><span class="lineCov">        212 :         PlaceHolderInfo *phinfo = (PlaceHolderInfo *) lfirst(lc);</span>
<span class="lineNum">     386 </span><span class="lineCov">        212 :         Relids      eval_at = phinfo-&gt;ph_eval_at;</span>
<span class="lineNum">     387 </span>            :         int         varno;
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span><span class="lineCov">        354 :         if (bms_get_singleton_member(eval_at, &amp;varno) &amp;&amp;</span>
<span class="lineNum">     390 </span><span class="lineCov">        142 :             bms_nonempty_difference(phinfo-&gt;ph_needed, eval_at))</span>
<span class="lineNum">     391 </span>            :         {
<span class="lineNum">     392 </span><span class="lineCov">        138 :             RelOptInfo *rel = find_base_rel(root, varno);</span>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span><span class="lineCov">        276 :             rel-&gt;reltarget-&gt;exprs = lappend(rel-&gt;reltarget-&gt;exprs,</span>
<span class="lineNum">     395 </span><span class="lineCov">        138 :                                             copyObject(phinfo-&gt;ph_var));</span>
<span class="lineNum">     396 </span>            :             /* reltarget's cost and width fields will be updated later */
<span class="lineNum">     397 </span>            :         }
<span class="lineNum">     398 </span>            :     }
<span class="lineNum">     399 </span><span class="lineCov">      45166 : }</span>
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            : /*
<span class="lineNum">     402 </span>            :  * add_placeholders_to_joinrel
<span class="lineNum">     403 </span>            :  *      Add any required PlaceHolderVars to a join rel's targetlist;
<span class="lineNum">     404 </span>            :  *      and if they contain lateral references, add those references to the
<span class="lineNum">     405 </span>            :  *      joinrel's direct_lateral_relids.
<span class="lineNum">     406 </span>            :  *
<span class="lineNum">     407 </span>            :  * A join rel should emit a PlaceHolderVar if (a) the PHV is needed above
<span class="lineNum">     408 </span>            :  * this join level and (b) the PHV can be computed at or below this level.
<a name="409"><span class="lineNum">     409 </span>            :  */</a>
<span class="lineNum">     410 </span>            : void
<span class="lineNum">     411 </span><span class="lineCov">      23456 : add_placeholders_to_joinrel(PlannerInfo *root, RelOptInfo *joinrel,</span>
<span class="lineNum">     412 </span>            :                             RelOptInfo *outer_rel, RelOptInfo *inner_rel)
<span class="lineNum">     413 </span>            : {
<span class="lineNum">     414 </span><span class="lineCov">      23456 :     Relids      relids = joinrel-&gt;relids;</span>
<span class="lineNum">     415 </span>            :     ListCell   *lc;
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span><span class="lineCov">      24244 :     foreach(lc, root-&gt;placeholder_list)</span>
<span class="lineNum">     418 </span>            :     {
<span class="lineNum">     419 </span><span class="lineCov">        788 :         PlaceHolderInfo *phinfo = (PlaceHolderInfo *) lfirst(lc);</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            :         /* Is it still needed above this joinrel? */
<span class="lineNum">     422 </span><span class="lineCov">        788 :         if (bms_nonempty_difference(phinfo-&gt;ph_needed, relids))</span>
<span class="lineNum">     423 </span>            :         {
<span class="lineNum">     424 </span>            :             /* Is it computable here? */
<span class="lineNum">     425 </span><span class="lineCov">        574 :             if (bms_is_subset(phinfo-&gt;ph_eval_at, relids))</span>
<span class="lineNum">     426 </span>            :             {
<span class="lineNum">     427 </span>            :                 /* Yup, add it to the output */
<span class="lineNum">     428 </span><span class="lineCov">        716 :                 joinrel-&gt;reltarget-&gt;exprs = lappend(joinrel-&gt;reltarget-&gt;exprs,</span>
<span class="lineNum">     429 </span><span class="lineCov">        358 :                                                     phinfo-&gt;ph_var);</span>
<span class="lineNum">     430 </span><span class="lineCov">        358 :                 joinrel-&gt;reltarget-&gt;width += phinfo-&gt;ph_width;</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            :                 /*
<span class="lineNum">     433 </span>            :                  * Charge the cost of evaluating the contained expression if
<span class="lineNum">     434 </span>            :                  * the PHV can be computed here but not in either input.  This
<span class="lineNum">     435 </span>            :                  * is a bit bogus because we make the decision based on the
<span class="lineNum">     436 </span>            :                  * first pair of possible input relations considered for the
<span class="lineNum">     437 </span>            :                  * joinrel.  With other pairs, it might be possible to compute
<span class="lineNum">     438 </span>            :                  * the PHV in one input or the other, and then we'd be double
<span class="lineNum">     439 </span>            :                  * charging the PHV's cost for some join paths.  For now, live
<span class="lineNum">     440 </span>            :                  * with that; but we might want to improve it later by
<span class="lineNum">     441 </span>            :                  * refiguring the reltarget costs for each pair of inputs.
<span class="lineNum">     442 </span>            :                  */
<span class="lineNum">     443 </span><span class="lineCov">        646 :                 if (!bms_is_subset(phinfo-&gt;ph_eval_at, outer_rel-&gt;relids) &amp;&amp;</span>
<span class="lineNum">     444 </span><span class="lineCov">        288 :                     !bms_is_subset(phinfo-&gt;ph_eval_at, inner_rel-&gt;relids))</span>
<span class="lineNum">     445 </span>            :                 {
<span class="lineNum">     446 </span>            :                     QualCost    cost;
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span><span class="lineCov">         96 :                     cost_qual_eval_node(&amp;cost, (Node *) phinfo-&gt;ph_var-&gt;phexpr,</span>
<span class="lineNum">     449 </span>            :                                         root);
<span class="lineNum">     450 </span><span class="lineCov">         96 :                     joinrel-&gt;reltarget-&gt;cost.startup += cost.startup;</span>
<span class="lineNum">     451 </span><span class="lineCov">         96 :                     joinrel-&gt;reltarget-&gt;cost.per_tuple += cost.per_tuple;</span>
<span class="lineNum">     452 </span>            :                 }
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :                 /* Adjust joinrel's direct_lateral_relids as needed */
<span class="lineNum">     455 </span><span class="lineCov">        358 :                 joinrel-&gt;direct_lateral_relids =</span>
<span class="lineNum">     456 </span><span class="lineCov">        358 :                     bms_add_members(joinrel-&gt;direct_lateral_relids,</span>
<span class="lineNum">     457 </span><span class="lineCov">        358 :                                     phinfo-&gt;ph_lateral);</span>
<span class="lineNum">     458 </span>            :             }
<span class="lineNum">     459 </span>            :         }
<span class="lineNum">     460 </span>            :     }
<span class="lineNum">     461 </span><span class="lineCov">      23456 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
