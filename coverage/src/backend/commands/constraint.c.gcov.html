<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/commands/constraint.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/backend/commands</a> - constraint.c<span style="font-size: 80%;"> (source / <a href="constraint.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">33</td>
            <td class="headerCovTableEntry">39</td>
            <td class="headerCovTableEntryMed">84.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * constraint.c
<span class="lineNum">       4 </span>            :  *    PostgreSQL CONSTRAINT support code.
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  * IDENTIFICATION
<span class="lineNum">      10 </span>            :  *    src/backend/commands/constraint.c
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      13 </span>            :  */
<span class="lineNum">      14 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &quot;access/genam.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;access/heapam.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;access/tableam.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;catalog/index.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;commands/trigger.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;executor/executor.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;utils/builtins.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;utils/rel.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;utils/snapmgr.h&quot;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : /*
<span class="lineNum">      28 </span>            :  * unique_key_recheck - trigger function to do a deferred uniqueness check.
<span class="lineNum">      29 </span>            :  *
<span class="lineNum">      30 </span>            :  * This now also does deferred exclusion-constraint checks, so the name is
<span class="lineNum">      31 </span>            :  * somewhat historical.
<span class="lineNum">      32 </span>            :  *
<span class="lineNum">      33 </span>            :  * This is invoked as an AFTER ROW trigger for both INSERT and UPDATE,
<span class="lineNum">      34 </span>            :  * for any rows recorded as potentially violating a deferrable unique
<span class="lineNum">      35 </span>            :  * or exclusion constraint.
<span class="lineNum">      36 </span>            :  *
<span class="lineNum">      37 </span>            :  * This may be an end-of-statement check, a commit-time check, or a
<span class="lineNum">      38 </span>            :  * check triggered by a SET CONSTRAINTS command.
<a name="39"><span class="lineNum">      39 </span>            :  */</a>
<span class="lineNum">      40 </span>            : Datum
<span class="lineNum">      41 </span><span class="lineCov">         40 : unique_key_recheck(PG_FUNCTION_ARGS)</span>
<span class="lineNum">      42 </span>            : {
<span class="lineNum">      43 </span><span class="lineCov">         40 :     TriggerData *trigdata = castNode(TriggerData, fcinfo-&gt;context);</span>
<span class="lineNum">      44 </span><span class="lineCov">         40 :     const char *funcname = &quot;unique_key_recheck&quot;;</span>
<span class="lineNum">      45 </span>            :     ItemPointerData checktid;
<span class="lineNum">      46 </span>            :     ItemPointerData tmptid;
<span class="lineNum">      47 </span>            :     Relation    indexRel;
<span class="lineNum">      48 </span>            :     IndexInfo  *indexInfo;
<span class="lineNum">      49 </span>            :     EState     *estate;
<span class="lineNum">      50 </span>            :     ExprContext *econtext;
<span class="lineNum">      51 </span>            :     TupleTableSlot *slot;
<span class="lineNum">      52 </span>            :     Datum       values[INDEX_MAX_KEYS];
<span class="lineNum">      53 </span>            :     bool        isnull[INDEX_MAX_KEYS];
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            :     /*
<span class="lineNum">      56 </span>            :      * Make sure this is being called as an AFTER ROW trigger.  Note:
<span class="lineNum">      57 </span>            :      * translatable error strings are shared with ri_triggers.c, so resist the
<span class="lineNum">      58 </span>            :      * temptation to fold the function name into them.
<span class="lineNum">      59 </span>            :      */
<span class="lineNum">      60 </span><span class="lineCov">         40 :     if (!CALLED_AS_TRIGGER(fcinfo))</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">      62 </span>            :                 (errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),
<span class="lineNum">      63 </span>            :                  errmsg(&quot;function \&quot;%s\&quot; was not called by trigger manager&quot;,
<span class="lineNum">      64 </span>            :                         funcname)));
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span><span class="lineCov">         80 :     if (!TRIGGER_FIRED_AFTER(trigdata-&gt;tg_event) ||</span>
<span class="lineNum">      67 </span><span class="lineCov">         40 :         !TRIGGER_FIRED_FOR_ROW(trigdata-&gt;tg_event))</span>
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">      69 </span>            :                 (errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),
<span class="lineNum">      70 </span>            :                  errmsg(&quot;function \&quot;%s\&quot; must be fired AFTER ROW&quot;,
<span class="lineNum">      71 </span>            :                         funcname)));
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            :     /*
<span class="lineNum">      74 </span>            :      * Get the new data that was inserted/updated.
<span class="lineNum">      75 </span>            :      */
<span class="lineNum">      76 </span><span class="lineCov">         40 :     if (TRIGGER_FIRED_BY_INSERT(trigdata-&gt;tg_event))</span>
<span class="lineNum">      77 </span><span class="lineCov">         28 :         checktid = trigdata-&gt;tg_trigslot-&gt;tts_tid;</span>
<span class="lineNum">      78 </span><span class="lineCov">         12 :     else if (TRIGGER_FIRED_BY_UPDATE(trigdata-&gt;tg_event))</span>
<span class="lineNum">      79 </span><span class="lineCov">         12 :         checktid = trigdata-&gt;tg_newslot-&gt;tts_tid;</span>
<span class="lineNum">      80 </span>            :     else
<span class="lineNum">      81 </span>            :     {
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">      83 </span>            :                 (errcode(ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED),
<span class="lineNum">      84 </span>            :                  errmsg(&quot;function \&quot;%s\&quot; must be fired for INSERT or UPDATE&quot;,
<span class="lineNum">      85 </span>            :                         funcname)));
<span class="lineNum">      86 </span>            :         ItemPointerSetInvalid(&amp;checktid);   /* keep compiler quiet */
<span class="lineNum">      87 </span>            :     }
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span><span class="lineCov">         40 :     slot = table_slot_create(trigdata-&gt;tg_relation, NULL);</span>
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :     /*
<span class="lineNum">      92 </span>            :      * If the row pointed at by checktid is now dead (ie, inserted and then
<span class="lineNum">      93 </span>            :      * deleted within our transaction), we can skip the check.  However, we
<span class="lineNum">      94 </span>            :      * have to be careful, because this trigger gets queued only in response
<span class="lineNum">      95 </span>            :      * to index insertions; which means it does not get queued e.g. for HOT
<span class="lineNum">      96 </span>            :      * updates.  The row we are called for might now be dead, but have a live
<span class="lineNum">      97 </span>            :      * HOT child, in which case we still need to make the check ---
<span class="lineNum">      98 </span>            :      * effectively, we're applying the check against the live child row,
<span class="lineNum">      99 </span>            :      * although we can use the values from this row since by definition all
<span class="lineNum">     100 </span>            :      * columns of interest to us are the same.
<span class="lineNum">     101 </span>            :      *
<span class="lineNum">     102 </span>            :      * This might look like just an optimization, because the index AM will
<span class="lineNum">     103 </span>            :      * make this identical test before throwing an error.  But it's actually
<span class="lineNum">     104 </span>            :      * needed for correctness, because the index AM will also throw an error
<span class="lineNum">     105 </span>            :      * if it doesn't find the index entry for the row.  If the row's dead then
<span class="lineNum">     106 </span>            :      * it's possible the index entry has also been marked dead, and even
<span class="lineNum">     107 </span>            :      * removed.
<span class="lineNum">     108 </span>            :      */
<span class="lineNum">     109 </span><span class="lineCov">         40 :     tmptid = checktid;</span>
<span class="lineNum">     110 </span>            :     {
<span class="lineNum">     111 </span><span class="lineCov">         40 :         IndexFetchTableData *scan = table_index_fetch_begin(trigdata-&gt;tg_relation);</span>
<span class="lineNum">     112 </span><span class="lineCov">         40 :         bool        call_again = false;</span>
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span><span class="lineCov">         40 :         if (!table_index_fetch_tuple(scan, &amp;tmptid, SnapshotSelf, slot,</span>
<span class="lineNum">     115 </span>            :                                      &amp;call_again, NULL))
<span class="lineNum">     116 </span>            :         {
<span class="lineNum">     117 </span>            :             /*
<span class="lineNum">     118 </span>            :              * All rows referenced by the index entry are dead, so skip the
<span class="lineNum">     119 </span>            :              * check.
<span class="lineNum">     120 </span>            :              */
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :             ExecDropSingleTupleTableSlot(slot);</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :             table_index_fetch_end(scan);</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :             return PointerGetDatum(NULL);</span>
<span class="lineNum">     124 </span>            :         }
<span class="lineNum">     125 </span><span class="lineCov">         40 :         table_index_fetch_end(scan);</span>
<span class="lineNum">     126 </span>            :     }
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :     /*
<span class="lineNum">     129 </span>            :      * Open the index, acquiring a RowExclusiveLock, just as if we were going
<span class="lineNum">     130 </span>            :      * to update it.  (This protects against possible changes of the index
<span class="lineNum">     131 </span>            :      * schema, not against concurrent updates.)
<span class="lineNum">     132 </span>            :      */
<span class="lineNum">     133 </span><span class="lineCov">         40 :     indexRel = index_open(trigdata-&gt;tg_trigger-&gt;tgconstrindid,</span>
<span class="lineNum">     134 </span>            :                           RowExclusiveLock);
<span class="lineNum">     135 </span><span class="lineCov">         40 :     indexInfo = BuildIndexInfo(indexRel);</span>
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            :     /*
<span class="lineNum">     138 </span>            :      * Typically the index won't have expressions, but if it does we need an
<span class="lineNum">     139 </span>            :      * EState to evaluate them.  We need it for exclusion constraints too,
<span class="lineNum">     140 </span>            :      * even if they are just on simple columns.
<span class="lineNum">     141 </span>            :      */
<span class="lineNum">     142 </span><span class="lineCov">         80 :     if (indexInfo-&gt;ii_Expressions != NIL ||</span>
<span class="lineNum">     143 </span><span class="lineCov">         40 :         indexInfo-&gt;ii_ExclusionOps != NULL)</span>
<span class="lineNum">     144 </span>            :     {
<span class="lineNum">     145 </span><span class="lineCov">          8 :         estate = CreateExecutorState();</span>
<span class="lineNum">     146 </span><span class="lineCov">          8 :         econtext = GetPerTupleExprContext(estate);</span>
<span class="lineNum">     147 </span><span class="lineCov">          8 :         econtext-&gt;ecxt_scantuple = slot;</span>
<span class="lineNum">     148 </span>            :     }
<span class="lineNum">     149 </span>            :     else
<span class="lineNum">     150 </span><span class="lineCov">         32 :         estate = NULL;</span>
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :     /*
<span class="lineNum">     153 </span>            :      * Form the index values and isnull flags for the index entry that we need
<span class="lineNum">     154 </span>            :      * to check.
<span class="lineNum">     155 </span>            :      *
<span class="lineNum">     156 </span>            :      * Note: if the index uses functions that are not as immutable as they are
<span class="lineNum">     157 </span>            :      * supposed to be, this could produce an index tuple different from the
<span class="lineNum">     158 </span>            :      * original.  The index AM can catch such errors by verifying that it
<span class="lineNum">     159 </span>            :      * finds a matching index entry with the tuple's TID.  For exclusion
<span class="lineNum">     160 </span>            :      * constraints we check this in check_exclusion_constraint().
<span class="lineNum">     161 </span>            :      */
<span class="lineNum">     162 </span><span class="lineCov">         40 :     FormIndexDatum(indexInfo, slot, estate, values, isnull);</span>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :     /*
<span class="lineNum">     165 </span>            :      * Now do the appropriate check.
<span class="lineNum">     166 </span>            :      */
<span class="lineNum">     167 </span><span class="lineCov">         40 :     if (indexInfo-&gt;ii_ExclusionOps == NULL)</span>
<span class="lineNum">     168 </span>            :     {
<span class="lineNum">     169 </span>            :         /*
<span class="lineNum">     170 </span>            :          * Note: this is not a real insert; it is a check that the index entry
<span class="lineNum">     171 </span>            :          * that has already been inserted is unique.  Passing the tuple's tid
<span class="lineNum">     172 </span>            :          * (i.e. unmodified by table_index_fetch_tuple()) is correct even if
<span class="lineNum">     173 </span>            :          * the row is now dead, because that is the TID the index will know
<span class="lineNum">     174 </span>            :          * about.
<span class="lineNum">     175 </span>            :          */
<span class="lineNum">     176 </span><span class="lineCov">         32 :         index_insert(indexRel, values, isnull, &amp;checktid,</span>
<span class="lineNum">     177 </span>            :                      trigdata-&gt;tg_relation, UNIQUE_CHECK_EXISTING,
<span class="lineNum">     178 </span>            :                      indexInfo);
<span class="lineNum">     179 </span>            :     }
<span class="lineNum">     180 </span>            :     else
<span class="lineNum">     181 </span>            :     {
<span class="lineNum">     182 </span>            :         /*
<span class="lineNum">     183 </span>            :          * For exclusion constraints we just do the normal check, but now it's
<span class="lineNum">     184 </span>            :          * okay to throw error.  In the HOT-update case, we must use the live
<span class="lineNum">     185 </span>            :          * HOT child's TID here, else check_exclusion_constraint will think
<span class="lineNum">     186 </span>            :          * the child is a conflict.
<span class="lineNum">     187 </span>            :          */
<span class="lineNum">     188 </span><span class="lineCov">          8 :         check_exclusion_constraint(trigdata-&gt;tg_relation, indexRel, indexInfo,</span>
<span class="lineNum">     189 </span>            :                                    &amp;tmptid, values, isnull,
<span class="lineNum">     190 </span>            :                                    estate, false);
<span class="lineNum">     191 </span>            :     }
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :     /*
<span class="lineNum">     194 </span>            :      * If that worked, then this index entry is unique or non-excluded, and we
<span class="lineNum">     195 </span>            :      * are done.
<span class="lineNum">     196 </span>            :      */
<span class="lineNum">     197 </span><span class="lineCov">         20 :     if (estate != NULL)</span>
<span class="lineNum">     198 </span><span class="lineCov">          2 :         FreeExecutorState(estate);</span>
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span><span class="lineCov">         20 :     ExecDropSingleTupleTableSlot(slot);</span>
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span><span class="lineCov">         20 :     index_close(indexRel, RowExclusiveLock);</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span><span class="lineCov">         20 :     return PointerGetDatum(NULL);</span>
<span class="lineNum">     205 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
