<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/catalog/indexing.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/backend/catalog</a> - indexing.c<span style="font-size: 80%;"> (source / <a href="indexing.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">59</td>
            <td class="headerCovTableEntry">60</td>
            <td class="headerCovTableEntryHi">98.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">8</td>
            <td class="headerCovTableEntry">8</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * indexing.c
<span class="lineNum">       4 </span>            :  *    This file contains routines to support indexes defined on system
<span class="lineNum">       5 </span>            :  *    catalogs.
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       8 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  *
<span class="lineNum">      11 </span>            :  * IDENTIFICATION
<span class="lineNum">      12 </span>            :  *    src/backend/catalog/indexing.c
<span class="lineNum">      13 </span>            :  *
<span class="lineNum">      14 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      15 </span>            :  */
<span class="lineNum">      16 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &quot;access/genam.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;access/heapam.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;access/htup_details.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;catalog/index.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;catalog/indexing.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;executor/executor.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;utils/rel.h&quot;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : /*
<span class="lineNum">      28 </span>            :  * CatalogOpenIndexes - open the indexes on a system catalog.
<span class="lineNum">      29 </span>            :  *
<span class="lineNum">      30 </span>            :  * When inserting or updating tuples in a system catalog, call this
<span class="lineNum">      31 </span>            :  * to prepare to update the indexes for the catalog.
<span class="lineNum">      32 </span>            :  *
<span class="lineNum">      33 </span>            :  * In the current implementation, we share code for opening/closing the
<span class="lineNum">      34 </span>            :  * indexes with execUtils.c.  But we do not use ExecInsertIndexTuples,
<span class="lineNum">      35 </span>            :  * because we don't want to create an EState.  This implies that we
<span class="lineNum">      36 </span>            :  * do not support partial or expressional indexes on system catalogs,
<span class="lineNum">      37 </span>            :  * nor can we support generalized exclusion constraints.
<span class="lineNum">      38 </span>            :  * This could be fixed with localized changes here if we wanted to pay
<span class="lineNum">      39 </span>            :  * the extra overhead of building an EState.
<a name="40"><span class="lineNum">      40 </span>            :  */</a>
<span class="lineNum">      41 </span>            : CatalogIndexState
<span class="lineNum">      42 </span><span class="lineCov">     158590 : CatalogOpenIndexes(Relation heapRel)</span>
<span class="lineNum">      43 </span>            : {
<span class="lineNum">      44 </span>            :     ResultRelInfo *resultRelInfo;
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span><span class="lineCov">     158590 :     resultRelInfo = makeNode(ResultRelInfo);</span>
<span class="lineNum">      47 </span><span class="lineCov">     158590 :     resultRelInfo-&gt;ri_RangeTableIndex = 0;   /* dummy */</span>
<span class="lineNum">      48 </span><span class="lineCov">     158590 :     resultRelInfo-&gt;ri_RelationDesc = heapRel;</span>
<span class="lineNum">      49 </span><span class="lineCov">     158590 :     resultRelInfo-&gt;ri_TrigDesc = NULL;   /* we don't fire triggers */</span>
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span><span class="lineCov">     158590 :     ExecOpenIndices(resultRelInfo, false);</span>
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span><span class="lineCov">     158590 :     return resultRelInfo;</span>
<span class="lineNum">      54 </span>            : }
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : /*
<span class="lineNum">      57 </span>            :  * CatalogCloseIndexes - clean up resources allocated by CatalogOpenIndexes
<a name="58"><span class="lineNum">      58 </span>            :  */</a>
<span class="lineNum">      59 </span>            : void
<span class="lineNum">      60 </span><span class="lineCov">     158590 : CatalogCloseIndexes(CatalogIndexState indstate)</span>
<span class="lineNum">      61 </span>            : {
<span class="lineNum">      62 </span><span class="lineCov">     158590 :     ExecCloseIndices(indstate);</span>
<span class="lineNum">      63 </span><span class="lineCov">     158590 :     pfree(indstate);</span>
<span class="lineNum">      64 </span><span class="lineCov">     158590 : }</span>
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : /*
<span class="lineNum">      67 </span>            :  * CatalogIndexInsert - insert index entries for one catalog tuple
<span class="lineNum">      68 </span>            :  *
<span class="lineNum">      69 </span>            :  * This should be called for each inserted or updated catalog tuple.
<span class="lineNum">      70 </span>            :  *
<span class="lineNum">      71 </span>            :  * This is effectively a cut-down version of ExecInsertIndexTuples.
<a name="72"><span class="lineNum">      72 </span>            :  */</a>
<span class="lineNum">      73 </span>            : static void
<span class="lineNum">      74 </span><span class="lineCov">     246116 : CatalogIndexInsert(CatalogIndexState indstate, HeapTuple heapTuple)</span>
<span class="lineNum">      75 </span>            : {
<span class="lineNum">      76 </span>            :     int         i;
<span class="lineNum">      77 </span>            :     int         numIndexes;
<span class="lineNum">      78 </span>            :     RelationPtr relationDescs;
<span class="lineNum">      79 </span>            :     Relation    heapRelation;
<span class="lineNum">      80 </span>            :     TupleTableSlot *slot;
<span class="lineNum">      81 </span>            :     IndexInfo **indexInfoArray;
<span class="lineNum">      82 </span>            :     Datum       values[INDEX_MAX_KEYS];
<span class="lineNum">      83 </span>            :     bool        isnull[INDEX_MAX_KEYS];
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            :     /*
<span class="lineNum">      86 </span>            :      * HOT update does not require index inserts. But with asserts enabled we
<span class="lineNum">      87 </span>            :      * want to check that it'd be legal to currently insert into the
<span class="lineNum">      88 </span>            :      * table/index.
<span class="lineNum">      89 </span>            :      */
<span class="lineNum">      90 </span>            : #ifndef USE_ASSERT_CHECKING
<span class="lineNum">      91 </span>            :     if (HeapTupleIsHeapOnly(heapTuple))
<span class="lineNum">      92 </span>            :         return;
<span class="lineNum">      93 </span>            : #endif
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            :     /*
<span class="lineNum">      96 </span>            :      * Get information from the state structure.  Fall out if nothing to do.
<span class="lineNum">      97 </span>            :      */
<span class="lineNum">      98 </span><span class="lineCov">     246116 :     numIndexes = indstate-&gt;ri_NumIndices;</span>
<span class="lineNum">      99 </span><span class="lineCov">     246116 :     if (numIndexes == 0)</span>
<span class="lineNum">     100 </span><span class="lineCov">     249866 :         return;</span>
<span class="lineNum">     101 </span><span class="lineCov">     242366 :     relationDescs = indstate-&gt;ri_IndexRelationDescs;</span>
<span class="lineNum">     102 </span><span class="lineCov">     242366 :     indexInfoArray = indstate-&gt;ri_IndexRelationInfo;</span>
<span class="lineNum">     103 </span><span class="lineCov">     242366 :     heapRelation = indstate-&gt;ri_RelationDesc;</span>
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            :     /* Need a slot to hold the tuple being examined */
<span class="lineNum">     106 </span><span class="lineCov">     242366 :     slot = MakeSingleTupleTableSlot(RelationGetDescr(heapRelation),</span>
<span class="lineNum">     107 </span>            :                                     &amp;TTSOpsHeapTuple);
<span class="lineNum">     108 </span><span class="lineCov">     242366 :     ExecStoreHeapTuple(heapTuple, slot, false);</span>
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            :     /*
<span class="lineNum">     111 </span>            :      * for each index, form and insert the index tuple
<span class="lineNum">     112 </span>            :      */
<span class="lineNum">     113 </span><span class="lineCov">     752758 :     for (i = 0; i &lt; numIndexes; i++)</span>
<span class="lineNum">     114 </span>            :     {
<span class="lineNum">     115 </span>            :         IndexInfo  *indexInfo;
<span class="lineNum">     116 </span>            :         Relation    index;
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span><span class="lineCov">     510392 :         indexInfo = indexInfoArray[i];</span>
<span class="lineNum">     119 </span><span class="lineCov">     510392 :         index = relationDescs[i];</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :         /* If the index is marked as read-only, ignore it */
<span class="lineNum">     122 </span><span class="lineCov">     510392 :         if (!indexInfo-&gt;ii_ReadyForInserts)</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            :         /*
<span class="lineNum">     126 </span>            :          * Expressional and partial indexes on system catalogs are not
<span class="lineNum">     127 </span>            :          * supported, nor exclusion constraints, nor deferred uniqueness
<span class="lineNum">     128 </span>            :          */
<span class="lineNum">     129 </span><span class="lineCov">     510392 :         Assert(indexInfo-&gt;ii_Expressions == NIL);</span>
<span class="lineNum">     130 </span><span class="lineCov">     510392 :         Assert(indexInfo-&gt;ii_Predicate == NIL);</span>
<span class="lineNum">     131 </span><span class="lineCov">     510392 :         Assert(indexInfo-&gt;ii_ExclusionOps == NULL);</span>
<span class="lineNum">     132 </span><span class="lineCov">     510392 :         Assert(index-&gt;rd_index-&gt;indimmediate);</span>
<span class="lineNum">     133 </span><span class="lineCov">     510392 :         Assert(indexInfo-&gt;ii_NumIndexKeyAttrs != 0);</span>
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            :         /* see earlier check above */
<span class="lineNum">     136 </span>            : #ifdef USE_ASSERT_CHECKING
<span class="lineNum">     137 </span><span class="lineCov">     510392 :         if (HeapTupleIsHeapOnly(heapTuple))</span>
<span class="lineNum">     138 </span>            :         {
<span class="lineNum">     139 </span><span class="lineCov">      35958 :             Assert(!ReindexIsProcessingIndex(RelationGetRelid(index)));</span>
<span class="lineNum">     140 </span><span class="lineCov">      35958 :             continue;</span>
<span class="lineNum">     141 </span>            :         }
<span class="lineNum">     142 </span>            : #endif                          /* USE_ASSERT_CHECKING */
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            :         /*
<span class="lineNum">     145 </span>            :          * FormIndexDatum fills in its values and isnull parameters with the
<span class="lineNum">     146 </span>            :          * appropriate values for the column(s) of the index.
<span class="lineNum">     147 </span>            :          */
<span class="lineNum">     148 </span><span class="lineCov">     474434 :         FormIndexDatum(indexInfo,</span>
<span class="lineNum">     149 </span>            :                        slot,
<span class="lineNum">     150 </span>            :                        NULL,    /* no expression eval to do */
<span class="lineNum">     151 </span>            :                        values,
<span class="lineNum">     152 </span>            :                        isnull);
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :         /*
<span class="lineNum">     155 </span>            :          * The index AM does the rest.
<span class="lineNum">     156 </span>            :          */
<span class="lineNum">     157 </span><span class="lineCov">     474434 :         index_insert(index,     /* index relation */</span>
<span class="lineNum">     158 </span>            :                      values,    /* array of index Datums */
<span class="lineNum">     159 </span>            :                      isnull,    /* is-null flags */
<span class="lineNum">     160 </span>            :                      &amp;(heapTuple-&gt;t_self),   /* tid of heap tuple */
<span class="lineNum">     161 </span>            :                      heapRelation,
<span class="lineNum">     162 </span><span class="lineCov">     474434 :                      index-&gt;rd_index-&gt;indisunique ?</span>
<span class="lineNum">     163 </span>            :                      UNIQUE_CHECK_YES : UNIQUE_CHECK_NO,
<span class="lineNum">     164 </span>            :                      indexInfo);
<span class="lineNum">     165 </span>            :     }
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span><span class="lineCov">     242366 :     ExecDropSingleTupleTableSlot(slot);</span>
<span class="lineNum">     168 </span>            : }
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            : /*
<span class="lineNum">     171 </span>            :  * CatalogTupleInsert - do heap and indexing work for a new catalog tuple
<span class="lineNum">     172 </span>            :  *
<span class="lineNum">     173 </span>            :  * Insert the tuple data in &quot;tup&quot; into the specified catalog relation.
<span class="lineNum">     174 </span>            :  * The Oid of the inserted tuple is returned.
<span class="lineNum">     175 </span>            :  *
<span class="lineNum">     176 </span>            :  * This is a convenience routine for the common case of inserting a single
<span class="lineNum">     177 </span>            :  * tuple in a system catalog; it inserts a new heap tuple, keeping indexes
<span class="lineNum">     178 </span>            :  * current.  Avoid using it for multiple tuples, since opening the indexes
<span class="lineNum">     179 </span>            :  * and building the index info structures is moderately expensive.
<span class="lineNum">     180 </span>            :  * (Use CatalogTupleInsertWithInfo in such cases.)
<a name="181"><span class="lineNum">     181 </span>            :  */</a>
<span class="lineNum">     182 </span>            : void
<span class="lineNum">     183 </span><span class="lineCov">      62972 : CatalogTupleInsert(Relation heapRel, HeapTuple tup)</span>
<span class="lineNum">     184 </span>            : {
<span class="lineNum">     185 </span>            :     CatalogIndexState indstate;
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span><span class="lineCov">      62972 :     indstate = CatalogOpenIndexes(heapRel);</span>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span><span class="lineCov">      62972 :     simple_heap_insert(heapRel, tup);</span>
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span><span class="lineCov">      62972 :     CatalogIndexInsert(indstate, tup);</span>
<span class="lineNum">     192 </span><span class="lineCov">      62972 :     CatalogCloseIndexes(indstate);</span>
<span class="lineNum">     193 </span><span class="lineCov">      62972 : }</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : /*
<span class="lineNum">     196 </span>            :  * CatalogTupleInsertWithInfo - as above, but with caller-supplied index info
<span class="lineNum">     197 </span>            :  *
<span class="lineNum">     198 </span>            :  * This should be used when it's important to amortize CatalogOpenIndexes/
<span class="lineNum">     199 </span>            :  * CatalogCloseIndexes work across multiple insertions.  At some point we
<span class="lineNum">     200 </span>            :  * might cache the CatalogIndexState data somewhere (perhaps in the relcache)
<span class="lineNum">     201 </span>            :  * so that callers needn't trouble over this ... but we don't do so today.
<a name="202"><span class="lineNum">     202 </span>            :  */</a>
<span class="lineNum">     203 </span>            : void
<span class="lineNum">     204 </span><span class="lineCov">     163080 : CatalogTupleInsertWithInfo(Relation heapRel, HeapTuple tup,</span>
<span class="lineNum">     205 </span>            :                            CatalogIndexState indstate)
<span class="lineNum">     206 </span>            : {
<span class="lineNum">     207 </span><span class="lineCov">     163080 :     simple_heap_insert(heapRel, tup);</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span><span class="lineCov">     163080 :     CatalogIndexInsert(indstate, tup);</span>
<span class="lineNum">     210 </span><span class="lineCov">     163080 : }</span>
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            : /*
<span class="lineNum">     213 </span>            :  * CatalogTupleUpdate - do heap and indexing work for updating a catalog tuple
<span class="lineNum">     214 </span>            :  *
<span class="lineNum">     215 </span>            :  * Update the tuple identified by &quot;otid&quot;, replacing it with the data in &quot;tup&quot;.
<span class="lineNum">     216 </span>            :  *
<span class="lineNum">     217 </span>            :  * This is a convenience routine for the common case of updating a single
<span class="lineNum">     218 </span>            :  * tuple in a system catalog; it updates one heap tuple, keeping indexes
<span class="lineNum">     219 </span>            :  * current.  Avoid using it for multiple tuples, since opening the indexes
<span class="lineNum">     220 </span>            :  * and building the index info structures is moderately expensive.
<span class="lineNum">     221 </span>            :  * (Use CatalogTupleUpdateWithInfo in such cases.)
<a name="222"><span class="lineNum">     222 </span>            :  */</a>
<span class="lineNum">     223 </span>            : void
<span class="lineNum">     224 </span><span class="lineCov">      19476 : CatalogTupleUpdate(Relation heapRel, ItemPointer otid, HeapTuple tup)</span>
<span class="lineNum">     225 </span>            : {
<span class="lineNum">     226 </span>            :     CatalogIndexState indstate;
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span><span class="lineCov">      19476 :     indstate = CatalogOpenIndexes(heapRel);</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span><span class="lineCov">      19476 :     simple_heap_update(heapRel, otid, tup);</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span><span class="lineCov">      19476 :     CatalogIndexInsert(indstate, tup);</span>
<span class="lineNum">     233 </span><span class="lineCov">      19476 :     CatalogCloseIndexes(indstate);</span>
<span class="lineNum">     234 </span><span class="lineCov">      19476 : }</span>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : /*
<span class="lineNum">     237 </span>            :  * CatalogTupleUpdateWithInfo - as above, but with caller-supplied index info
<span class="lineNum">     238 </span>            :  *
<span class="lineNum">     239 </span>            :  * This should be used when it's important to amortize CatalogOpenIndexes/
<span class="lineNum">     240 </span>            :  * CatalogCloseIndexes work across multiple updates.  At some point we
<span class="lineNum">     241 </span>            :  * might cache the CatalogIndexState data somewhere (perhaps in the relcache)
<span class="lineNum">     242 </span>            :  * so that callers needn't trouble over this ... but we don't do so today.
<a name="243"><span class="lineNum">     243 </span>            :  */</a>
<span class="lineNum">     244 </span>            : void
<span class="lineNum">     245 </span><span class="lineCov">        588 : CatalogTupleUpdateWithInfo(Relation heapRel, ItemPointer otid, HeapTuple tup,</span>
<span class="lineNum">     246 </span>            :                            CatalogIndexState indstate)
<span class="lineNum">     247 </span>            : {
<span class="lineNum">     248 </span><span class="lineCov">        588 :     simple_heap_update(heapRel, otid, tup);</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineCov">        588 :     CatalogIndexInsert(indstate, tup);</span>
<span class="lineNum">     251 </span><span class="lineCov">        588 : }</span>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : /*
<span class="lineNum">     254 </span>            :  * CatalogTupleDelete - do heap and indexing work for deleting a catalog tuple
<span class="lineNum">     255 </span>            :  *
<span class="lineNum">     256 </span>            :  * Delete the tuple identified by &quot;tid&quot; in the specified catalog.
<span class="lineNum">     257 </span>            :  *
<span class="lineNum">     258 </span>            :  * With Postgres heaps, there is no index work to do at deletion time;
<span class="lineNum">     259 </span>            :  * cleanup will be done later by VACUUM.  However, callers of this function
<span class="lineNum">     260 </span>            :  * shouldn't have to know that; we'd like a uniform abstraction for all
<span class="lineNum">     261 </span>            :  * catalog tuple changes.  Hence, provide this currently-trivial wrapper.
<span class="lineNum">     262 </span>            :  *
<span class="lineNum">     263 </span>            :  * The abstraction is a bit leaky in that we don't provide an optimized
<span class="lineNum">     264 </span>            :  * CatalogTupleDeleteWithInfo version, because there is currently nothing to
<span class="lineNum">     265 </span>            :  * optimize.  If we ever need that, rather than touching a lot of call sites,
<span class="lineNum">     266 </span>            :  * it might be better to do something about caching CatalogIndexState.
<a name="267"><span class="lineNum">     267 </span>            :  */</a>
<span class="lineNum">     268 </span>            : void
<span class="lineNum">     269 </span><span class="lineCov">     163044 : CatalogTupleDelete(Relation heapRel, ItemPointer tid)</span>
<span class="lineNum">     270 </span>            : {
<span class="lineNum">     271 </span><span class="lineCov">     163044 :     simple_heap_delete(heapRel, tid);</span>
<span class="lineNum">     272 </span><span class="lineCov">     163044 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
