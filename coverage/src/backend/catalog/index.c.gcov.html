<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/catalog/index.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/backend/catalog</a> - index.c<span style="font-size: 80%;"> (source / <a href="index.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1011</td>
            <td class="headerCovTableEntry">1080</td>
            <td class="headerCovTableEntryHi">93.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">37</td>
            <td class="headerCovTableEntry">37</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * index.c
<span class="lineNum">       4 </span>            :  *    code to create and destroy POSTGRES index relations
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * IDENTIFICATION
<span class="lineNum">      11 </span>            :  *    src/backend/catalog/index.c
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  *
<span class="lineNum">      14 </span>            :  * INTERFACE ROUTINES
<span class="lineNum">      15 </span>            :  *      index_create()          - Create a cataloged index relation
<span class="lineNum">      16 </span>            :  *      index_drop()            - Removes index relation from catalogs
<span class="lineNum">      17 </span>            :  *      BuildIndexInfo()        - Prepare to insert index tuples
<span class="lineNum">      18 </span>            :  *      FormIndexDatum()        - Construct datum vector for one index tuple
<span class="lineNum">      19 </span>            :  *
<span class="lineNum">      20 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      21 </span>            :  */
<span class="lineNum">      22 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #include &quot;access/amapi.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;access/heapam.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;access/multixact.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;access/relscan.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;access/sysattr.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;access/tableam.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;access/transam.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;access/visibilitymap.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;access/xact.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;bootstrap/bootstrap.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;catalog/binary_upgrade.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;catalog/catalog.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;catalog/dependency.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;catalog/heap.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;catalog/index.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;catalog/objectaccess.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;catalog/partition.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;catalog/pg_am.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;catalog/pg_collation.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;catalog/pg_constraint.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;catalog/pg_depend.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;catalog/pg_description.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;catalog/pg_inherits.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;catalog/pg_opclass.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;catalog/pg_operator.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;catalog/pg_tablespace.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;catalog/pg_trigger.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;catalog/pg_type.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;catalog/storage.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;commands/event_trigger.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;commands/progress.h&quot;
<span class="lineNum">      57 </span>            : #include &quot;commands/tablecmds.h&quot;
<span class="lineNum">      58 </span>            : #include &quot;commands/trigger.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;executor/executor.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;miscadmin.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;nodes/makefuncs.h&quot;
<span class="lineNum">      62 </span>            : #include &quot;nodes/nodeFuncs.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;optimizer/optimizer.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;parser/parser.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;pgstat.h&quot;
<span class="lineNum">      66 </span>            : #include &quot;rewrite/rewriteManip.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;storage/bufmgr.h&quot;
<span class="lineNum">      68 </span>            : #include &quot;storage/lmgr.h&quot;
<span class="lineNum">      69 </span>            : #include &quot;storage/predicate.h&quot;
<span class="lineNum">      70 </span>            : #include &quot;storage/procarray.h&quot;
<span class="lineNum">      71 </span>            : #include &quot;storage/smgr.h&quot;
<span class="lineNum">      72 </span>            : #include &quot;utils/builtins.h&quot;
<span class="lineNum">      73 </span>            : #include &quot;utils/fmgroids.h&quot;
<span class="lineNum">      74 </span>            : #include &quot;utils/guc.h&quot;
<span class="lineNum">      75 </span>            : #include &quot;utils/inval.h&quot;
<span class="lineNum">      76 </span>            : #include &quot;utils/lsyscache.h&quot;
<span class="lineNum">      77 </span>            : #include &quot;utils/memutils.h&quot;
<span class="lineNum">      78 </span>            : #include &quot;utils/pg_rusage.h&quot;
<span class="lineNum">      79 </span>            : #include &quot;utils/snapmgr.h&quot;
<span class="lineNum">      80 </span>            : #include &quot;utils/syscache.h&quot;
<span class="lineNum">      81 </span>            : #include &quot;utils/tuplesort.h&quot;
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : /* Potentially set by pg_upgrade_support functions */
<span class="lineNum">      84 </span>            : Oid         binary_upgrade_next_index_pg_class_oid = InvalidOid;
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : /*
<span class="lineNum">      87 </span>            :  * Pointer-free representation of variables used when reindexing system
<span class="lineNum">      88 </span>            :  * catalogs; we use this to propagate those values to parallel workers.
<span class="lineNum">      89 </span>            :  */
<span class="lineNum">      90 </span>            : typedef struct
<span class="lineNum">      91 </span>            : {
<span class="lineNum">      92 </span>            :     Oid         currentlyReindexedHeap;
<span class="lineNum">      93 </span>            :     Oid         currentlyReindexedIndex;
<span class="lineNum">      94 </span>            :     int         numPendingReindexedIndexes;
<span class="lineNum">      95 </span>            :     Oid         pendingReindexedIndexes[FLEXIBLE_ARRAY_MEMBER];
<span class="lineNum">      96 </span>            : } SerializedReindexState;
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : /* non-export function prototypes */
<span class="lineNum">      99 </span>            : static bool relationHasPrimaryKey(Relation rel);
<span class="lineNum">     100 </span>            : static TupleDesc ConstructTupleDescriptor(Relation heapRelation,
<span class="lineNum">     101 </span>            :                                           IndexInfo *indexInfo,
<span class="lineNum">     102 </span>            :                                           List *indexColNames,
<span class="lineNum">     103 </span>            :                                           Oid accessMethodObjectId,
<span class="lineNum">     104 </span>            :                                           Oid *collationObjectId,
<span class="lineNum">     105 </span>            :                                           Oid *classObjectId);
<span class="lineNum">     106 </span>            : static void InitializeAttributeOids(Relation indexRelation,
<span class="lineNum">     107 </span>            :                                     int numatts, Oid indexoid);
<span class="lineNum">     108 </span>            : static void AppendAttributeTuples(Relation indexRelation, int numatts);
<span class="lineNum">     109 </span>            : static void UpdateIndexRelation(Oid indexoid, Oid heapoid,
<span class="lineNum">     110 </span>            :                                 Oid parentIndexId,
<span class="lineNum">     111 </span>            :                                 IndexInfo *indexInfo,
<span class="lineNum">     112 </span>            :                                 Oid *collationOids,
<span class="lineNum">     113 </span>            :                                 Oid *classOids,
<span class="lineNum">     114 </span>            :                                 int16 *coloptions,
<span class="lineNum">     115 </span>            :                                 bool primary,
<span class="lineNum">     116 </span>            :                                 bool isexclusion,
<span class="lineNum">     117 </span>            :                                 bool immediate,
<span class="lineNum">     118 </span>            :                                 bool isvalid,
<span class="lineNum">     119 </span>            :                                 bool isready);
<span class="lineNum">     120 </span>            : static void index_update_stats(Relation rel,
<span class="lineNum">     121 </span>            :                                bool hasindex,
<span class="lineNum">     122 </span>            :                                double reltuples);
<span class="lineNum">     123 </span>            : static void IndexCheckExclusion(Relation heapRelation,
<span class="lineNum">     124 </span>            :                                 Relation indexRelation,
<span class="lineNum">     125 </span>            :                                 IndexInfo *indexInfo);
<span class="lineNum">     126 </span>            : static bool validate_index_callback(ItemPointer itemptr, void *opaque);
<span class="lineNum">     127 </span>            : static bool ReindexIsCurrentlyProcessingIndex(Oid indexOid);
<span class="lineNum">     128 </span>            : static void SetReindexProcessing(Oid heapOid, Oid indexOid);
<span class="lineNum">     129 </span>            : static void ResetReindexProcessing(void);
<span class="lineNum">     130 </span>            : static void SetReindexPending(List *indexes);
<span class="lineNum">     131 </span>            : static void RemoveReindexPending(Oid indexOid);
<span class="lineNum">     132 </span>            : static void ResetReindexPending(void);
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : /*
<span class="lineNum">     136 </span>            :  * relationHasPrimaryKey
<span class="lineNum">     137 </span>            :  *      See whether an existing relation has a primary key.
<span class="lineNum">     138 </span>            :  *
<span class="lineNum">     139 </span>            :  * Caller must have suitable lock on the relation.
<span class="lineNum">     140 </span>            :  *
<span class="lineNum">     141 </span>            :  * Note: we intentionally do not check indisvalid here; that's because this
<span class="lineNum">     142 </span>            :  * is used to enforce the rule that there can be only one indisprimary index,
<span class="lineNum">     143 </span>            :  * and we want that to be true even if said index is invalid.
<a name="144"><span class="lineNum">     144 </span>            :  */</a>
<span class="lineNum">     145 </span>            : static bool
<span class="lineNum">     146 </span><span class="lineCov">        248 : relationHasPrimaryKey(Relation rel)</span>
<span class="lineNum">     147 </span>            : {
<span class="lineNum">     148 </span><span class="lineCov">        248 :     bool        result = false;</span>
<span class="lineNum">     149 </span>            :     List       *indexoidlist;
<span class="lineNum">     150 </span>            :     ListCell   *indexoidscan;
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :     /*
<span class="lineNum">     153 </span>            :      * Get the list of index OIDs for the table from the relcache, and look up
<span class="lineNum">     154 </span>            :      * each one in the pg_index syscache until we find one marked primary key
<span class="lineNum">     155 </span>            :      * (hopefully there isn't more than one such).
<span class="lineNum">     156 </span>            :      */
<span class="lineNum">     157 </span><span class="lineCov">        248 :     indexoidlist = RelationGetIndexList(rel);</span>
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span><span class="lineCov">        320 :     foreach(indexoidscan, indexoidlist)</span>
<span class="lineNum">     160 </span>            :     {
<span class="lineNum">     161 </span><span class="lineCov">         82 :         Oid         indexoid = lfirst_oid(indexoidscan);</span>
<span class="lineNum">     162 </span>            :         HeapTuple   indexTuple;
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span><span class="lineCov">         82 :         indexTuple = SearchSysCache1(INDEXRELID, ObjectIdGetDatum(indexoid));</span>
<span class="lineNum">     165 </span><span class="lineCov">         82 :         if (!HeapTupleIsValid(indexTuple))  /* should not happen */</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;cache lookup failed for index %u&quot;, indexoid);</span>
<span class="lineNum">     167 </span><span class="lineCov">         82 :         result = ((Form_pg_index) GETSTRUCT(indexTuple))-&gt;indisprimary;</span>
<span class="lineNum">     168 </span><span class="lineCov">         82 :         ReleaseSysCache(indexTuple);</span>
<span class="lineNum">     169 </span><span class="lineCov">         82 :         if (result)</span>
<span class="lineNum">     170 </span><span class="lineCov">         10 :             break;</span>
<span class="lineNum">     171 </span>            :     }
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span><span class="lineCov">        248 :     list_free(indexoidlist);</span>
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span><span class="lineCov">        248 :     return result;</span>
<span class="lineNum">     176 </span>            : }
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            : /*
<span class="lineNum">     179 </span>            :  * index_check_primary_key
<span class="lineNum">     180 </span>            :  *      Apply special checks needed before creating a PRIMARY KEY index
<span class="lineNum">     181 </span>            :  *
<span class="lineNum">     182 </span>            :  * This processing used to be in DefineIndex(), but has been split out
<span class="lineNum">     183 </span>            :  * so that it can be applied during ALTER TABLE ADD PRIMARY KEY USING INDEX.
<span class="lineNum">     184 </span>            :  *
<span class="lineNum">     185 </span>            :  * We check for a pre-existing primary key, and that all columns of the index
<span class="lineNum">     186 </span>            :  * are simple column references (not expressions), and that all those
<span class="lineNum">     187 </span>            :  * columns are marked NOT NULL.  If not, fail.
<span class="lineNum">     188 </span>            :  *
<span class="lineNum">     189 </span>            :  * We used to automatically change unmarked columns to NOT NULL here by doing
<span class="lineNum">     190 </span>            :  * our own local ALTER TABLE command.  But that doesn't work well if we're
<span class="lineNum">     191 </span>            :  * executing one subcommand of an ALTER TABLE: the operations may not get
<span class="lineNum">     192 </span>            :  * performed in the right order overall.  Now we expect that the parser
<span class="lineNum">     193 </span>            :  * inserted any required ALTER TABLE SET NOT NULL operations before trying
<span class="lineNum">     194 </span>            :  * to create a primary-key index.
<span class="lineNum">     195 </span>            :  *
<span class="lineNum">     196 </span>            :  * Caller had better have at least ShareLock on the table, else the not-null
<span class="lineNum">     197 </span>            :  * checking isn't trustworthy.
<a name="198"><span class="lineNum">     198 </span>            :  */</a>
<span class="lineNum">     199 </span>            : void
<span class="lineNum">     200 </span><span class="lineCov">        876 : index_check_primary_key(Relation heapRel,</span>
<span class="lineNum">     201 </span>            :                         IndexInfo *indexInfo,
<span class="lineNum">     202 </span>            :                         bool is_alter_table,
<span class="lineNum">     203 </span>            :                         IndexStmt *stmt)
<span class="lineNum">     204 </span>            : {
<span class="lineNum">     205 </span>            :     int         i;
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :     /*
<span class="lineNum">     208 </span>            :      * If ALTER TABLE or CREATE TABLE .. PARTITION OF, check that there isn't
<span class="lineNum">     209 </span>            :      * already a PRIMARY KEY.  In CREATE TABLE for an ordinary relation, we
<span class="lineNum">     210 </span>            :      * have faith that the parser rejected multiple pkey clauses; and CREATE
<span class="lineNum">     211 </span>            :      * INDEX doesn't have a way to say PRIMARY KEY, so it's no problem either.
<span class="lineNum">     212 </span>            :      */
<span class="lineNum">     213 </span><span class="lineCov">       1124 :     if ((is_alter_table || heapRel-&gt;rd_rel-&gt;relispartition) &amp;&amp;</span>
<span class="lineNum">     214 </span><span class="lineCov">        248 :         relationHasPrimaryKey(heapRel))</span>
<span class="lineNum">     215 </span>            :     {
<span class="lineNum">     216 </span><span class="lineCov">         10 :         ereport(ERROR,</span>
<span class="lineNum">     217 </span>            :                 (errcode(ERRCODE_INVALID_TABLE_DEFINITION),
<span class="lineNum">     218 </span>            :                  errmsg(&quot;multiple primary keys for table \&quot;%s\&quot; are not allowed&quot;,
<span class="lineNum">     219 </span>            :                         RelationGetRelationName(heapRel))));
<span class="lineNum">     220 </span>            :     }
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :     /*
<span class="lineNum">     223 </span>            :      * Check that all of the attributes in a primary key are marked as not
<span class="lineNum">     224 </span>            :      * null.  (We don't really expect to see that; it'd mean the parser messed
<span class="lineNum">     225 </span>            :      * up.  But it seems wise to check anyway.)
<span class="lineNum">     226 </span>            :      */
<span class="lineNum">     227 </span><span class="lineCov">       1904 :     for (i = 0; i &lt; indexInfo-&gt;ii_NumIndexKeyAttrs; i++)</span>
<span class="lineNum">     228 </span>            :     {
<span class="lineNum">     229 </span><span class="lineCov">       1038 :         AttrNumber  attnum = indexInfo-&gt;ii_IndexAttrNumbers[i];</span>
<span class="lineNum">     230 </span>            :         HeapTuple   atttuple;
<span class="lineNum">     231 </span>            :         Form_pg_attribute attform;
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span><span class="lineCov">       1038 :         if (attnum == 0)</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">     235 </span>            :                     (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">     236 </span>            :                      errmsg(&quot;primary keys cannot be expressions&quot;)));
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            :         /* System attributes are never null, so no need to check */
<span class="lineNum">     239 </span><span class="lineCov">       1038 :         if (attnum &lt; 0)</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span><span class="lineCov">       2076 :         atttuple = SearchSysCache2(ATTNUM,</span>
<span class="lineNum">     243 </span><span class="lineCov">       1038 :                                    ObjectIdGetDatum(RelationGetRelid(heapRel)),</span>
<span class="lineNum">     244 </span>            :                                    Int16GetDatum(attnum));
<span class="lineNum">     245 </span><span class="lineCov">       1038 :         if (!HeapTupleIsValid(atttuple))</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;cache lookup failed for attribute %d of relation %u&quot;,</span>
<span class="lineNum">     247 </span>            :                  attnum, RelationGetRelid(heapRel));
<span class="lineNum">     248 </span><span class="lineCov">       1038 :         attform = (Form_pg_attribute) GETSTRUCT(atttuple);</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineCov">       1038 :         if (!attform-&gt;attnotnull)</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">     252 </span>            :                     (errcode(ERRCODE_INVALID_TABLE_DEFINITION),
<span class="lineNum">     253 </span>            :                      errmsg(&quot;primary key column \&quot;%s\&quot; is not marked NOT NULL&quot;,
<span class="lineNum">     254 </span>            :                             NameStr(attform-&gt;attname))));
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span><span class="lineCov">       1038 :         ReleaseSysCache(atttuple);</span>
<span class="lineNum">     257 </span>            :     }
<span class="lineNum">     258 </span><span class="lineCov">        866 : }</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            : /*
<span class="lineNum">     261 </span>            :  *      ConstructTupleDescriptor
<span class="lineNum">     262 </span>            :  *
<span class="lineNum">     263 </span>            :  * Build an index tuple descriptor for a new index
<a name="264"><span class="lineNum">     264 </span>            :  */</a>
<span class="lineNum">     265 </span>            : static TupleDesc
<span class="lineNum">     266 </span><span class="lineCov">       5010 : ConstructTupleDescriptor(Relation heapRelation,</span>
<span class="lineNum">     267 </span>            :                          IndexInfo *indexInfo,
<span class="lineNum">     268 </span>            :                          List *indexColNames,
<span class="lineNum">     269 </span>            :                          Oid accessMethodObjectId,
<span class="lineNum">     270 </span>            :                          Oid *collationObjectId,
<span class="lineNum">     271 </span>            :                          Oid *classObjectId)
<span class="lineNum">     272 </span>            : {
<span class="lineNum">     273 </span><span class="lineCov">       5010 :     int         numatts = indexInfo-&gt;ii_NumIndexAttrs;</span>
<span class="lineNum">     274 </span><span class="lineCov">       5010 :     int         numkeyatts = indexInfo-&gt;ii_NumIndexKeyAttrs;</span>
<span class="lineNum">     275 </span><span class="lineCov">       5010 :     ListCell   *colnames_item = list_head(indexColNames);</span>
<span class="lineNum">     276 </span><span class="lineCov">       5010 :     ListCell   *indexpr_item = list_head(indexInfo-&gt;ii_Expressions);</span>
<span class="lineNum">     277 </span>            :     IndexAmRoutine *amroutine;
<span class="lineNum">     278 </span>            :     TupleDesc   heapTupDesc;
<span class="lineNum">     279 </span>            :     TupleDesc   indexTupDesc;
<span class="lineNum">     280 </span>            :     int         natts;          /* #atts in heap rel --- for error checks */
<span class="lineNum">     281 </span>            :     int         i;
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :     /* We need access to the index AM's API struct */
<span class="lineNum">     284 </span><span class="lineCov">       5010 :     amroutine = GetIndexAmRoutineByAmId(accessMethodObjectId, false);</span>
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :     /* ... and to the table's tuple descriptor */
<span class="lineNum">     287 </span><span class="lineCov">       5010 :     heapTupDesc = RelationGetDescr(heapRelation);</span>
<span class="lineNum">     288 </span><span class="lineCov">       5010 :     natts = RelationGetForm(heapRelation)-&gt;relnatts;</span>
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :     /*
<span class="lineNum">     291 </span>            :      * allocate the new tuple descriptor
<span class="lineNum">     292 </span>            :      */
<span class="lineNum">     293 </span><span class="lineCov">       5010 :     indexTupDesc = CreateTemplateTupleDesc(numatts);</span>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :     /*
<span class="lineNum">     296 </span>            :      * Fill in the pg_attribute row.
<span class="lineNum">     297 </span>            :      */
<span class="lineNum">     298 </span><span class="lineCov">      13386 :     for (i = 0; i &lt; numatts; i++)</span>
<span class="lineNum">     299 </span>            :     {
<span class="lineNum">     300 </span><span class="lineCov">       8376 :         AttrNumber  atnum = indexInfo-&gt;ii_IndexAttrNumbers[i];</span>
<span class="lineNum">     301 </span><span class="lineCov">       8376 :         Form_pg_attribute to = TupleDescAttr(indexTupDesc, i);</span>
<span class="lineNum">     302 </span>            :         HeapTuple   tuple;
<span class="lineNum">     303 </span>            :         Form_pg_type typeTup;
<span class="lineNum">     304 </span>            :         Form_pg_opclass opclassTup;
<span class="lineNum">     305 </span>            :         Oid         keyType;
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span><span class="lineCov">       8376 :         MemSet(to, 0, ATTRIBUTE_FIXED_PART_SIZE);</span>
<span class="lineNum">     308 </span><span class="lineCov">       8376 :         to-&gt;attnum = i + 1;</span>
<span class="lineNum">     309 </span><span class="lineCov">       8376 :         to-&gt;attstattarget = -1;</span>
<span class="lineNum">     310 </span><span class="lineCov">       8376 :         to-&gt;attcacheoff = -1;</span>
<span class="lineNum">     311 </span><span class="lineCov">       8376 :         to-&gt;attislocal = true;</span>
<span class="lineNum">     312 </span><span class="lineCov">       8376 :         to-&gt;attcollation = (i &lt; numkeyatts) ?</span>
<span class="lineNum">     313 </span><span class="lineCov">       8376 :             collationObjectId[i] : InvalidOid;</span>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :         /*
<span class="lineNum">     316 </span>            :          * For simple index columns, we copy some pg_attribute fields from the
<span class="lineNum">     317 </span>            :          * parent relation.  For expressions we have to look at the expression
<span class="lineNum">     318 </span>            :          * result.
<span class="lineNum">     319 </span>            :          */
<span class="lineNum">     320 </span><span class="lineCov">       8376 :         if (atnum != 0)</span>
<span class="lineNum">     321 </span>            :         {
<span class="lineNum">     322 </span>            :             /* Simple index column */
<span class="lineNum">     323 </span>            :             const FormData_pg_attribute *from;
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span><span class="lineCov">       8208 :             Assert(atnum &gt; 0);   /* should've been caught above */</span>
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span><span class="lineCov">       8208 :             if (atnum &gt; natts)   /* safety check */</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :                 elog(ERROR, &quot;invalid column number %d&quot;, atnum);</span>
<span class="lineNum">     329 </span><span class="lineCov">       8208 :             from = TupleDescAttr(heapTupDesc,</span>
<span class="lineNum">     330 </span>            :                                  AttrNumberGetAttrOffset(atnum));
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineCov">       8208 :             namecpy(&amp;to-&gt;attname, &amp;from-&gt;attname);</span>
<span class="lineNum">     333 </span><span class="lineCov">       8208 :             to-&gt;atttypid = from-&gt;atttypid;</span>
<span class="lineNum">     334 </span><span class="lineCov">       8208 :             to-&gt;attlen = from-&gt;attlen;</span>
<span class="lineNum">     335 </span><span class="lineCov">       8208 :             to-&gt;attndims = from-&gt;attndims;</span>
<span class="lineNum">     336 </span><span class="lineCov">       8208 :             to-&gt;atttypmod = from-&gt;atttypmod;</span>
<span class="lineNum">     337 </span><span class="lineCov">       8208 :             to-&gt;attbyval = from-&gt;attbyval;</span>
<span class="lineNum">     338 </span><span class="lineCov">       8208 :             to-&gt;attstorage = from-&gt;attstorage;</span>
<span class="lineNum">     339 </span><span class="lineCov">       8208 :             to-&gt;attalign = from-&gt;attalign;</span>
<span class="lineNum">     340 </span>            :         }
<span class="lineNum">     341 </span>            :         else
<span class="lineNum">     342 </span>            :         {
<span class="lineNum">     343 </span>            :             /* Expressional index */
<span class="lineNum">     344 </span>            :             Node       *indexkey;
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineCov">        168 :             if (indexpr_item == NULL)   /* shouldn't happen */</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :                 elog(ERROR, &quot;too few entries in indexprs list&quot;);</span>
<span class="lineNum">     348 </span><span class="lineCov">        168 :             indexkey = (Node *) lfirst(indexpr_item);</span>
<span class="lineNum">     349 </span><span class="lineCov">        168 :             indexpr_item = lnext(indexInfo-&gt;ii_Expressions, indexpr_item);</span>
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            :             /*
<span class="lineNum">     352 </span>            :              * Lookup the expression type in pg_type for the type length etc.
<span class="lineNum">     353 </span>            :              */
<span class="lineNum">     354 </span><span class="lineCov">        168 :             keyType = exprType(indexkey);</span>
<span class="lineNum">     355 </span><span class="lineCov">        168 :             tuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(keyType));</span>
<span class="lineNum">     356 </span><span class="lineCov">        168 :             if (!HeapTupleIsValid(tuple))</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                 elog(ERROR, &quot;cache lookup failed for type %u&quot;, keyType);</span>
<span class="lineNum">     358 </span><span class="lineCov">        168 :             typeTup = (Form_pg_type) GETSTRUCT(tuple);</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            :             /*
<span class="lineNum">     361 </span>            :              * Assign some of the attributes values. Leave the rest.
<span class="lineNum">     362 </span>            :              */
<span class="lineNum">     363 </span><span class="lineCov">        168 :             to-&gt;atttypid = keyType;</span>
<span class="lineNum">     364 </span><span class="lineCov">        168 :             to-&gt;attlen = typeTup-&gt;typlen;</span>
<span class="lineNum">     365 </span><span class="lineCov">        168 :             to-&gt;attbyval = typeTup-&gt;typbyval;</span>
<span class="lineNum">     366 </span><span class="lineCov">        168 :             to-&gt;attstorage = typeTup-&gt;typstorage;</span>
<span class="lineNum">     367 </span><span class="lineCov">        168 :             to-&gt;attalign = typeTup-&gt;typalign;</span>
<span class="lineNum">     368 </span><span class="lineCov">        168 :             to-&gt;atttypmod = exprTypmod(indexkey);</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineCov">        168 :             ReleaseSysCache(tuple);</span>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            :             /*
<span class="lineNum">     373 </span>            :              * Make sure the expression yields a type that's safe to store in
<span class="lineNum">     374 </span>            :              * an index.  We need this defense because we have index opclasses
<span class="lineNum">     375 </span>            :              * for pseudo-types such as &quot;record&quot;, and the actually stored type
<span class="lineNum">     376 </span>            :              * had better be safe; eg, a named composite type is okay, an
<span class="lineNum">     377 </span>            :              * anonymous record type is not.  The test is the same as for
<span class="lineNum">     378 </span>            :              * whether a table column is of a safe type (which is why we
<span class="lineNum">     379 </span>            :              * needn't check for the non-expression case).
<span class="lineNum">     380 </span>            :              */
<span class="lineNum">     381 </span><span class="lineCov">        168 :             CheckAttributeType(NameStr(to-&gt;attname),</span>
<span class="lineNum">     382 </span>            :                                to-&gt;atttypid, to-&gt;attcollation,
<span class="lineNum">     383 </span>            :                                NIL, 0);
<span class="lineNum">     384 </span>            :         }
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            :         /*
<span class="lineNum">     387 </span>            :          * We do not yet have the correct relation OID for the index, so just
<span class="lineNum">     388 </span>            :          * set it invalid for now.  InitializeAttributeOids() will fix it
<span class="lineNum">     389 </span>            :          * later.
<span class="lineNum">     390 </span>            :          */
<span class="lineNum">     391 </span><span class="lineCov">       8376 :         to-&gt;attrelid = InvalidOid;</span>
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            :         /*
<span class="lineNum">     394 </span>            :          * Set the attribute name as specified by caller.
<span class="lineNum">     395 </span>            :          */
<span class="lineNum">     396 </span><span class="lineCov">       8376 :         if (colnames_item == NULL)  /* shouldn't happen */</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;too few entries in colnames list&quot;);</span>
<span class="lineNum">     398 </span><span class="lineCov">       8376 :         namestrcpy(&amp;to-&gt;attname, (const char *) lfirst(colnames_item));</span>
<span class="lineNum">     399 </span><span class="lineCov">       8376 :         colnames_item = lnext(indexColNames, colnames_item);</span>
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :         /*
<span class="lineNum">     402 </span>            :          * Check the opclass and index AM to see if either provides a keytype
<span class="lineNum">     403 </span>            :          * (overriding the attribute type).  Opclass (if exists) takes
<span class="lineNum">     404 </span>            :          * precedence.
<span class="lineNum">     405 </span>            :          */
<span class="lineNum">     406 </span><span class="lineCov">       8376 :         keyType = amroutine-&gt;amkeytype;</span>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :         /*
<span class="lineNum">     409 </span>            :          * Code below is concerned to the opclasses which are not used with
<span class="lineNum">     410 </span>            :          * the included columns.
<span class="lineNum">     411 </span>            :          */
<span class="lineNum">     412 </span><span class="lineCov">       8376 :         if (i &lt; indexInfo-&gt;ii_NumIndexKeyAttrs)</span>
<span class="lineNum">     413 </span>            :         {
<span class="lineNum">     414 </span><span class="lineCov">       8208 :             tuple = SearchSysCache1(CLAOID, ObjectIdGetDatum(classObjectId[i]));</span>
<span class="lineNum">     415 </span><span class="lineCov">       8208 :             if (!HeapTupleIsValid(tuple))</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :                 elog(ERROR, &quot;cache lookup failed for opclass %u&quot;,</span>
<span class="lineNum">     417 </span>            :                      classObjectId[i]);
<span class="lineNum">     418 </span><span class="lineCov">       8208 :             opclassTup = (Form_pg_opclass) GETSTRUCT(tuple);</span>
<span class="lineNum">     419 </span><span class="lineCov">       8208 :             if (OidIsValid(opclassTup-&gt;opckeytype))</span>
<span class="lineNum">     420 </span><span class="lineCov">        212 :                 keyType = opclassTup-&gt;opckeytype;</span>
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :             /*
<span class="lineNum">     423 </span>            :              * If keytype is specified as ANYELEMENT, and opcintype is
<span class="lineNum">     424 </span>            :              * ANYARRAY, then the attribute type must be an array (else it'd
<span class="lineNum">     425 </span>            :              * not have matched this opclass); use its element type.
<span class="lineNum">     426 </span>            :              */
<span class="lineNum">     427 </span><span class="lineCov">       8208 :             if (keyType == ANYELEMENTOID &amp;&amp; opclassTup-&gt;opcintype == ANYARRAYOID)</span>
<span class="lineNum">     428 </span>            :             {
<span class="lineNum">     429 </span><span class="lineCov">         14 :                 keyType = get_base_element_type(to-&gt;atttypid);</span>
<span class="lineNum">     430 </span><span class="lineCov">         14 :                 if (!OidIsValid(keyType))</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :                     elog(ERROR, &quot;could not get element type of array type %u&quot;,</span>
<span class="lineNum">     432 </span>            :                          to-&gt;atttypid);
<span class="lineNum">     433 </span>            :             }
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span><span class="lineCov">       8208 :             ReleaseSysCache(tuple);</span>
<span class="lineNum">     436 </span>            :         }
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :         /*
<span class="lineNum">     439 </span>            :          * If a key type different from the heap value is specified, update
<span class="lineNum">     440 </span>            :          * the type-related fields in the index tupdesc.
<span class="lineNum">     441 </span>            :          */
<span class="lineNum">     442 </span><span class="lineCov">       8376 :         if (OidIsValid(keyType) &amp;&amp; keyType != to-&gt;atttypid)</span>
<span class="lineNum">     443 </span>            :         {
<span class="lineNum">     444 </span><span class="lineCov">        174 :             tuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(keyType));</span>
<span class="lineNum">     445 </span><span class="lineCov">        174 :             if (!HeapTupleIsValid(tuple))</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :                 elog(ERROR, &quot;cache lookup failed for type %u&quot;, keyType);</span>
<span class="lineNum">     447 </span><span class="lineCov">        174 :             typeTup = (Form_pg_type) GETSTRUCT(tuple);</span>
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span><span class="lineCov">        174 :             to-&gt;atttypid = keyType;</span>
<span class="lineNum">     450 </span><span class="lineCov">        174 :             to-&gt;atttypmod = -1;</span>
<span class="lineNum">     451 </span><span class="lineCov">        174 :             to-&gt;attlen = typeTup-&gt;typlen;</span>
<span class="lineNum">     452 </span><span class="lineCov">        174 :             to-&gt;attbyval = typeTup-&gt;typbyval;</span>
<span class="lineNum">     453 </span><span class="lineCov">        174 :             to-&gt;attalign = typeTup-&gt;typalign;</span>
<span class="lineNum">     454 </span><span class="lineCov">        174 :             to-&gt;attstorage = typeTup-&gt;typstorage;</span>
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span><span class="lineCov">        174 :             ReleaseSysCache(tuple);</span>
<span class="lineNum">     457 </span>            :         }
<span class="lineNum">     458 </span>            :     }
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span><span class="lineCov">       5010 :     pfree(amroutine);</span>
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span><span class="lineCov">       5010 :     return indexTupDesc;</span>
<span class="lineNum">     463 </span>            : }
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            : /* ----------------------------------------------------------------
<span class="lineNum">     466 </span>            :  *      InitializeAttributeOids
<span class="lineNum">     467 </span>            :  * ----------------------------------------------------------------
<a name="468"><span class="lineNum">     468 </span>            :  */</a>
<span class="lineNum">     469 </span>            : static void
<span class="lineNum">     470 </span><span class="lineCov">       5010 : InitializeAttributeOids(Relation indexRelation,</span>
<span class="lineNum">     471 </span>            :                         int numatts,
<span class="lineNum">     472 </span>            :                         Oid indexoid)
<span class="lineNum">     473 </span>            : {
<span class="lineNum">     474 </span>            :     TupleDesc   tupleDescriptor;
<span class="lineNum">     475 </span>            :     int         i;
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineCov">       5010 :     tupleDescriptor = RelationGetDescr(indexRelation);</span>
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineCov">      13386 :     for (i = 0; i &lt; numatts; i += 1)</span>
<span class="lineNum">     480 </span><span class="lineCov">       8376 :         TupleDescAttr(tupleDescriptor, i)-&gt;attrelid = indexoid;</span>
<span class="lineNum">     481 </span><span class="lineCov">       5010 : }</span>
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            : /* ----------------------------------------------------------------
<span class="lineNum">     484 </span>            :  *      AppendAttributeTuples
<span class="lineNum">     485 </span>            :  * ----------------------------------------------------------------
<a name="486"><span class="lineNum">     486 </span>            :  */</a>
<span class="lineNum">     487 </span>            : static void
<span class="lineNum">     488 </span><span class="lineCov">       5010 : AppendAttributeTuples(Relation indexRelation, int numatts)</span>
<span class="lineNum">     489 </span>            : {
<span class="lineNum">     490 </span>            :     Relation    pg_attribute;
<span class="lineNum">     491 </span>            :     CatalogIndexState indstate;
<span class="lineNum">     492 </span>            :     TupleDesc   indexTupDesc;
<span class="lineNum">     493 </span>            :     int         i;
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            :     /*
<span class="lineNum">     496 </span>            :      * open the attribute relation and its indexes
<span class="lineNum">     497 </span>            :      */
<span class="lineNum">     498 </span><span class="lineCov">       5010 :     pg_attribute = table_open(AttributeRelationId, RowExclusiveLock);</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span><span class="lineCov">       5010 :     indstate = CatalogOpenIndexes(pg_attribute);</span>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            :     /*
<span class="lineNum">     503 </span>            :      * insert data from new index's tupdesc into pg_attribute
<span class="lineNum">     504 </span>            :      */
<span class="lineNum">     505 </span><span class="lineCov">       5010 :     indexTupDesc = RelationGetDescr(indexRelation);</span>
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineCov">      13386 :     for (i = 0; i &lt; numatts; i++)</span>
<span class="lineNum">     508 </span>            :     {
<span class="lineNum">     509 </span><span class="lineCov">       8376 :         Form_pg_attribute attr = TupleDescAttr(indexTupDesc, i);</span>
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span><span class="lineCov">       8376 :         Assert(attr-&gt;attnum == i + 1);</span>
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span><span class="lineCov">       8376 :         InsertPgAttributeTuple(pg_attribute, attr, indstate);</span>
<span class="lineNum">     514 </span>            :     }
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span><span class="lineCov">       5010 :     CatalogCloseIndexes(indstate);</span>
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span><span class="lineCov">       5010 :     table_close(pg_attribute, RowExclusiveLock);</span>
<span class="lineNum">     519 </span><span class="lineCov">       5010 : }</span>
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span>            : /* ----------------------------------------------------------------
<span class="lineNum">     522 </span>            :  *      UpdateIndexRelation
<span class="lineNum">     523 </span>            :  *
<span class="lineNum">     524 </span>            :  * Construct and insert a new entry in the pg_index catalog
<span class="lineNum">     525 </span>            :  * ----------------------------------------------------------------
<a name="526"><span class="lineNum">     526 </span>            :  */</a>
<span class="lineNum">     527 </span>            : static void
<span class="lineNum">     528 </span><span class="lineCov">       5010 : UpdateIndexRelation(Oid indexoid,</span>
<span class="lineNum">     529 </span>            :                     Oid heapoid,
<span class="lineNum">     530 </span>            :                     Oid parentIndexId,
<span class="lineNum">     531 </span>            :                     IndexInfo *indexInfo,
<span class="lineNum">     532 </span>            :                     Oid *collationOids,
<span class="lineNum">     533 </span>            :                     Oid *classOids,
<span class="lineNum">     534 </span>            :                     int16 *coloptions,
<span class="lineNum">     535 </span>            :                     bool primary,
<span class="lineNum">     536 </span>            :                     bool isexclusion,
<span class="lineNum">     537 </span>            :                     bool immediate,
<span class="lineNum">     538 </span>            :                     bool isvalid,
<span class="lineNum">     539 </span>            :                     bool isready)
<span class="lineNum">     540 </span>            : {
<span class="lineNum">     541 </span>            :     int2vector *indkey;
<span class="lineNum">     542 </span>            :     oidvector  *indcollation;
<span class="lineNum">     543 </span>            :     oidvector  *indclass;
<span class="lineNum">     544 </span>            :     int2vector *indoption;
<span class="lineNum">     545 </span>            :     Datum       exprsDatum;
<span class="lineNum">     546 </span>            :     Datum       predDatum;
<span class="lineNum">     547 </span>            :     Datum       values[Natts_pg_index];
<span class="lineNum">     548 </span>            :     bool        nulls[Natts_pg_index];
<span class="lineNum">     549 </span>            :     Relation    pg_index;
<span class="lineNum">     550 </span>            :     HeapTuple   tuple;
<span class="lineNum">     551 </span>            :     int         i;
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            :     /*
<span class="lineNum">     554 </span>            :      * Copy the index key, opclass, and indoption info into arrays (should we
<span class="lineNum">     555 </span>            :      * make the caller pass them like this to start with?)
<span class="lineNum">     556 </span>            :      */
<span class="lineNum">     557 </span><span class="lineCov">       5010 :     indkey = buildint2vector(NULL, indexInfo-&gt;ii_NumIndexAttrs);</span>
<span class="lineNum">     558 </span><span class="lineCov">      13386 :     for (i = 0; i &lt; indexInfo-&gt;ii_NumIndexAttrs; i++)</span>
<span class="lineNum">     559 </span><span class="lineCov">       8376 :         indkey-&gt;values[i] = indexInfo-&gt;ii_IndexAttrNumbers[i];</span>
<span class="lineNum">     560 </span><span class="lineCov">       5010 :     indcollation = buildoidvector(collationOids, indexInfo-&gt;ii_NumIndexKeyAttrs);</span>
<span class="lineNum">     561 </span><span class="lineCov">       5010 :     indclass = buildoidvector(classOids, indexInfo-&gt;ii_NumIndexKeyAttrs);</span>
<span class="lineNum">     562 </span><span class="lineCov">       5010 :     indoption = buildint2vector(coloptions, indexInfo-&gt;ii_NumIndexKeyAttrs);</span>
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :     /*
<span class="lineNum">     565 </span>            :      * Convert the index expressions (if any) to a text datum
<span class="lineNum">     566 </span>            :      */
<span class="lineNum">     567 </span><span class="lineCov">       5010 :     if (indexInfo-&gt;ii_Expressions != NIL)</span>
<span class="lineNum">     568 </span>            :     {
<span class="lineNum">     569 </span>            :         char       *exprsString;
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span><span class="lineCov">        164 :         exprsString = nodeToString(indexInfo-&gt;ii_Expressions);</span>
<span class="lineNum">     572 </span><span class="lineCov">        164 :         exprsDatum = CStringGetTextDatum(exprsString);</span>
<span class="lineNum">     573 </span><span class="lineCov">        164 :         pfree(exprsString);</span>
<span class="lineNum">     574 </span>            :     }
<span class="lineNum">     575 </span>            :     else
<span class="lineNum">     576 </span><span class="lineCov">       4846 :         exprsDatum = (Datum) 0;</span>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :     /*
<span class="lineNum">     579 </span>            :      * Convert the index predicate (if any) to a text datum.  Note we convert
<span class="lineNum">     580 </span>            :      * implicit-AND format to normal explicit-AND for storage.
<span class="lineNum">     581 </span>            :      */
<span class="lineNum">     582 </span><span class="lineCov">       5010 :     if (indexInfo-&gt;ii_Predicate != NIL)</span>
<span class="lineNum">     583 </span>            :     {
<span class="lineNum">     584 </span>            :         char       *predString;
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span><span class="lineCov">         84 :         predString = nodeToString(make_ands_explicit(indexInfo-&gt;ii_Predicate));</span>
<span class="lineNum">     587 </span><span class="lineCov">         84 :         predDatum = CStringGetTextDatum(predString);</span>
<span class="lineNum">     588 </span><span class="lineCov">         84 :         pfree(predString);</span>
<span class="lineNum">     589 </span>            :     }
<span class="lineNum">     590 </span>            :     else
<span class="lineNum">     591 </span><span class="lineCov">       4926 :         predDatum = (Datum) 0;</span>
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            :     /*
<span class="lineNum">     594 </span>            :      * open the system catalog index relation
<span class="lineNum">     595 </span>            :      */
<span class="lineNum">     596 </span><span class="lineCov">       5010 :     pg_index = table_open(IndexRelationId, RowExclusiveLock);</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            :     /*
<span class="lineNum">     599 </span>            :      * Build a pg_index tuple
<span class="lineNum">     600 </span>            :      */
<span class="lineNum">     601 </span><span class="lineCov">       5010 :     MemSet(nulls, false, sizeof(nulls));</span>
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indexrelid - 1] = ObjectIdGetDatum(indexoid);</span>
<span class="lineNum">     604 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indrelid - 1] = ObjectIdGetDatum(heapoid);</span>
<span class="lineNum">     605 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indnatts - 1] = Int16GetDatum(indexInfo-&gt;ii_NumIndexAttrs);</span>
<span class="lineNum">     606 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indnkeyatts - 1] = Int16GetDatum(indexInfo-&gt;ii_NumIndexKeyAttrs);</span>
<span class="lineNum">     607 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indisunique - 1] = BoolGetDatum(indexInfo-&gt;ii_Unique);</span>
<span class="lineNum">     608 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indisprimary - 1] = BoolGetDatum(primary);</span>
<span class="lineNum">     609 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indisexclusion - 1] = BoolGetDatum(isexclusion);</span>
<span class="lineNum">     610 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indimmediate - 1] = BoolGetDatum(immediate);</span>
<span class="lineNum">     611 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indisclustered - 1] = BoolGetDatum(false);</span>
<span class="lineNum">     612 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indisvalid - 1] = BoolGetDatum(isvalid);</span>
<span class="lineNum">     613 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indcheckxmin - 1] = BoolGetDatum(false);</span>
<span class="lineNum">     614 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indisready - 1] = BoolGetDatum(isready);</span>
<span class="lineNum">     615 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indislive - 1] = BoolGetDatum(true);</span>
<span class="lineNum">     616 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indisreplident - 1] = BoolGetDatum(false);</span>
<span class="lineNum">     617 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indkey - 1] = PointerGetDatum(indkey);</span>
<span class="lineNum">     618 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indcollation - 1] = PointerGetDatum(indcollation);</span>
<span class="lineNum">     619 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indclass - 1] = PointerGetDatum(indclass);</span>
<span class="lineNum">     620 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indoption - 1] = PointerGetDatum(indoption);</span>
<span class="lineNum">     621 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indexprs - 1] = exprsDatum;</span>
<span class="lineNum">     622 </span><span class="lineCov">       5010 :     if (exprsDatum == (Datum) 0)</span>
<span class="lineNum">     623 </span><span class="lineCov">       4846 :         nulls[Anum_pg_index_indexprs - 1] = true;</span>
<span class="lineNum">     624 </span><span class="lineCov">       5010 :     values[Anum_pg_index_indpred - 1] = predDatum;</span>
<span class="lineNum">     625 </span><span class="lineCov">       5010 :     if (predDatum == (Datum) 0)</span>
<span class="lineNum">     626 </span><span class="lineCov">       4926 :         nulls[Anum_pg_index_indpred - 1] = true;</span>
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span><span class="lineCov">       5010 :     tuple = heap_form_tuple(RelationGetDescr(pg_index), values, nulls);</span>
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            :     /*
<span class="lineNum">     631 </span>            :      * insert the tuple into the pg_index catalog
<span class="lineNum">     632 </span>            :      */
<span class="lineNum">     633 </span><span class="lineCov">       5010 :     CatalogTupleInsert(pg_index, tuple);</span>
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            :     /*
<span class="lineNum">     636 </span>            :      * close the relation and free the tuple
<span class="lineNum">     637 </span>            :      */
<span class="lineNum">     638 </span><span class="lineCov">       5010 :     table_close(pg_index, RowExclusiveLock);</span>
<span class="lineNum">     639 </span><span class="lineCov">       5010 :     heap_freetuple(tuple);</span>
<span class="lineNum">     640 </span><span class="lineCov">       5010 : }</span>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            : /*
<span class="lineNum">     644 </span>            :  * index_create
<span class="lineNum">     645 </span>            :  *
<span class="lineNum">     646 </span>            :  * heapRelation: table to build index on (suitably locked by caller)
<span class="lineNum">     647 </span>            :  * indexRelationName: what it say
<span class="lineNum">     648 </span>            :  * indexRelationId: normally, pass InvalidOid to let this routine
<span class="lineNum">     649 </span>            :  *      generate an OID for the index.  During bootstrap this may be
<span class="lineNum">     650 </span>            :  *      nonzero to specify a preselected OID.
<span class="lineNum">     651 </span>            :  * parentIndexRelid: if creating an index partition, the OID of the
<span class="lineNum">     652 </span>            :  *      parent index; otherwise InvalidOid.
<span class="lineNum">     653 </span>            :  * parentConstraintId: if creating a constraint on a partition, the OID
<span class="lineNum">     654 </span>            :  *      of the constraint in the parent; otherwise InvalidOid.
<span class="lineNum">     655 </span>            :  * relFileNode: normally, pass InvalidOid to get new storage.  May be
<span class="lineNum">     656 </span>            :  *      nonzero to attach an existing valid build.
<span class="lineNum">     657 </span>            :  * indexInfo: same info executor uses to insert into the index
<span class="lineNum">     658 </span>            :  * indexColNames: column names to use for index (List of char *)
<span class="lineNum">     659 </span>            :  * accessMethodObjectId: OID of index AM to use
<span class="lineNum">     660 </span>            :  * tableSpaceId: OID of tablespace to use
<span class="lineNum">     661 </span>            :  * collationObjectId: array of collation OIDs, one per index column
<span class="lineNum">     662 </span>            :  * classObjectId: array of index opclass OIDs, one per index column
<span class="lineNum">     663 </span>            :  * coloptions: array of per-index-column indoption settings
<span class="lineNum">     664 </span>            :  * reloptions: AM-specific options
<span class="lineNum">     665 </span>            :  * flags: bitmask that can include any combination of these bits:
<span class="lineNum">     666 </span>            :  *      INDEX_CREATE_IS_PRIMARY
<span class="lineNum">     667 </span>            :  *          the index is a primary key
<span class="lineNum">     668 </span>            :  *      INDEX_CREATE_ADD_CONSTRAINT:
<span class="lineNum">     669 </span>            :  *          invoke index_constraint_create also
<span class="lineNum">     670 </span>            :  *      INDEX_CREATE_SKIP_BUILD:
<span class="lineNum">     671 </span>            :  *          skip the index_build() step for the moment; caller must do it
<span class="lineNum">     672 </span>            :  *          later (typically via reindex_index())
<span class="lineNum">     673 </span>            :  *      INDEX_CREATE_CONCURRENT:
<span class="lineNum">     674 </span>            :  *          do not lock the table against writers.  The index will be
<span class="lineNum">     675 </span>            :  *          marked &quot;invalid&quot; and the caller must take additional steps
<span class="lineNum">     676 </span>            :  *          to fix it up.
<span class="lineNum">     677 </span>            :  *      INDEX_CREATE_IF_NOT_EXISTS:
<span class="lineNum">     678 </span>            :  *          do not throw an error if a relation with the same name
<span class="lineNum">     679 </span>            :  *          already exists.
<span class="lineNum">     680 </span>            :  *      INDEX_CREATE_PARTITIONED:
<span class="lineNum">     681 </span>            :  *          create a partitioned index (table must be partitioned)
<span class="lineNum">     682 </span>            :  * constr_flags: flags passed to index_constraint_create
<span class="lineNum">     683 </span>            :  *      (only if INDEX_CREATE_ADD_CONSTRAINT is set)
<span class="lineNum">     684 </span>            :  * allow_system_table_mods: allow table to be a system catalog
<span class="lineNum">     685 </span>            :  * is_internal: if true, post creation hook for new index
<span class="lineNum">     686 </span>            :  * constraintId: if not NULL, receives OID of created constraint
<span class="lineNum">     687 </span>            :  *
<span class="lineNum">     688 </span>            :  * Returns the OID of the created index.
<a name="689"><span class="lineNum">     689 </span>            :  */</a>
<span class="lineNum">     690 </span>            : Oid
<span class="lineNum">     691 </span><span class="lineCov">       5020 : index_create(Relation heapRelation,</span>
<span class="lineNum">     692 </span>            :              const char *indexRelationName,
<span class="lineNum">     693 </span>            :              Oid indexRelationId,
<span class="lineNum">     694 </span>            :              Oid parentIndexRelid,
<span class="lineNum">     695 </span>            :              Oid parentConstraintId,
<span class="lineNum">     696 </span>            :              Oid relFileNode,
<span class="lineNum">     697 </span>            :              IndexInfo *indexInfo,
<span class="lineNum">     698 </span>            :              List *indexColNames,
<span class="lineNum">     699 </span>            :              Oid accessMethodObjectId,
<span class="lineNum">     700 </span>            :              Oid tableSpaceId,
<span class="lineNum">     701 </span>            :              Oid *collationObjectId,
<span class="lineNum">     702 </span>            :              Oid *classObjectId,
<span class="lineNum">     703 </span>            :              int16 *coloptions,
<span class="lineNum">     704 </span>            :              Datum reloptions,
<span class="lineNum">     705 </span>            :              bits16 flags,
<span class="lineNum">     706 </span>            :              bits16 constr_flags,
<span class="lineNum">     707 </span>            :              bool allow_system_table_mods,
<span class="lineNum">     708 </span>            :              bool is_internal,
<span class="lineNum">     709 </span>            :              Oid *constraintId)
<span class="lineNum">     710 </span>            : {
<span class="lineNum">     711 </span><span class="lineCov">       5020 :     Oid         heapRelationId = RelationGetRelid(heapRelation);</span>
<span class="lineNum">     712 </span>            :     Relation    pg_class;
<span class="lineNum">     713 </span>            :     Relation    indexRelation;
<span class="lineNum">     714 </span>            :     TupleDesc   indexTupDesc;
<span class="lineNum">     715 </span>            :     bool        shared_relation;
<span class="lineNum">     716 </span>            :     bool        mapped_relation;
<span class="lineNum">     717 </span>            :     bool        is_exclusion;
<span class="lineNum">     718 </span>            :     Oid         namespaceId;
<span class="lineNum">     719 </span>            :     int         i;
<span class="lineNum">     720 </span>            :     char        relpersistence;
<span class="lineNum">     721 </span><span class="lineCov">       5020 :     bool        isprimary = (flags &amp; INDEX_CREATE_IS_PRIMARY) != 0;</span>
<span class="lineNum">     722 </span><span class="lineCov">       5020 :     bool        invalid = (flags &amp; INDEX_CREATE_INVALID) != 0;</span>
<span class="lineNum">     723 </span><span class="lineCov">       5020 :     bool        concurrent = (flags &amp; INDEX_CREATE_CONCURRENT) != 0;</span>
<span class="lineNum">     724 </span><span class="lineCov">       5020 :     bool        partitioned = (flags &amp; INDEX_CREATE_PARTITIONED) != 0;</span>
<span class="lineNum">     725 </span>            :     char        relkind;
<span class="lineNum">     726 </span>            :     TransactionId relfrozenxid;
<span class="lineNum">     727 </span>            :     MultiXactId relminmxid;
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            :     /* constraint flags can only be set when a constraint is requested */
<span class="lineNum">     730 </span><span class="lineCov">       5020 :     Assert((constr_flags == 0) ||</span>
<span class="lineNum">     731 </span>            :            ((flags &amp; INDEX_CREATE_ADD_CONSTRAINT) != 0));
<span class="lineNum">     732 </span>            :     /* partitioned indexes must never be &quot;built&quot; by themselves */
<span class="lineNum">     733 </span><span class="lineCov">       5020 :     Assert(!partitioned || (flags &amp; INDEX_CREATE_SKIP_BUILD));</span>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span><span class="lineCov">       5020 :     relkind = partitioned ? RELKIND_PARTITIONED_INDEX : RELKIND_INDEX;</span>
<span class="lineNum">     736 </span><span class="lineCov">       5020 :     is_exclusion = (indexInfo-&gt;ii_ExclusionOps != NULL);</span>
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span><span class="lineCov">       5020 :     pg_class = table_open(RelationRelationId, RowExclusiveLock);</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            :     /*
<span class="lineNum">     741 </span>            :      * The index will be in the same namespace as its parent table, and is
<span class="lineNum">     742 </span>            :      * shared across databases if and only if the parent is.  Likewise, it
<span class="lineNum">     743 </span>            :      * will use the relfilenode map if and only if the parent does; and it
<span class="lineNum">     744 </span>            :      * inherits the parent's relpersistence.
<span class="lineNum">     745 </span>            :      */
<span class="lineNum">     746 </span><span class="lineCov">       5020 :     namespaceId = RelationGetNamespace(heapRelation);</span>
<span class="lineNum">     747 </span><span class="lineCov">       5020 :     shared_relation = heapRelation-&gt;rd_rel-&gt;relisshared;</span>
<span class="lineNum">     748 </span><span class="lineCov">       5020 :     mapped_relation = RelationIsMapped(heapRelation);</span>
<span class="lineNum">     749 </span><span class="lineCov">       5020 :     relpersistence = heapRelation-&gt;rd_rel-&gt;relpersistence;</span>
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            :     /*
<span class="lineNum">     752 </span>            :      * check parameters
<span class="lineNum">     753 </span>            :      */
<span class="lineNum">     754 </span><span class="lineCov">       5020 :     if (indexInfo-&gt;ii_NumIndexAttrs &lt; 1)</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;must index at least one column&quot;);</span>
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span><span class="lineCov">       7562 :     if (!allow_system_table_mods &amp;&amp;</span>
<span class="lineNum">     758 </span><span class="lineCov">       2776 :         IsSystemRelation(heapRelation) &amp;&amp;</span>
<span class="lineNum">     759 </span><span class="lineCov">        234 :         IsNormalProcessingMode())</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">     761 </span>            :                 (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">     762 </span>            :                  errmsg(&quot;user-defined indexes on system catalog tables are not supported&quot;)));
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :     /*
<span class="lineNum">     765 </span>            :      * Btree text_pattern_ops uses text_eq as the equality operator, which is
<span class="lineNum">     766 </span>            :      * fine as long as the collation is deterministic; text_eq then reduces to
<span class="lineNum">     767 </span>            :      * bitwise equality and so it is semantically compatible with the other
<span class="lineNum">     768 </span>            :      * operators and functions in that opclass.  But with a nondeterministic
<span class="lineNum">     769 </span>            :      * collation, text_eq could yield results that are incompatible with the
<span class="lineNum">     770 </span>            :      * actual behavior of the index (which is determined by the opclass's
<span class="lineNum">     771 </span>            :      * comparison function).  We prevent such problems by refusing creation of
<span class="lineNum">     772 </span>            :      * an index with that opclass and a nondeterministic collation.
<span class="lineNum">     773 </span>            :      *
<span class="lineNum">     774 </span>            :      * The same applies to varchar_pattern_ops and bpchar_pattern_ops.  If we
<span class="lineNum">     775 </span>            :      * find more cases, we might decide to create a real mechanism for marking
<span class="lineNum">     776 </span>            :      * opclasses as incompatible with nondeterminism; but for now, this small
<span class="lineNum">     777 </span>            :      * hack suffices.
<span class="lineNum">     778 </span>            :      *
<span class="lineNum">     779 </span>            :      * Another solution is to use a special operator, not text_eq, as the
<span class="lineNum">     780 </span>            :      * equality opclass member; but that is undesirable because it would
<span class="lineNum">     781 </span>            :      * prevent index usage in many queries that work fine today.
<span class="lineNum">     782 </span>            :      */
<span class="lineNum">     783 </span><span class="lineCov">      13240 :     for (i = 0; i &lt; indexInfo-&gt;ii_NumIndexKeyAttrs; i++)</span>
<span class="lineNum">     784 </span>            :     {
<span class="lineNum">     785 </span><span class="lineCov">       8220 :         Oid         collation = collationObjectId[i];</span>
<span class="lineNum">     786 </span><span class="lineCov">       8220 :         Oid         opclass = classObjectId[i];</span>
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span><span class="lineCov">       8220 :         if (collation)</span>
<span class="lineNum">     789 </span>            :         {
<span class="lineNum">     790 </span><span class="lineCov">        476 :             if ((opclass == TEXT_BTREE_PATTERN_OPS_OID ||</span>
<span class="lineNum">     791 </span><span class="lineCov">        454 :                  opclass == VARCHAR_BTREE_PATTERN_OPS_OID ||</span>
<span class="lineNum">     792 </span><span class="lineCov">         24 :                  opclass == BPCHAR_BTREE_PATTERN_OPS_OID) &amp;&amp;</span>
<span class="lineNum">     793 </span><span class="lineCov">         24 :                 !get_collation_isdeterministic(collation))</span>
<span class="lineNum">     794 </span>            :             {
<span class="lineNum">     795 </span>            :                 HeapTuple   classtup;
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :                 classtup = SearchSysCache1(CLAOID, ObjectIdGetDatum(opclass));</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :                 if (!HeapTupleIsValid(classtup))</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :                     elog(ERROR, &quot;cache lookup failed for operator class %u&quot;, opclass);</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :                 ereport(ERROR,</span>
<span class="lineNum">     801 </span>            :                         (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">     802 </span>            :                          errmsg(&quot;nondeterministic collations are not supported for operator class \&quot;%s\&quot;&quot;,
<span class="lineNum">     803 </span>            :                                 NameStr(((Form_pg_opclass) GETSTRUCT(classtup))-&gt;opcname))));
<span class="lineNum">     804 </span>            :                 ReleaseSysCache(classtup);
<span class="lineNum">     805 </span>            :             }
<span class="lineNum">     806 </span>            :         }
<span class="lineNum">     807 </span>            :     }
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :     /*
<span class="lineNum">     810 </span>            :      * Concurrent index build on a system catalog is unsafe because we tend to
<span class="lineNum">     811 </span>            :      * release locks before committing in catalogs.
<span class="lineNum">     812 </span>            :      */
<span class="lineNum">     813 </span><span class="lineCov">       5088 :     if (concurrent &amp;&amp;</span>
<span class="lineNum">     814 </span><span class="lineCov">         68 :         IsCatalogRelation(heapRelation))</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">     816 </span>            :                 (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">     817 </span>            :                  errmsg(&quot;concurrent index creation on system catalog tables is not supported&quot;)));
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            :     /*
<span class="lineNum">     820 </span>            :      * This case is currently not supported.  There's no way to ask for it in
<span class="lineNum">     821 </span>            :      * the grammar with CREATE INDEX, but it can happen with REINDEX.
<span class="lineNum">     822 </span>            :      */
<span class="lineNum">     823 </span><span class="lineCov">       5020 :     if (concurrent &amp;&amp; is_exclusion)</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">     825 </span>            :                 (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">     826 </span>            :                  errmsg(&quot;concurrent index creation for exclusion constraints is not supported&quot;)));
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            :     /*
<span class="lineNum">     829 </span>            :      * We cannot allow indexing a shared relation after initdb (because
<span class="lineNum">     830 </span>            :      * there's no way to make the entry in other databases' pg_class).
<span class="lineNum">     831 </span>            :      */
<span class="lineNum">     832 </span><span class="lineCov">       5020 :     if (shared_relation &amp;&amp; !IsBootstrapProcessingMode())</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">     834 </span>            :                 (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),
<span class="lineNum">     835 </span>            :                  errmsg(&quot;shared indexes cannot be created after initdb&quot;)));
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span>            :     /*
<span class="lineNum">     838 </span>            :      * Shared relations must be in pg_global, too (last-ditch check)
<span class="lineNum">     839 </span>            :      */
<span class="lineNum">     840 </span><span class="lineCov">       5020 :     if (shared_relation &amp;&amp; tableSpaceId != GLOBALTABLESPACE_OID)</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;shared relations must be placed in pg_global tablespace&quot;);</span>
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            :     /*
<span class="lineNum">     844 </span>            :      * Check for duplicate name (both as to the index, and as to the
<span class="lineNum">     845 </span>            :      * associated constraint if any).  Such cases would fail on the relevant
<span class="lineNum">     846 </span>            :      * catalogs' unique indexes anyway, but we prefer to give a friendlier
<span class="lineNum">     847 </span>            :      * error message.
<span class="lineNum">     848 </span>            :      */
<span class="lineNum">     849 </span><span class="lineCov">       5020 :     if (get_relname_relid(indexRelationName, namespaceId))</span>
<span class="lineNum">     850 </span>            :     {
<span class="lineNum">     851 </span><span class="lineCov">          8 :         if ((flags &amp; INDEX_CREATE_IF_NOT_EXISTS) != 0)</span>
<span class="lineNum">     852 </span>            :         {
<span class="lineNum">     853 </span><span class="lineCov">          6 :             ereport(NOTICE,</span>
<span class="lineNum">     854 </span>            :                     (errcode(ERRCODE_DUPLICATE_TABLE),
<span class="lineNum">     855 </span>            :                      errmsg(&quot;relation \&quot;%s\&quot; already exists, skipping&quot;,
<span class="lineNum">     856 </span>            :                             indexRelationName)));
<span class="lineNum">     857 </span><span class="lineCov">          6 :             table_close(pg_class, RowExclusiveLock);</span>
<span class="lineNum">     858 </span><span class="lineCov">          6 :             return InvalidOid;</span>
<span class="lineNum">     859 </span>            :         }
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span><span class="lineCov">          2 :         ereport(ERROR,</span>
<span class="lineNum">     862 </span>            :                 (errcode(ERRCODE_DUPLICATE_TABLE),
<span class="lineNum">     863 </span>            :                  errmsg(&quot;relation \&quot;%s\&quot; already exists&quot;,
<span class="lineNum">     864 </span>            :                         indexRelationName)));
<span class="lineNum">     865 </span>            :     }
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span><span class="lineCov">       6112 :     if ((flags &amp; INDEX_CREATE_ADD_CONSTRAINT) != 0 &amp;&amp;</span>
<span class="lineNum">     868 </span><span class="lineCov">       1100 :         ConstraintNameIsUsed(CONSTRAINT_RELATION, heapRelationId,</span>
<span class="lineNum">     869 </span>            :                              indexRelationName))
<span class="lineNum">     870 </span>            :     {
<span class="lineNum">     871 </span>            :         /*
<span class="lineNum">     872 </span>            :          * INDEX_CREATE_IF_NOT_EXISTS does not apply here, since the
<span class="lineNum">     873 </span>            :          * conflicting constraint is not an index.
<span class="lineNum">     874 </span>            :          */
<span class="lineNum">     875 </span><span class="lineCov">          2 :         ereport(ERROR,</span>
<span class="lineNum">     876 </span>            :                 (errcode(ERRCODE_DUPLICATE_OBJECT),
<span class="lineNum">     877 </span>            :                  errmsg(&quot;constraint \&quot;%s\&quot; for relation \&quot;%s\&quot; already exists&quot;,
<span class="lineNum">     878 </span>            :                         indexRelationName, RelationGetRelationName(heapRelation))));
<span class="lineNum">     879 </span>            :     }
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span>            :     /*
<span class="lineNum">     882 </span>            :      * construct tuple descriptor for index tuples
<span class="lineNum">     883 </span>            :      */
<span class="lineNum">     884 </span><span class="lineCov">       5010 :     indexTupDesc = ConstructTupleDescriptor(heapRelation,</span>
<span class="lineNum">     885 </span>            :                                             indexInfo,
<span class="lineNum">     886 </span>            :                                             indexColNames,
<span class="lineNum">     887 </span>            :                                             accessMethodObjectId,
<span class="lineNum">     888 </span>            :                                             collationObjectId,
<span class="lineNum">     889 </span>            :                                             classObjectId);
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span>            :     /*
<span class="lineNum">     892 </span>            :      * Allocate an OID for the index, unless we were told what to use.
<span class="lineNum">     893 </span>            :      *
<span class="lineNum">     894 </span>            :      * The OID will be the relfilenode as well, so make sure it doesn't
<span class="lineNum">     895 </span>            :      * collide with either pg_class OIDs or existing physical files.
<span class="lineNum">     896 </span>            :      */
<span class="lineNum">     897 </span><span class="lineCov">       5010 :     if (!OidIsValid(indexRelationId))</span>
<span class="lineNum">     898 </span>            :     {
<span class="lineNum">     899 </span>            :         /* Use binary-upgrade override for pg_class.oid/relfilenode? */
<span class="lineNum">     900 </span><span class="lineCov">       4706 :         if (IsBinaryUpgrade)</span>
<span class="lineNum">     901 </span>            :         {
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :             if (!OidIsValid(binary_upgrade_next_index_pg_class_oid))</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :                 ereport(ERROR,</span>
<span class="lineNum">     904 </span>            :                         (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
<span class="lineNum">     905 </span>            :                          errmsg(&quot;pg_class index OID value not set when in binary upgrade mode&quot;)));
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :             indexRelationId = binary_upgrade_next_index_pg_class_oid;</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :             binary_upgrade_next_index_pg_class_oid = InvalidOid;</span>
<span class="lineNum">     909 </span>            :         }
<span class="lineNum">     910 </span>            :         else
<span class="lineNum">     911 </span>            :         {
<span class="lineNum">     912 </span><span class="lineCov">       4706 :             indexRelationId =</span>
<span class="lineNum">     913 </span><span class="lineCov">       4706 :                 GetNewRelFileNode(tableSpaceId, pg_class, relpersistence);</span>
<span class="lineNum">     914 </span>            :         }
<span class="lineNum">     915 </span>            :     }
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            :     /*
<span class="lineNum">     918 </span>            :      * create the index relation's relcache entry and, if necessary, the
<span class="lineNum">     919 </span>            :      * physical disk file. (If we fail further down, it's the smgr's
<span class="lineNum">     920 </span>            :      * responsibility to remove the disk file again, if any.)
<span class="lineNum">     921 </span>            :      */
<span class="lineNum">     922 </span><span class="lineCov">       5010 :     indexRelation = heap_create(indexRelationName,</span>
<span class="lineNum">     923 </span>            :                                 namespaceId,
<span class="lineNum">     924 </span>            :                                 tableSpaceId,
<span class="lineNum">     925 </span>            :                                 indexRelationId,
<span class="lineNum">     926 </span>            :                                 relFileNode,
<span class="lineNum">     927 </span>            :                                 accessMethodObjectId,
<span class="lineNum">     928 </span>            :                                 indexTupDesc,
<span class="lineNum">     929 </span>            :                                 relkind,
<span class="lineNum">     930 </span>            :                                 relpersistence,
<span class="lineNum">     931 </span>            :                                 shared_relation,
<span class="lineNum">     932 </span>            :                                 mapped_relation,
<span class="lineNum">     933 </span>            :                                 allow_system_table_mods,
<span class="lineNum">     934 </span>            :                                 &amp;relfrozenxid,
<span class="lineNum">     935 </span>            :                                 &amp;relminmxid);
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span><span class="lineCov">       5010 :     Assert(relfrozenxid == InvalidTransactionId);</span>
<span class="lineNum">     938 </span><span class="lineCov">       5010 :     Assert(relminmxid == InvalidMultiXactId);</span>
<span class="lineNum">     939 </span><span class="lineCov">       5010 :     Assert(indexRelationId == RelationGetRelid(indexRelation));</span>
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            :     /*
<span class="lineNum">     942 </span>            :      * Obtain exclusive lock on it.  Although no other transactions can see it
<span class="lineNum">     943 </span>            :      * until we commit, this prevents deadlock-risk complaints from lock
<span class="lineNum">     944 </span>            :      * manager in cases such as CLUSTER.
<span class="lineNum">     945 </span>            :      */
<span class="lineNum">     946 </span><span class="lineCov">       5010 :     LockRelation(indexRelation, AccessExclusiveLock);</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span>            :     /*
<span class="lineNum">     949 </span>            :      * Fill in fields of the index's pg_class entry that are not set correctly
<span class="lineNum">     950 </span>            :      * by heap_create.
<span class="lineNum">     951 </span>            :      *
<span class="lineNum">     952 </span>            :      * XXX should have a cleaner way to create cataloged indexes
<span class="lineNum">     953 </span>            :      */
<span class="lineNum">     954 </span><span class="lineCov">       5010 :     indexRelation-&gt;rd_rel-&gt;relowner = heapRelation-&gt;rd_rel-&gt;relowner;</span>
<span class="lineNum">     955 </span><span class="lineCov">       5010 :     indexRelation-&gt;rd_rel-&gt;relam = accessMethodObjectId;</span>
<span class="lineNum">     956 </span><span class="lineCov">       5010 :     indexRelation-&gt;rd_rel-&gt;relispartition = OidIsValid(parentIndexRelid);</span>
<span class="lineNum">     957 </span><span class="lineCov">       5010 :     indexRelation-&gt;rd_rel-&gt;relisivm = false;</span>
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            :     /*
<span class="lineNum">     960 </span>            :      * store index's pg_class entry
<span class="lineNum">     961 </span>            :      */
<span class="lineNum">     962 </span><span class="lineCov">       5010 :     InsertPgClassTuple(pg_class, indexRelation,</span>
<span class="lineNum">     963 </span>            :                        RelationGetRelid(indexRelation),
<span class="lineNum">     964 </span>            :                        (Datum) 0,
<span class="lineNum">     965 </span>            :                        reloptions);
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            :     /* done with pg_class */
<span class="lineNum">     968 </span><span class="lineCov">       5010 :     table_close(pg_class, RowExclusiveLock);</span>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span>            :     /*
<span class="lineNum">     971 </span>            :      * now update the object id's of all the attribute tuple forms in the
<span class="lineNum">     972 </span>            :      * index relation's tuple descriptor
<span class="lineNum">     973 </span>            :      */
<span class="lineNum">     974 </span><span class="lineCov">       5010 :     InitializeAttributeOids(indexRelation,</span>
<span class="lineNum">     975 </span>            :                             indexInfo-&gt;ii_NumIndexAttrs,
<span class="lineNum">     976 </span>            :                             indexRelationId);
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            :     /*
<span class="lineNum">     979 </span>            :      * append ATTRIBUTE tuples for the index
<span class="lineNum">     980 </span>            :      */
<span class="lineNum">     981 </span><span class="lineCov">       5010 :     AppendAttributeTuples(indexRelation, indexInfo-&gt;ii_NumIndexAttrs);</span>
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span>            :     /* ----------------
<span class="lineNum">     984 </span>            :      *    update pg_index
<span class="lineNum">     985 </span>            :      *    (append INDEX tuple)
<span class="lineNum">     986 </span>            :      *
<span class="lineNum">     987 </span>            :      *    Note that this stows away a representation of &quot;predicate&quot;.
<span class="lineNum">     988 </span>            :      *    (Or, could define a rule to maintain the predicate) --Nels, Feb '92
<span class="lineNum">     989 </span>            :      * ----------------
<span class="lineNum">     990 </span>            :      */
<span class="lineNum">     991 </span><span class="lineCov">      15030 :     UpdateIndexRelation(indexRelationId, heapRelationId, parentIndexRelid,</span>
<span class="lineNum">     992 </span>            :                         indexInfo,
<span class="lineNum">     993 </span>            :                         collationObjectId, classObjectId, coloptions,
<span class="lineNum">     994 </span>            :                         isprimary, is_exclusion,
<span class="lineNum">     995 </span><span class="lineCov">       5010 :                         (constr_flags &amp; INDEX_CONSTR_CREATE_DEFERRABLE) == 0,</span>
<span class="lineNum">     996 </span><span class="lineCov">       5010 :                         !concurrent &amp;&amp; !invalid,</span>
<span class="lineNum">     997 </span><span class="lineCov">       5010 :                         !concurrent);</span>
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span>            :     /*
<span class="lineNum">    1000 </span>            :      * Register relcache invalidation on the indexes' heap relation, to
<span class="lineNum">    1001 </span>            :      * maintain consistency of its index list
<span class="lineNum">    1002 </span>            :      */
<span class="lineNum">    1003 </span><span class="lineCov">       5010 :     CacheInvalidateRelcache(heapRelation);</span>
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span>            :     /* update pg_inherits and the parent's relhassubclass, if needed */
<span class="lineNum">    1006 </span><span class="lineCov">       5010 :     if (OidIsValid(parentIndexRelid))</span>
<span class="lineNum">    1007 </span>            :     {
<span class="lineNum">    1008 </span><span class="lineCov">        376 :         StoreSingleInheritance(indexRelationId, parentIndexRelid, 1);</span>
<span class="lineNum">    1009 </span><span class="lineCov">        376 :         SetRelationHasSubclass(parentIndexRelid, true);</span>
<span class="lineNum">    1010 </span>            :     }
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span>            :     /*
<span class="lineNum">    1013 </span>            :      * Register constraint and dependencies for the index.
<span class="lineNum">    1014 </span>            :      *
<span class="lineNum">    1015 </span>            :      * If the index is from a CONSTRAINT clause, construct a pg_constraint
<span class="lineNum">    1016 </span>            :      * entry.  The index will be linked to the constraint, which in turn is
<span class="lineNum">    1017 </span>            :      * linked to the table.  If it's not a CONSTRAINT, we need to make a
<span class="lineNum">    1018 </span>            :      * dependency directly on the table.
<span class="lineNum">    1019 </span>            :      *
<span class="lineNum">    1020 </span>            :      * We don't need a dependency on the namespace, because there'll be an
<span class="lineNum">    1021 </span>            :      * indirect dependency via our parent table.
<span class="lineNum">    1022 </span>            :      *
<span class="lineNum">    1023 </span>            :      * During bootstrap we can't register any dependencies, and we don't try
<span class="lineNum">    1024 </span>            :      * to make a constraint either.
<span class="lineNum">    1025 </span>            :      */
<span class="lineNum">    1026 </span><span class="lineCov">       5010 :     if (!IsBootstrapProcessingMode())</span>
<span class="lineNum">    1027 </span>            :     {
<span class="lineNum">    1028 </span>            :         ObjectAddress myself,
<span class="lineNum">    1029 </span>            :                     referenced;
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span><span class="lineCov">       4706 :         myself.classId = RelationRelationId;</span>
<span class="lineNum">    1032 </span><span class="lineCov">       4706 :         myself.objectId = indexRelationId;</span>
<span class="lineNum">    1033 </span><span class="lineCov">       4706 :         myself.objectSubId = 0;</span>
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span><span class="lineCov">       4706 :         if ((flags &amp; INDEX_CREATE_ADD_CONSTRAINT) != 0)</span>
<span class="lineNum">    1036 </span>            :         {
<span class="lineNum">    1037 </span>            :             char        constraintType;
<span class="lineNum">    1038 </span>            :             ObjectAddress localaddr;
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span><span class="lineCov">       1098 :             if (isprimary)</span>
<span class="lineNum">    1041 </span><span class="lineCov">        846 :                 constraintType = CONSTRAINT_PRIMARY;</span>
<span class="lineNum">    1042 </span><span class="lineCov">        252 :             else if (indexInfo-&gt;ii_Unique)</span>
<span class="lineNum">    1043 </span><span class="lineCov">        216 :                 constraintType = CONSTRAINT_UNIQUE;</span>
<span class="lineNum">    1044 </span><span class="lineCov">         36 :             else if (is_exclusion)</span>
<span class="lineNum">    1045 </span><span class="lineCov">         36 :                 constraintType = CONSTRAINT_EXCLUSION;</span>
<span class="lineNum">    1046 </span>            :             else
<span class="lineNum">    1047 </span>            :             {
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :                 elog(ERROR, &quot;constraint must be PRIMARY, UNIQUE or EXCLUDE&quot;);</span>
<span class="lineNum">    1049 </span>            :                 constraintType = 0; /* keep compiler quiet */
<span class="lineNum">    1050 </span>            :             }
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span><span class="lineCov">       1098 :             localaddr = index_constraint_create(heapRelation,</span>
<span class="lineNum">    1053 </span>            :                                                 indexRelationId,
<span class="lineNum">    1054 </span>            :                                                 parentConstraintId,
<span class="lineNum">    1055 </span>            :                                                 indexInfo,
<span class="lineNum">    1056 </span>            :                                                 indexRelationName,
<span class="lineNum">    1057 </span>            :                                                 constraintType,
<span class="lineNum">    1058 </span>            :                                                 constr_flags,
<span class="lineNum">    1059 </span>            :                                                 allow_system_table_mods,
<span class="lineNum">    1060 </span>            :                                                 is_internal);
<span class="lineNum">    1061 </span><span class="lineCov">       1098 :             if (constraintId)</span>
<span class="lineNum">    1062 </span><span class="lineCov">       1098 :                 *constraintId = localaddr.objectId;</span>
<span class="lineNum">    1063 </span>            :         }
<span class="lineNum">    1064 </span>            :         else
<span class="lineNum">    1065 </span>            :         {
<span class="lineNum">    1066 </span><span class="lineCov">       3608 :             bool        have_simple_col = false;</span>
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span>            :             /* Create auto dependencies on simply-referenced columns */
<span class="lineNum">    1069 </span><span class="lineCov">      10052 :             for (i = 0; i &lt; indexInfo-&gt;ii_NumIndexAttrs; i++)</span>
<span class="lineNum">    1070 </span>            :             {
<span class="lineNum">    1071 </span><span class="lineCov">       6444 :                 if (indexInfo-&gt;ii_IndexAttrNumbers[i] != 0)</span>
<span class="lineNum">    1072 </span>            :                 {
<span class="lineNum">    1073 </span><span class="lineCov">       6280 :                     referenced.classId = RelationRelationId;</span>
<span class="lineNum">    1074 </span><span class="lineCov">       6280 :                     referenced.objectId = heapRelationId;</span>
<span class="lineNum">    1075 </span><span class="lineCov">       6280 :                     referenced.objectSubId = indexInfo-&gt;ii_IndexAttrNumbers[i];</span>
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span><span class="lineCov">       6280 :                     recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_AUTO);</span>
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span><span class="lineCov">       6280 :                     have_simple_col = true;</span>
<span class="lineNum">    1080 </span>            :                 }
<span class="lineNum">    1081 </span>            :             }
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span>            :             /*
<span class="lineNum">    1084 </span>            :              * If there are no simply-referenced columns, give the index an
<span class="lineNum">    1085 </span>            :              * auto dependency on the whole table.  In most cases, this will
<span class="lineNum">    1086 </span>            :              * be redundant, but it might not be if the index expressions and
<span class="lineNum">    1087 </span>            :              * predicate contain no Vars or only whole-row Vars.
<span class="lineNum">    1088 </span>            :              */
<span class="lineNum">    1089 </span><span class="lineCov">       3608 :             if (!have_simple_col)</span>
<span class="lineNum">    1090 </span>            :             {
<span class="lineNum">    1091 </span><span class="lineCov">        112 :                 referenced.classId = RelationRelationId;</span>
<span class="lineNum">    1092 </span><span class="lineCov">        112 :                 referenced.objectId = heapRelationId;</span>
<span class="lineNum">    1093 </span><span class="lineCov">        112 :                 referenced.objectSubId = 0;</span>
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span><span class="lineCov">        112 :                 recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_AUTO);</span>
<span class="lineNum">    1096 </span>            :             }
<span class="lineNum">    1097 </span>            :         }
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            :         /*
<span class="lineNum">    1100 </span>            :          * If this is an index partition, create partition dependencies on
<span class="lineNum">    1101 </span>            :          * both the parent index and the table.  (Note: these must be *in
<span class="lineNum">    1102 </span>            :          * addition to*, not instead of, all other dependencies.  Otherwise
<span class="lineNum">    1103 </span>            :          * we'll be short some dependencies after DETACH PARTITION.)
<span class="lineNum">    1104 </span>            :          */
<span class="lineNum">    1105 </span><span class="lineCov">       4706 :         if (OidIsValid(parentIndexRelid))</span>
<span class="lineNum">    1106 </span>            :         {
<span class="lineNum">    1107 </span><span class="lineCov">        376 :             referenced.classId = RelationRelationId;</span>
<span class="lineNum">    1108 </span><span class="lineCov">        376 :             referenced.objectId = parentIndexRelid;</span>
<span class="lineNum">    1109 </span><span class="lineCov">        376 :             referenced.objectSubId = 0;</span>
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span><span class="lineCov">        376 :             recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_PARTITION_PRI);</span>
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span><span class="lineCov">        376 :             referenced.classId = RelationRelationId;</span>
<span class="lineNum">    1114 </span><span class="lineCov">        376 :             referenced.objectId = heapRelationId;</span>
<span class="lineNum">    1115 </span><span class="lineCov">        376 :             referenced.objectSubId = 0;</span>
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span><span class="lineCov">        376 :             recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_PARTITION_SEC);</span>
<span class="lineNum">    1118 </span>            :         }
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            :         /* Store dependency on collations */
<span class="lineNum">    1121 </span>            :         /* The default collation is pinned, so don't bother recording it */
<span class="lineNum">    1122 </span><span class="lineCov">      12386 :         for (i = 0; i &lt; indexInfo-&gt;ii_NumIndexKeyAttrs; i++)</span>
<span class="lineNum">    1123 </span>            :         {
<span class="lineNum">    1124 </span><span class="lineCov">       8078 :             if (OidIsValid(collationObjectId[i]) &amp;&amp;</span>
<span class="lineNum">    1125 </span><span class="lineCov">        398 :                 collationObjectId[i] != DEFAULT_COLLATION_OID)</span>
<span class="lineNum">    1126 </span>            :             {
<span class="lineNum">    1127 </span><span class="lineCov">         72 :                 referenced.classId = CollationRelationId;</span>
<span class="lineNum">    1128 </span><span class="lineCov">         72 :                 referenced.objectId = collationObjectId[i];</span>
<span class="lineNum">    1129 </span><span class="lineCov">         72 :                 referenced.objectSubId = 0;</span>
<span class="lineNum">    1130 </span>            : 
<span class="lineNum">    1131 </span><span class="lineCov">         72 :                 recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);</span>
<span class="lineNum">    1132 </span>            :             }
<span class="lineNum">    1133 </span>            :         }
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span>            :         /* Store dependency on operator classes */
<span class="lineNum">    1136 </span><span class="lineCov">      12386 :         for (i = 0; i &lt; indexInfo-&gt;ii_NumIndexKeyAttrs; i++)</span>
<span class="lineNum">    1137 </span>            :         {
<span class="lineNum">    1138 </span><span class="lineCov">       7680 :             referenced.classId = OperatorClassRelationId;</span>
<span class="lineNum">    1139 </span><span class="lineCov">       7680 :             referenced.objectId = classObjectId[i];</span>
<span class="lineNum">    1140 </span><span class="lineCov">       7680 :             referenced.objectSubId = 0;</span>
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span><span class="lineCov">       7680 :             recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);</span>
<span class="lineNum">    1143 </span>            :         }
<span class="lineNum">    1144 </span>            : 
<span class="lineNum">    1145 </span>            :         /* Store dependencies on anything mentioned in index expressions */
<span class="lineNum">    1146 </span><span class="lineCov">       4706 :         if (indexInfo-&gt;ii_Expressions)</span>
<span class="lineNum">    1147 </span>            :         {
<span class="lineNum">    1148 </span><span class="lineCov">        164 :             recordDependencyOnSingleRelExpr(&amp;myself,</span>
<span class="lineNum">    1149 </span><span class="lineCov">        164 :                                             (Node *) indexInfo-&gt;ii_Expressions,</span>
<span class="lineNum">    1150 </span>            :                                             heapRelationId,
<span class="lineNum">    1151 </span>            :                                             DEPENDENCY_NORMAL,
<span class="lineNum">    1152 </span>            :                                             DEPENDENCY_AUTO, false);
<span class="lineNum">    1153 </span>            :         }
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span>            :         /* Store dependencies on anything mentioned in predicate */
<span class="lineNum">    1156 </span><span class="lineCov">       4706 :         if (indexInfo-&gt;ii_Predicate)</span>
<span class="lineNum">    1157 </span>            :         {
<span class="lineNum">    1158 </span><span class="lineCov">         84 :             recordDependencyOnSingleRelExpr(&amp;myself,</span>
<span class="lineNum">    1159 </span><span class="lineCov">         84 :                                             (Node *) indexInfo-&gt;ii_Predicate,</span>
<span class="lineNum">    1160 </span>            :                                             heapRelationId,
<span class="lineNum">    1161 </span>            :                                             DEPENDENCY_NORMAL,
<span class="lineNum">    1162 </span>            :                                             DEPENDENCY_AUTO, false);
<span class="lineNum">    1163 </span>            :         }
<span class="lineNum">    1164 </span>            :     }
<span class="lineNum">    1165 </span>            :     else
<span class="lineNum">    1166 </span>            :     {
<span class="lineNum">    1167 </span>            :         /* Bootstrap mode - assert we weren't asked for constraint support */
<span class="lineNum">    1168 </span><span class="lineCov">        304 :         Assert((flags &amp; INDEX_CREATE_ADD_CONSTRAINT) == 0);</span>
<span class="lineNum">    1169 </span>            :     }
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span>            :     /* Post creation hook for new index */
<span class="lineNum">    1172 </span><span class="lineCov">       5010 :     InvokeObjectPostCreateHookArg(RelationRelationId,</span>
<span class="lineNum">    1173 </span>            :                                   indexRelationId, 0, is_internal);
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span>            :     /*
<span class="lineNum">    1176 </span>            :      * Advance the command counter so that we can see the newly-entered
<span class="lineNum">    1177 </span>            :      * catalog tuples for the index.
<span class="lineNum">    1178 </span>            :      */
<span class="lineNum">    1179 </span><span class="lineCov">       5010 :     CommandCounterIncrement();</span>
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span>            :     /*
<span class="lineNum">    1182 </span>            :      * In bootstrap mode, we have to fill in the index strategy structure with
<span class="lineNum">    1183 </span>            :      * information from the catalogs.  If we aren't bootstrapping, then the
<span class="lineNum">    1184 </span>            :      * relcache entry has already been rebuilt thanks to sinval update during
<span class="lineNum">    1185 </span>            :      * CommandCounterIncrement.
<span class="lineNum">    1186 </span>            :      */
<span class="lineNum">    1187 </span><span class="lineCov">       5010 :     if (IsBootstrapProcessingMode())</span>
<span class="lineNum">    1188 </span><span class="lineCov">        304 :         RelationInitIndexAccessInfo(indexRelation);</span>
<span class="lineNum">    1189 </span>            :     else
<span class="lineNum">    1190 </span><span class="lineCov">       4706 :         Assert(indexRelation-&gt;rd_indexcxt != NULL);</span>
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span><span class="lineCov">       5010 :     indexRelation-&gt;rd_index-&gt;indnkeyatts = indexInfo-&gt;ii_NumIndexKeyAttrs;</span>
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span>            :     /*
<span class="lineNum">    1195 </span>            :      * If this is bootstrap (initdb) time, then we don't actually fill in the
<span class="lineNum">    1196 </span>            :      * index yet.  We'll be creating more indexes and classes later, so we
<span class="lineNum">    1197 </span>            :      * delay filling them in until just before we're done with bootstrapping.
<span class="lineNum">    1198 </span>            :      * Similarly, if the caller specified to skip the build then filling the
<span class="lineNum">    1199 </span>            :      * index is delayed till later (ALTER TABLE can save work in some cases
<span class="lineNum">    1200 </span>            :      * with this).  Otherwise, we call the AM routine that constructs the
<span class="lineNum">    1201 </span>            :      * index.
<span class="lineNum">    1202 </span>            :      */
<span class="lineNum">    1203 </span><span class="lineCov">       5010 :     if (IsBootstrapProcessingMode())</span>
<span class="lineNum">    1204 </span>            :     {
<span class="lineNum">    1205 </span><span class="lineCov">        304 :         index_register(heapRelationId, indexRelationId, indexInfo);</span>
<span class="lineNum">    1206 </span>            :     }
<span class="lineNum">    1207 </span><span class="lineCov">       4706 :     else if ((flags &amp; INDEX_CREATE_SKIP_BUILD) != 0)</span>
<span class="lineNum">    1208 </span>            :     {
<span class="lineNum">    1209 </span>            :         /*
<span class="lineNum">    1210 </span>            :          * Caller is responsible for filling the index later on.  However,
<span class="lineNum">    1211 </span>            :          * we'd better make sure that the heap relation is correctly marked as
<span class="lineNum">    1212 </span>            :          * having an index.
<span class="lineNum">    1213 </span>            :          */
<span class="lineNum">    1214 </span><span class="lineCov">        494 :         index_update_stats(heapRelation,</span>
<span class="lineNum">    1215 </span>            :                            true,
<span class="lineNum">    1216 </span>            :                            -1.0);
<span class="lineNum">    1217 </span>            :         /* Make the above update visible */
<span class="lineNum">    1218 </span><span class="lineCov">        494 :         CommandCounterIncrement();</span>
<span class="lineNum">    1219 </span>            :     }
<span class="lineNum">    1220 </span>            :     else
<span class="lineNum">    1221 </span>            :     {
<span class="lineNum">    1222 </span><span class="lineCov">       4212 :         index_build(heapRelation, indexRelation, indexInfo, false, true);</span>
<span class="lineNum">    1223 </span>            :     }
<span class="lineNum">    1224 </span>            : 
<span class="lineNum">    1225 </span>            :     /*
<span class="lineNum">    1226 </span>            :      * Close the index; but we keep the lock that we acquired above until end
<span class="lineNum">    1227 </span>            :      * of transaction.  Closing the heap is caller's responsibility.
<span class="lineNum">    1228 </span>            :      */
<span class="lineNum">    1229 </span><span class="lineCov">       4996 :     index_close(indexRelation, NoLock);</span>
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span><span class="lineCov">       4996 :     return indexRelationId;</span>
<span class="lineNum">    1232 </span>            : }
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span>            : /*
<span class="lineNum">    1235 </span>            :  * index_concurrently_create_copy
<span class="lineNum">    1236 </span>            :  *
<span class="lineNum">    1237 </span>            :  * Create concurrently an index based on the definition of the one provided by
<span class="lineNum">    1238 </span>            :  * caller.  The index is inserted into catalogs and needs to be built later
<span class="lineNum">    1239 </span>            :  * on.  This is called during concurrent reindex processing.
<a name="1240"><span class="lineNum">    1240 </span>            :  */</a>
<span class="lineNum">    1241 </span>            : Oid
<span class="lineNum">    1242 </span><span class="lineCov">         48 : index_concurrently_create_copy(Relation heapRelation, Oid oldIndexId, const char *newName)</span>
<span class="lineNum">    1243 </span>            : {
<span class="lineNum">    1244 </span>            :     Relation    indexRelation;
<span class="lineNum">    1245 </span>            :     IndexInfo  *oldInfo,
<span class="lineNum">    1246 </span>            :                *newInfo;
<span class="lineNum">    1247 </span><span class="lineCov">         48 :     Oid         newIndexId = InvalidOid;</span>
<span class="lineNum">    1248 </span>            :     HeapTuple   indexTuple,
<span class="lineNum">    1249 </span>            :                 classTuple;
<span class="lineNum">    1250 </span>            :     Datum       indclassDatum,
<span class="lineNum">    1251 </span>            :                 colOptionDatum,
<span class="lineNum">    1252 </span>            :                 optionDatum;
<span class="lineNum">    1253 </span>            :     oidvector  *indclass;
<span class="lineNum">    1254 </span>            :     int2vector *indcoloptions;
<span class="lineNum">    1255 </span>            :     bool        isnull;
<span class="lineNum">    1256 </span><span class="lineCov">         48 :     List       *indexColNames = NIL;</span>
<span class="lineNum">    1257 </span><span class="lineCov">         48 :     List       *indexExprs = NIL;</span>
<span class="lineNum">    1258 </span><span class="lineCov">         48 :     List       *indexPreds = NIL;</span>
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span><span class="lineCov">         48 :     indexRelation = index_open(oldIndexId, RowExclusiveLock);</span>
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span>            :     /* The new index needs some information from the old index */
<span class="lineNum">    1263 </span><span class="lineCov">         48 :     oldInfo = BuildIndexInfo(indexRelation);</span>
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span>            :     /*
<span class="lineNum">    1266 </span>            :      * Concurrent build of an index with exclusion constraints is not
<span class="lineNum">    1267 </span>            :      * supported.
<span class="lineNum">    1268 </span>            :      */
<span class="lineNum">    1269 </span><span class="lineCov">         48 :     if (oldInfo-&gt;ii_ExclusionOps != NULL)</span>
<span class="lineNum">    1270 </span><span class="lineCov">          2 :         ereport(ERROR,</span>
<span class="lineNum">    1271 </span>            :                 (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">    1272 </span>            :                  errmsg(&quot;concurrent index creation for exclusion constraints is not supported&quot;)));
<span class="lineNum">    1273 </span>            : 
<span class="lineNum">    1274 </span>            :     /* Get the array of class and column options IDs from index info */
<span class="lineNum">    1275 </span><span class="lineCov">         46 :     indexTuple = SearchSysCache1(INDEXRELID, ObjectIdGetDatum(oldIndexId));</span>
<span class="lineNum">    1276 </span><span class="lineCov">         46 :     if (!HeapTupleIsValid(indexTuple))</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cache lookup failed for index %u&quot;, oldIndexId);</span>
<span class="lineNum">    1278 </span><span class="lineCov">         46 :     indclassDatum = SysCacheGetAttr(INDEXRELID, indexTuple,</span>
<span class="lineNum">    1279 </span>            :                                     Anum_pg_index_indclass, &amp;isnull);
<span class="lineNum">    1280 </span><span class="lineCov">         46 :     Assert(!isnull);</span>
<span class="lineNum">    1281 </span><span class="lineCov">         46 :     indclass = (oidvector *) DatumGetPointer(indclassDatum);</span>
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span><span class="lineCov">         46 :     colOptionDatum = SysCacheGetAttr(INDEXRELID, indexTuple,</span>
<span class="lineNum">    1284 </span>            :                                      Anum_pg_index_indoption, &amp;isnull);
<span class="lineNum">    1285 </span><span class="lineCov">         46 :     Assert(!isnull);</span>
<span class="lineNum">    1286 </span><span class="lineCov">         46 :     indcoloptions = (int2vector *) DatumGetPointer(colOptionDatum);</span>
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span>            :     /* Fetch options of index if any */
<span class="lineNum">    1289 </span><span class="lineCov">         46 :     classTuple = SearchSysCache1(RELOID, oldIndexId);</span>
<span class="lineNum">    1290 </span><span class="lineCov">         46 :     if (!HeapTupleIsValid(classTuple))</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cache lookup failed for relation %u&quot;, oldIndexId);</span>
<span class="lineNum">    1292 </span><span class="lineCov">         46 :     optionDatum = SysCacheGetAttr(RELOID, classTuple,</span>
<span class="lineNum">    1293 </span>            :                                   Anum_pg_class_reloptions, &amp;isnull);
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span>            :     /*
<span class="lineNum">    1296 </span>            :      * Fetch the list of expressions and predicates directly from the
<span class="lineNum">    1297 </span>            :      * catalogs.  This cannot rely on the information from IndexInfo of the
<span class="lineNum">    1298 </span>            :      * old index as these have been flattened for the planner.
<span class="lineNum">    1299 </span>            :      */
<span class="lineNum">    1300 </span><span class="lineCov">         46 :     if (oldInfo-&gt;ii_Expressions != NIL)</span>
<span class="lineNum">    1301 </span>            :     {
<span class="lineNum">    1302 </span>            :         Datum       exprDatum;
<span class="lineNum">    1303 </span>            :         char       *exprString;
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span><span class="lineCov">          6 :         exprDatum = SysCacheGetAttr(INDEXRELID, indexTuple,</span>
<span class="lineNum">    1306 </span>            :                                     Anum_pg_index_indexprs, &amp;isnull);
<span class="lineNum">    1307 </span><span class="lineCov">          6 :         Assert(!isnull);</span>
<span class="lineNum">    1308 </span><span class="lineCov">          6 :         exprString = TextDatumGetCString(exprDatum);</span>
<span class="lineNum">    1309 </span><span class="lineCov">          6 :         indexExprs = (List *) stringToNode(exprString);</span>
<span class="lineNum">    1310 </span><span class="lineCov">          6 :         pfree(exprString);</span>
<span class="lineNum">    1311 </span>            :     }
<span class="lineNum">    1312 </span><span class="lineCov">         46 :     if (oldInfo-&gt;ii_Predicate != NIL)</span>
<span class="lineNum">    1313 </span>            :     {
<span class="lineNum">    1314 </span>            :         Datum       predDatum;
<span class="lineNum">    1315 </span>            :         char       *predString;
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span><span class="lineCov">          4 :         predDatum = SysCacheGetAttr(INDEXRELID, indexTuple,</span>
<span class="lineNum">    1318 </span>            :                                     Anum_pg_index_indpred, &amp;isnull);
<span class="lineNum">    1319 </span><span class="lineCov">          4 :         Assert(!isnull);</span>
<span class="lineNum">    1320 </span><span class="lineCov">          4 :         predString = TextDatumGetCString(predDatum);</span>
<span class="lineNum">    1321 </span><span class="lineCov">          4 :         indexPreds = (List *) stringToNode(predString);</span>
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span>            :         /* Also convert to implicit-AND format */
<span class="lineNum">    1324 </span><span class="lineCov">          4 :         indexPreds = make_ands_implicit((Expr *) indexPreds);</span>
<span class="lineNum">    1325 </span><span class="lineCov">          4 :         pfree(predString);</span>
<span class="lineNum">    1326 </span>            :     }
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            :     /*
<span class="lineNum">    1329 </span>            :      * Build the index information for the new index.  Note that rebuild of
<span class="lineNum">    1330 </span>            :      * indexes with exclusion constraints is not supported, hence there is no
<span class="lineNum">    1331 </span>            :      * need to fill all the ii_Exclusion* fields.
<span class="lineNum">    1332 </span>            :      */
<span class="lineNum">    1333 </span><span class="lineCov">         46 :     newInfo = makeIndexInfo(oldInfo-&gt;ii_NumIndexAttrs,</span>
<span class="lineNum">    1334 </span>            :                             oldInfo-&gt;ii_NumIndexKeyAttrs,
<span class="lineNum">    1335 </span>            :                             oldInfo-&gt;ii_Am,
<span class="lineNum">    1336 </span>            :                             indexExprs,
<span class="lineNum">    1337 </span>            :                             indexPreds,
<span class="lineNum">    1338 </span><span class="lineCov">         46 :                             oldInfo-&gt;ii_Unique,</span>
<span class="lineNum">    1339 </span>            :                             false,  /* not ready for inserts */
<span class="lineNum">    1340 </span>            :                             true);
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span>            :     /*
<span class="lineNum">    1343 </span>            :      * Extract the list of column names and the column numbers for the new
<span class="lineNum">    1344 </span>            :      * index information.  All this information will be used for the index
<span class="lineNum">    1345 </span>            :      * creation.
<span class="lineNum">    1346 </span>            :      */
<span class="lineNum">    1347 </span><span class="lineCov">        104 :     for (int i = 0; i &lt; oldInfo-&gt;ii_NumIndexAttrs; i++)</span>
<span class="lineNum">    1348 </span>            :     {
<span class="lineNum">    1349 </span><span class="lineCov">         58 :         TupleDesc   indexTupDesc = RelationGetDescr(indexRelation);</span>
<span class="lineNum">    1350 </span><span class="lineCov">         58 :         Form_pg_attribute att = TupleDescAttr(indexTupDesc, i);</span>
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span><span class="lineCov">         58 :         indexColNames = lappend(indexColNames, NameStr(att-&gt;attname));</span>
<span class="lineNum">    1353 </span><span class="lineCov">         58 :         newInfo-&gt;ii_IndexAttrNumbers[i] = oldInfo-&gt;ii_IndexAttrNumbers[i];</span>
<span class="lineNum">    1354 </span>            :     }
<span class="lineNum">    1355 </span>            : 
<span class="lineNum">    1356 </span>            :     /*
<span class="lineNum">    1357 </span>            :      * Now create the new index.
<span class="lineNum">    1358 </span>            :      *
<span class="lineNum">    1359 </span>            :      * For a partition index, we adjust the partition dependency later, to
<span class="lineNum">    1360 </span>            :      * ensure a consistent state at all times.  That is why parentIndexRelid
<span class="lineNum">    1361 </span>            :      * is not set here.
<span class="lineNum">    1362 </span>            :      */
<span class="lineNum">    1363 </span><span class="lineCov">        138 :     newIndexId = index_create(heapRelation,</span>
<span class="lineNum">    1364 </span>            :                               newName,
<span class="lineNum">    1365 </span>            :                               InvalidOid,   /* indexRelationId */
<span class="lineNum">    1366 </span>            :                               InvalidOid,   /* parentIndexRelid */
<span class="lineNum">    1367 </span>            :                               InvalidOid,   /* parentConstraintId */
<span class="lineNum">    1368 </span>            :                               InvalidOid,   /* relFileNode */
<span class="lineNum">    1369 </span>            :                               newInfo,
<span class="lineNum">    1370 </span>            :                               indexColNames,
<span class="lineNum">    1371 </span><span class="lineCov">         46 :                               indexRelation-&gt;rd_rel-&gt;relam,</span>
<span class="lineNum">    1372 </span><span class="lineCov">         46 :                               indexRelation-&gt;rd_rel-&gt;reltablespace,</span>
<span class="lineNum">    1373 </span>            :                               indexRelation-&gt;rd_indcollation,
<span class="lineNum">    1374 </span><span class="lineCov">         46 :                               indclass-&gt;values,</span>
<span class="lineNum">    1375 </span><span class="lineCov">         46 :                               indcoloptions-&gt;values,</span>
<span class="lineNum">    1376 </span>            :                               optionDatum,
<span class="lineNum">    1377 </span>            :                               INDEX_CREATE_SKIP_BUILD | INDEX_CREATE_CONCURRENT,
<span class="lineNum">    1378 </span>            :                               0,
<span class="lineNum">    1379 </span>            :                               true, /* allow table to be a system catalog? */
<span class="lineNum">    1380 </span>            :                               false,    /* is_internal? */
<span class="lineNum">    1381 </span>            :                               NULL);
<span class="lineNum">    1382 </span>            : 
<span class="lineNum">    1383 </span>            :     /* Close the relations used and clean up */
<span class="lineNum">    1384 </span><span class="lineCov">         46 :     index_close(indexRelation, NoLock);</span>
<span class="lineNum">    1385 </span><span class="lineCov">         46 :     ReleaseSysCache(indexTuple);</span>
<span class="lineNum">    1386 </span><span class="lineCov">         46 :     ReleaseSysCache(classTuple);</span>
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span><span class="lineCov">         46 :     return newIndexId;</span>
<span class="lineNum">    1389 </span>            : }
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span>            : /*
<span class="lineNum">    1392 </span>            :  * index_concurrently_build
<span class="lineNum">    1393 </span>            :  *
<span class="lineNum">    1394 </span>            :  * Build index for a concurrent operation.  Low-level locks are taken when
<span class="lineNum">    1395 </span>            :  * this operation is performed to prevent only schema changes, but they need
<span class="lineNum">    1396 </span>            :  * to be kept until the end of the transaction performing this operation.
<span class="lineNum">    1397 </span>            :  * 'indexOid' refers to an index relation OID already created as part of
<span class="lineNum">    1398 </span>            :  * previous processing, and 'heapOid' refers to its parent heap relation.
<a name="1399"><span class="lineNum">    1399 </span>            :  */</a>
<span class="lineNum">    1400 </span>            : void
<span class="lineNum">    1401 </span><span class="lineCov">         64 : index_concurrently_build(Oid heapRelationId,</span>
<span class="lineNum">    1402 </span>            :                          Oid indexRelationId)
<span class="lineNum">    1403 </span>            : {
<span class="lineNum">    1404 </span>            :     Relation    heapRel;
<span class="lineNum">    1405 </span>            :     Relation    indexRelation;
<span class="lineNum">    1406 </span>            :     IndexInfo  *indexInfo;
<span class="lineNum">    1407 </span>            : 
<span class="lineNum">    1408 </span>            :     /* This had better make sure that a snapshot is active */
<span class="lineNum">    1409 </span><span class="lineCov">         64 :     Assert(ActiveSnapshotSet());</span>
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span>            :     /* Open and lock the parent heap relation */
<span class="lineNum">    1412 </span><span class="lineCov">         64 :     heapRel = table_open(heapRelationId, ShareUpdateExclusiveLock);</span>
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span>            :     /* And the target index relation */
<span class="lineNum">    1415 </span><span class="lineCov">         64 :     indexRelation = index_open(indexRelationId, RowExclusiveLock);</span>
<span class="lineNum">    1416 </span>            : 
<span class="lineNum">    1417 </span>            :     /*
<span class="lineNum">    1418 </span>            :      * We have to re-build the IndexInfo struct, since it was lost in the
<span class="lineNum">    1419 </span>            :      * commit of the transaction where this concurrent index was created at
<span class="lineNum">    1420 </span>            :      * the catalog level.
<span class="lineNum">    1421 </span>            :      */
<span class="lineNum">    1422 </span><span class="lineCov">         64 :     indexInfo = BuildIndexInfo(indexRelation);</span>
<span class="lineNum">    1423 </span><span class="lineCov">         64 :     Assert(!indexInfo-&gt;ii_ReadyForInserts);</span>
<span class="lineNum">    1424 </span><span class="lineCov">         64 :     indexInfo-&gt;ii_Concurrent = true;</span>
<span class="lineNum">    1425 </span><span class="lineCov">         64 :     indexInfo-&gt;ii_BrokenHotChain = false;</span>
<span class="lineNum">    1426 </span>            : 
<span class="lineNum">    1427 </span>            :     /* Now build the index */
<span class="lineNum">    1428 </span><span class="lineCov">         64 :     index_build(heapRel, indexRelation, indexInfo, false, true);</span>
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span>            :     /* Close both the relations, but keep the locks */
<span class="lineNum">    1431 </span><span class="lineCov">         58 :     table_close(heapRel, NoLock);</span>
<span class="lineNum">    1432 </span><span class="lineCov">         58 :     index_close(indexRelation, NoLock);</span>
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span>            :     /*
<span class="lineNum">    1435 </span>            :      * Update the pg_index row to mark the index as ready for inserts. Once we
<span class="lineNum">    1436 </span>            :      * commit this transaction, any new transactions that open the table must
<span class="lineNum">    1437 </span>            :      * insert new entries into the index for insertions and non-HOT updates.
<span class="lineNum">    1438 </span>            :      */
<span class="lineNum">    1439 </span><span class="lineCov">         58 :     index_set_state_flags(indexRelationId, INDEX_CREATE_SET_READY);</span>
<span class="lineNum">    1440 </span><span class="lineCov">         58 : }</span>
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span>            : /*
<span class="lineNum">    1443 </span>            :  * index_concurrently_swap
<span class="lineNum">    1444 </span>            :  *
<span class="lineNum">    1445 </span>            :  * Swap name, dependencies, and constraints of the old index over to the new
<span class="lineNum">    1446 </span>            :  * index, while marking the old index as invalid and the new as valid.
<a name="1447"><span class="lineNum">    1447 </span>            :  */</a>
<span class="lineNum">    1448 </span>            : void
<span class="lineNum">    1449 </span><span class="lineCov">         44 : index_concurrently_swap(Oid newIndexId, Oid oldIndexId, const char *oldName)</span>
<span class="lineNum">    1450 </span>            : {
<span class="lineNum">    1451 </span>            :     Relation    pg_class,
<span class="lineNum">    1452 </span>            :                 pg_index,
<span class="lineNum">    1453 </span>            :                 pg_constraint,
<span class="lineNum">    1454 </span>            :                 pg_trigger;
<span class="lineNum">    1455 </span>            :     Relation    oldClassRel,
<span class="lineNum">    1456 </span>            :                 newClassRel;
<span class="lineNum">    1457 </span>            :     HeapTuple   oldClassTuple,
<span class="lineNum">    1458 </span>            :                 newClassTuple;
<span class="lineNum">    1459 </span>            :     Form_pg_class oldClassForm,
<span class="lineNum">    1460 </span>            :                 newClassForm;
<span class="lineNum">    1461 </span>            :     HeapTuple   oldIndexTuple,
<span class="lineNum">    1462 </span>            :                 newIndexTuple;
<span class="lineNum">    1463 </span>            :     Form_pg_index oldIndexForm,
<span class="lineNum">    1464 </span>            :                 newIndexForm;
<span class="lineNum">    1465 </span>            :     bool        isPartition;
<span class="lineNum">    1466 </span>            :     Oid         indexConstraintOid;
<span class="lineNum">    1467 </span><span class="lineCov">         44 :     List       *constraintOids = NIL;</span>
<span class="lineNum">    1468 </span>            :     ListCell   *lc;
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span>            :     /*
<span class="lineNum">    1471 </span>            :      * Take a necessary lock on the old and new index before swapping them.
<span class="lineNum">    1472 </span>            :      */
<span class="lineNum">    1473 </span><span class="lineCov">         44 :     oldClassRel = relation_open(oldIndexId, ShareUpdateExclusiveLock);</span>
<span class="lineNum">    1474 </span><span class="lineCov">         44 :     newClassRel = relation_open(newIndexId, ShareUpdateExclusiveLock);</span>
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span>            :     /* Now swap names and dependencies of those indexes */
<span class="lineNum">    1477 </span><span class="lineCov">         44 :     pg_class = table_open(RelationRelationId, RowExclusiveLock);</span>
<span class="lineNum">    1478 </span>            : 
<span class="lineNum">    1479 </span><span class="lineCov">         44 :     oldClassTuple = SearchSysCacheCopy1(RELOID,</span>
<span class="lineNum">    1480 </span>            :                                         ObjectIdGetDatum(oldIndexId));
<span class="lineNum">    1481 </span><span class="lineCov">         44 :     if (!HeapTupleIsValid(oldClassTuple))</span>
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;could not find tuple for relation %u&quot;, oldIndexId);</span>
<span class="lineNum">    1483 </span><span class="lineCov">         44 :     newClassTuple = SearchSysCacheCopy1(RELOID,</span>
<span class="lineNum">    1484 </span>            :                                         ObjectIdGetDatum(newIndexId));
<span class="lineNum">    1485 </span><span class="lineCov">         44 :     if (!HeapTupleIsValid(newClassTuple))</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;could not find tuple for relation %u&quot;, newIndexId);</span>
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span><span class="lineCov">         44 :     oldClassForm = (Form_pg_class) GETSTRUCT(oldClassTuple);</span>
<span class="lineNum">    1489 </span><span class="lineCov">         44 :     newClassForm = (Form_pg_class) GETSTRUCT(newClassTuple);</span>
<span class="lineNum">    1490 </span>            : 
<span class="lineNum">    1491 </span>            :     /* Swap the names */
<span class="lineNum">    1492 </span><span class="lineCov">         44 :     namestrcpy(&amp;newClassForm-&gt;relname, NameStr(oldClassForm-&gt;relname));</span>
<span class="lineNum">    1493 </span><span class="lineCov">         44 :     namestrcpy(&amp;oldClassForm-&gt;relname, oldName);</span>
<span class="lineNum">    1494 </span>            : 
<span class="lineNum">    1495 </span>            :     /* Swap the partition flags to track inheritance properly */
<span class="lineNum">    1496 </span><span class="lineCov">         44 :     isPartition = newClassForm-&gt;relispartition;</span>
<span class="lineNum">    1497 </span><span class="lineCov">         44 :     newClassForm-&gt;relispartition = oldClassForm-&gt;relispartition;</span>
<span class="lineNum">    1498 </span><span class="lineCov">         44 :     oldClassForm-&gt;relispartition = isPartition;</span>
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span><span class="lineCov">         44 :     CatalogTupleUpdate(pg_class, &amp;oldClassTuple-&gt;t_self, oldClassTuple);</span>
<span class="lineNum">    1501 </span><span class="lineCov">         44 :     CatalogTupleUpdate(pg_class, &amp;newClassTuple-&gt;t_self, newClassTuple);</span>
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span><span class="lineCov">         44 :     heap_freetuple(oldClassTuple);</span>
<span class="lineNum">    1504 </span><span class="lineCov">         44 :     heap_freetuple(newClassTuple);</span>
<span class="lineNum">    1505 </span>            : 
<span class="lineNum">    1506 </span>            :     /* Now swap index info */
<span class="lineNum">    1507 </span><span class="lineCov">         44 :     pg_index = table_open(IndexRelationId, RowExclusiveLock);</span>
<span class="lineNum">    1508 </span>            : 
<span class="lineNum">    1509 </span><span class="lineCov">         44 :     oldIndexTuple = SearchSysCacheCopy1(INDEXRELID,</span>
<span class="lineNum">    1510 </span>            :                                         ObjectIdGetDatum(oldIndexId));
<span class="lineNum">    1511 </span><span class="lineCov">         44 :     if (!HeapTupleIsValid(oldIndexTuple))</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;could not find tuple for relation %u&quot;, oldIndexId);</span>
<span class="lineNum">    1513 </span><span class="lineCov">         44 :     newIndexTuple = SearchSysCacheCopy1(INDEXRELID,</span>
<span class="lineNum">    1514 </span>            :                                         ObjectIdGetDatum(newIndexId));
<span class="lineNum">    1515 </span><span class="lineCov">         44 :     if (!HeapTupleIsValid(newIndexTuple))</span>
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;could not find tuple for relation %u&quot;, newIndexId);</span>
<span class="lineNum">    1517 </span>            : 
<span class="lineNum">    1518 </span><span class="lineCov">         44 :     oldIndexForm = (Form_pg_index) GETSTRUCT(oldIndexTuple);</span>
<span class="lineNum">    1519 </span><span class="lineCov">         44 :     newIndexForm = (Form_pg_index) GETSTRUCT(newIndexTuple);</span>
<span class="lineNum">    1520 </span>            : 
<span class="lineNum">    1521 </span>            :     /*
<span class="lineNum">    1522 </span>            :      * Copy constraint flags from the old index. This is safe because the old
<span class="lineNum">    1523 </span>            :      * index guaranteed uniqueness.
<span class="lineNum">    1524 </span>            :      */
<span class="lineNum">    1525 </span><span class="lineCov">         44 :     newIndexForm-&gt;indisprimary = oldIndexForm-&gt;indisprimary;</span>
<span class="lineNum">    1526 </span><span class="lineCov">         44 :     oldIndexForm-&gt;indisprimary = false;</span>
<span class="lineNum">    1527 </span><span class="lineCov">         44 :     newIndexForm-&gt;indisexclusion = oldIndexForm-&gt;indisexclusion;</span>
<span class="lineNum">    1528 </span><span class="lineCov">         44 :     oldIndexForm-&gt;indisexclusion = false;</span>
<span class="lineNum">    1529 </span><span class="lineCov">         44 :     newIndexForm-&gt;indimmediate = oldIndexForm-&gt;indimmediate;</span>
<span class="lineNum">    1530 </span><span class="lineCov">         44 :     oldIndexForm-&gt;indimmediate = true;</span>
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span>            :     /* Mark old index as valid and new as invalid as index_set_state_flags */
<span class="lineNum">    1533 </span><span class="lineCov">         44 :     newIndexForm-&gt;indisvalid = true;</span>
<span class="lineNum">    1534 </span><span class="lineCov">         44 :     oldIndexForm-&gt;indisvalid = false;</span>
<span class="lineNum">    1535 </span><span class="lineCov">         44 :     oldIndexForm-&gt;indisclustered = false;</span>
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span><span class="lineCov">         44 :     CatalogTupleUpdate(pg_index, &amp;oldIndexTuple-&gt;t_self, oldIndexTuple);</span>
<span class="lineNum">    1538 </span><span class="lineCov">         44 :     CatalogTupleUpdate(pg_index, &amp;newIndexTuple-&gt;t_self, newIndexTuple);</span>
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span><span class="lineCov">         44 :     heap_freetuple(oldIndexTuple);</span>
<span class="lineNum">    1541 </span><span class="lineCov">         44 :     heap_freetuple(newIndexTuple);</span>
<span class="lineNum">    1542 </span>            : 
<span class="lineNum">    1543 </span>            :     /*
<span class="lineNum">    1544 </span>            :      * Move constraints and triggers over to the new index
<span class="lineNum">    1545 </span>            :      */
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span><span class="lineCov">         44 :     constraintOids = get_index_ref_constraints(oldIndexId);</span>
<span class="lineNum">    1548 </span>            : 
<span class="lineNum">    1549 </span><span class="lineCov">         44 :     indexConstraintOid = get_index_constraint(oldIndexId);</span>
<span class="lineNum">    1550 </span>            : 
<span class="lineNum">    1551 </span><span class="lineCov">         44 :     if (OidIsValid(indexConstraintOid))</span>
<span class="lineNum">    1552 </span><span class="lineCov">          8 :         constraintOids = lappend_oid(constraintOids, indexConstraintOid);</span>
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span><span class="lineCov">         44 :     pg_constraint = table_open(ConstraintRelationId, RowExclusiveLock);</span>
<span class="lineNum">    1555 </span><span class="lineCov">         44 :     pg_trigger = table_open(TriggerRelationId, RowExclusiveLock);</span>
<span class="lineNum">    1556 </span>            : 
<span class="lineNum">    1557 </span><span class="lineCov">         56 :     foreach(lc, constraintOids)</span>
<span class="lineNum">    1558 </span>            :     {
<span class="lineNum">    1559 </span>            :         HeapTuple   constraintTuple,
<span class="lineNum">    1560 </span>            :                     triggerTuple;
<span class="lineNum">    1561 </span>            :         Form_pg_constraint conForm;
<span class="lineNum">    1562 </span>            :         ScanKeyData key[1];
<span class="lineNum">    1563 </span>            :         SysScanDesc scan;
<span class="lineNum">    1564 </span><span class="lineCov">         12 :         Oid         constraintOid = lfirst_oid(lc);</span>
<span class="lineNum">    1565 </span>            : 
<span class="lineNum">    1566 </span>            :         /* Move the constraint from the old to the new index */
<span class="lineNum">    1567 </span><span class="lineCov">         12 :         constraintTuple = SearchSysCacheCopy1(CONSTROID,</span>
<span class="lineNum">    1568 </span>            :                                               ObjectIdGetDatum(constraintOid));
<span class="lineNum">    1569 </span><span class="lineCov">         12 :         if (!HeapTupleIsValid(constraintTuple))</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;could not find tuple for constraint %u&quot;, constraintOid);</span>
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span><span class="lineCov">         12 :         conForm = ((Form_pg_constraint) GETSTRUCT(constraintTuple));</span>
<span class="lineNum">    1573 </span>            : 
<span class="lineNum">    1574 </span><span class="lineCov">         12 :         if (conForm-&gt;conindid == oldIndexId)</span>
<span class="lineNum">    1575 </span>            :         {
<span class="lineNum">    1576 </span><span class="lineCov">         12 :             conForm-&gt;conindid = newIndexId;</span>
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span><span class="lineCov">         12 :             CatalogTupleUpdate(pg_constraint, &amp;constraintTuple-&gt;t_self, constraintTuple);</span>
<span class="lineNum">    1579 </span>            :         }
<span class="lineNum">    1580 </span>            : 
<span class="lineNum">    1581 </span><span class="lineCov">         12 :         heap_freetuple(constraintTuple);</span>
<span class="lineNum">    1582 </span>            : 
<span class="lineNum">    1583 </span>            :         /* Search for trigger records */
<span class="lineNum">    1584 </span><span class="lineCov">         12 :         ScanKeyInit(&amp;key[0],</span>
<span class="lineNum">    1585 </span>            :                     Anum_pg_trigger_tgconstraint,
<span class="lineNum">    1586 </span>            :                     BTEqualStrategyNumber, F_OIDEQ,
<span class="lineNum">    1587 </span>            :                     ObjectIdGetDatum(constraintOid));
<span class="lineNum">    1588 </span>            : 
<span class="lineNum">    1589 </span><span class="lineCov">         12 :         scan = systable_beginscan(pg_trigger, TriggerConstraintIndexId, true,</span>
<span class="lineNum">    1590 </span>            :                                   NULL, 1, key);
<span class="lineNum">    1591 </span>            : 
<span class="lineNum">    1592 </span><span class="lineCov">         40 :         while (HeapTupleIsValid((triggerTuple = systable_getnext(scan))))</span>
<span class="lineNum">    1593 </span>            :         {
<span class="lineNum">    1594 </span><span class="lineCov">         16 :             Form_pg_trigger tgForm = (Form_pg_trigger) GETSTRUCT(triggerTuple);</span>
<span class="lineNum">    1595 </span>            : 
<span class="lineNum">    1596 </span><span class="lineCov">         16 :             if (tgForm-&gt;tgconstrindid != oldIndexId)</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1598 </span>            : 
<span class="lineNum">    1599 </span>            :             /* Make a modifiable copy */
<span class="lineNum">    1600 </span><span class="lineCov">         16 :             triggerTuple = heap_copytuple(triggerTuple);</span>
<span class="lineNum">    1601 </span><span class="lineCov">         16 :             tgForm = (Form_pg_trigger) GETSTRUCT(triggerTuple);</span>
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span><span class="lineCov">         16 :             tgForm-&gt;tgconstrindid = newIndexId;</span>
<span class="lineNum">    1604 </span>            : 
<span class="lineNum">    1605 </span><span class="lineCov">         16 :             CatalogTupleUpdate(pg_trigger, &amp;triggerTuple-&gt;t_self, triggerTuple);</span>
<span class="lineNum">    1606 </span>            : 
<span class="lineNum">    1607 </span><span class="lineCov">         16 :             heap_freetuple(triggerTuple);</span>
<span class="lineNum">    1608 </span>            :         }
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span><span class="lineCov">         12 :         systable_endscan(scan);</span>
<span class="lineNum">    1611 </span>            :     }
<span class="lineNum">    1612 </span>            : 
<span class="lineNum">    1613 </span>            :     /*
<span class="lineNum">    1614 </span>            :      * Move comment if any
<span class="lineNum">    1615 </span>            :      */
<span class="lineNum">    1616 </span>            :     {
<span class="lineNum">    1617 </span>            :         Relation    description;
<span class="lineNum">    1618 </span>            :         ScanKeyData skey[3];
<span class="lineNum">    1619 </span>            :         SysScanDesc sd;
<span class="lineNum">    1620 </span>            :         HeapTuple   tuple;
<span class="lineNum">    1621 </span><span class="lineCov">         44 :         Datum       values[Natts_pg_description] = {0};</span>
<span class="lineNum">    1622 </span><span class="lineCov">         44 :         bool        nulls[Natts_pg_description] = {0};</span>
<span class="lineNum">    1623 </span><span class="lineCov">         44 :         bool        replaces[Natts_pg_description] = {0};</span>
<span class="lineNum">    1624 </span>            : 
<span class="lineNum">    1625 </span><span class="lineCov">         44 :         values[Anum_pg_description_objoid - 1] = ObjectIdGetDatum(newIndexId);</span>
<span class="lineNum">    1626 </span><span class="lineCov">         44 :         replaces[Anum_pg_description_objoid - 1] = true;</span>
<span class="lineNum">    1627 </span>            : 
<span class="lineNum">    1628 </span><span class="lineCov">         44 :         ScanKeyInit(&amp;skey[0],</span>
<span class="lineNum">    1629 </span>            :                     Anum_pg_description_objoid,
<span class="lineNum">    1630 </span>            :                     BTEqualStrategyNumber, F_OIDEQ,
<span class="lineNum">    1631 </span>            :                     ObjectIdGetDatum(oldIndexId));
<span class="lineNum">    1632 </span><span class="lineCov">         44 :         ScanKeyInit(&amp;skey[1],</span>
<span class="lineNum">    1633 </span>            :                     Anum_pg_description_classoid,
<span class="lineNum">    1634 </span>            :                     BTEqualStrategyNumber, F_OIDEQ,
<span class="lineNum">    1635 </span>            :                     ObjectIdGetDatum(RelationRelationId));
<span class="lineNum">    1636 </span><span class="lineCov">         44 :         ScanKeyInit(&amp;skey[2],</span>
<span class="lineNum">    1637 </span>            :                     Anum_pg_description_objsubid,
<span class="lineNum">    1638 </span>            :                     BTEqualStrategyNumber, F_INT4EQ,
<span class="lineNum">    1639 </span>            :                     Int32GetDatum(0));
<span class="lineNum">    1640 </span>            : 
<span class="lineNum">    1641 </span><span class="lineCov">         44 :         description = table_open(DescriptionRelationId, RowExclusiveLock);</span>
<span class="lineNum">    1642 </span>            : 
<span class="lineNum">    1643 </span><span class="lineCov">         44 :         sd = systable_beginscan(description, DescriptionObjIndexId, true,</span>
<span class="lineNum">    1644 </span>            :                                 NULL, 3, skey);
<span class="lineNum">    1645 </span>            : 
<span class="lineNum">    1646 </span><span class="lineCov">         44 :         while ((tuple = systable_getnext(sd)) != NULL)</span>
<span class="lineNum">    1647 </span>            :         {
<span class="lineNum">    1648 </span><span class="lineCov">          2 :             tuple = heap_modify_tuple(tuple, RelationGetDescr(description),</span>
<span class="lineNum">    1649 </span>            :                                       values, nulls, replaces);
<span class="lineNum">    1650 </span><span class="lineCov">          2 :             CatalogTupleUpdate(description, &amp;tuple-&gt;t_self, tuple);</span>
<span class="lineNum">    1651 </span>            : 
<span class="lineNum">    1652 </span><span class="lineCov">          2 :             break;              /* Assume there can be only one match */</span>
<span class="lineNum">    1653 </span>            :         }
<span class="lineNum">    1654 </span>            : 
<span class="lineNum">    1655 </span><span class="lineCov">         44 :         systable_endscan(sd);</span>
<span class="lineNum">    1656 </span><span class="lineCov">         44 :         table_close(description, NoLock);</span>
<span class="lineNum">    1657 </span>            :     }
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span>            :     /*
<span class="lineNum">    1660 </span>            :      * Swap inheritance relationship with parent index
<span class="lineNum">    1661 </span>            :      */
<span class="lineNum">    1662 </span><span class="lineCov">         44 :     if (get_rel_relispartition(oldIndexId))</span>
<span class="lineNum">    1663 </span>            :     {
<span class="lineNum">    1664 </span><span class="lineCov">          8 :         List       *ancestors = get_partition_ancestors(oldIndexId);</span>
<span class="lineNum">    1665 </span><span class="lineCov">          8 :         Oid         parentIndexRelid = linitial_oid(ancestors);</span>
<span class="lineNum">    1666 </span>            : 
<span class="lineNum">    1667 </span><span class="lineCov">          8 :         DeleteInheritsTuple(oldIndexId, parentIndexRelid);</span>
<span class="lineNum">    1668 </span><span class="lineCov">          8 :         StoreSingleInheritance(newIndexId, parentIndexRelid, 1);</span>
<span class="lineNum">    1669 </span>            : 
<span class="lineNum">    1670 </span><span class="lineCov">          8 :         list_free(ancestors);</span>
<span class="lineNum">    1671 </span>            :     }
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span>            :     /*
<span class="lineNum">    1674 </span>            :      * Move all dependencies of and on the old index to the new one.  First
<span class="lineNum">    1675 </span>            :      * remove any dependencies that the new index may have to provide an
<span class="lineNum">    1676 </span>            :      * initial clean state for the dependency switch, and then move all the
<span class="lineNum">    1677 </span>            :      * dependencies from the old index to the new one.
<span class="lineNum">    1678 </span>            :      */
<span class="lineNum">    1679 </span><span class="lineCov">         44 :     deleteDependencyRecordsFor(RelationRelationId, newIndexId, false);</span>
<span class="lineNum">    1680 </span><span class="lineCov">         44 :     changeDependenciesOf(RelationRelationId, oldIndexId, newIndexId);</span>
<span class="lineNum">    1681 </span><span class="lineCov">         44 :     changeDependenciesOn(RelationRelationId, oldIndexId, newIndexId);</span>
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span>            :     /*
<span class="lineNum">    1684 </span>            :      * Copy over statistics from old to new index
<span class="lineNum">    1685 </span>            :      */
<span class="lineNum">    1686 </span>            :     {
<span class="lineNum">    1687 </span>            :         PgStat_StatTabEntry *tabentry;
<span class="lineNum">    1688 </span>            : 
<span class="lineNum">    1689 </span><span class="lineCov">         44 :         tabentry = pgstat_fetch_stat_tabentry(oldIndexId);</span>
<span class="lineNum">    1690 </span><span class="lineCov">         44 :         if (tabentry)</span>
<span class="lineNum">    1691 </span>            :         {
<span class="lineNum">    1692 </span><span class="lineCov">          6 :             if (newClassRel-&gt;pgstat_info)</span>
<span class="lineNum">    1693 </span>            :             {
<span class="lineNum">    1694 </span><span class="lineCov">          6 :                 newClassRel-&gt;pgstat_info-&gt;t_counts.t_numscans = tabentry-&gt;numscans;</span>
<span class="lineNum">    1695 </span><span class="lineCov">          6 :                 newClassRel-&gt;pgstat_info-&gt;t_counts.t_tuples_returned = tabentry-&gt;tuples_returned;</span>
<span class="lineNum">    1696 </span><span class="lineCov">          6 :                 newClassRel-&gt;pgstat_info-&gt;t_counts.t_tuples_fetched = tabentry-&gt;tuples_fetched;</span>
<span class="lineNum">    1697 </span><span class="lineCov">          6 :                 newClassRel-&gt;pgstat_info-&gt;t_counts.t_blocks_fetched = tabentry-&gt;blocks_fetched;</span>
<span class="lineNum">    1698 </span><span class="lineCov">          6 :                 newClassRel-&gt;pgstat_info-&gt;t_counts.t_blocks_hit = tabentry-&gt;blocks_hit;</span>
<span class="lineNum">    1699 </span>            : 
<span class="lineNum">    1700 </span>            :                 /*
<span class="lineNum">    1701 </span>            :                  * The data will be sent by the next pgstat_report_stat()
<span class="lineNum">    1702 </span>            :                  * call.
<span class="lineNum">    1703 </span>            :                  */
<span class="lineNum">    1704 </span>            :             }
<span class="lineNum">    1705 </span>            :         }
<span class="lineNum">    1706 </span>            :     }
<span class="lineNum">    1707 </span>            : 
<span class="lineNum">    1708 </span>            :     /* Close relations */
<span class="lineNum">    1709 </span><span class="lineCov">         44 :     table_close(pg_class, RowExclusiveLock);</span>
<span class="lineNum">    1710 </span><span class="lineCov">         44 :     table_close(pg_index, RowExclusiveLock);</span>
<span class="lineNum">    1711 </span><span class="lineCov">         44 :     table_close(pg_constraint, RowExclusiveLock);</span>
<span class="lineNum">    1712 </span><span class="lineCov">         44 :     table_close(pg_trigger, RowExclusiveLock);</span>
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span>            :     /* The lock taken previously is not released until the end of transaction */
<span class="lineNum">    1715 </span><span class="lineCov">         44 :     relation_close(oldClassRel, NoLock);</span>
<span class="lineNum">    1716 </span><span class="lineCov">         44 :     relation_close(newClassRel, NoLock);</span>
<span class="lineNum">    1717 </span><span class="lineCov">         44 : }</span>
<span class="lineNum">    1718 </span>            : 
<span class="lineNum">    1719 </span>            : /*
<span class="lineNum">    1720 </span>            :  * index_concurrently_set_dead
<span class="lineNum">    1721 </span>            :  *
<span class="lineNum">    1722 </span>            :  * Perform the last invalidation stage of DROP INDEX CONCURRENTLY or REINDEX
<span class="lineNum">    1723 </span>            :  * CONCURRENTLY before actually dropping the index.  After calling this
<span class="lineNum">    1724 </span>            :  * function, the index is seen by all the backends as dead.  Low-level locks
<span class="lineNum">    1725 </span>            :  * taken here are kept until the end of the transaction calling this function.
<a name="1726"><span class="lineNum">    1726 </span>            :  */</a>
<span class="lineNum">    1727 </span>            : void
<span class="lineNum">    1728 </span><span class="lineCov">         56 : index_concurrently_set_dead(Oid heapId, Oid indexId)</span>
<span class="lineNum">    1729 </span>            : {
<span class="lineNum">    1730 </span>            :     Relation    userHeapRelation;
<span class="lineNum">    1731 </span>            :     Relation    userIndexRelation;
<span class="lineNum">    1732 </span>            : 
<span class="lineNum">    1733 </span>            :     /*
<span class="lineNum">    1734 </span>            :      * No more predicate locks will be acquired on this index, and we're about
<span class="lineNum">    1735 </span>            :      * to stop doing inserts into the index which could show conflicts with
<span class="lineNum">    1736 </span>            :      * existing predicate locks, so now is the time to move them to the heap
<span class="lineNum">    1737 </span>            :      * relation.
<span class="lineNum">    1738 </span>            :      */
<span class="lineNum">    1739 </span><span class="lineCov">         56 :     userHeapRelation = table_open(heapId, ShareUpdateExclusiveLock);</span>
<span class="lineNum">    1740 </span><span class="lineCov">         56 :     userIndexRelation = index_open(indexId, ShareUpdateExclusiveLock);</span>
<span class="lineNum">    1741 </span><span class="lineCov">         56 :     TransferPredicateLocksToHeapRelation(userIndexRelation);</span>
<span class="lineNum">    1742 </span>            : 
<span class="lineNum">    1743 </span>            :     /*
<span class="lineNum">    1744 </span>            :      * Now we are sure that nobody uses the index for queries; they just might
<span class="lineNum">    1745 </span>            :      * have it open for updating it.  So now we can unset indisready and
<span class="lineNum">    1746 </span>            :      * indislive, then wait till nobody could be using it at all anymore.
<span class="lineNum">    1747 </span>            :      */
<span class="lineNum">    1748 </span><span class="lineCov">         56 :     index_set_state_flags(indexId, INDEX_DROP_SET_DEAD);</span>
<span class="lineNum">    1749 </span>            : 
<span class="lineNum">    1750 </span>            :     /*
<span class="lineNum">    1751 </span>            :      * Invalidate the relcache for the table, so that after this commit all
<span class="lineNum">    1752 </span>            :      * sessions will refresh the table's index list.  Forgetting just the
<span class="lineNum">    1753 </span>            :      * index's relcache entry is not enough.
<span class="lineNum">    1754 </span>            :      */
<span class="lineNum">    1755 </span><span class="lineCov">         56 :     CacheInvalidateRelcache(userHeapRelation);</span>
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span>            :     /*
<span class="lineNum">    1758 </span>            :      * Close the relations again, though still holding session lock.
<span class="lineNum">    1759 </span>            :      */
<span class="lineNum">    1760 </span><span class="lineCov">         56 :     table_close(userHeapRelation, NoLock);</span>
<span class="lineNum">    1761 </span><span class="lineCov">         56 :     index_close(userIndexRelation, NoLock);</span>
<span class="lineNum">    1762 </span><span class="lineCov">         56 : }</span>
<span class="lineNum">    1763 </span>            : 
<span class="lineNum">    1764 </span>            : /*
<span class="lineNum">    1765 </span>            :  * index_constraint_create
<span class="lineNum">    1766 </span>            :  *
<span class="lineNum">    1767 </span>            :  * Set up a constraint associated with an index.  Return the new constraint's
<span class="lineNum">    1768 </span>            :  * address.
<span class="lineNum">    1769 </span>            :  *
<span class="lineNum">    1770 </span>            :  * heapRelation: table owning the index (must be suitably locked by caller)
<span class="lineNum">    1771 </span>            :  * indexRelationId: OID of the index
<span class="lineNum">    1772 </span>            :  * parentConstraintId: if constraint is on a partition, the OID of the
<span class="lineNum">    1773 </span>            :  *      constraint in the parent.
<span class="lineNum">    1774 </span>            :  * indexInfo: same info executor uses to insert into the index
<span class="lineNum">    1775 </span>            :  * constraintName: what it say (generally, should match name of index)
<span class="lineNum">    1776 </span>            :  * constraintType: one of CONSTRAINT_PRIMARY, CONSTRAINT_UNIQUE, or
<span class="lineNum">    1777 </span>            :  *      CONSTRAINT_EXCLUSION
<span class="lineNum">    1778 </span>            :  * flags: bitmask that can include any combination of these bits:
<span class="lineNum">    1779 </span>            :  *      INDEX_CONSTR_CREATE_MARK_AS_PRIMARY: index is a PRIMARY KEY
<span class="lineNum">    1780 </span>            :  *      INDEX_CONSTR_CREATE_DEFERRABLE: constraint is DEFERRABLE
<span class="lineNum">    1781 </span>            :  *      INDEX_CONSTR_CREATE_INIT_DEFERRED: constraint is INITIALLY DEFERRED
<span class="lineNum">    1782 </span>            :  *      INDEX_CONSTR_CREATE_UPDATE_INDEX: update the pg_index row
<span class="lineNum">    1783 </span>            :  *      INDEX_CONSTR_CREATE_REMOVE_OLD_DEPS: remove existing dependencies
<span class="lineNum">    1784 </span>            :  *          of index on table's columns
<span class="lineNum">    1785 </span>            :  * allow_system_table_mods: allow table to be a system catalog
<span class="lineNum">    1786 </span>            :  * is_internal: index is constructed due to internal process
<a name="1787"><span class="lineNum">    1787 </span>            :  */</a>
<span class="lineNum">    1788 </span>            : ObjectAddress
<span class="lineNum">    1789 </span><span class="lineCov">       1110 : index_constraint_create(Relation heapRelation,</span>
<span class="lineNum">    1790 </span>            :                         Oid indexRelationId,
<span class="lineNum">    1791 </span>            :                         Oid parentConstraintId,
<span class="lineNum">    1792 </span>            :                         IndexInfo *indexInfo,
<span class="lineNum">    1793 </span>            :                         const char *constraintName,
<span class="lineNum">    1794 </span>            :                         char constraintType,
<span class="lineNum">    1795 </span>            :                         bits16 constr_flags,
<span class="lineNum">    1796 </span>            :                         bool allow_system_table_mods,
<span class="lineNum">    1797 </span>            :                         bool is_internal)
<span class="lineNum">    1798 </span>            : {
<span class="lineNum">    1799 </span><span class="lineCov">       1110 :     Oid         namespaceId = RelationGetNamespace(heapRelation);</span>
<span class="lineNum">    1800 </span>            :     ObjectAddress myself,
<span class="lineNum">    1801 </span>            :                 idxaddr;
<span class="lineNum">    1802 </span>            :     Oid         conOid;
<span class="lineNum">    1803 </span>            :     bool        deferrable;
<span class="lineNum">    1804 </span>            :     bool        initdeferred;
<span class="lineNum">    1805 </span>            :     bool        mark_as_primary;
<span class="lineNum">    1806 </span>            :     bool        islocal;
<span class="lineNum">    1807 </span>            :     bool        noinherit;
<span class="lineNum">    1808 </span>            :     int         inhcount;
<span class="lineNum">    1809 </span>            : 
<span class="lineNum">    1810 </span><span class="lineCov">       1110 :     deferrable = (constr_flags &amp; INDEX_CONSTR_CREATE_DEFERRABLE) != 0;</span>
<span class="lineNum">    1811 </span><span class="lineCov">       1110 :     initdeferred = (constr_flags &amp; INDEX_CONSTR_CREATE_INIT_DEFERRED) != 0;</span>
<span class="lineNum">    1812 </span><span class="lineCov">       1110 :     mark_as_primary = (constr_flags &amp; INDEX_CONSTR_CREATE_MARK_AS_PRIMARY) != 0;</span>
<span class="lineNum">    1813 </span>            : 
<span class="lineNum">    1814 </span>            :     /* constraint creation support doesn't work while bootstrapping */
<span class="lineNum">    1815 </span><span class="lineCov">       1110 :     Assert(!IsBootstrapProcessingMode());</span>
<span class="lineNum">    1816 </span>            : 
<span class="lineNum">    1817 </span>            :     /* enforce system-table restriction */
<span class="lineNum">    1818 </span><span class="lineCov">       2220 :     if (!allow_system_table_mods &amp;&amp;</span>
<span class="lineNum">    1819 </span><span class="lineCov">       1110 :         IsSystemRelation(heapRelation) &amp;&amp;</span>
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :         IsNormalProcessingMode())</span>
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    1822 </span>            :                 (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">    1823 </span>            :                  errmsg(&quot;user-defined indexes on system catalog tables are not supported&quot;)));
<span class="lineNum">    1824 </span>            : 
<span class="lineNum">    1825 </span>            :     /* primary/unique constraints shouldn't have any expressions */
<span class="lineNum">    1826 </span><span class="lineCov">       1110 :     if (indexInfo-&gt;ii_Expressions &amp;&amp;</span>
<span class="lineNum">    1827 </span>            :         constraintType != CONSTRAINT_EXCLUSION)
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;constraints cannot have index expressions&quot;);</span>
<span class="lineNum">    1829 </span>            : 
<span class="lineNum">    1830 </span>            :     /*
<span class="lineNum">    1831 </span>            :      * If we're manufacturing a constraint for a pre-existing index, we need
<span class="lineNum">    1832 </span>            :      * to get rid of the existing auto dependencies for the index (the ones
<span class="lineNum">    1833 </span>            :      * that index_create() would have made instead of calling this function).
<span class="lineNum">    1834 </span>            :      *
<span class="lineNum">    1835 </span>            :      * Note: this code would not necessarily do the right thing if the index
<span class="lineNum">    1836 </span>            :      * has any expressions or predicate, but we'd never be turning such an
<span class="lineNum">    1837 </span>            :      * index into a UNIQUE or PRIMARY KEY constraint.
<span class="lineNum">    1838 </span>            :      */
<span class="lineNum">    1839 </span><span class="lineCov">       1110 :     if (constr_flags &amp; INDEX_CONSTR_CREATE_REMOVE_OLD_DEPS)</span>
<span class="lineNum">    1840 </span><span class="lineCov">         12 :         deleteDependencyRecordsForClass(RelationRelationId, indexRelationId,</span>
<span class="lineNum">    1841 </span>            :                                         RelationRelationId, DEPENDENCY_AUTO);
<span class="lineNum">    1842 </span>            : 
<span class="lineNum">    1843 </span><span class="lineCov">       1110 :     if (OidIsValid(parentConstraintId))</span>
<span class="lineNum">    1844 </span>            :     {
<span class="lineNum">    1845 </span><span class="lineCov">        160 :         islocal = false;</span>
<span class="lineNum">    1846 </span><span class="lineCov">        160 :         inhcount = 1;</span>
<span class="lineNum">    1847 </span><span class="lineCov">        160 :         noinherit = false;</span>
<span class="lineNum">    1848 </span>            :     }
<span class="lineNum">    1849 </span>            :     else
<span class="lineNum">    1850 </span>            :     {
<span class="lineNum">    1851 </span><span class="lineCov">        950 :         islocal = true;</span>
<span class="lineNum">    1852 </span><span class="lineCov">        950 :         inhcount = 0;</span>
<span class="lineNum">    1853 </span><span class="lineCov">        950 :         noinherit = true;</span>
<span class="lineNum">    1854 </span>            :     }
<span class="lineNum">    1855 </span>            : 
<span class="lineNum">    1856 </span>            :     /*
<span class="lineNum">    1857 </span>            :      * Construct a pg_constraint entry.
<span class="lineNum">    1858 </span>            :      */
<span class="lineNum">    1859 </span><span class="lineCov">       3330 :     conOid = CreateConstraintEntry(constraintName,</span>
<span class="lineNum">    1860 </span>            :                                    namespaceId,
<span class="lineNum">    1861 </span>            :                                    constraintType,
<span class="lineNum">    1862 </span>            :                                    deferrable,
<span class="lineNum">    1863 </span>            :                                    initdeferred,
<span class="lineNum">    1864 </span>            :                                    true,
<span class="lineNum">    1865 </span>            :                                    parentConstraintId,
<span class="lineNum">    1866 </span>            :                                    RelationGetRelid(heapRelation),
<span class="lineNum">    1867 </span><span class="lineCov">       1110 :                                    indexInfo-&gt;ii_IndexAttrNumbers,</span>
<span class="lineNum">    1868 </span>            :                                    indexInfo-&gt;ii_NumIndexKeyAttrs,
<span class="lineNum">    1869 </span>            :                                    indexInfo-&gt;ii_NumIndexAttrs,
<span class="lineNum">    1870 </span>            :                                    InvalidOid,  /* no domain */
<span class="lineNum">    1871 </span>            :                                    indexRelationId, /* index OID */
<span class="lineNum">    1872 </span>            :                                    InvalidOid,  /* no foreign key */
<span class="lineNum">    1873 </span>            :                                    NULL,
<span class="lineNum">    1874 </span>            :                                    NULL,
<span class="lineNum">    1875 </span>            :                                    NULL,
<span class="lineNum">    1876 </span>            :                                    NULL,
<span class="lineNum">    1877 </span>            :                                    0,
<span class="lineNum">    1878 </span>            :                                    ' ',
<span class="lineNum">    1879 </span>            :                                    ' ',
<span class="lineNum">    1880 </span>            :                                    ' ',
<span class="lineNum">    1881 </span><span class="lineCov">       1110 :                                    indexInfo-&gt;ii_ExclusionOps,</span>
<span class="lineNum">    1882 </span>            :                                    NULL,    /* no check constraint */
<span class="lineNum">    1883 </span>            :                                    NULL,
<span class="lineNum">    1884 </span>            :                                    islocal,
<span class="lineNum">    1885 </span>            :                                    inhcount,
<span class="lineNum">    1886 </span>            :                                    noinherit,
<span class="lineNum">    1887 </span>            :                                    is_internal);
<span class="lineNum">    1888 </span>            : 
<span class="lineNum">    1889 </span>            :     /*
<span class="lineNum">    1890 </span>            :      * Register the index as internally dependent on the constraint.
<span class="lineNum">    1891 </span>            :      *
<span class="lineNum">    1892 </span>            :      * Note that the constraint has a dependency on the table, so we don't
<span class="lineNum">    1893 </span>            :      * need (or want) any direct dependency from the index to the table.
<span class="lineNum">    1894 </span>            :      */
<span class="lineNum">    1895 </span><span class="lineCov">       1110 :     ObjectAddressSet(myself, ConstraintRelationId, conOid);</span>
<span class="lineNum">    1896 </span><span class="lineCov">       1110 :     ObjectAddressSet(idxaddr, RelationRelationId, indexRelationId);</span>
<span class="lineNum">    1897 </span><span class="lineCov">       1110 :     recordDependencyOn(&amp;idxaddr, &amp;myself, DEPENDENCY_INTERNAL);</span>
<span class="lineNum">    1898 </span>            : 
<span class="lineNum">    1899 </span>            :     /*
<span class="lineNum">    1900 </span>            :      * Also, if this is a constraint on a partition, give it partition-type
<span class="lineNum">    1901 </span>            :      * dependencies on the parent constraint as well as the table.
<span class="lineNum">    1902 </span>            :      */
<span class="lineNum">    1903 </span><span class="lineCov">       1110 :     if (OidIsValid(parentConstraintId))</span>
<span class="lineNum">    1904 </span>            :     {
<span class="lineNum">    1905 </span>            :         ObjectAddress referenced;
<span class="lineNum">    1906 </span>            : 
<span class="lineNum">    1907 </span><span class="lineCov">        160 :         ObjectAddressSet(referenced, ConstraintRelationId, parentConstraintId);</span>
<span class="lineNum">    1908 </span><span class="lineCov">        160 :         recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_PARTITION_PRI);</span>
<span class="lineNum">    1909 </span><span class="lineCov">        160 :         ObjectAddressSet(referenced, RelationRelationId,</span>
<span class="lineNum">    1910 </span>            :                          RelationGetRelid(heapRelation));
<span class="lineNum">    1911 </span><span class="lineCov">        160 :         recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_PARTITION_SEC);</span>
<span class="lineNum">    1912 </span>            :     }
<span class="lineNum">    1913 </span>            : 
<span class="lineNum">    1914 </span>            :     /*
<span class="lineNum">    1915 </span>            :      * If the constraint is deferrable, create the deferred uniqueness
<span class="lineNum">    1916 </span>            :      * checking trigger.  (The trigger will be given an internal dependency on
<span class="lineNum">    1917 </span>            :      * the constraint by CreateTrigger.)
<span class="lineNum">    1918 </span>            :      */
<span class="lineNum">    1919 </span><span class="lineCov">       1110 :     if (deferrable)</span>
<span class="lineNum">    1920 </span>            :     {
<span class="lineNum">    1921 </span>            :         CreateTrigStmt *trigger;
<span class="lineNum">    1922 </span>            : 
<span class="lineNum">    1923 </span><span class="lineCov">         26 :         trigger = makeNode(CreateTrigStmt);</span>
<span class="lineNum">    1924 </span><span class="lineCov">         26 :         trigger-&gt;trigname = (constraintType == CONSTRAINT_PRIMARY) ?</span>
<span class="lineNum">    1925 </span><span class="lineCov">         26 :             &quot;PK_ConstraintTrigger&quot; :</span>
<span class="lineNum">    1926 </span>            :             &quot;Unique_ConstraintTrigger&quot;;
<span class="lineNum">    1927 </span><span class="lineCov">         26 :         trigger-&gt;relation = NULL;</span>
<span class="lineNum">    1928 </span><span class="lineCov">         26 :         trigger-&gt;funcname = SystemFuncName(&quot;unique_key_recheck&quot;);</span>
<span class="lineNum">    1929 </span><span class="lineCov">         26 :         trigger-&gt;args = NIL;</span>
<span class="lineNum">    1930 </span><span class="lineCov">         26 :         trigger-&gt;row = true;</span>
<span class="lineNum">    1931 </span><span class="lineCov">         26 :         trigger-&gt;timing = TRIGGER_TYPE_AFTER;</span>
<span class="lineNum">    1932 </span><span class="lineCov">         26 :         trigger-&gt;events = TRIGGER_TYPE_INSERT | TRIGGER_TYPE_UPDATE;</span>
<span class="lineNum">    1933 </span><span class="lineCov">         26 :         trigger-&gt;columns = NIL;</span>
<span class="lineNum">    1934 </span><span class="lineCov">         26 :         trigger-&gt;whenClause = NULL;</span>
<span class="lineNum">    1935 </span><span class="lineCov">         26 :         trigger-&gt;isconstraint = true;</span>
<span class="lineNum">    1936 </span><span class="lineCov">         26 :         trigger-&gt;deferrable = true;</span>
<span class="lineNum">    1937 </span><span class="lineCov">         26 :         trigger-&gt;initdeferred = initdeferred;</span>
<span class="lineNum">    1938 </span><span class="lineCov">         26 :         trigger-&gt;constrrel = NULL;</span>
<span class="lineNum">    1939 </span>            : 
<span class="lineNum">    1940 </span><span class="lineCov">         26 :         (void) CreateTrigger(trigger, NULL, RelationGetRelid(heapRelation),</span>
<span class="lineNum">    1941 </span>            :                              InvalidOid, conOid, indexRelationId, InvalidOid,
<span class="lineNum">    1942 </span>            :                              InvalidOid, NULL, true, false);
<span class="lineNum">    1943 </span>            :     }
<span class="lineNum">    1944 </span>            : 
<span class="lineNum">    1945 </span>            :     /*
<span class="lineNum">    1946 </span>            :      * If needed, mark the index as primary and/or deferred in pg_index.
<span class="lineNum">    1947 </span>            :      *
<span class="lineNum">    1948 </span>            :      * Note: When making an existing index into a constraint, caller must have
<span class="lineNum">    1949 </span>            :      * a table lock that prevents concurrent table updates; otherwise, there
<span class="lineNum">    1950 </span>            :      * is a risk that concurrent readers of the table will miss seeing this
<span class="lineNum">    1951 </span>            :      * index at all.
<span class="lineNum">    1952 </span>            :      */
<span class="lineNum">    1953 </span><span class="lineCov">       1110 :     if ((constr_flags &amp; INDEX_CONSTR_CREATE_UPDATE_INDEX) &amp;&amp;</span>
<span class="lineNum">    1954 </span><span class="lineCov">          2 :         (mark_as_primary || deferrable))</span>
<span class="lineNum">    1955 </span>            :     {
<span class="lineNum">    1956 </span>            :         Relation    pg_index;
<span class="lineNum">    1957 </span>            :         HeapTuple   indexTuple;
<span class="lineNum">    1958 </span>            :         Form_pg_index indexForm;
<span class="lineNum">    1959 </span><span class="lineCov">         10 :         bool        dirty = false;</span>
<span class="lineNum">    1960 </span>            : 
<span class="lineNum">    1961 </span><span class="lineCov">         10 :         pg_index = table_open(IndexRelationId, RowExclusiveLock);</span>
<span class="lineNum">    1962 </span>            : 
<span class="lineNum">    1963 </span><span class="lineCov">         10 :         indexTuple = SearchSysCacheCopy1(INDEXRELID,</span>
<span class="lineNum">    1964 </span>            :                                          ObjectIdGetDatum(indexRelationId));
<span class="lineNum">    1965 </span><span class="lineCov">         10 :         if (!HeapTupleIsValid(indexTuple))</span>
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;cache lookup failed for index %u&quot;, indexRelationId);</span>
<span class="lineNum">    1967 </span><span class="lineCov">         10 :         indexForm = (Form_pg_index) GETSTRUCT(indexTuple);</span>
<span class="lineNum">    1968 </span>            : 
<span class="lineNum">    1969 </span><span class="lineCov">         10 :         if (mark_as_primary &amp;&amp; !indexForm-&gt;indisprimary)</span>
<span class="lineNum">    1970 </span>            :         {
<span class="lineNum">    1971 </span><span class="lineCov">         10 :             indexForm-&gt;indisprimary = true;</span>
<span class="lineNum">    1972 </span><span class="lineCov">         10 :             dirty = true;</span>
<span class="lineNum">    1973 </span>            :         }
<span class="lineNum">    1974 </span>            : 
<span class="lineNum">    1975 </span><span class="lineCov">         10 :         if (deferrable &amp;&amp; indexForm-&gt;indimmediate)</span>
<span class="lineNum">    1976 </span>            :         {
<span class="lineNum">    1977 </span><span class="lineNoCov">          0 :             indexForm-&gt;indimmediate = false;</span>
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :             dirty = true;</span>
<span class="lineNum">    1979 </span>            :         }
<span class="lineNum">    1980 </span>            : 
<span class="lineNum">    1981 </span><span class="lineCov">         10 :         if (dirty)</span>
<span class="lineNum">    1982 </span>            :         {
<span class="lineNum">    1983 </span><span class="lineCov">         10 :             CatalogTupleUpdate(pg_index, &amp;indexTuple-&gt;t_self, indexTuple);</span>
<span class="lineNum">    1984 </span>            : 
<span class="lineNum">    1985 </span><span class="lineCov">         10 :             InvokeObjectPostAlterHookArg(IndexRelationId, indexRelationId, 0,</span>
<span class="lineNum">    1986 </span>            :                                          InvalidOid, is_internal);
<span class="lineNum">    1987 </span>            :         }
<span class="lineNum">    1988 </span>            : 
<span class="lineNum">    1989 </span><span class="lineCov">         10 :         heap_freetuple(indexTuple);</span>
<span class="lineNum">    1990 </span><span class="lineCov">         10 :         table_close(pg_index, RowExclusiveLock);</span>
<span class="lineNum">    1991 </span>            :     }
<span class="lineNum">    1992 </span>            : 
<span class="lineNum">    1993 </span><span class="lineCov">       1110 :     return myself;</span>
<span class="lineNum">    1994 </span>            : }
<span class="lineNum">    1995 </span>            : 
<span class="lineNum">    1996 </span>            : /*
<span class="lineNum">    1997 </span>            :  *      index_drop
<span class="lineNum">    1998 </span>            :  *
<span class="lineNum">    1999 </span>            :  * NOTE: this routine should now only be called through performDeletion(),
<span class="lineNum">    2000 </span>            :  * else associated dependencies won't be cleaned up.
<span class="lineNum">    2001 </span>            :  *
<span class="lineNum">    2002 </span>            :  * If concurrent is true, do a DROP INDEX CONCURRENTLY.  If concurrent is
<span class="lineNum">    2003 </span>            :  * false but concurrent_lock_mode is true, then do a normal DROP INDEX but
<span class="lineNum">    2004 </span>            :  * take a lock for CONCURRENTLY processing.  That is used as part of REINDEX
<span class="lineNum">    2005 </span>            :  * CONCURRENTLY.
<a name="2006"><span class="lineNum">    2006 </span>            :  */</a>
<span class="lineNum">    2007 </span>            : void
<span class="lineNum">    2008 </span><span class="lineCov">       3718 : index_drop(Oid indexId, bool concurrent, bool concurrent_lock_mode)</span>
<span class="lineNum">    2009 </span>            : {
<span class="lineNum">    2010 </span>            :     Oid         heapId;
<span class="lineNum">    2011 </span>            :     Relation    userHeapRelation;
<span class="lineNum">    2012 </span>            :     Relation    userIndexRelation;
<span class="lineNum">    2013 </span>            :     Relation    indexRelation;
<span class="lineNum">    2014 </span>            :     HeapTuple   tuple;
<span class="lineNum">    2015 </span>            :     bool        hasexprs;
<span class="lineNum">    2016 </span>            :     LockRelId   heaprelid,
<span class="lineNum">    2017 </span>            :                 indexrelid;
<span class="lineNum">    2018 </span>            :     LOCKTAG     heaplocktag;
<span class="lineNum">    2019 </span>            :     LOCKMODE    lockmode;
<span class="lineNum">    2020 </span>            : 
<span class="lineNum">    2021 </span>            :     /*
<span class="lineNum">    2022 </span>            :      * To drop an index safely, we must grab exclusive lock on its parent
<span class="lineNum">    2023 </span>            :      * table.  Exclusive lock on the index alone is insufficient because
<span class="lineNum">    2024 </span>            :      * another backend might be about to execute a query on the parent table.
<span class="lineNum">    2025 </span>            :      * If it relies on a previously cached list of index OIDs, then it could
<span class="lineNum">    2026 </span>            :      * attempt to access the just-dropped index.  We must therefore take a
<span class="lineNum">    2027 </span>            :      * table lock strong enough to prevent all queries on the table from
<span class="lineNum">    2028 </span>            :      * proceeding until we commit and send out a shared-cache-inval notice
<span class="lineNum">    2029 </span>            :      * that will make them update their index lists.
<span class="lineNum">    2030 </span>            :      *
<span class="lineNum">    2031 </span>            :      * In the concurrent case we avoid this requirement by disabling index use
<span class="lineNum">    2032 </span>            :      * in multiple steps and waiting out any transactions that might be using
<span class="lineNum">    2033 </span>            :      * the index, so we don't need exclusive lock on the parent table. Instead
<span class="lineNum">    2034 </span>            :      * we take ShareUpdateExclusiveLock, to ensure that two sessions aren't
<span class="lineNum">    2035 </span>            :      * doing CREATE/DROP INDEX CONCURRENTLY on the same index.  (We will get
<span class="lineNum">    2036 </span>            :      * AccessExclusiveLock on the index below, once we're sure nobody else is
<span class="lineNum">    2037 </span>            :      * using it.)
<span class="lineNum">    2038 </span>            :      */
<span class="lineNum">    2039 </span><span class="lineCov">       3718 :     heapId = IndexGetRelation(indexId, false);</span>
<span class="lineNum">    2040 </span><span class="lineCov">       3718 :     lockmode = (concurrent || concurrent_lock_mode) ? ShareUpdateExclusiveLock : AccessExclusiveLock;</span>
<span class="lineNum">    2041 </span><span class="lineCov">       3718 :     userHeapRelation = table_open(heapId, lockmode);</span>
<span class="lineNum">    2042 </span><span class="lineCov">       3718 :     userIndexRelation = index_open(indexId, lockmode);</span>
<span class="lineNum">    2043 </span>            : 
<span class="lineNum">    2044 </span>            :     /*
<span class="lineNum">    2045 </span>            :      * We might still have open queries using it in our own session, which the
<span class="lineNum">    2046 </span>            :      * above locking won't prevent, so test explicitly.
<span class="lineNum">    2047 </span>            :      */
<span class="lineNum">    2048 </span><span class="lineCov">       3718 :     CheckTableNotInUse(userIndexRelation, &quot;DROP INDEX&quot;);</span>
<span class="lineNum">    2049 </span>            : 
<span class="lineNum">    2050 </span>            :     /*
<span class="lineNum">    2051 </span>            :      * Drop Index Concurrently is more or less the reverse process of Create
<span class="lineNum">    2052 </span>            :      * Index Concurrently.
<span class="lineNum">    2053 </span>            :      *
<span class="lineNum">    2054 </span>            :      * First we unset indisvalid so queries starting afterwards don't use the
<span class="lineNum">    2055 </span>            :      * index to answer queries anymore.  We have to keep indisready = true so
<span class="lineNum">    2056 </span>            :      * transactions that are still scanning the index can continue to see
<span class="lineNum">    2057 </span>            :      * valid index contents.  For instance, if they are using READ COMMITTED
<span class="lineNum">    2058 </span>            :      * mode, and another transaction makes changes and commits, they need to
<span class="lineNum">    2059 </span>            :      * see those new tuples in the index.
<span class="lineNum">    2060 </span>            :      *
<span class="lineNum">    2061 </span>            :      * After all transactions that could possibly have used the index for
<span class="lineNum">    2062 </span>            :      * queries end, we can unset indisready and indislive, then wait till
<span class="lineNum">    2063 </span>            :      * nobody could be touching it anymore.  (Note: we need indislive because
<span class="lineNum">    2064 </span>            :      * this state must be distinct from the initial state during CREATE INDEX
<span class="lineNum">    2065 </span>            :      * CONCURRENTLY, which has indislive true while indisready and indisvalid
<span class="lineNum">    2066 </span>            :      * are false.  That's because in that state, transactions must examine the
<span class="lineNum">    2067 </span>            :      * index for HOT-safety decisions, while in this state we don't want them
<span class="lineNum">    2068 </span>            :      * to open it at all.)
<span class="lineNum">    2069 </span>            :      *
<span class="lineNum">    2070 </span>            :      * Since all predicate locks on the index are about to be made invalid, we
<span class="lineNum">    2071 </span>            :      * must promote them to predicate locks on the heap.  In the
<span class="lineNum">    2072 </span>            :      * non-concurrent case we can just do that now.  In the concurrent case
<span class="lineNum">    2073 </span>            :      * it's a bit trickier.  The predicate locks must be moved when there are
<span class="lineNum">    2074 </span>            :      * no index scans in progress on the index and no more can subsequently
<span class="lineNum">    2075 </span>            :      * start, so that no new predicate locks can be made on the index.  Also,
<span class="lineNum">    2076 </span>            :      * they must be moved before heap inserts stop maintaining the index, else
<span class="lineNum">    2077 </span>            :      * the conflict with the predicate lock on the index gap could be missed
<span class="lineNum">    2078 </span>            :      * before the lock on the heap relation is in place to detect a conflict
<span class="lineNum">    2079 </span>            :      * based on the heap tuple insert.
<span class="lineNum">    2080 </span>            :      */
<span class="lineNum">    2081 </span><span class="lineCov">       3718 :     if (concurrent)</span>
<span class="lineNum">    2082 </span>            :     {
<span class="lineNum">    2083 </span>            :         /*
<span class="lineNum">    2084 </span>            :          * We must commit our transaction in order to make the first pg_index
<span class="lineNum">    2085 </span>            :          * state update visible to other sessions.  If the DROP machinery has
<span class="lineNum">    2086 </span>            :          * already performed any other actions (removal of other objects,
<span class="lineNum">    2087 </span>            :          * pg_depend entries, etc), the commit would make those actions
<span class="lineNum">    2088 </span>            :          * permanent, which would leave us with inconsistent catalog state if
<span class="lineNum">    2089 </span>            :          * we fail partway through the following sequence.  Since DROP INDEX
<span class="lineNum">    2090 </span>            :          * CONCURRENTLY is restricted to dropping just one index that has no
<span class="lineNum">    2091 </span>            :          * dependencies, we should get here before anything's been done ---
<span class="lineNum">    2092 </span>            :          * but let's check that to be sure.  We can verify that the current
<span class="lineNum">    2093 </span>            :          * transaction has not executed any transactional updates by checking
<span class="lineNum">    2094 </span>            :          * that no XID has been assigned.
<span class="lineNum">    2095 </span>            :          */
<span class="lineNum">    2096 </span><span class="lineCov">         12 :         if (GetTopTransactionIdIfAny() != InvalidTransactionId)</span>
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">    2098 </span>            :                     (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">    2099 </span>            :                      errmsg(&quot;DROP INDEX CONCURRENTLY must be first action in transaction&quot;)));
<span class="lineNum">    2100 </span>            : 
<span class="lineNum">    2101 </span>            :         /*
<span class="lineNum">    2102 </span>            :          * Mark index invalid by updating its pg_index entry
<span class="lineNum">    2103 </span>            :          */
<span class="lineNum">    2104 </span><span class="lineCov">         12 :         index_set_state_flags(indexId, INDEX_DROP_CLEAR_VALID);</span>
<span class="lineNum">    2105 </span>            : 
<span class="lineNum">    2106 </span>            :         /*
<span class="lineNum">    2107 </span>            :          * Invalidate the relcache for the table, so that after this commit
<span class="lineNum">    2108 </span>            :          * all sessions will refresh any cached plans that might reference the
<span class="lineNum">    2109 </span>            :          * index.
<span class="lineNum">    2110 </span>            :          */
<span class="lineNum">    2111 </span><span class="lineCov">         12 :         CacheInvalidateRelcache(userHeapRelation);</span>
<span class="lineNum">    2112 </span>            : 
<span class="lineNum">    2113 </span>            :         /* save lockrelid and locktag for below, then close but keep locks */
<span class="lineNum">    2114 </span><span class="lineCov">         12 :         heaprelid = userHeapRelation-&gt;rd_lockInfo.lockRelId;</span>
<span class="lineNum">    2115 </span><span class="lineCov">         12 :         SET_LOCKTAG_RELATION(heaplocktag, heaprelid.dbId, heaprelid.relId);</span>
<span class="lineNum">    2116 </span><span class="lineCov">         12 :         indexrelid = userIndexRelation-&gt;rd_lockInfo.lockRelId;</span>
<span class="lineNum">    2117 </span>            : 
<span class="lineNum">    2118 </span><span class="lineCov">         12 :         table_close(userHeapRelation, NoLock);</span>
<span class="lineNum">    2119 </span><span class="lineCov">         12 :         index_close(userIndexRelation, NoLock);</span>
<span class="lineNum">    2120 </span>            : 
<span class="lineNum">    2121 </span>            :         /*
<span class="lineNum">    2122 </span>            :          * We must commit our current transaction so that the indisvalid
<span class="lineNum">    2123 </span>            :          * update becomes visible to other transactions; then start another.
<span class="lineNum">    2124 </span>            :          * Note that any previously-built data structures are lost in the
<span class="lineNum">    2125 </span>            :          * commit.  The only data we keep past here are the relation IDs.
<span class="lineNum">    2126 </span>            :          *
<span class="lineNum">    2127 </span>            :          * Before committing, get a session-level lock on the table, to ensure
<span class="lineNum">    2128 </span>            :          * that neither it nor the index can be dropped before we finish. This
<span class="lineNum">    2129 </span>            :          * cannot block, even if someone else is waiting for access, because
<span class="lineNum">    2130 </span>            :          * we already have the same lock within our transaction.
<span class="lineNum">    2131 </span>            :          */
<span class="lineNum">    2132 </span><span class="lineCov">         12 :         LockRelationIdForSession(&amp;heaprelid, ShareUpdateExclusiveLock);</span>
<span class="lineNum">    2133 </span><span class="lineCov">         12 :         LockRelationIdForSession(&amp;indexrelid, ShareUpdateExclusiveLock);</span>
<span class="lineNum">    2134 </span>            : 
<span class="lineNum">    2135 </span><span class="lineCov">         12 :         PopActiveSnapshot();</span>
<span class="lineNum">    2136 </span><span class="lineCov">         12 :         CommitTransactionCommand();</span>
<span class="lineNum">    2137 </span><span class="lineCov">         12 :         StartTransactionCommand();</span>
<span class="lineNum">    2138 </span>            : 
<span class="lineNum">    2139 </span>            :         /*
<span class="lineNum">    2140 </span>            :          * Now we must wait until no running transaction could be using the
<span class="lineNum">    2141 </span>            :          * index for a query.  Use AccessExclusiveLock here to check for
<span class="lineNum">    2142 </span>            :          * running transactions that hold locks of any kind on the table. Note
<span class="lineNum">    2143 </span>            :          * we do not need to worry about xacts that open the table for reading
<span class="lineNum">    2144 </span>            :          * after this point; they will see the index as invalid when they open
<span class="lineNum">    2145 </span>            :          * the relation.
<span class="lineNum">    2146 </span>            :          *
<span class="lineNum">    2147 </span>            :          * Note: the reason we use actual lock acquisition here, rather than
<span class="lineNum">    2148 </span>            :          * just checking the ProcArray and sleeping, is that deadlock is
<span class="lineNum">    2149 </span>            :          * possible if one of the transactions in question is blocked trying
<span class="lineNum">    2150 </span>            :          * to acquire an exclusive lock on our table.  The lock code will
<span class="lineNum">    2151 </span>            :          * detect deadlock and error out properly.
<span class="lineNum">    2152 </span>            :          *
<span class="lineNum">    2153 </span>            :          * Note: we report progress through WaitForLockers() unconditionally
<span class="lineNum">    2154 </span>            :          * here, even though it will only be used when we're called by REINDEX
<span class="lineNum">    2155 </span>            :          * CONCURRENTLY and not when called by DROP INDEX CONCURRENTLY.
<span class="lineNum">    2156 </span>            :          */
<span class="lineNum">    2157 </span><span class="lineCov">         12 :         WaitForLockers(heaplocktag, AccessExclusiveLock, true);</span>
<span class="lineNum">    2158 </span>            : 
<span class="lineNum">    2159 </span>            :         /* Finish invalidation of index and mark it as dead */
<span class="lineNum">    2160 </span><span class="lineCov">         12 :         index_concurrently_set_dead(heapId, indexId);</span>
<span class="lineNum">    2161 </span>            : 
<span class="lineNum">    2162 </span>            :         /*
<span class="lineNum">    2163 </span>            :          * Again, commit the transaction to make the pg_index update visible
<span class="lineNum">    2164 </span>            :          * to other sessions.
<span class="lineNum">    2165 </span>            :          */
<span class="lineNum">    2166 </span><span class="lineCov">         12 :         CommitTransactionCommand();</span>
<span class="lineNum">    2167 </span><span class="lineCov">         12 :         StartTransactionCommand();</span>
<span class="lineNum">    2168 </span>            : 
<span class="lineNum">    2169 </span>            :         /*
<span class="lineNum">    2170 </span>            :          * Wait till every transaction that saw the old index state has
<span class="lineNum">    2171 </span>            :          * finished.  See above about progress reporting.
<span class="lineNum">    2172 </span>            :          */
<span class="lineNum">    2173 </span><span class="lineCov">         12 :         WaitForLockers(heaplocktag, AccessExclusiveLock, true);</span>
<span class="lineNum">    2174 </span>            : 
<span class="lineNum">    2175 </span>            :         /*
<span class="lineNum">    2176 </span>            :          * Re-open relations to allow us to complete our actions.
<span class="lineNum">    2177 </span>            :          *
<span class="lineNum">    2178 </span>            :          * At this point, nothing should be accessing the index, but lets
<span class="lineNum">    2179 </span>            :          * leave nothing to chance and grab AccessExclusiveLock on the index
<span class="lineNum">    2180 </span>            :          * before the physical deletion.
<span class="lineNum">    2181 </span>            :          */
<span class="lineNum">    2182 </span><span class="lineCov">         12 :         userHeapRelation = table_open(heapId, ShareUpdateExclusiveLock);</span>
<span class="lineNum">    2183 </span><span class="lineCov">         12 :         userIndexRelation = index_open(indexId, AccessExclusiveLock);</span>
<span class="lineNum">    2184 </span>            :     }
<span class="lineNum">    2185 </span>            :     else
<span class="lineNum">    2186 </span>            :     {
<span class="lineNum">    2187 </span>            :         /* Not concurrent, so just transfer predicate locks and we're good */
<span class="lineNum">    2188 </span><span class="lineCov">       3706 :         TransferPredicateLocksToHeapRelation(userIndexRelation);</span>
<span class="lineNum">    2189 </span>            :     }
<span class="lineNum">    2190 </span>            : 
<span class="lineNum">    2191 </span>            :     /*
<span class="lineNum">    2192 </span>            :      * Schedule physical removal of the files (if any)
<span class="lineNum">    2193 </span>            :      */
<span class="lineNum">    2194 </span><span class="lineCov">       3718 :     if (userIndexRelation-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_INDEX)</span>
<span class="lineNum">    2195 </span><span class="lineCov">       3434 :         RelationDropStorage(userIndexRelation);</span>
<span class="lineNum">    2196 </span>            : 
<span class="lineNum">    2197 </span>            :     /*
<span class="lineNum">    2198 </span>            :      * Close and flush the index's relcache entry, to ensure relcache doesn't
<span class="lineNum">    2199 </span>            :      * try to rebuild it while we're deleting catalog entries. We keep the
<span class="lineNum">    2200 </span>            :      * lock though.
<span class="lineNum">    2201 </span>            :      */
<span class="lineNum">    2202 </span><span class="lineCov">       3718 :     index_close(userIndexRelation, NoLock);</span>
<span class="lineNum">    2203 </span>            : 
<span class="lineNum">    2204 </span><span class="lineCov">       3718 :     RelationForgetRelation(indexId);</span>
<span class="lineNum">    2205 </span>            : 
<span class="lineNum">    2206 </span>            :     /*
<span class="lineNum">    2207 </span>            :      * fix INDEX relation, and check for expressional index
<span class="lineNum">    2208 </span>            :      */
<span class="lineNum">    2209 </span><span class="lineCov">       3718 :     indexRelation = table_open(IndexRelationId, RowExclusiveLock);</span>
<span class="lineNum">    2210 </span>            : 
<span class="lineNum">    2211 </span><span class="lineCov">       3718 :     tuple = SearchSysCache1(INDEXRELID, ObjectIdGetDatum(indexId));</span>
<span class="lineNum">    2212 </span><span class="lineCov">       3718 :     if (!HeapTupleIsValid(tuple))</span>
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cache lookup failed for index %u&quot;, indexId);</span>
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span><span class="lineCov">       7436 :     hasexprs = !heap_attisnull(tuple, Anum_pg_index_indexprs,</span>
<span class="lineNum">    2216 </span><span class="lineCov">       3718 :                                RelationGetDescr(indexRelation));</span>
<span class="lineNum">    2217 </span>            : 
<span class="lineNum">    2218 </span><span class="lineCov">       3718 :     CatalogTupleDelete(indexRelation, &amp;tuple-&gt;t_self);</span>
<span class="lineNum">    2219 </span>            : 
<span class="lineNum">    2220 </span><span class="lineCov">       3718 :     ReleaseSysCache(tuple);</span>
<span class="lineNum">    2221 </span><span class="lineCov">       3718 :     table_close(indexRelation, RowExclusiveLock);</span>
<span class="lineNum">    2222 </span>            : 
<span class="lineNum">    2223 </span>            :     /*
<span class="lineNum">    2224 </span>            :      * if it has any expression columns, we might have stored statistics about
<span class="lineNum">    2225 </span>            :      * them.
<span class="lineNum">    2226 </span>            :      */
<span class="lineNum">    2227 </span><span class="lineCov">       3718 :     if (hasexprs)</span>
<span class="lineNum">    2228 </span><span class="lineCov">        142 :         RemoveStatistics(indexId, 0);</span>
<span class="lineNum">    2229 </span>            : 
<span class="lineNum">    2230 </span>            :     /*
<span class="lineNum">    2231 </span>            :      * fix ATTRIBUTE relation
<span class="lineNum">    2232 </span>            :      */
<span class="lineNum">    2233 </span><span class="lineCov">       3718 :     DeleteAttributeTuples(indexId);</span>
<span class="lineNum">    2234 </span>            : 
<span class="lineNum">    2235 </span>            :     /*
<span class="lineNum">    2236 </span>            :      * fix RELATION relation
<span class="lineNum">    2237 </span>            :      */
<span class="lineNum">    2238 </span><span class="lineCov">       3718 :     DeleteRelationTuple(indexId);</span>
<span class="lineNum">    2239 </span>            : 
<span class="lineNum">    2240 </span>            :     /*
<span class="lineNum">    2241 </span>            :      * fix INHERITS relation
<span class="lineNum">    2242 </span>            :      */
<span class="lineNum">    2243 </span><span class="lineCov">       3718 :     DeleteInheritsTuple(indexId, InvalidOid);</span>
<span class="lineNum">    2244 </span>            : 
<span class="lineNum">    2245 </span>            :     /*
<span class="lineNum">    2246 </span>            :      * We are presently too lazy to attempt to compute the new correct value
<span class="lineNum">    2247 </span>            :      * of relhasindex (the next VACUUM will fix it if necessary). So there is
<span class="lineNum">    2248 </span>            :      * no need to update the pg_class tuple for the owning relation. But we
<span class="lineNum">    2249 </span>            :      * must send out a shared-cache-inval notice on the owning relation to
<span class="lineNum">    2250 </span>            :      * ensure other backends update their relcache lists of indexes.  (In the
<span class="lineNum">    2251 </span>            :      * concurrent case, this is redundant but harmless.)
<span class="lineNum">    2252 </span>            :      */
<span class="lineNum">    2253 </span><span class="lineCov">       3718 :     CacheInvalidateRelcache(userHeapRelation);</span>
<span class="lineNum">    2254 </span>            : 
<span class="lineNum">    2255 </span>            :     /*
<span class="lineNum">    2256 </span>            :      * Close owning rel, but keep lock
<span class="lineNum">    2257 </span>            :      */
<span class="lineNum">    2258 </span><span class="lineCov">       3718 :     table_close(userHeapRelation, NoLock);</span>
<span class="lineNum">    2259 </span>            : 
<span class="lineNum">    2260 </span>            :     /*
<span class="lineNum">    2261 </span>            :      * Release the session locks before we go.
<span class="lineNum">    2262 </span>            :      */
<span class="lineNum">    2263 </span><span class="lineCov">       3718 :     if (concurrent)</span>
<span class="lineNum">    2264 </span>            :     {
<span class="lineNum">    2265 </span><span class="lineCov">         12 :         UnlockRelationIdForSession(&amp;heaprelid, ShareUpdateExclusiveLock);</span>
<span class="lineNum">    2266 </span><span class="lineCov">         12 :         UnlockRelationIdForSession(&amp;indexrelid, ShareUpdateExclusiveLock);</span>
<span class="lineNum">    2267 </span>            :     }
<span class="lineNum">    2268 </span><span class="lineCov">       3718 : }</span>
<span class="lineNum">    2269 </span>            : 
<span class="lineNum">    2270 </span>            : /* ----------------------------------------------------------------
<span class="lineNum">    2271 </span>            :  *                      index_build support
<span class="lineNum">    2272 </span>            :  * ----------------------------------------------------------------
<span class="lineNum">    2273 </span>            :  */
<span class="lineNum">    2274 </span>            : 
<span class="lineNum">    2275 </span>            : /* ----------------
<span class="lineNum">    2276 </span>            :  *      BuildIndexInfo
<span class="lineNum">    2277 </span>            :  *          Construct an IndexInfo record for an open index
<span class="lineNum">    2278 </span>            :  *
<span class="lineNum">    2279 </span>            :  * IndexInfo stores the information about the index that's needed by
<span class="lineNum">    2280 </span>            :  * FormIndexDatum, which is used for both index_build() and later insertion
<span class="lineNum">    2281 </span>            :  * of individual index tuples.  Normally we build an IndexInfo for an index
<span class="lineNum">    2282 </span>            :  * just once per command, and then use it for (potentially) many tuples.
<span class="lineNum">    2283 </span>            :  * ----------------
<a name="2284"><span class="lineNum">    2284 </span>            :  */</a>
<span class="lineNum">    2285 </span>            : IndexInfo *
<span class="lineNum">    2286 </span><span class="lineCov">     348172 : BuildIndexInfo(Relation index)</span>
<span class="lineNum">    2287 </span>            : {
<span class="lineNum">    2288 </span>            :     IndexInfo  *ii;
<span class="lineNum">    2289 </span><span class="lineCov">     348172 :     Form_pg_index indexStruct = index-&gt;rd_index;</span>
<span class="lineNum">    2290 </span>            :     int         i;
<span class="lineNum">    2291 </span>            :     int         numAtts;
<span class="lineNum">    2292 </span>            : 
<span class="lineNum">    2293 </span>            :     /* check the number of keys, and copy attr numbers into the IndexInfo */
<span class="lineNum">    2294 </span><span class="lineCov">     348172 :     numAtts = indexStruct-&gt;indnatts;</span>
<span class="lineNum">    2295 </span><span class="lineCov">     348172 :     if (numAtts &lt; 1 || numAtts &gt; INDEX_MAX_KEYS)</span>
<span class="lineNum">    2296 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;invalid indnatts %d for index %u&quot;,</span>
<span class="lineNum">    2297 </span>            :              numAtts, RelationGetRelid(index));
<span class="lineNum">    2298 </span>            : 
<span class="lineNum">    2299 </span>            :     /*
<span class="lineNum">    2300 </span>            :      * Create the node, fetching any expressions needed for expressional
<span class="lineNum">    2301 </span>            :      * indexes and index predicate if any.
<span class="lineNum">    2302 </span>            :      */
<span class="lineNum">    2303 </span><span class="lineCov">    1392688 :     ii = makeIndexInfo(indexStruct-&gt;indnatts,</span>
<span class="lineNum">    2304 </span><span class="lineCov">     348172 :                        indexStruct-&gt;indnkeyatts,</span>
<span class="lineNum">    2305 </span><span class="lineCov">     348172 :                        index-&gt;rd_rel-&gt;relam,</span>
<span class="lineNum">    2306 </span>            :                        RelationGetIndexExpressions(index),
<span class="lineNum">    2307 </span>            :                        RelationGetIndexPredicate(index),
<span class="lineNum">    2308 </span><span class="lineCov">     348172 :                        indexStruct-&gt;indisunique,</span>
<span class="lineNum">    2309 </span><span class="lineCov">     348172 :                        indexStruct-&gt;indisready,</span>
<span class="lineNum">    2310 </span>            :                        false);
<span class="lineNum">    2311 </span>            : 
<span class="lineNum">    2312 </span>            :     /* fill in attribute numbers */
<span class="lineNum">    2313 </span><span class="lineCov">    1096476 :     for (i = 0; i &lt; numAtts; i++)</span>
<span class="lineNum">    2314 </span><span class="lineCov">     748304 :         ii-&gt;ii_IndexAttrNumbers[i] = indexStruct-&gt;indkey.values[i];</span>
<span class="lineNum">    2315 </span>            : 
<span class="lineNum">    2316 </span>            :     /* fetch exclusion constraint info if any */
<span class="lineNum">    2317 </span><span class="lineCov">     348172 :     if (indexStruct-&gt;indisexclusion)</span>
<span class="lineNum">    2318 </span>            :     {
<span class="lineNum">    2319 </span><span class="lineCov">        104 :         RelationGetExclusionInfo(index,</span>
<span class="lineNum">    2320 </span>            :                                  &amp;ii-&gt;ii_ExclusionOps,
<span class="lineNum">    2321 </span>            :                                  &amp;ii-&gt;ii_ExclusionProcs,
<span class="lineNum">    2322 </span>            :                                  &amp;ii-&gt;ii_ExclusionStrats);
<span class="lineNum">    2323 </span>            :     }
<span class="lineNum">    2324 </span>            : 
<span class="lineNum">    2325 </span><span class="lineCov">     348172 :     return ii;</span>
<span class="lineNum">    2326 </span>            : }
<span class="lineNum">    2327 </span>            : 
<span class="lineNum">    2328 </span>            : /*
<span class="lineNum">    2329 </span>            :  * CompareIndexInfo
<span class="lineNum">    2330 </span>            :  *      Return whether the properties of two indexes (in different tables)
<span class="lineNum">    2331 </span>            :  *      indicate that they have the &quot;same&quot; definitions.
<span class="lineNum">    2332 </span>            :  *
<span class="lineNum">    2333 </span>            :  * Note: passing collations and opfamilies separately is a kludge.  Adding
<span class="lineNum">    2334 </span>            :  * them to IndexInfo may result in better coding here and elsewhere.
<span class="lineNum">    2335 </span>            :  *
<span class="lineNum">    2336 </span>            :  * Use convert_tuples_by_name_map(index2, index1) to build the attmap.
<a name="2337"><span class="lineNum">    2337 </span>            :  */</a>
<span class="lineNum">    2338 </span>            : bool
<span class="lineNum">    2339 </span><span class="lineCov">        116 : CompareIndexInfo(IndexInfo *info1, IndexInfo *info2,</span>
<span class="lineNum">    2340 </span>            :                  Oid *collations1, Oid *collations2,
<span class="lineNum">    2341 </span>            :                  Oid *opfamilies1, Oid *opfamilies2,
<span class="lineNum">    2342 </span>            :                  AttrNumber *attmap, int maplen)
<span class="lineNum">    2343 </span>            : {
<span class="lineNum">    2344 </span>            :     int         i;
<span class="lineNum">    2345 </span>            : 
<span class="lineNum">    2346 </span><span class="lineCov">        116 :     if (info1-&gt;ii_Unique != info2-&gt;ii_Unique)</span>
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2348 </span>            : 
<span class="lineNum">    2349 </span>            :     /* indexes are only equivalent if they have the same access method */
<span class="lineNum">    2350 </span><span class="lineCov">        116 :     if (info1-&gt;ii_Am != info2-&gt;ii_Am)</span>
<span class="lineNum">    2351 </span><span class="lineCov">          4 :         return false;</span>
<span class="lineNum">    2352 </span>            : 
<span class="lineNum">    2353 </span>            :     /* and same number of attributes */
<span class="lineNum">    2354 </span><span class="lineCov">        112 :     if (info1-&gt;ii_NumIndexAttrs != info2-&gt;ii_NumIndexAttrs)</span>
<span class="lineNum">    2355 </span><span class="lineCov">          8 :         return false;</span>
<span class="lineNum">    2356 </span>            : 
<span class="lineNum">    2357 </span>            :     /* and same number of key attributes */
<span class="lineNum">    2358 </span><span class="lineCov">        104 :     if (info1-&gt;ii_NumIndexKeyAttrs != info2-&gt;ii_NumIndexKeyAttrs)</span>
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2360 </span>            : 
<span class="lineNum">    2361 </span>            :     /*
<span class="lineNum">    2362 </span>            :      * and columns match through the attribute map (actual attribute numbers
<span class="lineNum">    2363 </span>            :      * might differ!)  Note that this implies that index columns that are
<span class="lineNum">    2364 </span>            :      * expressions appear in the same positions.  We will next compare the
<span class="lineNum">    2365 </span>            :      * expressions themselves.
<span class="lineNum">    2366 </span>            :      */
<span class="lineNum">    2367 </span><span class="lineCov">        210 :     for (i = 0; i &lt; info1-&gt;ii_NumIndexAttrs; i++)</span>
<span class="lineNum">    2368 </span>            :     {
<span class="lineNum">    2369 </span><span class="lineCov">        118 :         if (maplen &lt; info2-&gt;ii_IndexAttrNumbers[i])</span>
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;incorrect attribute map&quot;);</span>
<span class="lineNum">    2371 </span>            : 
<span class="lineNum">    2372 </span>            :         /* ignore expressions at this stage */
<span class="lineNum">    2373 </span><span class="lineCov">        224 :         if ((info1-&gt;ii_IndexAttrNumbers[i] != InvalidAttrNumber) &amp;&amp;</span>
<span class="lineNum">    2374 </span><span class="lineCov">        106 :             (attmap[info2-&gt;ii_IndexAttrNumbers[i] - 1] !=</span>
<span class="lineNum">    2375 </span><span class="lineCov">        106 :              info1-&gt;ii_IndexAttrNumbers[i]))</span>
<span class="lineNum">    2376 </span><span class="lineCov">          4 :             return false;</span>
<span class="lineNum">    2377 </span>            : 
<span class="lineNum">    2378 </span>            :         /* collation and opfamily is not valid for including columns */
<span class="lineNum">    2379 </span><span class="lineCov">        114 :         if (i &gt;= info1-&gt;ii_NumIndexKeyAttrs)</span>
<span class="lineNum">    2380 </span><span class="lineCov">          2 :             continue;</span>
<span class="lineNum">    2381 </span>            : 
<span class="lineNum">    2382 </span><span class="lineCov">        112 :         if (collations1[i] != collations2[i])</span>
<span class="lineNum">    2383 </span><span class="lineCov">          4 :             return false;</span>
<span class="lineNum">    2384 </span><span class="lineCov">        108 :         if (opfamilies1[i] != opfamilies2[i])</span>
<span class="lineNum">    2385 </span><span class="lineCov">          4 :             return false;</span>
<span class="lineNum">    2386 </span>            :     }
<span class="lineNum">    2387 </span>            : 
<span class="lineNum">    2388 </span>            :     /*
<span class="lineNum">    2389 </span>            :      * For expression indexes: either both are expression indexes, or neither
<span class="lineNum">    2390 </span>            :      * is; if they are, make sure the expressions match.
<span class="lineNum">    2391 </span>            :      */
<span class="lineNum">    2392 </span><span class="lineCov">         92 :     if ((info1-&gt;ii_Expressions != NIL) != (info2-&gt;ii_Expressions != NIL))</span>
<span class="lineNum">    2393 </span><span class="lineCov">          2 :         return false;</span>
<span class="lineNum">    2394 </span><span class="lineCov">         90 :     if (info1-&gt;ii_Expressions != NIL)</span>
<span class="lineNum">    2395 </span>            :     {
<span class="lineNum">    2396 </span>            :         bool        found_whole_row;
<span class="lineNum">    2397 </span>            :         Node       *mapped;
<span class="lineNum">    2398 </span>            : 
<span class="lineNum">    2399 </span><span class="lineCov">         10 :         mapped = map_variable_attnos((Node *) info2-&gt;ii_Expressions,</span>
<span class="lineNum">    2400 </span>            :                                      1, 0, attmap, maplen,
<span class="lineNum">    2401 </span>            :                                      InvalidOid, &amp;found_whole_row);
<span class="lineNum">    2402 </span><span class="lineCov">         10 :         if (found_whole_row)</span>
<span class="lineNum">    2403 </span>            :         {
<span class="lineNum">    2404 </span>            :             /*
<span class="lineNum">    2405 </span>            :              * we could throw an error here, but seems out of scope for this
<span class="lineNum">    2406 </span>            :              * routine.
<span class="lineNum">    2407 </span>            :              */
<span class="lineNum">    2408 </span><span class="lineCov">          2 :             return false;</span>
<span class="lineNum">    2409 </span>            :         }
<span class="lineNum">    2410 </span>            : 
<span class="lineNum">    2411 </span><span class="lineCov">         10 :         if (!equal(info1-&gt;ii_Expressions, mapped))</span>
<span class="lineNum">    2412 </span><span class="lineCov">          2 :             return false;</span>
<span class="lineNum">    2413 </span>            :     }
<span class="lineNum">    2414 </span>            : 
<span class="lineNum">    2415 </span>            :     /* Partial index predicates must be identical, if they exist */
<span class="lineNum">    2416 </span><span class="lineCov">         88 :     if ((info1-&gt;ii_Predicate == NULL) != (info2-&gt;ii_Predicate == NULL))</span>
<span class="lineNum">    2417 </span><span class="lineCov">          4 :         return false;</span>
<span class="lineNum">    2418 </span><span class="lineCov">         84 :     if (info1-&gt;ii_Predicate != NULL)</span>
<span class="lineNum">    2419 </span>            :     {
<span class="lineNum">    2420 </span>            :         bool        found_whole_row;
<span class="lineNum">    2421 </span>            :         Node       *mapped;
<span class="lineNum">    2422 </span>            : 
<span class="lineNum">    2423 </span><span class="lineCov">          6 :         mapped = map_variable_attnos((Node *) info2-&gt;ii_Predicate,</span>
<span class="lineNum">    2424 </span>            :                                      1, 0, attmap, maplen,
<span class="lineNum">    2425 </span>            :                                      InvalidOid, &amp;found_whole_row);
<span class="lineNum">    2426 </span><span class="lineCov">          6 :         if (found_whole_row)</span>
<span class="lineNum">    2427 </span>            :         {
<span class="lineNum">    2428 </span>            :             /*
<span class="lineNum">    2429 </span>            :              * we could throw an error here, but seems out of scope for this
<span class="lineNum">    2430 </span>            :              * routine.
<span class="lineNum">    2431 </span>            :              */
<span class="lineNum">    2432 </span><span class="lineCov">          2 :             return false;</span>
<span class="lineNum">    2433 </span>            :         }
<span class="lineNum">    2434 </span><span class="lineCov">          6 :         if (!equal(info1-&gt;ii_Predicate, mapped))</span>
<span class="lineNum">    2435 </span><span class="lineCov">          2 :             return false;</span>
<span class="lineNum">    2436 </span>            :     }
<span class="lineNum">    2437 </span>            : 
<span class="lineNum">    2438 </span>            :     /* No support currently for comparing exclusion indexes. */
<span class="lineNum">    2439 </span><span class="lineCov">         82 :     if (info1-&gt;ii_ExclusionOps != NULL || info2-&gt;ii_ExclusionOps != NULL)</span>
<span class="lineNum">    2440 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2441 </span>            : 
<span class="lineNum">    2442 </span><span class="lineCov">         82 :     return true;</span>
<span class="lineNum">    2443 </span>            : }
<span class="lineNum">    2444 </span>            : 
<span class="lineNum">    2445 </span>            : /* ----------------
<span class="lineNum">    2446 </span>            :  *      BuildSpeculativeIndexInfo
<span class="lineNum">    2447 </span>            :  *          Add extra state to IndexInfo record
<span class="lineNum">    2448 </span>            :  *
<span class="lineNum">    2449 </span>            :  * For unique indexes, we usually don't want to add info to the IndexInfo for
<span class="lineNum">    2450 </span>            :  * checking uniqueness, since the B-Tree AM handles that directly.  However,
<span class="lineNum">    2451 </span>            :  * in the case of speculative insertion, additional support is required.
<span class="lineNum">    2452 </span>            :  *
<span class="lineNum">    2453 </span>            :  * Do this processing here rather than in BuildIndexInfo() to not incur the
<span class="lineNum">    2454 </span>            :  * overhead in the common non-speculative cases.
<span class="lineNum">    2455 </span>            :  * ----------------
<a name="2456"><span class="lineNum">    2456 </span>            :  */</a>
<span class="lineNum">    2457 </span>            : void
<span class="lineNum">    2458 </span><span class="lineCov">        480 : BuildSpeculativeIndexInfo(Relation index, IndexInfo *ii)</span>
<span class="lineNum">    2459 </span>            : {
<span class="lineNum">    2460 </span>            :     int         indnkeyatts;
<span class="lineNum">    2461 </span>            :     int         i;
<span class="lineNum">    2462 </span>            : 
<span class="lineNum">    2463 </span><span class="lineCov">        480 :     indnkeyatts = IndexRelationGetNumberOfKeyAttributes(index);</span>
<span class="lineNum">    2464 </span>            : 
<span class="lineNum">    2465 </span>            :     /*
<span class="lineNum">    2466 </span>            :      * fetch info for checking unique indexes
<span class="lineNum">    2467 </span>            :      */
<span class="lineNum">    2468 </span><span class="lineCov">        480 :     Assert(ii-&gt;ii_Unique);</span>
<span class="lineNum">    2469 </span>            : 
<span class="lineNum">    2470 </span><span class="lineCov">        480 :     if (index-&gt;rd_rel-&gt;relam != BTREE_AM_OID)</span>
<span class="lineNum">    2471 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;unexpected non-btree speculative unique index&quot;);</span>
<span class="lineNum">    2472 </span>            : 
<span class="lineNum">    2473 </span><span class="lineCov">        480 :     ii-&gt;ii_UniqueOps = (Oid *) palloc(sizeof(Oid) * indnkeyatts);</span>
<span class="lineNum">    2474 </span><span class="lineCov">        480 :     ii-&gt;ii_UniqueProcs = (Oid *) palloc(sizeof(Oid) * indnkeyatts);</span>
<span class="lineNum">    2475 </span><span class="lineCov">        480 :     ii-&gt;ii_UniqueStrats = (uint16 *) palloc(sizeof(uint16) * indnkeyatts);</span>
<span class="lineNum">    2476 </span>            : 
<span class="lineNum">    2477 </span>            :     /*
<span class="lineNum">    2478 </span>            :      * We have to look up the operator's strategy number.  This provides a
<span class="lineNum">    2479 </span>            :      * cross-check that the operator does match the index.
<span class="lineNum">    2480 </span>            :      */
<span class="lineNum">    2481 </span>            :     /* We need the func OIDs and strategy numbers too */
<span class="lineNum">    2482 </span><span class="lineCov">       1080 :     for (i = 0; i &lt; indnkeyatts; i++)</span>
<span class="lineNum">    2483 </span>            :     {
<span class="lineNum">    2484 </span><span class="lineCov">        600 :         ii-&gt;ii_UniqueStrats[i] = BTEqualStrategyNumber;</span>
<span class="lineNum">    2485 </span><span class="lineCov">       1200 :         ii-&gt;ii_UniqueOps[i] =</span>
<span class="lineNum">    2486 </span><span class="lineCov">       1800 :             get_opfamily_member(index-&gt;rd_opfamily[i],</span>
<span class="lineNum">    2487 </span><span class="lineCov">        600 :                                 index-&gt;rd_opcintype[i],</span>
<span class="lineNum">    2488 </span><span class="lineCov">        600 :                                 index-&gt;rd_opcintype[i],</span>
<span class="lineNum">    2489 </span><span class="lineCov">        600 :                                 ii-&gt;ii_UniqueStrats[i]);</span>
<span class="lineNum">    2490 </span><span class="lineCov">        600 :         if (!OidIsValid(ii-&gt;ii_UniqueOps[i]))</span>
<span class="lineNum">    2491 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;missing operator %d(%u,%u) in opfamily %u&quot;,</span>
<span class="lineNum">    2492 </span>            :                  ii-&gt;ii_UniqueStrats[i], index-&gt;rd_opcintype[i],
<span class="lineNum">    2493 </span>            :                  index-&gt;rd_opcintype[i], index-&gt;rd_opfamily[i]);
<span class="lineNum">    2494 </span><span class="lineCov">        600 :         ii-&gt;ii_UniqueProcs[i] = get_opcode(ii-&gt;ii_UniqueOps[i]);</span>
<span class="lineNum">    2495 </span>            :     }
<span class="lineNum">    2496 </span><span class="lineCov">        480 : }</span>
<span class="lineNum">    2497 </span>            : 
<span class="lineNum">    2498 </span>            : /* ----------------
<span class="lineNum">    2499 </span>            :  *      FormIndexDatum
<span class="lineNum">    2500 </span>            :  *          Construct values[] and isnull[] arrays for a new index tuple.
<span class="lineNum">    2501 </span>            :  *
<span class="lineNum">    2502 </span>            :  *  indexInfo       Info about the index
<span class="lineNum">    2503 </span>            :  *  slot            Heap tuple for which we must prepare an index entry
<span class="lineNum">    2504 </span>            :  *  estate          executor state for evaluating any index expressions
<span class="lineNum">    2505 </span>            :  *  values          Array of index Datums (output area)
<span class="lineNum">    2506 </span>            :  *  isnull          Array of is-null indicators (output area)
<span class="lineNum">    2507 </span>            :  *
<span class="lineNum">    2508 </span>            :  * When there are no index expressions, estate may be NULL.  Otherwise it
<span class="lineNum">    2509 </span>            :  * must be supplied, *and* the ecxt_scantuple slot of its per-tuple expr
<span class="lineNum">    2510 </span>            :  * context must point to the heap tuple passed in.
<span class="lineNum">    2511 </span>            :  *
<span class="lineNum">    2512 </span>            :  * Notice we don't actually call index_form_tuple() here; we just prepare
<span class="lineNum">    2513 </span>            :  * its input arrays values[] and isnull[].  This is because the index AM
<span class="lineNum">    2514 </span>            :  * may wish to alter the data before storage.
<span class="lineNum">    2515 </span>            :  * ----------------
<a name="2516"><span class="lineNum">    2516 </span>            :  */</a>
<span class="lineNum">    2517 </span>            : void
<span class="lineNum">    2518 </span><span class="lineCov">    3488018 : FormIndexDatum(IndexInfo *indexInfo,</span>
<span class="lineNum">    2519 </span>            :                TupleTableSlot *slot,
<span class="lineNum">    2520 </span>            :                EState *estate,
<span class="lineNum">    2521 </span>            :                Datum *values,
<span class="lineNum">    2522 </span>            :                bool *isnull)
<span class="lineNum">    2523 </span>            : {
<span class="lineNum">    2524 </span>            :     ListCell   *indexpr_item;
<span class="lineNum">    2525 </span>            :     int         i;
<span class="lineNum">    2526 </span>            : 
<span class="lineNum">    2527 </span><span class="lineCov">    3640972 :     if (indexInfo-&gt;ii_Expressions != NIL &amp;&amp;</span>
<span class="lineNum">    2528 </span><span class="lineCov">     152954 :         indexInfo-&gt;ii_ExpressionsState == NIL)</span>
<span class="lineNum">    2529 </span>            :     {
<span class="lineNum">    2530 </span>            :         /* First time through, set up expression evaluation state */
<span class="lineNum">    2531 </span><span class="lineCov">        160 :         indexInfo-&gt;ii_ExpressionsState =</span>
<span class="lineNum">    2532 </span><span class="lineCov">        160 :             ExecPrepareExprList(indexInfo-&gt;ii_Expressions, estate);</span>
<span class="lineNum">    2533 </span>            :         /* Check caller has set up context correctly */
<span class="lineNum">    2534 </span><span class="lineCov">        160 :         Assert(GetPerTupleExprContext(estate)-&gt;ecxt_scantuple == slot);</span>
<span class="lineNum">    2535 </span>            :     }
<span class="lineNum">    2536 </span><span class="lineCov">    3488018 :     indexpr_item = list_head(indexInfo-&gt;ii_ExpressionsState);</span>
<span class="lineNum">    2537 </span>            : 
<span class="lineNum">    2538 </span><span class="lineCov">    8559782 :     for (i = 0; i &lt; indexInfo-&gt;ii_NumIndexAttrs; i++)</span>
<span class="lineNum">    2539 </span>            :     {
<span class="lineNum">    2540 </span><span class="lineCov">    5071768 :         int         keycol = indexInfo-&gt;ii_IndexAttrNumbers[i];</span>
<span class="lineNum">    2541 </span>            :         Datum       iDatum;
<span class="lineNum">    2542 </span>            :         bool        isNull;
<span class="lineNum">    2543 </span>            : 
<span class="lineNum">    2544 </span><span class="lineCov">    5071768 :         if (keycol &lt; 0)</span>
<span class="lineNum">    2545 </span><span class="lineNoCov">          0 :             iDatum = slot_getsysattr(slot, keycol, &amp;isNull);</span>
<span class="lineNum">    2546 </span><span class="lineCov">    5071768 :         else if (keycol != 0)</span>
<span class="lineNum">    2547 </span>            :         {
<span class="lineNum">    2548 </span>            :             /*
<span class="lineNum">    2549 </span>            :              * Plain index column; get the value we need directly from the
<span class="lineNum">    2550 </span>            :              * heap tuple.
<span class="lineNum">    2551 </span>            :              */
<span class="lineNum">    2552 </span><span class="lineCov">    4918796 :             iDatum = slot_getattr(slot, keycol, &amp;isNull);</span>
<span class="lineNum">    2553 </span>            :         }
<span class="lineNum">    2554 </span>            :         else
<span class="lineNum">    2555 </span>            :         {
<span class="lineNum">    2556 </span>            :             /*
<span class="lineNum">    2557 </span>            :              * Index expression --- need to evaluate it.
<span class="lineNum">    2558 </span>            :              */
<span class="lineNum">    2559 </span><span class="lineCov">     152972 :             if (indexpr_item == NULL)</span>
<span class="lineNum">    2560 </span><span class="lineNoCov">          0 :                 elog(ERROR, &quot;wrong number of index expressions&quot;);</span>
<span class="lineNum">    2561 </span><span class="lineCov">     152972 :             iDatum = ExecEvalExprSwitchContext((ExprState *) lfirst(indexpr_item),</span>
<span class="lineNum">    2562 </span><span class="lineCov">     152972 :                                                GetPerTupleExprContext(estate),</span>
<span class="lineNum">    2563 </span>            :                                                &amp;isNull);
<span class="lineNum">    2564 </span><span class="lineCov">     152968 :             indexpr_item = lnext(indexInfo-&gt;ii_ExpressionsState, indexpr_item);</span>
<span class="lineNum">    2565 </span>            :         }
<span class="lineNum">    2566 </span><span class="lineCov">    5071764 :         values[i] = iDatum;</span>
<span class="lineNum">    2567 </span><span class="lineCov">    5071764 :         isnull[i] = isNull;</span>
<span class="lineNum">    2568 </span>            :     }
<span class="lineNum">    2569 </span>            : 
<span class="lineNum">    2570 </span><span class="lineCov">    3488014 :     if (indexpr_item != NULL)</span>
<span class="lineNum">    2571 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;wrong number of index expressions&quot;);</span>
<span class="lineNum">    2572 </span><span class="lineCov">    3488014 : }</span>
<span class="lineNum">    2573 </span>            : 
<span class="lineNum">    2574 </span>            : 
<span class="lineNum">    2575 </span>            : /*
<span class="lineNum">    2576 </span>            :  * index_update_stats --- update pg_class entry after CREATE INDEX or REINDEX
<span class="lineNum">    2577 </span>            :  *
<span class="lineNum">    2578 </span>            :  * This routine updates the pg_class row of either an index or its parent
<span class="lineNum">    2579 </span>            :  * relation after CREATE INDEX or REINDEX.  Its rather bizarre API is designed
<span class="lineNum">    2580 </span>            :  * to ensure we can do all the necessary work in just one update.
<span class="lineNum">    2581 </span>            :  *
<span class="lineNum">    2582 </span>            :  * hasindex: set relhasindex to this value
<span class="lineNum">    2583 </span>            :  * reltuples: if &gt;= 0, set reltuples to this value; else no change
<span class="lineNum">    2584 </span>            :  *
<span class="lineNum">    2585 </span>            :  * If reltuples &gt;= 0, relpages and relallvisible are also updated (using
<span class="lineNum">    2586 </span>            :  * RelationGetNumberOfBlocks() and visibilitymap_count()).
<span class="lineNum">    2587 </span>            :  *
<span class="lineNum">    2588 </span>            :  * NOTE: an important side-effect of this operation is that an SI invalidation
<span class="lineNum">    2589 </span>            :  * message is sent out to all backends --- including me --- causing relcache
<span class="lineNum">    2590 </span>            :  * entries to be flushed or updated with the new data.  This must happen even
<span class="lineNum">    2591 </span>            :  * if we find that no change is needed in the pg_class row.  When updating
<span class="lineNum">    2592 </span>            :  * a heap entry, this ensures that other backends find out about the new
<span class="lineNum">    2593 </span>            :  * index.  When updating an index, it's important because some index AMs
<span class="lineNum">    2594 </span>            :  * expect a relcache flush to occur after REINDEX.
<a name="2595"><span class="lineNum">    2595 </span>            :  */</a>
<span class="lineNum">    2596 </span>            : static void
<span class="lineNum">    2597 </span><span class="lineCov">      12270 : index_update_stats(Relation rel,</span>
<span class="lineNum">    2598 </span>            :                    bool hasindex,
<span class="lineNum">    2599 </span>            :                    double reltuples)
<span class="lineNum">    2600 </span>            : {
<span class="lineNum">    2601 </span><span class="lineCov">      12270 :     Oid         relid = RelationGetRelid(rel);</span>
<span class="lineNum">    2602 </span>            :     Relation    pg_class;
<span class="lineNum">    2603 </span>            :     HeapTuple   tuple;
<span class="lineNum">    2604 </span>            :     Form_pg_class rd_rel;
<span class="lineNum">    2605 </span>            :     bool        dirty;
<span class="lineNum">    2606 </span>            : 
<span class="lineNum">    2607 </span>            :     /*
<span class="lineNum">    2608 </span>            :      * We always update the pg_class row using a non-transactional,
<span class="lineNum">    2609 </span>            :      * overwrite-in-place update.  There are several reasons for this:
<span class="lineNum">    2610 </span>            :      *
<span class="lineNum">    2611 </span>            :      * 1. In bootstrap mode, we have no choice --- UPDATE wouldn't work.
<span class="lineNum">    2612 </span>            :      *
<span class="lineNum">    2613 </span>            :      * 2. We could be reindexing pg_class itself, in which case we can't move
<span class="lineNum">    2614 </span>            :      * its pg_class row because CatalogTupleInsert/CatalogTupleUpdate might
<span class="lineNum">    2615 </span>            :      * not know about all the indexes yet (see reindex_relation).
<span class="lineNum">    2616 </span>            :      *
<span class="lineNum">    2617 </span>            :      * 3. Because we execute CREATE INDEX with just share lock on the parent
<span class="lineNum">    2618 </span>            :      * rel (to allow concurrent index creations), an ordinary update could
<span class="lineNum">    2619 </span>            :      * suffer a tuple-concurrently-updated failure against another CREATE
<span class="lineNum">    2620 </span>            :      * INDEX committing at about the same time.  We can avoid that by having
<span class="lineNum">    2621 </span>            :      * them both do nontransactional updates (we assume they will both be
<span class="lineNum">    2622 </span>            :      * trying to change the pg_class row to the same thing, so it doesn't
<span class="lineNum">    2623 </span>            :      * matter which goes first).
<span class="lineNum">    2624 </span>            :      *
<span class="lineNum">    2625 </span>            :      * It is safe to use a non-transactional update even though our
<span class="lineNum">    2626 </span>            :      * transaction could still fail before committing.  Setting relhasindex
<span class="lineNum">    2627 </span>            :      * true is safe even if there are no indexes (VACUUM will eventually fix
<span class="lineNum">    2628 </span>            :      * it).  And of course the new relpages and reltuples counts are correct
<span class="lineNum">    2629 </span>            :      * regardless.  However, we don't want to change relpages (or
<span class="lineNum">    2630 </span>            :      * relallvisible) if the caller isn't providing an updated reltuples
<span class="lineNum">    2631 </span>            :      * count, because that would bollix the reltuples/relpages ratio which is
<span class="lineNum">    2632 </span>            :      * what's really important.
<span class="lineNum">    2633 </span>            :      */
<span class="lineNum">    2634 </span>            : 
<span class="lineNum">    2635 </span><span class="lineCov">      12270 :     pg_class = table_open(RelationRelationId, RowExclusiveLock);</span>
<span class="lineNum">    2636 </span>            : 
<span class="lineNum">    2637 </span>            :     /*
<span class="lineNum">    2638 </span>            :      * Make a copy of the tuple to update.  Normally we use the syscache, but
<span class="lineNum">    2639 </span>            :      * we can't rely on that during bootstrap or while reindexing pg_class
<span class="lineNum">    2640 </span>            :      * itself.
<span class="lineNum">    2641 </span>            :      */
<span class="lineNum">    2642 </span><span class="lineCov">      23932 :     if (IsBootstrapProcessingMode() ||</span>
<span class="lineNum">    2643 </span><span class="lineCov">      11662 :         ReindexIsProcessingHeap(RelationRelationId))</span>
<span class="lineNum">    2644 </span><span class="lineCov">        620 :     {</span>
<span class="lineNum">    2645 </span>            :         /* don't assume syscache will work */
<span class="lineNum">    2646 </span>            :         TableScanDesc pg_class_scan;
<span class="lineNum">    2647 </span>            :         ScanKeyData key[1];
<span class="lineNum">    2648 </span>            : 
<span class="lineNum">    2649 </span><span class="lineCov">        620 :         ScanKeyInit(&amp;key[0],</span>
<span class="lineNum">    2650 </span>            :                     Anum_pg_class_oid,
<span class="lineNum">    2651 </span>            :                     BTEqualStrategyNumber, F_OIDEQ,
<span class="lineNum">    2652 </span>            :                     ObjectIdGetDatum(relid));
<span class="lineNum">    2653 </span>            : 
<span class="lineNum">    2654 </span><span class="lineCov">        620 :         pg_class_scan = table_beginscan_catalog(pg_class, 1, key);</span>
<span class="lineNum">    2655 </span><span class="lineCov">        620 :         tuple = heap_getnext(pg_class_scan, ForwardScanDirection);</span>
<span class="lineNum">    2656 </span><span class="lineCov">        620 :         tuple = heap_copytuple(tuple);</span>
<span class="lineNum">    2657 </span><span class="lineCov">        620 :         table_endscan(pg_class_scan);</span>
<span class="lineNum">    2658 </span>            :     }
<span class="lineNum">    2659 </span>            :     else
<span class="lineNum">    2660 </span>            :     {
<span class="lineNum">    2661 </span>            :         /* normal case, use syscache */
<span class="lineNum">    2662 </span><span class="lineCov">      11650 :         tuple = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(relid));</span>
<span class="lineNum">    2663 </span>            :     }
<span class="lineNum">    2664 </span>            : 
<span class="lineNum">    2665 </span><span class="lineCov">      12270 :     if (!HeapTupleIsValid(tuple))</span>
<span class="lineNum">    2666 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;could not find tuple for relation %u&quot;, relid);</span>
<span class="lineNum">    2667 </span><span class="lineCov">      12270 :     rd_rel = (Form_pg_class) GETSTRUCT(tuple);</span>
<span class="lineNum">    2668 </span>            : 
<span class="lineNum">    2669 </span>            :     /* Should this be a more comprehensive test? */
<span class="lineNum">    2670 </span><span class="lineCov">      12270 :     Assert(rd_rel-&gt;relkind != RELKIND_PARTITIONED_INDEX);</span>
<span class="lineNum">    2671 </span>            : 
<span class="lineNum">    2672 </span>            :     /* Apply required updates, if any, to copied tuple */
<span class="lineNum">    2673 </span>            : 
<span class="lineNum">    2674 </span><span class="lineCov">      12270 :     dirty = false;</span>
<span class="lineNum">    2675 </span><span class="lineCov">      12270 :     if (rd_rel-&gt;relhasindex != hasindex)</span>
<span class="lineNum">    2676 </span>            :     {
<span class="lineNum">    2677 </span><span class="lineCov">       4206 :         rd_rel-&gt;relhasindex = hasindex;</span>
<span class="lineNum">    2678 </span><span class="lineCov">       4206 :         dirty = true;</span>
<span class="lineNum">    2679 </span>            :     }
<span class="lineNum">    2680 </span>            : 
<span class="lineNum">    2681 </span><span class="lineCov">      12270 :     if (reltuples &gt;= 0)</span>
<span class="lineNum">    2682 </span>            :     {
<span class="lineNum">    2683 </span><span class="lineCov">      11776 :         BlockNumber relpages = RelationGetNumberOfBlocks(rel);</span>
<span class="lineNum">    2684 </span>            :         BlockNumber relallvisible;
<span class="lineNum">    2685 </span>            : 
<span class="lineNum">    2686 </span><span class="lineCov">      11776 :         if (rd_rel-&gt;relkind != RELKIND_INDEX)</span>
<span class="lineNum">    2687 </span><span class="lineCov">       5888 :             visibilitymap_count(rel, &amp;relallvisible, NULL);</span>
<span class="lineNum">    2688 </span>            :         else                    /* don't bother for indexes */
<span class="lineNum">    2689 </span><span class="lineCov">       5888 :             relallvisible = 0;</span>
<span class="lineNum">    2690 </span>            : 
<span class="lineNum">    2691 </span><span class="lineCov">      11776 :         if (rd_rel-&gt;relpages != (int32) relpages)</span>
<span class="lineNum">    2692 </span>            :         {
<span class="lineNum">    2693 </span><span class="lineCov">       5750 :             rd_rel-&gt;relpages = (int32) relpages;</span>
<span class="lineNum">    2694 </span><span class="lineCov">       5750 :             dirty = true;</span>
<span class="lineNum">    2695 </span>            :         }
<span class="lineNum">    2696 </span><span class="lineCov">      11776 :         if (rd_rel-&gt;reltuples != (float4) reltuples)</span>
<span class="lineNum">    2697 </span>            :         {
<span class="lineNum">    2698 </span><span class="lineCov">       1206 :             rd_rel-&gt;reltuples = (float4) reltuples;</span>
<span class="lineNum">    2699 </span><span class="lineCov">       1206 :             dirty = true;</span>
<span class="lineNum">    2700 </span>            :         }
<span class="lineNum">    2701 </span><span class="lineCov">      11776 :         if (rd_rel-&gt;relallvisible != (int32) relallvisible)</span>
<span class="lineNum">    2702 </span>            :         {
<span class="lineNum">    2703 </span><span class="lineCov">          2 :             rd_rel-&gt;relallvisible = (int32) relallvisible;</span>
<span class="lineNum">    2704 </span><span class="lineCov">          2 :             dirty = true;</span>
<span class="lineNum">    2705 </span>            :         }
<span class="lineNum">    2706 </span>            :     }
<span class="lineNum">    2707 </span>            : 
<span class="lineNum">    2708 </span>            :     /*
<span class="lineNum">    2709 </span>            :      * If anything changed, write out the tuple
<span class="lineNum">    2710 </span>            :      */
<span class="lineNum">    2711 </span><span class="lineCov">      12270 :     if (dirty)</span>
<span class="lineNum">    2712 </span>            :     {
<span class="lineNum">    2713 </span><span class="lineCov">       9710 :         heap_inplace_update(pg_class, tuple);</span>
<span class="lineNum">    2714 </span>            :         /* the above sends a cache inval message */
<span class="lineNum">    2715 </span>            :     }
<span class="lineNum">    2716 </span>            :     else
<span class="lineNum">    2717 </span>            :     {
<span class="lineNum">    2718 </span>            :         /* no need to change tuple, but force relcache inval anyway */
<span class="lineNum">    2719 </span><span class="lineCov">       2560 :         CacheInvalidateRelcacheByTuple(tuple);</span>
<span class="lineNum">    2720 </span>            :     }
<span class="lineNum">    2721 </span>            : 
<span class="lineNum">    2722 </span><span class="lineCov">      12270 :     heap_freetuple(tuple);</span>
<span class="lineNum">    2723 </span>            : 
<span class="lineNum">    2724 </span><span class="lineCov">      12270 :     table_close(pg_class, RowExclusiveLock);</span>
<span class="lineNum">    2725 </span><span class="lineCov">      12270 : }</span>
<span class="lineNum">    2726 </span>            : 
<span class="lineNum">    2727 </span>            : 
<span class="lineNum">    2728 </span>            : /*
<span class="lineNum">    2729 </span>            :  * index_build - invoke access-method-specific index build procedure
<span class="lineNum">    2730 </span>            :  *
<span class="lineNum">    2731 </span>            :  * On entry, the index's catalog entries are valid, and its physical disk
<span class="lineNum">    2732 </span>            :  * file has been created but is empty.  We call the AM-specific build
<span class="lineNum">    2733 </span>            :  * procedure to fill in the index contents.  We then update the pg_class
<span class="lineNum">    2734 </span>            :  * entries of the index and heap relation as needed, using statistics
<span class="lineNum">    2735 </span>            :  * returned by ambuild as well as data passed by the caller.
<span class="lineNum">    2736 </span>            :  *
<span class="lineNum">    2737 </span>            :  * isreindex indicates we are recreating a previously-existing index.
<span class="lineNum">    2738 </span>            :  * parallel indicates if parallelism may be useful.
<span class="lineNum">    2739 </span>            :  *
<span class="lineNum">    2740 </span>            :  * Note: before Postgres 8.2, the passed-in heap and index Relations
<span class="lineNum">    2741 </span>            :  * were automatically closed by this routine.  This is no longer the case.
<span class="lineNum">    2742 </span>            :  * The caller opened 'em, and the caller should close 'em.
<a name="2743"><span class="lineNum">    2743 </span>            :  */</a>
<span class="lineNum">    2744 </span>            : void
<span class="lineNum">    2745 </span><span class="lineCov">       5912 : index_build(Relation heapRelation,</span>
<span class="lineNum">    2746 </span>            :             Relation indexRelation,
<span class="lineNum">    2747 </span>            :             IndexInfo *indexInfo,
<span class="lineNum">    2748 </span>            :             bool isreindex,
<span class="lineNum">    2749 </span>            :             bool parallel)
<span class="lineNum">    2750 </span>            : {
<span class="lineNum">    2751 </span>            :     IndexBuildResult *stats;
<span class="lineNum">    2752 </span>            :     Oid         save_userid;
<span class="lineNum">    2753 </span>            :     int         save_sec_context;
<span class="lineNum">    2754 </span>            :     int         save_nestlevel;
<span class="lineNum">    2755 </span>            : 
<span class="lineNum">    2756 </span>            :     /*
<span class="lineNum">    2757 </span>            :      * sanity checks
<span class="lineNum">    2758 </span>            :      */
<span class="lineNum">    2759 </span><span class="lineCov">       5912 :     Assert(RelationIsValid(indexRelation));</span>
<span class="lineNum">    2760 </span><span class="lineCov">       5912 :     Assert(PointerIsValid(indexRelation-&gt;rd_indam));</span>
<span class="lineNum">    2761 </span><span class="lineCov">       5912 :     Assert(PointerIsValid(indexRelation-&gt;rd_indam-&gt;ambuild));</span>
<span class="lineNum">    2762 </span><span class="lineCov">       5912 :     Assert(PointerIsValid(indexRelation-&gt;rd_indam-&gt;ambuildempty));</span>
<span class="lineNum">    2763 </span>            : 
<span class="lineNum">    2764 </span>            :     /*
<span class="lineNum">    2765 </span>            :      * Determine worker process details for parallel CREATE INDEX.  Currently,
<span class="lineNum">    2766 </span>            :      * only btree has support for parallel builds.
<span class="lineNum">    2767 </span>            :      *
<span class="lineNum">    2768 </span>            :      * Note that planner considers parallel safety for us.
<span class="lineNum">    2769 </span>            :      */
<span class="lineNum">    2770 </span><span class="lineCov">      11030 :     if (parallel &amp;&amp; IsNormalProcessingMode() &amp;&amp;</span>
<span class="lineNum">    2771 </span><span class="lineCov">       5118 :         indexRelation-&gt;rd_rel-&gt;relam == BTREE_AM_OID)</span>
<span class="lineNum">    2772 </span><span class="lineCov">       4938 :         indexInfo-&gt;ii_ParallelWorkers =</span>
<span class="lineNum">    2773 </span><span class="lineCov">       4938 :             plan_create_index_workers(RelationGetRelid(heapRelation),</span>
<span class="lineNum">    2774 </span>            :                                       RelationGetRelid(indexRelation));
<span class="lineNum">    2775 </span>            : 
<span class="lineNum">    2776 </span><span class="lineCov">       5912 :     if (indexInfo-&gt;ii_ParallelWorkers == 0)</span>
<span class="lineNum">    2777 </span><span class="lineCov">       5872 :         ereport(DEBUG1,</span>
<span class="lineNum">    2778 </span>            :                 (errmsg(&quot;building index \&quot;%s\&quot; on table \&quot;%s\&quot; serially&quot;,
<span class="lineNum">    2779 </span>            :                         RelationGetRelationName(indexRelation),
<span class="lineNum">    2780 </span>            :                         RelationGetRelationName(heapRelation))));
<span class="lineNum">    2781 </span>            :     else
<span class="lineNum">    2782 </span><span class="lineCov">         40 :         ereport(DEBUG1,</span>
<span class="lineNum">    2783 </span>            :                 (errmsg_plural(&quot;building index \&quot;%s\&quot; on table \&quot;%s\&quot; with request for %d parallel worker&quot;,
<span class="lineNum">    2784 </span>            :                                &quot;building index \&quot;%s\&quot; on table \&quot;%s\&quot; with request for %d parallel workers&quot;,
<span class="lineNum">    2785 </span>            :                                indexInfo-&gt;ii_ParallelWorkers,
<span class="lineNum">    2786 </span>            :                                RelationGetRelationName(indexRelation),
<span class="lineNum">    2787 </span>            :                                RelationGetRelationName(heapRelation),
<span class="lineNum">    2788 </span>            :                                indexInfo-&gt;ii_ParallelWorkers)));
<span class="lineNum">    2789 </span>            : 
<span class="lineNum">    2790 </span>            :     /*
<span class="lineNum">    2791 </span>            :      * Switch to the table owner's userid, so that any index functions are run
<span class="lineNum">    2792 </span>            :      * as that user.  Also lock down security-restricted operations and
<span class="lineNum">    2793 </span>            :      * arrange to make GUC variable changes local to this command.
<span class="lineNum">    2794 </span>            :      */
<span class="lineNum">    2795 </span><span class="lineCov">       5912 :     GetUserIdAndSecContext(&amp;save_userid, &amp;save_sec_context);</span>
<span class="lineNum">    2796 </span><span class="lineCov">       5912 :     SetUserIdAndSecContext(heapRelation-&gt;rd_rel-&gt;relowner,</span>
<span class="lineNum">    2797 </span>            :                            save_sec_context | SECURITY_RESTRICTED_OPERATION);
<span class="lineNum">    2798 </span><span class="lineCov">       5912 :     save_nestlevel = NewGUCNestLevel();</span>
<span class="lineNum">    2799 </span>            : 
<span class="lineNum">    2800 </span>            :     /* Set up initial progress report status */
<span class="lineNum">    2801 </span>            :     {
<span class="lineNum">    2802 </span><span class="lineCov">       5912 :         const int   index[] = {</span>
<span class="lineNum">    2803 </span>            :             PROGRESS_CREATEIDX_PHASE,
<span class="lineNum">    2804 </span>            :             PROGRESS_CREATEIDX_SUBPHASE,
<span class="lineNum">    2805 </span>            :             PROGRESS_CREATEIDX_TUPLES_DONE,
<span class="lineNum">    2806 </span>            :             PROGRESS_CREATEIDX_TUPLES_TOTAL,
<span class="lineNum">    2807 </span>            :             PROGRESS_SCAN_BLOCKS_DONE,
<span class="lineNum">    2808 </span>            :             PROGRESS_SCAN_BLOCKS_TOTAL
<span class="lineNum">    2809 </span>            :         };
<span class="lineNum">    2810 </span><span class="lineCov">       5912 :         const int64 val[] = {</span>
<span class="lineNum">    2811 </span>            :             PROGRESS_CREATEIDX_PHASE_BUILD,
<span class="lineNum">    2812 </span>            :             PROGRESS_CREATEIDX_SUBPHASE_INITIALIZE,
<span class="lineNum">    2813 </span>            :             0, 0, 0, 0
<span class="lineNum">    2814 </span>            :         };
<span class="lineNum">    2815 </span>            : 
<span class="lineNum">    2816 </span><span class="lineCov">       5912 :         pgstat_progress_update_multi_param(6, index, val);</span>
<span class="lineNum">    2817 </span>            :     }
<span class="lineNum">    2818 </span>            : 
<span class="lineNum">    2819 </span>            :     /*
<span class="lineNum">    2820 </span>            :      * Call the access method's build procedure
<span class="lineNum">    2821 </span>            :      */
<span class="lineNum">    2822 </span><span class="lineCov">       5912 :     stats = indexRelation-&gt;rd_indam-&gt;ambuild(heapRelation, indexRelation,</span>
<span class="lineNum">    2823 </span>            :                                              indexInfo);
<span class="lineNum">    2824 </span><span class="lineCov">       5888 :     Assert(PointerIsValid(stats));</span>
<span class="lineNum">    2825 </span>            : 
<span class="lineNum">    2826 </span>            :     /*
<span class="lineNum">    2827 </span>            :      * If this is an unlogged index, we may need to write out an init fork for
<span class="lineNum">    2828 </span>            :      * it -- but we must first check whether one already exists.  If, for
<span class="lineNum">    2829 </span>            :      * example, an unlogged relation is truncated in the transaction that
<span class="lineNum">    2830 </span>            :      * created it, or truncated twice in a subsequent transaction, the
<span class="lineNum">    2831 </span>            :      * relfilenode won't change, and nothing needs to be done here.
<span class="lineNum">    2832 </span>            :      */
<span class="lineNum">    2833 </span><span class="lineCov">       5912 :     if (indexRelation-&gt;rd_rel-&gt;relpersistence == RELPERSISTENCE_UNLOGGED &amp;&amp;</span>
<span class="lineNum">    2834 </span><span class="lineCov">         24 :         !smgrexists(indexRelation-&gt;rd_smgr, INIT_FORKNUM))</span>
<span class="lineNum">    2835 </span>            :     {
<span class="lineNum">    2836 </span><span class="lineCov">         24 :         RelationOpenSmgr(indexRelation);</span>
<span class="lineNum">    2837 </span><span class="lineCov">         24 :         smgrcreate(indexRelation-&gt;rd_smgr, INIT_FORKNUM, false);</span>
<span class="lineNum">    2838 </span><span class="lineCov">         24 :         indexRelation-&gt;rd_indam-&gt;ambuildempty(indexRelation);</span>
<span class="lineNum">    2839 </span>            :     }
<span class="lineNum">    2840 </span>            : 
<span class="lineNum">    2841 </span>            :     /*
<span class="lineNum">    2842 </span>            :      * If we found any potentially broken HOT chains, mark the index as not
<span class="lineNum">    2843 </span>            :      * being usable until the current transaction is below the event horizon.
<span class="lineNum">    2844 </span>            :      * See src/backend/access/heap/README.HOT for discussion.  Also set this
<span class="lineNum">    2845 </span>            :      * if early pruning/vacuuming is enabled for the heap relation.  While it
<span class="lineNum">    2846 </span>            :      * might become safe to use the index earlier based on actual cleanup
<span class="lineNum">    2847 </span>            :      * activity and other active transactions, the test for that would be much
<span class="lineNum">    2848 </span>            :      * more complex and would require some form of blocking, so keep it simple
<span class="lineNum">    2849 </span>            :      * and fast by just using the current transaction.
<span class="lineNum">    2850 </span>            :      *
<span class="lineNum">    2851 </span>            :      * However, when reindexing an existing index, we should do nothing here.
<span class="lineNum">    2852 </span>            :      * Any HOT chains that are broken with respect to the index must predate
<span class="lineNum">    2853 </span>            :      * the index's original creation, so there is no need to change the
<span class="lineNum">    2854 </span>            :      * index's usability horizon.  Moreover, we *must not* try to change the
<span class="lineNum">    2855 </span>            :      * index's pg_index entry while reindexing pg_index itself, and this
<span class="lineNum">    2856 </span>            :      * optimization nicely prevents that.  The more complex rules needed for a
<span class="lineNum">    2857 </span>            :      * reindex are handled separately after this function returns.
<span class="lineNum">    2858 </span>            :      *
<span class="lineNum">    2859 </span>            :      * We also need not set indcheckxmin during a concurrent index build,
<span class="lineNum">    2860 </span>            :      * because we won't set indisvalid true until all transactions that care
<span class="lineNum">    2861 </span>            :      * about the broken HOT chains or early pruning/vacuuming are gone.
<span class="lineNum">    2862 </span>            :      *
<span class="lineNum">    2863 </span>            :      * Therefore, this code path can only be taken during non-concurrent
<span class="lineNum">    2864 </span>            :      * CREATE INDEX.  Thus the fact that heap_update will set the pg_index
<span class="lineNum">    2865 </span>            :      * tuple's xmin doesn't matter, because that tuple was created in the
<span class="lineNum">    2866 </span>            :      * current transaction anyway.  That also means we don't need to worry
<span class="lineNum">    2867 </span>            :      * about any concurrent readers of the tuple; no other transaction can see
<span class="lineNum">    2868 </span>            :      * it yet.
<span class="lineNum">    2869 </span>            :      */
<span class="lineNum">    2870 </span><span class="lineCov">       5900 :     if ((indexInfo-&gt;ii_BrokenHotChain || EarlyPruningEnabled(heapRelation)) &amp;&amp;</span>
<span class="lineNum">    2871 </span><span class="lineCov">         24 :         !isreindex &amp;&amp;</span>
<span class="lineNum">    2872 </span><span class="lineCov">         12 :         !indexInfo-&gt;ii_Concurrent)</span>
<span class="lineNum">    2873 </span>            :     {
<span class="lineNum">    2874 </span><span class="lineCov">         12 :         Oid         indexId = RelationGetRelid(indexRelation);</span>
<span class="lineNum">    2875 </span>            :         Relation    pg_index;
<span class="lineNum">    2876 </span>            :         HeapTuple   indexTuple;
<span class="lineNum">    2877 </span>            :         Form_pg_index indexForm;
<span class="lineNum">    2878 </span>            : 
<span class="lineNum">    2879 </span><span class="lineCov">         12 :         pg_index = table_open(IndexRelationId, RowExclusiveLock);</span>
<span class="lineNum">    2880 </span>            : 
<span class="lineNum">    2881 </span><span class="lineCov">         12 :         indexTuple = SearchSysCacheCopy1(INDEXRELID,</span>
<span class="lineNum">    2882 </span>            :                                          ObjectIdGetDatum(indexId));
<span class="lineNum">    2883 </span><span class="lineCov">         12 :         if (!HeapTupleIsValid(indexTuple))</span>
<span class="lineNum">    2884 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;cache lookup failed for index %u&quot;, indexId);</span>
<span class="lineNum">    2885 </span><span class="lineCov">         12 :         indexForm = (Form_pg_index) GETSTRUCT(indexTuple);</span>
<span class="lineNum">    2886 </span>            : 
<span class="lineNum">    2887 </span>            :         /* If it's a new index, indcheckxmin shouldn't be set ... */
<span class="lineNum">    2888 </span><span class="lineCov">         12 :         Assert(!indexForm-&gt;indcheckxmin);</span>
<span class="lineNum">    2889 </span>            : 
<span class="lineNum">    2890 </span><span class="lineCov">         12 :         indexForm-&gt;indcheckxmin = true;</span>
<span class="lineNum">    2891 </span><span class="lineCov">         12 :         CatalogTupleUpdate(pg_index, &amp;indexTuple-&gt;t_self, indexTuple);</span>
<span class="lineNum">    2892 </span>            : 
<span class="lineNum">    2893 </span><span class="lineCov">         12 :         heap_freetuple(indexTuple);</span>
<span class="lineNum">    2894 </span><span class="lineCov">         12 :         table_close(pg_index, RowExclusiveLock);</span>
<span class="lineNum">    2895 </span>            :     }
<span class="lineNum">    2896 </span>            : 
<span class="lineNum">    2897 </span>            :     /*
<span class="lineNum">    2898 </span>            :      * Update heap and index pg_class rows
<span class="lineNum">    2899 </span>            :      */
<span class="lineNum">    2900 </span><span class="lineCov">       5888 :     index_update_stats(heapRelation,</span>
<span class="lineNum">    2901 </span>            :                        true,
<span class="lineNum">    2902 </span>            :                        stats-&gt;heap_tuples);
<span class="lineNum">    2903 </span>            : 
<span class="lineNum">    2904 </span><span class="lineCov">       5888 :     index_update_stats(indexRelation,</span>
<span class="lineNum">    2905 </span>            :                        false,
<span class="lineNum">    2906 </span>            :                        stats-&gt;index_tuples);
<span class="lineNum">    2907 </span>            : 
<span class="lineNum">    2908 </span>            :     /* Make the updated catalog row versions visible */
<span class="lineNum">    2909 </span><span class="lineCov">       5888 :     CommandCounterIncrement();</span>
<span class="lineNum">    2910 </span>            : 
<span class="lineNum">    2911 </span>            :     /*
<span class="lineNum">    2912 </span>            :      * If it's for an exclusion constraint, make a second pass over the heap
<span class="lineNum">    2913 </span>            :      * to verify that the constraint is satisfied.  We must not do this until
<span class="lineNum">    2914 </span>            :      * the index is fully valid.  (Broken HOT chains shouldn't matter, though;
<span class="lineNum">    2915 </span>            :      * see comments for IndexCheckExclusion.)
<span class="lineNum">    2916 </span>            :      */
<span class="lineNum">    2917 </span><span class="lineCov">       5888 :     if (indexInfo-&gt;ii_ExclusionOps != NULL)</span>
<span class="lineNum">    2918 </span><span class="lineCov">         48 :         IndexCheckExclusion(heapRelation, indexRelation, indexInfo);</span>
<span class="lineNum">    2919 </span>            : 
<span class="lineNum">    2920 </span>            :     /* Roll back any GUC changes executed by index functions */
<span class="lineNum">    2921 </span><span class="lineCov">       5884 :     AtEOXact_GUC(false, save_nestlevel);</span>
<span class="lineNum">    2922 </span>            : 
<span class="lineNum">    2923 </span>            :     /* Restore userid and security context */
<span class="lineNum">    2924 </span><span class="lineCov">       5884 :     SetUserIdAndSecContext(save_userid, save_sec_context);</span>
<span class="lineNum">    2925 </span><span class="lineCov">       5884 : }</span>
<span class="lineNum">    2926 </span>            : 
<span class="lineNum">    2927 </span>            : /*
<span class="lineNum">    2928 </span>            :  * IndexCheckExclusion - verify that a new exclusion constraint is satisfied
<span class="lineNum">    2929 </span>            :  *
<span class="lineNum">    2930 </span>            :  * When creating an exclusion constraint, we first build the index normally
<span class="lineNum">    2931 </span>            :  * and then rescan the heap to check for conflicts.  We assume that we only
<span class="lineNum">    2932 </span>            :  * need to validate tuples that are live according to an up-to-date snapshot,
<span class="lineNum">    2933 </span>            :  * and that these were correctly indexed even in the presence of broken HOT
<span class="lineNum">    2934 </span>            :  * chains.  This should be OK since we are holding at least ShareLock on the
<span class="lineNum">    2935 </span>            :  * table, meaning there can be no uncommitted updates from other transactions.
<span class="lineNum">    2936 </span>            :  * (Note: that wouldn't necessarily work for system catalogs, since many
<span class="lineNum">    2937 </span>            :  * operations release write lock early on the system catalogs.)
<a name="2938"><span class="lineNum">    2938 </span>            :  */</a>
<span class="lineNum">    2939 </span>            : static void
<span class="lineNum">    2940 </span><span class="lineCov">         48 : IndexCheckExclusion(Relation heapRelation,</span>
<span class="lineNum">    2941 </span>            :                     Relation indexRelation,
<span class="lineNum">    2942 </span>            :                     IndexInfo *indexInfo)
<span class="lineNum">    2943 </span>            : {
<span class="lineNum">    2944 </span>            :     TableScanDesc scan;
<span class="lineNum">    2945 </span>            :     Datum       values[INDEX_MAX_KEYS];
<span class="lineNum">    2946 </span>            :     bool        isnull[INDEX_MAX_KEYS];
<span class="lineNum">    2947 </span>            :     ExprState  *predicate;
<span class="lineNum">    2948 </span>            :     TupleTableSlot *slot;
<span class="lineNum">    2949 </span>            :     EState     *estate;
<span class="lineNum">    2950 </span>            :     ExprContext *econtext;
<span class="lineNum">    2951 </span>            :     Snapshot    snapshot;
<span class="lineNum">    2952 </span>            : 
<span class="lineNum">    2953 </span>            :     /*
<span class="lineNum">    2954 </span>            :      * If we are reindexing the target index, mark it as no longer being
<span class="lineNum">    2955 </span>            :      * reindexed, to forestall an Assert in index_beginscan when we try to use
<span class="lineNum">    2956 </span>            :      * the index for probes.  This is OK because the index is now fully valid.
<span class="lineNum">    2957 </span>            :      */
<span class="lineNum">    2958 </span><span class="lineCov">         48 :     if (ReindexIsCurrentlyProcessingIndex(RelationGetRelid(indexRelation)))</span>
<span class="lineNum">    2959 </span><span class="lineCov">         20 :         ResetReindexProcessing();</span>
<span class="lineNum">    2960 </span>            : 
<span class="lineNum">    2961 </span>            :     /*
<span class="lineNum">    2962 </span>            :      * Need an EState for evaluation of index expressions and partial-index
<span class="lineNum">    2963 </span>            :      * predicates.  Also a slot to hold the current tuple.
<span class="lineNum">    2964 </span>            :      */
<span class="lineNum">    2965 </span><span class="lineCov">         48 :     estate = CreateExecutorState();</span>
<span class="lineNum">    2966 </span><span class="lineCov">         48 :     econtext = GetPerTupleExprContext(estate);</span>
<span class="lineNum">    2967 </span><span class="lineCov">         48 :     slot = table_slot_create(heapRelation, NULL);</span>
<span class="lineNum">    2968 </span>            : 
<span class="lineNum">    2969 </span>            :     /* Arrange for econtext's scan tuple to be the tuple under test */
<span class="lineNum">    2970 </span><span class="lineCov">         48 :     econtext-&gt;ecxt_scantuple = slot;</span>
<span class="lineNum">    2971 </span>            : 
<span class="lineNum">    2972 </span>            :     /* Set up execution state for predicate, if any. */
<span class="lineNum">    2973 </span><span class="lineCov">         48 :     predicate = ExecPrepareQual(indexInfo-&gt;ii_Predicate, estate);</span>
<span class="lineNum">    2974 </span>            : 
<span class="lineNum">    2975 </span>            :     /*
<span class="lineNum">    2976 </span>            :      * Scan all live tuples in the base relation.
<span class="lineNum">    2977 </span>            :      */
<span class="lineNum">    2978 </span><span class="lineCov">         48 :     snapshot = RegisterSnapshot(GetLatestSnapshot());</span>
<span class="lineNum">    2979 </span><span class="lineCov">         48 :     scan = table_beginscan_strat(heapRelation,  /* relation */</span>
<span class="lineNum">    2980 </span>            :                                  snapshot,  /* snapshot */
<span class="lineNum">    2981 </span>            :                                  0, /* number of keys */
<span class="lineNum">    2982 </span>            :                                  NULL,  /* scan key */
<span class="lineNum">    2983 </span>            :                                  true,  /* buffer access strategy OK */
<span class="lineNum">    2984 </span>            :                                  true); /* syncscan OK */
<span class="lineNum">    2985 </span>            : 
<span class="lineNum">    2986 </span><span class="lineCov">        106 :     while (table_scan_getnextslot(scan, ForwardScanDirection, slot))</span>
<span class="lineNum">    2987 </span>            :     {
<span class="lineNum">    2988 </span><span class="lineCov">         14 :         CHECK_FOR_INTERRUPTS();</span>
<span class="lineNum">    2989 </span>            : 
<span class="lineNum">    2990 </span>            :         /*
<span class="lineNum">    2991 </span>            :          * In a partial index, ignore tuples that don't satisfy the predicate.
<span class="lineNum">    2992 </span>            :          */
<span class="lineNum">    2993 </span><span class="lineCov">         14 :         if (predicate != NULL)</span>
<span class="lineNum">    2994 </span>            :         {
<span class="lineNum">    2995 </span><span class="lineCov">         10 :             if (!ExecQual(predicate, econtext))</span>
<span class="lineNum">    2996 </span><span class="lineCov">          4 :                 continue;</span>
<span class="lineNum">    2997 </span>            :         }
<span class="lineNum">    2998 </span>            : 
<span class="lineNum">    2999 </span>            :         /*
<span class="lineNum">    3000 </span>            :          * Extract index column values, including computing expressions.
<span class="lineNum">    3001 </span>            :          */
<span class="lineNum">    3002 </span><span class="lineCov">         10 :         FormIndexDatum(indexInfo,</span>
<span class="lineNum">    3003 </span>            :                        slot,
<span class="lineNum">    3004 </span>            :                        estate,
<span class="lineNum">    3005 </span>            :                        values,
<span class="lineNum">    3006 </span>            :                        isnull);
<span class="lineNum">    3007 </span>            : 
<span class="lineNum">    3008 </span>            :         /*
<span class="lineNum">    3009 </span>            :          * Check that this tuple has no conflicts.
<span class="lineNum">    3010 </span>            :          */
<span class="lineNum">    3011 </span><span class="lineCov">         10 :         check_exclusion_constraint(heapRelation,</span>
<span class="lineNum">    3012 </span>            :                                    indexRelation, indexInfo,
<span class="lineNum">    3013 </span>            :                                    &amp;(slot-&gt;tts_tid), values, isnull,
<span class="lineNum">    3014 </span>            :                                    estate, true);
<span class="lineNum">    3015 </span>            : 
<span class="lineNum">    3016 </span><span class="lineCov">          6 :         MemoryContextReset(econtext-&gt;ecxt_per_tuple_memory);</span>
<span class="lineNum">    3017 </span>            :     }
<span class="lineNum">    3018 </span>            : 
<span class="lineNum">    3019 </span><span class="lineCov">         44 :     table_endscan(scan);</span>
<span class="lineNum">    3020 </span><span class="lineCov">         44 :     UnregisterSnapshot(snapshot);</span>
<span class="lineNum">    3021 </span>            : 
<span class="lineNum">    3022 </span><span class="lineCov">         44 :     ExecDropSingleTupleTableSlot(slot);</span>
<span class="lineNum">    3023 </span>            : 
<span class="lineNum">    3024 </span><span class="lineCov">         44 :     FreeExecutorState(estate);</span>
<span class="lineNum">    3025 </span>            : 
<span class="lineNum">    3026 </span>            :     /* These may have been pointing to the now-gone estate */
<span class="lineNum">    3027 </span><span class="lineCov">         44 :     indexInfo-&gt;ii_ExpressionsState = NIL;</span>
<span class="lineNum">    3028 </span><span class="lineCov">         44 :     indexInfo-&gt;ii_PredicateState = NULL;</span>
<span class="lineNum">    3029 </span><span class="lineCov">         44 : }</span>
<span class="lineNum">    3030 </span>            : 
<span class="lineNum">    3031 </span>            : 
<span class="lineNum">    3032 </span>            : /*
<span class="lineNum">    3033 </span>            :  * validate_index - support code for concurrent index builds
<span class="lineNum">    3034 </span>            :  *
<span class="lineNum">    3035 </span>            :  * We do a concurrent index build by first inserting the catalog entry for the
<span class="lineNum">    3036 </span>            :  * index via index_create(), marking it not indisready and not indisvalid.
<span class="lineNum">    3037 </span>            :  * Then we commit our transaction and start a new one, then we wait for all
<span class="lineNum">    3038 </span>            :  * transactions that could have been modifying the table to terminate.  Now
<span class="lineNum">    3039 </span>            :  * we know that any subsequently-started transactions will see the index and
<span class="lineNum">    3040 </span>            :  * honor its constraints on HOT updates; so while existing HOT-chains might
<span class="lineNum">    3041 </span>            :  * be broken with respect to the index, no currently live tuple will have an
<span class="lineNum">    3042 </span>            :  * incompatible HOT update done to it.  We now build the index normally via
<span class="lineNum">    3043 </span>            :  * index_build(), while holding a weak lock that allows concurrent
<span class="lineNum">    3044 </span>            :  * insert/update/delete.  Also, we index only tuples that are valid
<span class="lineNum">    3045 </span>            :  * as of the start of the scan (see table_index_build_scan), whereas a normal
<span class="lineNum">    3046 </span>            :  * build takes care to include recently-dead tuples.  This is OK because
<span class="lineNum">    3047 </span>            :  * we won't mark the index valid until all transactions that might be able
<span class="lineNum">    3048 </span>            :  * to see those tuples are gone.  The reason for doing that is to avoid
<span class="lineNum">    3049 </span>            :  * bogus unique-index failures due to concurrent UPDATEs (we might see
<span class="lineNum">    3050 </span>            :  * different versions of the same row as being valid when we pass over them,
<span class="lineNum">    3051 </span>            :  * if we used HeapTupleSatisfiesVacuum).  This leaves us with an index that
<span class="lineNum">    3052 </span>            :  * does not contain any tuples added to the table while we built the index.
<span class="lineNum">    3053 </span>            :  *
<span class="lineNum">    3054 </span>            :  * Next, we mark the index &quot;indisready&quot; (but still not &quot;indisvalid&quot;) and
<span class="lineNum">    3055 </span>            :  * commit the second transaction and start a third.  Again we wait for all
<span class="lineNum">    3056 </span>            :  * transactions that could have been modifying the table to terminate.  Now
<span class="lineNum">    3057 </span>            :  * we know that any subsequently-started transactions will see the index and
<span class="lineNum">    3058 </span>            :  * insert their new tuples into it.  We then take a new reference snapshot
<span class="lineNum">    3059 </span>            :  * which is passed to validate_index().  Any tuples that are valid according
<span class="lineNum">    3060 </span>            :  * to this snap, but are not in the index, must be added to the index.
<span class="lineNum">    3061 </span>            :  * (Any tuples committed live after the snap will be inserted into the
<span class="lineNum">    3062 </span>            :  * index by their originating transaction.  Any tuples committed dead before
<span class="lineNum">    3063 </span>            :  * the snap need not be indexed, because we will wait out all transactions
<span class="lineNum">    3064 </span>            :  * that might care about them before we mark the index valid.)
<span class="lineNum">    3065 </span>            :  *
<span class="lineNum">    3066 </span>            :  * validate_index() works by first gathering all the TIDs currently in the
<span class="lineNum">    3067 </span>            :  * index, using a bulkdelete callback that just stores the TIDs and doesn't
<span class="lineNum">    3068 </span>            :  * ever say &quot;delete it&quot;.  (This should be faster than a plain indexscan;
<span class="lineNum">    3069 </span>            :  * also, not all index AMs support full-index indexscan.)  Then we sort the
<span class="lineNum">    3070 </span>            :  * TIDs, and finally scan the table doing a &quot;merge join&quot; against the TID list
<span class="lineNum">    3071 </span>            :  * to see which tuples are missing from the index.  Thus we will ensure that
<span class="lineNum">    3072 </span>            :  * all tuples valid according to the reference snapshot are in the index.
<span class="lineNum">    3073 </span>            :  *
<span class="lineNum">    3074 </span>            :  * Building a unique index this way is tricky: we might try to insert a
<span class="lineNum">    3075 </span>            :  * tuple that is already dead or is in process of being deleted, and we
<span class="lineNum">    3076 </span>            :  * mustn't have a uniqueness failure against an updated version of the same
<span class="lineNum">    3077 </span>            :  * row.  We could try to check the tuple to see if it's already dead and tell
<span class="lineNum">    3078 </span>            :  * index_insert() not to do the uniqueness check, but that still leaves us
<span class="lineNum">    3079 </span>            :  * with a race condition against an in-progress update.  To handle that,
<span class="lineNum">    3080 </span>            :  * we expect the index AM to recheck liveness of the to-be-inserted tuple
<span class="lineNum">    3081 </span>            :  * before it declares a uniqueness error.
<span class="lineNum">    3082 </span>            :  *
<span class="lineNum">    3083 </span>            :  * After completing validate_index(), we wait until all transactions that
<span class="lineNum">    3084 </span>            :  * were alive at the time of the reference snapshot are gone; this is
<span class="lineNum">    3085 </span>            :  * necessary to be sure there are none left with a transaction snapshot
<span class="lineNum">    3086 </span>            :  * older than the reference (and hence possibly able to see tuples we did
<span class="lineNum">    3087 </span>            :  * not index).  Then we mark the index &quot;indisvalid&quot; and commit.  Subsequent
<span class="lineNum">    3088 </span>            :  * transactions will be able to use it for queries.
<span class="lineNum">    3089 </span>            :  *
<span class="lineNum">    3090 </span>            :  * Doing two full table scans is a brute-force strategy.  We could try to be
<span class="lineNum">    3091 </span>            :  * cleverer, eg storing new tuples in a special area of the table (perhaps
<span class="lineNum">    3092 </span>            :  * making the table append-only by setting use_fsm).  However that would
<span class="lineNum">    3093 </span>            :  * add yet more locking issues.
<a name="3094"><span class="lineNum">    3094 </span>            :  */</a>
<span class="lineNum">    3095 </span>            : void
<span class="lineNum">    3096 </span><span class="lineCov">         58 : validate_index(Oid heapId, Oid indexId, Snapshot snapshot)</span>
<span class="lineNum">    3097 </span>            : {
<span class="lineNum">    3098 </span>            :     Relation    heapRelation,
<span class="lineNum">    3099 </span>            :                 indexRelation;
<span class="lineNum">    3100 </span>            :     IndexInfo  *indexInfo;
<span class="lineNum">    3101 </span>            :     IndexVacuumInfo ivinfo;
<span class="lineNum">    3102 </span>            :     ValidateIndexState state;
<span class="lineNum">    3103 </span>            :     Oid         save_userid;
<span class="lineNum">    3104 </span>            :     int         save_sec_context;
<span class="lineNum">    3105 </span>            :     int         save_nestlevel;
<span class="lineNum">    3106 </span>            : 
<span class="lineNum">    3107 </span>            :     {
<span class="lineNum">    3108 </span><span class="lineCov">         58 :         const int   index[] = {</span>
<span class="lineNum">    3109 </span>            :             PROGRESS_CREATEIDX_PHASE,
<span class="lineNum">    3110 </span>            :             PROGRESS_CREATEIDX_TUPLES_DONE,
<span class="lineNum">    3111 </span>            :             PROGRESS_CREATEIDX_TUPLES_TOTAL,
<span class="lineNum">    3112 </span>            :             PROGRESS_SCAN_BLOCKS_DONE,
<span class="lineNum">    3113 </span>            :             PROGRESS_SCAN_BLOCKS_TOTAL
<span class="lineNum">    3114 </span>            :         };
<span class="lineNum">    3115 </span><span class="lineCov">         58 :         const int64 val[] = {</span>
<span class="lineNum">    3116 </span>            :             PROGRESS_CREATEIDX_PHASE_VALIDATE_IDXSCAN,
<span class="lineNum">    3117 </span>            :             0, 0, 0, 0
<span class="lineNum">    3118 </span>            :         };
<span class="lineNum">    3119 </span>            : 
<span class="lineNum">    3120 </span><span class="lineCov">         58 :         pgstat_progress_update_multi_param(5, index, val);</span>
<span class="lineNum">    3121 </span>            :     }
<span class="lineNum">    3122 </span>            : 
<span class="lineNum">    3123 </span>            :     /* Open and lock the parent heap relation */
<span class="lineNum">    3124 </span><span class="lineCov">         58 :     heapRelation = table_open(heapId, ShareUpdateExclusiveLock);</span>
<span class="lineNum">    3125 </span>            :     /* And the target index relation */
<span class="lineNum">    3126 </span><span class="lineCov">         58 :     indexRelation = index_open(indexId, RowExclusiveLock);</span>
<span class="lineNum">    3127 </span>            : 
<span class="lineNum">    3128 </span>            :     /*
<span class="lineNum">    3129 </span>            :      * Fetch info needed for index_insert.  (You might think this should be
<span class="lineNum">    3130 </span>            :      * passed in from DefineIndex, but its copy is long gone due to having
<span class="lineNum">    3131 </span>            :      * been built in a previous transaction.)
<span class="lineNum">    3132 </span>            :      */
<span class="lineNum">    3133 </span><span class="lineCov">         58 :     indexInfo = BuildIndexInfo(indexRelation);</span>
<span class="lineNum">    3134 </span>            : 
<span class="lineNum">    3135 </span>            :     /* mark build is concurrent just for consistency */
<span class="lineNum">    3136 </span><span class="lineCov">         58 :     indexInfo-&gt;ii_Concurrent = true;</span>
<span class="lineNum">    3137 </span>            : 
<span class="lineNum">    3138 </span>            :     /*
<span class="lineNum">    3139 </span>            :      * Switch to the table owner's userid, so that any index functions are run
<span class="lineNum">    3140 </span>            :      * as that user.  Also lock down security-restricted operations and
<span class="lineNum">    3141 </span>            :      * arrange to make GUC variable changes local to this command.
<span class="lineNum">    3142 </span>            :      */
<span class="lineNum">    3143 </span><span class="lineCov">         58 :     GetUserIdAndSecContext(&amp;save_userid, &amp;save_sec_context);</span>
<span class="lineNum">    3144 </span><span class="lineCov">         58 :     SetUserIdAndSecContext(heapRelation-&gt;rd_rel-&gt;relowner,</span>
<span class="lineNum">    3145 </span>            :                            save_sec_context | SECURITY_RESTRICTED_OPERATION);
<span class="lineNum">    3146 </span><span class="lineCov">         58 :     save_nestlevel = NewGUCNestLevel();</span>
<span class="lineNum">    3147 </span>            : 
<span class="lineNum">    3148 </span>            :     /*
<span class="lineNum">    3149 </span>            :      * Scan the index and gather up all the TIDs into a tuplesort object.
<span class="lineNum">    3150 </span>            :      */
<span class="lineNum">    3151 </span><span class="lineCov">         58 :     ivinfo.index = indexRelation;</span>
<span class="lineNum">    3152 </span><span class="lineCov">         58 :     ivinfo.analyze_only = false;</span>
<span class="lineNum">    3153 </span><span class="lineCov">         58 :     ivinfo.report_progress = true;</span>
<span class="lineNum">    3154 </span><span class="lineCov">         58 :     ivinfo.estimated_count = true;</span>
<span class="lineNum">    3155 </span><span class="lineCov">         58 :     ivinfo.message_level = DEBUG2;</span>
<span class="lineNum">    3156 </span><span class="lineCov">         58 :     ivinfo.num_heap_tuples = heapRelation-&gt;rd_rel-&gt;reltuples;</span>
<span class="lineNum">    3157 </span><span class="lineCov">         58 :     ivinfo.strategy = NULL;</span>
<span class="lineNum">    3158 </span>            : 
<span class="lineNum">    3159 </span>            :     /*
<span class="lineNum">    3160 </span>            :      * Encode TIDs as int8 values for the sort, rather than directly sorting
<span class="lineNum">    3161 </span>            :      * item pointers.  This can be significantly faster, primarily because TID
<span class="lineNum">    3162 </span>            :      * is a pass-by-reference type on all platforms, whereas int8 is
<span class="lineNum">    3163 </span>            :      * pass-by-value on most platforms.
<span class="lineNum">    3164 </span>            :      */
<span class="lineNum">    3165 </span><span class="lineCov">         58 :     state.tuplesort = tuplesort_begin_datum(INT8OID, Int8LessOperator,</span>
<span class="lineNum">    3166 </span>            :                                             InvalidOid, false,
<span class="lineNum">    3167 </span>            :                                             maintenance_work_mem,
<span class="lineNum">    3168 </span>            :                                             NULL, false);
<span class="lineNum">    3169 </span><span class="lineCov">         58 :     state.htups = state.itups = state.tups_inserted = 0;</span>
<span class="lineNum">    3170 </span>            : 
<span class="lineNum">    3171 </span>            :     /* ambulkdelete updates progress metrics */
<span class="lineNum">    3172 </span><span class="lineCov">         58 :     (void) index_bulk_delete(&amp;ivinfo, NULL,</span>
<span class="lineNum">    3173 </span>            :                              validate_index_callback, (void *) &amp;state);
<span class="lineNum">    3174 </span>            : 
<span class="lineNum">    3175 </span>            :     /* Execute the sort */
<span class="lineNum">    3176 </span>            :     {
<span class="lineNum">    3177 </span><span class="lineCov">         58 :         const int   index[] = {</span>
<span class="lineNum">    3178 </span>            :             PROGRESS_CREATEIDX_PHASE,
<span class="lineNum">    3179 </span>            :             PROGRESS_SCAN_BLOCKS_DONE,
<span class="lineNum">    3180 </span>            :             PROGRESS_SCAN_BLOCKS_TOTAL
<span class="lineNum">    3181 </span>            :         };
<span class="lineNum">    3182 </span><span class="lineCov">         58 :         const int64 val[] = {</span>
<span class="lineNum">    3183 </span>            :             PROGRESS_CREATEIDX_PHASE_VALIDATE_SORT,
<span class="lineNum">    3184 </span>            :             0, 0
<span class="lineNum">    3185 </span>            :         };
<span class="lineNum">    3186 </span>            : 
<span class="lineNum">    3187 </span><span class="lineCov">         58 :         pgstat_progress_update_multi_param(3, index, val);</span>
<span class="lineNum">    3188 </span>            :     }
<span class="lineNum">    3189 </span><span class="lineCov">         58 :     tuplesort_performsort(state.tuplesort);</span>
<span class="lineNum">    3190 </span>            : 
<span class="lineNum">    3191 </span>            :     /*
<span class="lineNum">    3192 </span>            :      * Now scan the heap and &quot;merge&quot; it with the index
<span class="lineNum">    3193 </span>            :      */
<span class="lineNum">    3194 </span><span class="lineCov">         58 :     pgstat_progress_update_param(PROGRESS_CREATEIDX_PHASE,</span>
<span class="lineNum">    3195 </span>            :                                  PROGRESS_CREATEIDX_PHASE_VALIDATE_TABLESCAN);
<span class="lineNum">    3196 </span><span class="lineCov">         58 :     table_index_validate_scan(heapRelation,</span>
<span class="lineNum">    3197 </span>            :                               indexRelation,
<span class="lineNum">    3198 </span>            :                               indexInfo,
<span class="lineNum">    3199 </span>            :                               snapshot,
<span class="lineNum">    3200 </span>            :                               &amp;state);
<span class="lineNum">    3201 </span>            : 
<span class="lineNum">    3202 </span>            :     /* Done with tuplesort object */
<span class="lineNum">    3203 </span><span class="lineCov">         58 :     tuplesort_end(state.tuplesort);</span>
<span class="lineNum">    3204 </span>            : 
<span class="lineNum">    3205 </span><span class="lineCov">         58 :     elog(DEBUG2,</span>
<span class="lineNum">    3206 </span>            :          &quot;validate_index found %.0f heap tuples, %.0f index tuples; inserted %.0f missing tuples&quot;,
<span class="lineNum">    3207 </span>            :          state.htups, state.itups, state.tups_inserted);
<span class="lineNum">    3208 </span>            : 
<span class="lineNum">    3209 </span>            :     /* Roll back any GUC changes executed by index functions */
<span class="lineNum">    3210 </span><span class="lineCov">         58 :     AtEOXact_GUC(false, save_nestlevel);</span>
<span class="lineNum">    3211 </span>            : 
<span class="lineNum">    3212 </span>            :     /* Restore userid and security context */
<span class="lineNum">    3213 </span><span class="lineCov">         58 :     SetUserIdAndSecContext(save_userid, save_sec_context);</span>
<span class="lineNum">    3214 </span>            : 
<span class="lineNum">    3215 </span>            :     /* Close rels, but keep locks */
<span class="lineNum">    3216 </span><span class="lineCov">         58 :     index_close(indexRelation, NoLock);</span>
<span class="lineNum">    3217 </span><span class="lineCov">         58 :     table_close(heapRelation, NoLock);</span>
<span class="lineNum">    3218 </span><span class="lineCov">         58 : }</span>
<span class="lineNum">    3219 </span>            : 
<span class="lineNum">    3220 </span>            : /*
<span class="lineNum">    3221 </span>            :  * validate_index_callback - bulkdelete callback to collect the index TIDs
<a name="3222"><span class="lineNum">    3222 </span>            :  */</a>
<span class="lineNum">    3223 </span>            : static bool
<span class="lineNum">    3224 </span><span class="lineCov">       5260 : validate_index_callback(ItemPointer itemptr, void *opaque)</span>
<span class="lineNum">    3225 </span>            : {
<span class="lineNum">    3226 </span><span class="lineCov">       5260 :     ValidateIndexState *state = (ValidateIndexState *) opaque;</span>
<span class="lineNum">    3227 </span><span class="lineCov">       5260 :     int64       encoded = itemptr_encode(itemptr);</span>
<span class="lineNum">    3228 </span>            : 
<span class="lineNum">    3229 </span><span class="lineCov">       5260 :     tuplesort_putdatum(state-&gt;tuplesort, Int64GetDatum(encoded), false);</span>
<span class="lineNum">    3230 </span><span class="lineCov">       5260 :     state-&gt;itups += 1;</span>
<span class="lineNum">    3231 </span><span class="lineCov">       5260 :     return false;               /* never actually delete anything */</span>
<span class="lineNum">    3232 </span>            : }
<span class="lineNum">    3233 </span>            : 
<span class="lineNum">    3234 </span>            : /*
<span class="lineNum">    3235 </span>            :  * index_set_state_flags - adjust pg_index state flags
<span class="lineNum">    3236 </span>            :  *
<span class="lineNum">    3237 </span>            :  * This is used during CREATE/DROP INDEX CONCURRENTLY to adjust the pg_index
<span class="lineNum">    3238 </span>            :  * flags that denote the index's state.  Because the update is not
<span class="lineNum">    3239 </span>            :  * transactional and will not roll back on error, this must only be used as
<span class="lineNum">    3240 </span>            :  * the last step in a transaction that has not made any transactional catalog
<span class="lineNum">    3241 </span>            :  * updates!
<span class="lineNum">    3242 </span>            :  *
<span class="lineNum">    3243 </span>            :  * Note that heap_inplace_update does send a cache inval message for the
<span class="lineNum">    3244 </span>            :  * tuple, so other sessions will hear about the update as soon as we commit.
<span class="lineNum">    3245 </span>            :  *
<span class="lineNum">    3246 </span>            :  * NB: In releases prior to PostgreSQL 9.4, the use of a non-transactional
<span class="lineNum">    3247 </span>            :  * update here would have been unsafe; now that MVCC rules apply even for
<span class="lineNum">    3248 </span>            :  * system catalog scans, we could potentially use a transactional update here
<span class="lineNum">    3249 </span>            :  * instead.
<a name="3250"><span class="lineNum">    3250 </span>            :  */</a>
<span class="lineNum">    3251 </span>            : void
<span class="lineNum">    3252 </span><span class="lineCov">        140 : index_set_state_flags(Oid indexId, IndexStateFlagsAction action)</span>
<span class="lineNum">    3253 </span>            : {
<span class="lineNum">    3254 </span>            :     Relation    pg_index;
<span class="lineNum">    3255 </span>            :     HeapTuple   indexTuple;
<span class="lineNum">    3256 </span>            :     Form_pg_index indexForm;
<span class="lineNum">    3257 </span>            : 
<span class="lineNum">    3258 </span>            :     /* Assert that current xact hasn't done any transactional updates */
<span class="lineNum">    3259 </span><span class="lineCov">        140 :     Assert(GetTopTransactionIdIfAny() == InvalidTransactionId);</span>
<span class="lineNum">    3260 </span>            : 
<span class="lineNum">    3261 </span>            :     /* Open pg_index and fetch a writable copy of the index's tuple */
<span class="lineNum">    3262 </span><span class="lineCov">        140 :     pg_index = table_open(IndexRelationId, RowExclusiveLock);</span>
<span class="lineNum">    3263 </span>            : 
<span class="lineNum">    3264 </span><span class="lineCov">        140 :     indexTuple = SearchSysCacheCopy1(INDEXRELID,</span>
<span class="lineNum">    3265 </span>            :                                      ObjectIdGetDatum(indexId));
<span class="lineNum">    3266 </span><span class="lineCov">        140 :     if (!HeapTupleIsValid(indexTuple))</span>
<span class="lineNum">    3267 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cache lookup failed for index %u&quot;, indexId);</span>
<span class="lineNum">    3268 </span><span class="lineCov">        140 :     indexForm = (Form_pg_index) GETSTRUCT(indexTuple);</span>
<span class="lineNum">    3269 </span>            : 
<span class="lineNum">    3270 </span>            :     /* Perform the requested state change on the copy */
<span class="lineNum">    3271 </span><span class="lineCov">        140 :     switch (action)</span>
<span class="lineNum">    3272 </span>            :     {
<span class="lineNum">    3273 </span>            :         case INDEX_CREATE_SET_READY:
<span class="lineNum">    3274 </span>            :             /* Set indisready during a CREATE INDEX CONCURRENTLY sequence */
<span class="lineNum">    3275 </span><span class="lineCov">         58 :             Assert(indexForm-&gt;indislive);</span>
<span class="lineNum">    3276 </span><span class="lineCov">         58 :             Assert(!indexForm-&gt;indisready);</span>
<span class="lineNum">    3277 </span><span class="lineCov">         58 :             Assert(!indexForm-&gt;indisvalid);</span>
<span class="lineNum">    3278 </span><span class="lineCov">         58 :             indexForm-&gt;indisready = true;</span>
<span class="lineNum">    3279 </span><span class="lineCov">         58 :             break;</span>
<span class="lineNum">    3280 </span>            :         case INDEX_CREATE_SET_VALID:
<span class="lineNum">    3281 </span>            :             /* Set indisvalid during a CREATE INDEX CONCURRENTLY sequence */
<span class="lineNum">    3282 </span><span class="lineCov">         14 :             Assert(indexForm-&gt;indislive);</span>
<span class="lineNum">    3283 </span><span class="lineCov">         14 :             Assert(indexForm-&gt;indisready);</span>
<span class="lineNum">    3284 </span><span class="lineCov">         14 :             Assert(!indexForm-&gt;indisvalid);</span>
<span class="lineNum">    3285 </span><span class="lineCov">         14 :             indexForm-&gt;indisvalid = true;</span>
<span class="lineNum">    3286 </span><span class="lineCov">         14 :             break;</span>
<span class="lineNum">    3287 </span>            :         case INDEX_DROP_CLEAR_VALID:
<span class="lineNum">    3288 </span>            : 
<span class="lineNum">    3289 </span>            :             /*
<span class="lineNum">    3290 </span>            :              * Clear indisvalid during a DROP INDEX CONCURRENTLY sequence
<span class="lineNum">    3291 </span>            :              *
<span class="lineNum">    3292 </span>            :              * If indisready == true we leave it set so the index still gets
<span class="lineNum">    3293 </span>            :              * maintained by active transactions.  We only need to ensure that
<span class="lineNum">    3294 </span>            :              * indisvalid is false.  (We don't assert that either is initially
<span class="lineNum">    3295 </span>            :              * true, though, since we want to be able to retry a DROP INDEX
<span class="lineNum">    3296 </span>            :              * CONCURRENTLY that failed partway through.)
<span class="lineNum">    3297 </span>            :              *
<span class="lineNum">    3298 </span>            :              * Note: the CLUSTER logic assumes that indisclustered cannot be
<span class="lineNum">    3299 </span>            :              * set on any invalid index, so clear that flag too.
<span class="lineNum">    3300 </span>            :              */
<span class="lineNum">    3301 </span><span class="lineCov">         12 :             indexForm-&gt;indisvalid = false;</span>
<span class="lineNum">    3302 </span><span class="lineCov">         12 :             indexForm-&gt;indisclustered = false;</span>
<span class="lineNum">    3303 </span><span class="lineCov">         12 :             break;</span>
<span class="lineNum">    3304 </span>            :         case INDEX_DROP_SET_DEAD:
<span class="lineNum">    3305 </span>            : 
<span class="lineNum">    3306 </span>            :             /*
<span class="lineNum">    3307 </span>            :              * Clear indisready/indislive during DROP INDEX CONCURRENTLY
<span class="lineNum">    3308 </span>            :              *
<span class="lineNum">    3309 </span>            :              * We clear both indisready and indislive, because we not only
<span class="lineNum">    3310 </span>            :              * want to stop updates, we want to prevent sessions from touching
<span class="lineNum">    3311 </span>            :              * the index at all.
<span class="lineNum">    3312 </span>            :              */
<span class="lineNum">    3313 </span><span class="lineCov">         56 :             Assert(!indexForm-&gt;indisvalid);</span>
<span class="lineNum">    3314 </span><span class="lineCov">         56 :             indexForm-&gt;indisready = false;</span>
<span class="lineNum">    3315 </span><span class="lineCov">         56 :             indexForm-&gt;indislive = false;</span>
<span class="lineNum">    3316 </span><span class="lineCov">         56 :             break;</span>
<span class="lineNum">    3317 </span>            :     }
<span class="lineNum">    3318 </span>            : 
<span class="lineNum">    3319 </span>            :     /* ... and write it back in-place */
<span class="lineNum">    3320 </span><span class="lineCov">        140 :     heap_inplace_update(pg_index, indexTuple);</span>
<span class="lineNum">    3321 </span>            : 
<span class="lineNum">    3322 </span><span class="lineCov">        140 :     table_close(pg_index, RowExclusiveLock);</span>
<span class="lineNum">    3323 </span><span class="lineCov">        140 : }</span>
<span class="lineNum">    3324 </span>            : 
<span class="lineNum">    3325 </span>            : 
<span class="lineNum">    3326 </span>            : /*
<span class="lineNum">    3327 </span>            :  * IndexGetRelation: given an index's relation OID, get the OID of the
<span class="lineNum">    3328 </span>            :  * relation it is an index on.  Uses the system cache.
<a name="3329"><span class="lineNum">    3329 </span>            :  */</a>
<span class="lineNum">    3330 </span>            : Oid
<span class="lineNum">    3331 </span><span class="lineCov">       5608 : IndexGetRelation(Oid indexId, bool missing_ok)</span>
<span class="lineNum">    3332 </span>            : {
<span class="lineNum">    3333 </span>            :     HeapTuple   tuple;
<span class="lineNum">    3334 </span>            :     Form_pg_index index;
<span class="lineNum">    3335 </span>            :     Oid         result;
<span class="lineNum">    3336 </span>            : 
<span class="lineNum">    3337 </span><span class="lineCov">       5608 :     tuple = SearchSysCache1(INDEXRELID, ObjectIdGetDatum(indexId));</span>
<span class="lineNum">    3338 </span><span class="lineCov">       5608 :     if (!HeapTupleIsValid(tuple))</span>
<span class="lineNum">    3339 </span>            :     {
<span class="lineNum">    3340 </span><span class="lineCov">          2 :         if (missing_ok)</span>
<span class="lineNum">    3341 </span><span class="lineCov">          2 :             return InvalidOid;</span>
<span class="lineNum">    3342 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cache lookup failed for index %u&quot;, indexId);</span>
<span class="lineNum">    3343 </span>            :     }
<span class="lineNum">    3344 </span><span class="lineCov">       5606 :     index = (Form_pg_index) GETSTRUCT(tuple);</span>
<span class="lineNum">    3345 </span><span class="lineCov">       5606 :     Assert(index-&gt;indexrelid == indexId);</span>
<span class="lineNum">    3346 </span>            : 
<span class="lineNum">    3347 </span><span class="lineCov">       5606 :     result = index-&gt;indrelid;</span>
<span class="lineNum">    3348 </span><span class="lineCov">       5606 :     ReleaseSysCache(tuple);</span>
<span class="lineNum">    3349 </span><span class="lineCov">       5606 :     return result;</span>
<span class="lineNum">    3350 </span>            : }
<span class="lineNum">    3351 </span>            : 
<span class="lineNum">    3352 </span>            : /*
<span class="lineNum">    3353 </span>            :  * reindex_index - This routine is used to recreate a single index
<a name="3354"><span class="lineNum">    3354 </span>            :  */</a>
<span class="lineNum">    3355 </span>            : void
<span class="lineNum">    3356 </span><span class="lineCov">        842 : reindex_index(Oid indexId, bool skip_constraint_checks, char persistence,</span>
<span class="lineNum">    3357 </span>            :               int options)
<span class="lineNum">    3358 </span>            : {
<span class="lineNum">    3359 </span>            :     Relation    iRel,
<span class="lineNum">    3360 </span>            :                 heapRelation;
<span class="lineNum">    3361 </span>            :     Oid         heapId;
<span class="lineNum">    3362 </span>            :     IndexInfo  *indexInfo;
<span class="lineNum">    3363 </span><span class="lineCov">        842 :     volatile bool skipped_constraint = false;</span>
<span class="lineNum">    3364 </span>            :     PGRUsage    ru0;
<span class="lineNum">    3365 </span><span class="lineCov">        842 :     bool        progress = (options &amp; REINDEXOPT_REPORT_PROGRESS) != 0;</span>
<span class="lineNum">    3366 </span>            : 
<span class="lineNum">    3367 </span><span class="lineCov">        842 :     pg_rusage_init(&amp;ru0);</span>
<span class="lineNum">    3368 </span>            : 
<span class="lineNum">    3369 </span>            :     /*
<span class="lineNum">    3370 </span>            :      * Open and lock the parent heap relation.  ShareLock is sufficient since
<span class="lineNum">    3371 </span>            :      * we only need to be sure no schema or data changes are going on.
<span class="lineNum">    3372 </span>            :      */
<span class="lineNum">    3373 </span><span class="lineCov">        842 :     heapId = IndexGetRelation(indexId, false);</span>
<span class="lineNum">    3374 </span><span class="lineCov">        842 :     heapRelation = table_open(heapId, ShareLock);</span>
<span class="lineNum">    3375 </span>            : 
<span class="lineNum">    3376 </span><span class="lineCov">        842 :     if (progress)</span>
<span class="lineNum">    3377 </span>            :     {
<span class="lineNum">    3378 </span><span class="lineCov">         60 :         pgstat_progress_start_command(PROGRESS_COMMAND_CREATE_INDEX,</span>
<span class="lineNum">    3379 </span>            :                                       heapId);
<span class="lineNum">    3380 </span><span class="lineCov">         60 :         pgstat_progress_update_param(PROGRESS_CREATEIDX_COMMAND,</span>
<span class="lineNum">    3381 </span>            :                                      PROGRESS_CREATEIDX_COMMAND_REINDEX);
<span class="lineNum">    3382 </span><span class="lineCov">         60 :         pgstat_progress_update_param(PROGRESS_CREATEIDX_INDEX_OID,</span>
<span class="lineNum">    3383 </span>            :                                      indexId);
<span class="lineNum">    3384 </span>            :     }
<span class="lineNum">    3385 </span>            : 
<span class="lineNum">    3386 </span>            :     /*
<span class="lineNum">    3387 </span>            :      * Open the target index relation and get an exclusive lock on it, to
<span class="lineNum">    3388 </span>            :      * ensure that no one else is touching this particular index.
<span class="lineNum">    3389 </span>            :      */
<span class="lineNum">    3390 </span><span class="lineCov">        842 :     iRel = index_open(indexId, AccessExclusiveLock);</span>
<span class="lineNum">    3391 </span>            : 
<span class="lineNum">    3392 </span><span class="lineCov">        842 :     if (progress)</span>
<span class="lineNum">    3393 </span><span class="lineCov">         60 :         pgstat_progress_update_param(PROGRESS_CREATEIDX_ACCESS_METHOD_OID,</span>
<span class="lineNum">    3394 </span><span class="lineCov">         60 :                                      iRel-&gt;rd_rel-&gt;relam);</span>
<span class="lineNum">    3395 </span>            : 
<span class="lineNum">    3396 </span>            :     /*
<span class="lineNum">    3397 </span>            :      * The case of reindexing partitioned tables and indexes is handled
<span class="lineNum">    3398 </span>            :      * differently by upper layers, so this case shouldn't arise.
<span class="lineNum">    3399 </span>            :      */
<span class="lineNum">    3400 </span><span class="lineCov">        842 :     if (iRel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_INDEX)</span>
<span class="lineNum">    3401 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;unsupported relation kind for index \&quot;%s\&quot;&quot;,</span>
<span class="lineNum">    3402 </span>            :              RelationGetRelationName(iRel));
<span class="lineNum">    3403 </span>            : 
<span class="lineNum">    3404 </span>            :     /*
<span class="lineNum">    3405 </span>            :      * Don't allow reindex on temp tables of other backends ... their local
<span class="lineNum">    3406 </span>            :      * buffer manager is not going to cope.
<span class="lineNum">    3407 </span>            :      */
<span class="lineNum">    3408 </span><span class="lineCov">        842 :     if (RELATION_IS_OTHER_TEMP(iRel))</span>
<span class="lineNum">    3409 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">    3410 </span>            :                 (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">    3411 </span>            :                  errmsg(&quot;cannot reindex temporary tables of other sessions&quot;)));
<span class="lineNum">    3412 </span>            : 
<span class="lineNum">    3413 </span>            :     /*
<span class="lineNum">    3414 </span>            :      * Also check for active uses of the index in the current transaction; we
<span class="lineNum">    3415 </span>            :      * don't want to reindex underneath an open indexscan.
<span class="lineNum">    3416 </span>            :      */
<span class="lineNum">    3417 </span><span class="lineCov">        842 :     CheckTableNotInUse(iRel, &quot;REINDEX INDEX&quot;);</span>
<span class="lineNum">    3418 </span>            : 
<span class="lineNum">    3419 </span>            :     /*
<span class="lineNum">    3420 </span>            :      * All predicate locks on the index are about to be made invalid. Promote
<span class="lineNum">    3421 </span>            :      * them to relation locks on the heap.
<span class="lineNum">    3422 </span>            :      */
<span class="lineNum">    3423 </span><span class="lineCov">        842 :     TransferPredicateLocksToHeapRelation(iRel);</span>
<span class="lineNum">    3424 </span>            : 
<span class="lineNum">    3425 </span>            :     /* Fetch info needed for index_build */
<span class="lineNum">    3426 </span><span class="lineCov">        842 :     indexInfo = BuildIndexInfo(iRel);</span>
<span class="lineNum">    3427 </span>            : 
<span class="lineNum">    3428 </span>            :     /* If requested, skip checking uniqueness/exclusion constraints */
<span class="lineNum">    3429 </span><span class="lineCov">        842 :     if (skip_constraint_checks)</span>
<span class="lineNum">    3430 </span>            :     {
<span class="lineNum">    3431 </span><span class="lineCov">        606 :         if (indexInfo-&gt;ii_Unique || indexInfo-&gt;ii_ExclusionOps != NULL)</span>
<span class="lineNum">    3432 </span><span class="lineCov">        500 :             skipped_constraint = true;</span>
<span class="lineNum">    3433 </span><span class="lineCov">        606 :         indexInfo-&gt;ii_Unique = false;</span>
<span class="lineNum">    3434 </span><span class="lineCov">        606 :         indexInfo-&gt;ii_ExclusionOps = NULL;</span>
<span class="lineNum">    3435 </span><span class="lineCov">        606 :         indexInfo-&gt;ii_ExclusionProcs = NULL;</span>
<span class="lineNum">    3436 </span><span class="lineCov">        606 :         indexInfo-&gt;ii_ExclusionStrats = NULL;</span>
<span class="lineNum">    3437 </span>            :     }
<span class="lineNum">    3438 </span>            : 
<span class="lineNum">    3439 </span>            :     /* ensure SetReindexProcessing state isn't leaked */
<span class="lineNum">    3440 </span><span class="lineCov">        842 :     PG_TRY();</span>
<span class="lineNum">    3441 </span>            :     {
<span class="lineNum">    3442 </span>            :         /* Suppress use of the target index while rebuilding it */
<span class="lineNum">    3443 </span><span class="lineCov">        842 :         SetReindexProcessing(heapId, indexId);</span>
<span class="lineNum">    3444 </span>            : 
<span class="lineNum">    3445 </span>            :         /* Create a new physical relation for the index */
<span class="lineNum">    3446 </span><span class="lineCov">        842 :         RelationSetNewRelfilenode(iRel, persistence);</span>
<span class="lineNum">    3447 </span>            : 
<span class="lineNum">    3448 </span>            :         /* Initialize the index and rebuild */
<span class="lineNum">    3449 </span>            :         /* Note: we do not need to re-establish pkey setting */
<span class="lineNum">    3450 </span><span class="lineCov">        842 :         index_build(heapRelation, iRel, indexInfo, true, true);</span>
<span class="lineNum">    3451 </span>            :     }
<span class="lineNum">    3452 </span><span class="lineCov">          8 :     PG_FINALLY();</span>
<span class="lineNum">    3453 </span>            :     {
<span class="lineNum">    3454 </span>            :         /* Make sure flag gets cleared on error exit */
<span class="lineNum">    3455 </span><span class="lineCov">        842 :         ResetReindexProcessing();</span>
<span class="lineNum">    3456 </span>            :     }
<span class="lineNum">    3457 </span><span class="lineCov">        842 :     PG_END_TRY();</span>
<span class="lineNum">    3458 </span>            : 
<span class="lineNum">    3459 </span>            :     /*
<span class="lineNum">    3460 </span>            :      * If the index is marked invalid/not-ready/dead (ie, it's from a failed
<span class="lineNum">    3461 </span>            :      * CREATE INDEX CONCURRENTLY, or a DROP INDEX CONCURRENTLY failed midway),
<span class="lineNum">    3462 </span>            :      * and we didn't skip a uniqueness check, we can now mark it valid.  This
<span class="lineNum">    3463 </span>            :      * allows REINDEX to be used to clean up in such cases.
<span class="lineNum">    3464 </span>            :      *
<span class="lineNum">    3465 </span>            :      * We can also reset indcheckxmin, because we have now done a
<span class="lineNum">    3466 </span>            :      * non-concurrent index build, *except* in the case where index_build
<span class="lineNum">    3467 </span>            :      * found some still-broken HOT chains. If it did, and we don't have to
<span class="lineNum">    3468 </span>            :      * change any of the other flags, we just leave indcheckxmin alone (note
<span class="lineNum">    3469 </span>            :      * that index_build won't have changed it, because this is a reindex).
<span class="lineNum">    3470 </span>            :      * This is okay and desirable because not updating the tuple leaves the
<span class="lineNum">    3471 </span>            :      * index's usability horizon (recorded as the tuple's xmin value) the same
<span class="lineNum">    3472 </span>            :      * as it was.
<span class="lineNum">    3473 </span>            :      *
<span class="lineNum">    3474 </span>            :      * But, if the index was invalid/not-ready/dead and there were broken HOT
<span class="lineNum">    3475 </span>            :      * chains, we had better force indcheckxmin true, because the normal
<span class="lineNum">    3476 </span>            :      * argument that the HOT chains couldn't conflict with the index is
<span class="lineNum">    3477 </span>            :      * suspect for an invalid index.  (A conflict is definitely possible if
<span class="lineNum">    3478 </span>            :      * the index was dead.  It probably shouldn't happen otherwise, but let's
<span class="lineNum">    3479 </span>            :      * be conservative.)  In this case advancing the usability horizon is
<span class="lineNum">    3480 </span>            :      * appropriate.
<span class="lineNum">    3481 </span>            :      *
<span class="lineNum">    3482 </span>            :      * Another reason for avoiding unnecessary updates here is that while
<span class="lineNum">    3483 </span>            :      * reindexing pg_index itself, we must not try to update tuples in it.
<span class="lineNum">    3484 </span>            :      * pg_index's indexes should always have these flags in their clean state,
<span class="lineNum">    3485 </span>            :      * so that won't happen.
<span class="lineNum">    3486 </span>            :      *
<span class="lineNum">    3487 </span>            :      * If early pruning/vacuuming is enabled for the heap relation, the
<span class="lineNum">    3488 </span>            :      * usability horizon must be advanced to the current transaction on every
<span class="lineNum">    3489 </span>            :      * build or rebuild.  pg_index is OK in this regard because catalog tables
<span class="lineNum">    3490 </span>            :      * are not subject to early cleanup.
<span class="lineNum">    3491 </span>            :      */
<span class="lineNum">    3492 </span><span class="lineCov">        834 :     if (!skipped_constraint)</span>
<span class="lineNum">    3493 </span>            :     {
<span class="lineNum">    3494 </span>            :         Relation    pg_index;
<span class="lineNum">    3495 </span>            :         HeapTuple   indexTuple;
<span class="lineNum">    3496 </span>            :         Form_pg_index indexForm;
<span class="lineNum">    3497 </span>            :         bool        index_bad;
<span class="lineNum">    3498 </span><span class="lineCov">        334 :         bool        early_pruning_enabled = EarlyPruningEnabled(heapRelation);</span>
<span class="lineNum">    3499 </span>            : 
<span class="lineNum">    3500 </span><span class="lineCov">        334 :         pg_index = table_open(IndexRelationId, RowExclusiveLock);</span>
<span class="lineNum">    3501 </span>            : 
<span class="lineNum">    3502 </span><span class="lineCov">        334 :         indexTuple = SearchSysCacheCopy1(INDEXRELID,</span>
<span class="lineNum">    3503 </span>            :                                          ObjectIdGetDatum(indexId));
<span class="lineNum">    3504 </span><span class="lineCov">        334 :         if (!HeapTupleIsValid(indexTuple))</span>
<span class="lineNum">    3505 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;cache lookup failed for index %u&quot;, indexId);</span>
<span class="lineNum">    3506 </span><span class="lineCov">        334 :         indexForm = (Form_pg_index) GETSTRUCT(indexTuple);</span>
<span class="lineNum">    3507 </span>            : 
<span class="lineNum">    3508 </span><span class="lineCov">       1000 :         index_bad = (!indexForm-&gt;indisvalid ||</span>
<span class="lineNum">    3509 </span><span class="lineCov">        666 :                      !indexForm-&gt;indisready ||</span>
<span class="lineNum">    3510 </span><span class="lineCov">        332 :                      !indexForm-&gt;indislive);</span>
<span class="lineNum">    3511 </span><span class="lineCov">        666 :         if (index_bad ||</span>
<span class="lineNum">    3512 </span><span class="lineCov">        332 :             (indexForm-&gt;indcheckxmin &amp;&amp; !indexInfo-&gt;ii_BrokenHotChain) ||</span>
<span class="lineNum">    3513 </span>            :             early_pruning_enabled)
<span class="lineNum">    3514 </span>            :         {
<span class="lineNum">    3515 </span><span class="lineCov">          2 :             if (!indexInfo-&gt;ii_BrokenHotChain &amp;&amp; !early_pruning_enabled)</span>
<span class="lineNum">    3516 </span><span class="lineCov">          2 :                 indexForm-&gt;indcheckxmin = false;</span>
<span class="lineNum">    3517 </span><span class="lineNoCov">          0 :             else if (index_bad || early_pruning_enabled)</span>
<span class="lineNum">    3518 </span><span class="lineNoCov">          0 :                 indexForm-&gt;indcheckxmin = true;</span>
<span class="lineNum">    3519 </span><span class="lineCov">          2 :             indexForm-&gt;indisvalid = true;</span>
<span class="lineNum">    3520 </span><span class="lineCov">          2 :             indexForm-&gt;indisready = true;</span>
<span class="lineNum">    3521 </span><span class="lineCov">          2 :             indexForm-&gt;indislive = true;</span>
<span class="lineNum">    3522 </span><span class="lineCov">          2 :             CatalogTupleUpdate(pg_index, &amp;indexTuple-&gt;t_self, indexTuple);</span>
<span class="lineNum">    3523 </span>            : 
<span class="lineNum">    3524 </span>            :             /*
<span class="lineNum">    3525 </span>            :              * Invalidate the relcache for the table, so that after we commit
<span class="lineNum">    3526 </span>            :              * all sessions will refresh the table's index list.  This ensures
<span class="lineNum">    3527 </span>            :              * that if anyone misses seeing the pg_index row during this
<span class="lineNum">    3528 </span>            :              * update, they'll refresh their list before attempting any update
<span class="lineNum">    3529 </span>            :              * on the table.
<span class="lineNum">    3530 </span>            :              */
<span class="lineNum">    3531 </span><span class="lineCov">          2 :             CacheInvalidateRelcache(heapRelation);</span>
<span class="lineNum">    3532 </span>            :         }
<span class="lineNum">    3533 </span>            : 
<span class="lineNum">    3534 </span><span class="lineCov">        334 :         table_close(pg_index, RowExclusiveLock);</span>
<span class="lineNum">    3535 </span>            :     }
<span class="lineNum">    3536 </span>            : 
<span class="lineNum">    3537 </span>            :     /* Log what we did */
<span class="lineNum">    3538 </span><span class="lineCov">        834 :     if (options &amp; REINDEXOPT_VERBOSE)</span>
<span class="lineNum">    3539 </span><span class="lineCov">          2 :         ereport(INFO,</span>
<span class="lineNum">    3540 </span>            :                 (errmsg(&quot;index \&quot;%s\&quot; was reindexed&quot;,
<span class="lineNum">    3541 </span>            :                         get_rel_name(indexId)),
<span class="lineNum">    3542 </span>            :                  errdetail_internal(&quot;%s&quot;,
<span class="lineNum">    3543 </span>            :                                     pg_rusage_show(&amp;ru0))));
<span class="lineNum">    3544 </span>            : 
<span class="lineNum">    3545 </span><span class="lineCov">        834 :     if (progress)</span>
<span class="lineNum">    3546 </span><span class="lineCov">         58 :         pgstat_progress_end_command();</span>
<span class="lineNum">    3547 </span>            : 
<span class="lineNum">    3548 </span>            :     /* Close rels, but keep locks */
<span class="lineNum">    3549 </span><span class="lineCov">        834 :     index_close(iRel, NoLock);</span>
<span class="lineNum">    3550 </span><span class="lineCov">        834 :     table_close(heapRelation, NoLock);</span>
<span class="lineNum">    3551 </span><span class="lineCov">        834 : }</span>
<span class="lineNum">    3552 </span>            : 
<span class="lineNum">    3553 </span>            : /*
<span class="lineNum">    3554 </span>            :  * reindex_relation - This routine is used to recreate all indexes
<span class="lineNum">    3555 </span>            :  * of a relation (and optionally its toast relation too, if any).
<span class="lineNum">    3556 </span>            :  *
<span class="lineNum">    3557 </span>            :  * &quot;flags&quot; is a bitmask that can include any combination of these bits:
<span class="lineNum">    3558 </span>            :  *
<span class="lineNum">    3559 </span>            :  * REINDEX_REL_PROCESS_TOAST: if true, process the toast table too (if any).
<span class="lineNum">    3560 </span>            :  *
<span class="lineNum">    3561 </span>            :  * REINDEX_REL_SUPPRESS_INDEX_USE: if true, the relation was just completely
<span class="lineNum">    3562 </span>            :  * rebuilt by an operation such as VACUUM FULL or CLUSTER, and therefore its
<span class="lineNum">    3563 </span>            :  * indexes are inconsistent with it.  This makes things tricky if the relation
<span class="lineNum">    3564 </span>            :  * is a system catalog that we might consult during the reindexing.  To deal
<span class="lineNum">    3565 </span>            :  * with that case, we mark all of the indexes as pending rebuild so that they
<span class="lineNum">    3566 </span>            :  * won't be trusted until rebuilt.  The caller is required to call us *without*
<span class="lineNum">    3567 </span>            :  * having made the rebuilt table visible by doing CommandCounterIncrement;
<span class="lineNum">    3568 </span>            :  * we'll do CCI after having collected the index list.  (This way we can still
<span class="lineNum">    3569 </span>            :  * use catalog indexes while collecting the list.)
<span class="lineNum">    3570 </span>            :  *
<span class="lineNum">    3571 </span>            :  * REINDEX_REL_CHECK_CONSTRAINTS: if true, recheck unique and exclusion
<span class="lineNum">    3572 </span>            :  * constraint conditions, else don't.  To avoid deadlocks, VACUUM FULL or
<span class="lineNum">    3573 </span>            :  * CLUSTER on a system catalog must omit this flag.  REINDEX should be used to
<span class="lineNum">    3574 </span>            :  * rebuild an index if constraint inconsistency is suspected.  For optimal
<span class="lineNum">    3575 </span>            :  * performance, other callers should include the flag only after transforming
<span class="lineNum">    3576 </span>            :  * the data in a manner that risks a change in constraint validity.
<span class="lineNum">    3577 </span>            :  *
<span class="lineNum">    3578 </span>            :  * REINDEX_REL_FORCE_INDEXES_UNLOGGED: if true, set the persistence of the
<span class="lineNum">    3579 </span>            :  * rebuilt indexes to unlogged.
<span class="lineNum">    3580 </span>            :  *
<span class="lineNum">    3581 </span>            :  * REINDEX_REL_FORCE_INDEXES_PERMANENT: if true, set the persistence of the
<span class="lineNum">    3582 </span>            :  * rebuilt indexes to permanent.
<span class="lineNum">    3583 </span>            :  *
<span class="lineNum">    3584 </span>            :  * Returns true if any indexes were rebuilt (including toast table's index
<span class="lineNum">    3585 </span>            :  * when relevant).  Note that a CommandCounterIncrement will occur after each
<span class="lineNum">    3586 </span>            :  * index rebuild.
<a name="3587"><span class="lineNum">    3587 </span>            :  */</a>
<span class="lineNum">    3588 </span>            : bool
<span class="lineNum">    3589 </span><span class="lineCov">       1218 : reindex_relation(Oid relid, int flags, int options)</span>
<span class="lineNum">    3590 </span>            : {
<span class="lineNum">    3591 </span>            :     Relation    rel;
<span class="lineNum">    3592 </span>            :     Oid         toast_relid;
<span class="lineNum">    3593 </span>            :     List       *indexIds;
<span class="lineNum">    3594 </span>            :     bool        result;
<span class="lineNum">    3595 </span>            :     int         i;
<span class="lineNum">    3596 </span>            : 
<span class="lineNum">    3597 </span>            :     /*
<span class="lineNum">    3598 </span>            :      * Open and lock the relation.  ShareLock is sufficient since we only need
<span class="lineNum">    3599 </span>            :      * to prevent schema and data changes in it.  The lock level used here
<span class="lineNum">    3600 </span>            :      * should match ReindexTable().
<span class="lineNum">    3601 </span>            :      */
<span class="lineNum">    3602 </span><span class="lineCov">       1218 :     rel = table_open(relid, ShareLock);</span>
<span class="lineNum">    3603 </span>            : 
<span class="lineNum">    3604 </span>            :     /*
<span class="lineNum">    3605 </span>            :      * This may be useful when implemented someday; but that day is not today.
<span class="lineNum">    3606 </span>            :      * For now, avoid erroring out when called in a multi-table context
<span class="lineNum">    3607 </span>            :      * (REINDEX SCHEMA) and happen to come across a partitioned table.  The
<span class="lineNum">    3608 </span>            :      * partitions may be reindexed on their own anyway.
<span class="lineNum">    3609 </span>            :      */
<span class="lineNum">    3610 </span><span class="lineCov">       1218 :     if (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)</span>
<span class="lineNum">    3611 </span>            :     {
<span class="lineNum">    3612 </span><span class="lineCov">          2 :         ereport(WARNING,</span>
<span class="lineNum">    3613 </span>            :                 (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
<span class="lineNum">    3614 </span>            :                  errmsg(&quot;REINDEX of partitioned tables is not yet implemented, skipping \&quot;%s\&quot;&quot;,
<span class="lineNum">    3615 </span>            :                         RelationGetRelationName(rel))));
<span class="lineNum">    3616 </span><span class="lineCov">          2 :         table_close(rel, ShareLock);</span>
<span class="lineNum">    3617 </span><span class="lineCov">          2 :         return false;</span>
<span class="lineNum">    3618 </span>            :     }
<span class="lineNum">    3619 </span>            : 
<span class="lineNum">    3620 </span><span class="lineCov">       1216 :     toast_relid = rel-&gt;rd_rel-&gt;reltoastrelid;</span>
<span class="lineNum">    3621 </span>            : 
<span class="lineNum">    3622 </span>            :     /*
<span class="lineNum">    3623 </span>            :      * Get the list of index OIDs for this relation.  (We trust to the
<span class="lineNum">    3624 </span>            :      * relcache to get this with a sequential scan if ignoring system
<span class="lineNum">    3625 </span>            :      * indexes.)
<span class="lineNum">    3626 </span>            :      */
<span class="lineNum">    3627 </span><span class="lineCov">       1216 :     indexIds = RelationGetIndexList(rel);</span>
<span class="lineNum">    3628 </span>            : 
<span class="lineNum">    3629 </span><span class="lineCov">       1216 :     PG_TRY();</span>
<span class="lineNum">    3630 </span>            :     {
<span class="lineNum">    3631 </span>            :         ListCell   *indexId;
<span class="lineNum">    3632 </span>            :         char        persistence;
<span class="lineNum">    3633 </span>            : 
<span class="lineNum">    3634 </span><span class="lineCov">       1216 :         if (flags &amp; REINDEX_REL_SUPPRESS_INDEX_USE)</span>
<span class="lineNum">    3635 </span>            :         {
<span class="lineNum">    3636 </span>            :             /* Suppress use of all the indexes until they are rebuilt */
<span class="lineNum">    3637 </span><span class="lineCov">        250 :             SetReindexPending(indexIds);</span>
<span class="lineNum">    3638 </span>            : 
<span class="lineNum">    3639 </span>            :             /*
<span class="lineNum">    3640 </span>            :              * Make the new heap contents visible --- now things might be
<span class="lineNum">    3641 </span>            :              * inconsistent!
<span class="lineNum">    3642 </span>            :              */
<span class="lineNum">    3643 </span><span class="lineCov">        250 :             CommandCounterIncrement();</span>
<span class="lineNum">    3644 </span>            :         }
<span class="lineNum">    3645 </span>            : 
<span class="lineNum">    3646 </span>            :         /*
<span class="lineNum">    3647 </span>            :          * Compute persistence of indexes: same as that of owning rel, unless
<span class="lineNum">    3648 </span>            :          * caller specified otherwise.
<span class="lineNum">    3649 </span>            :          */
<span class="lineNum">    3650 </span><span class="lineCov">       1216 :         if (flags &amp; REINDEX_REL_FORCE_INDEXES_UNLOGGED)</span>
<span class="lineNum">    3651 </span><span class="lineCov">          6 :             persistence = RELPERSISTENCE_UNLOGGED;</span>
<span class="lineNum">    3652 </span><span class="lineCov">       1210 :         else if (flags &amp; REINDEX_REL_FORCE_INDEXES_PERMANENT)</span>
<span class="lineNum">    3653 </span><span class="lineCov">        232 :             persistence = RELPERSISTENCE_PERMANENT;</span>
<span class="lineNum">    3654 </span>            :         else
<span class="lineNum">    3655 </span><span class="lineCov">        978 :             persistence = rel-&gt;rd_rel-&gt;relpersistence;</span>
<span class="lineNum">    3656 </span>            : 
<span class="lineNum">    3657 </span>            :         /* Reindex all the indexes. */
<span class="lineNum">    3658 </span><span class="lineCov">       1216 :         i = 1;</span>
<span class="lineNum">    3659 </span><span class="lineCov">       2036 :         foreach(indexId, indexIds)</span>
<span class="lineNum">    3660 </span>            :         {
<span class="lineNum">    3661 </span><span class="lineCov">        828 :             Oid         indexOid = lfirst_oid(indexId);</span>
<span class="lineNum">    3662 </span>            : 
<span class="lineNum">    3663 </span><span class="lineCov">        828 :             reindex_index(indexOid, !(flags &amp; REINDEX_REL_CHECK_CONSTRAINTS),</span>
<span class="lineNum">    3664 </span>            :                           persistence, options);
<span class="lineNum">    3665 </span>            : 
<span class="lineNum">    3666 </span><span class="lineCov">        820 :             CommandCounterIncrement();</span>
<span class="lineNum">    3667 </span>            : 
<span class="lineNum">    3668 </span>            :             /* Index should no longer be in the pending list */
<span class="lineNum">    3669 </span><span class="lineCov">        820 :             Assert(!ReindexIsProcessingIndex(indexOid));</span>
<span class="lineNum">    3670 </span>            : 
<span class="lineNum">    3671 </span>            :             /* Set index rebuild count */
<span class="lineNum">    3672 </span><span class="lineCov">        820 :             pgstat_progress_update_param(PROGRESS_CLUSTER_INDEX_REBUILD_COUNT,</span>
<span class="lineNum">    3673 </span>            :                                          i);
<span class="lineNum">    3674 </span><span class="lineCov">        820 :             i++;</span>
<span class="lineNum">    3675 </span>            :         }
<span class="lineNum">    3676 </span>            :     }
<span class="lineNum">    3677 </span><span class="lineCov">          8 :     PG_FINALLY();</span>
<span class="lineNum">    3678 </span>            :     {
<span class="lineNum">    3679 </span>            :         /* Make sure list gets cleared on error exit */
<span class="lineNum">    3680 </span><span class="lineCov">       1216 :         ResetReindexPending();</span>
<span class="lineNum">    3681 </span>            :     }
<span class="lineNum">    3682 </span><span class="lineCov">       1216 :     PG_END_TRY();</span>
<span class="lineNum">    3683 </span>            : 
<span class="lineNum">    3684 </span>            :     /*
<span class="lineNum">    3685 </span>            :      * Close rel, but continue to hold the lock.
<span class="lineNum">    3686 </span>            :      */
<span class="lineNum">    3687 </span><span class="lineCov">       1208 :     table_close(rel, NoLock);</span>
<span class="lineNum">    3688 </span>            : 
<span class="lineNum">    3689 </span><span class="lineCov">       1208 :     result = (indexIds != NIL);</span>
<span class="lineNum">    3690 </span>            : 
<span class="lineNum">    3691 </span>            :     /*
<span class="lineNum">    3692 </span>            :      * If the relation has a secondary toast rel, reindex that too while we
<span class="lineNum">    3693 </span>            :      * still hold the lock on the master table.
<span class="lineNum">    3694 </span>            :      */
<span class="lineNum">    3695 </span><span class="lineCov">       1208 :     if ((flags &amp; REINDEX_REL_PROCESS_TOAST) &amp;&amp; OidIsValid(toast_relid))</span>
<span class="lineNum">    3696 </span><span class="lineCov">        378 :         result |= reindex_relation(toast_relid, flags, options);</span>
<span class="lineNum">    3697 </span>            : 
<span class="lineNum">    3698 </span><span class="lineCov">       1208 :     return result;</span>
<span class="lineNum">    3699 </span>            : }
<span class="lineNum">    3700 </span>            : 
<span class="lineNum">    3701 </span>            : 
<span class="lineNum">    3702 </span>            : /* ----------------------------------------------------------------
<span class="lineNum">    3703 </span>            :  *      System index reindexing support
<span class="lineNum">    3704 </span>            :  *
<span class="lineNum">    3705 </span>            :  * When we are busy reindexing a system index, this code provides support
<span class="lineNum">    3706 </span>            :  * for preventing catalog lookups from using that index.  We also make use
<span class="lineNum">    3707 </span>            :  * of this to catch attempted uses of user indexes during reindexing of
<span class="lineNum">    3708 </span>            :  * those indexes.  This information is propagated to parallel workers;
<span class="lineNum">    3709 </span>            :  * attempting to change it during a parallel operation is not permitted.
<span class="lineNum">    3710 </span>            :  * ----------------------------------------------------------------
<span class="lineNum">    3711 </span>            :  */
<span class="lineNum">    3712 </span>            : 
<span class="lineNum">    3713 </span>            : static Oid  currentlyReindexedHeap = InvalidOid;
<span class="lineNum">    3714 </span>            : static Oid  currentlyReindexedIndex = InvalidOid;
<span class="lineNum">    3715 </span>            : static List *pendingReindexedIndexes = NIL;
<span class="lineNum">    3716 </span>            : 
<span class="lineNum">    3717 </span>            : /*
<span class="lineNum">    3718 </span>            :  * ReindexIsProcessingHeap
<span class="lineNum">    3719 </span>            :  *      True if heap specified by OID is currently being reindexed.
<a name="3720"><span class="lineNum">    3720 </span>            :  */</a>
<span class="lineNum">    3721 </span>            : bool
<span class="lineNum">    3722 </span><span class="lineCov">      11662 : ReindexIsProcessingHeap(Oid heapOid)</span>
<span class="lineNum">    3723 </span>            : {
<span class="lineNum">    3724 </span><span class="lineCov">      11662 :     return heapOid == currentlyReindexedHeap;</span>
<span class="lineNum">    3725 </span>            : }
<span class="lineNum">    3726 </span>            : 
<span class="lineNum">    3727 </span>            : /*
<span class="lineNum">    3728 </span>            :  * ReindexIsCurrentlyProcessingIndex
<span class="lineNum">    3729 </span>            :  *      True if index specified by OID is currently being reindexed.
<a name="3730"><span class="lineNum">    3730 </span>            :  */</a>
<span class="lineNum">    3731 </span>            : static bool
<span class="lineNum">    3732 </span><span class="lineCov">         48 : ReindexIsCurrentlyProcessingIndex(Oid indexOid)</span>
<span class="lineNum">    3733 </span>            : {
<span class="lineNum">    3734 </span><span class="lineCov">         48 :     return indexOid == currentlyReindexedIndex;</span>
<span class="lineNum">    3735 </span>            : }
<span class="lineNum">    3736 </span>            : 
<span class="lineNum">    3737 </span>            : /*
<span class="lineNum">    3738 </span>            :  * ReindexIsProcessingIndex
<span class="lineNum">    3739 </span>            :  *      True if index specified by OID is currently being reindexed,
<span class="lineNum">    3740 </span>            :  *      or should be treated as invalid because it is awaiting reindex.
<a name="3741"><span class="lineNum">    3741 </span>            :  */</a>
<span class="lineNum">    3742 </span>            : bool
<span class="lineNum">    3743 </span><span class="lineCov">    3640280 : ReindexIsProcessingIndex(Oid indexOid)</span>
<span class="lineNum">    3744 </span>            : {
<span class="lineNum">    3745 </span><span class="lineCov">    7278928 :     return indexOid == currentlyReindexedIndex ||</span>
<span class="lineNum">    3746 </span><span class="lineCov">    3638648 :         list_member_oid(pendingReindexedIndexes, indexOid);</span>
<span class="lineNum">    3747 </span>            : }
<span class="lineNum">    3748 </span>            : 
<span class="lineNum">    3749 </span>            : /*
<span class="lineNum">    3750 </span>            :  * SetReindexProcessing
<span class="lineNum">    3751 </span>            :  *      Set flag that specified heap/index are being reindexed.
<span class="lineNum">    3752 </span>            :  *
<span class="lineNum">    3753 </span>            :  * NB: caller must use a PG_TRY block to ensure ResetReindexProcessing is done.
<a name="3754"><span class="lineNum">    3754 </span>            :  */</a>
<span class="lineNum">    3755 </span>            : static void
<span class="lineNum">    3756 </span><span class="lineCov">        842 : SetReindexProcessing(Oid heapOid, Oid indexOid)</span>
<span class="lineNum">    3757 </span>            : {
<span class="lineNum">    3758 </span><span class="lineCov">        842 :     Assert(OidIsValid(heapOid) &amp;&amp; OidIsValid(indexOid));</span>
<span class="lineNum">    3759 </span>            :     /* Reindexing is not re-entrant. */
<span class="lineNum">    3760 </span><span class="lineCov">        842 :     if (OidIsValid(currentlyReindexedHeap))</span>
<span class="lineNum">    3761 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cannot reindex while reindexing&quot;);</span>
<span class="lineNum">    3762 </span><span class="lineCov">        842 :     currentlyReindexedHeap = heapOid;</span>
<span class="lineNum">    3763 </span><span class="lineCov">        842 :     currentlyReindexedIndex = indexOid;</span>
<span class="lineNum">    3764 </span>            :     /* Index is no longer &quot;pending&quot; reindex. */
<span class="lineNum">    3765 </span><span class="lineCov">        842 :     RemoveReindexPending(indexOid);</span>
<span class="lineNum">    3766 </span><span class="lineCov">        842 : }</span>
<span class="lineNum">    3767 </span>            : 
<span class="lineNum">    3768 </span>            : /*
<span class="lineNum">    3769 </span>            :  * ResetReindexProcessing
<span class="lineNum">    3770 </span>            :  *      Unset reindexing status.
<a name="3771"><span class="lineNum">    3771 </span>            :  */</a>
<span class="lineNum">    3772 </span>            : static void
<span class="lineNum">    3773 </span><span class="lineCov">        862 : ResetReindexProcessing(void)</span>
<span class="lineNum">    3774 </span>            : {
<span class="lineNum">    3775 </span>            :     /* This may be called in leader error path */
<span class="lineNum">    3776 </span><span class="lineCov">        862 :     currentlyReindexedHeap = InvalidOid;</span>
<span class="lineNum">    3777 </span><span class="lineCov">        862 :     currentlyReindexedIndex = InvalidOid;</span>
<span class="lineNum">    3778 </span><span class="lineCov">        862 : }</span>
<span class="lineNum">    3779 </span>            : 
<span class="lineNum">    3780 </span>            : /*
<span class="lineNum">    3781 </span>            :  * SetReindexPending
<span class="lineNum">    3782 </span>            :  *      Mark the given indexes as pending reindex.
<span class="lineNum">    3783 </span>            :  *
<span class="lineNum">    3784 </span>            :  * NB: caller must use a PG_TRY block to ensure ResetReindexPending is done.
<span class="lineNum">    3785 </span>            :  * Also, we assume that the current memory context stays valid throughout.
<a name="3786"><span class="lineNum">    3786 </span>            :  */</a>
<span class="lineNum">    3787 </span>            : static void
<span class="lineNum">    3788 </span><span class="lineCov">        250 : SetReindexPending(List *indexes)</span>
<span class="lineNum">    3789 </span>            : {
<span class="lineNum">    3790 </span>            :     /* Reindexing is not re-entrant. */
<span class="lineNum">    3791 </span><span class="lineCov">        250 :     if (pendingReindexedIndexes)</span>
<span class="lineNum">    3792 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cannot reindex while reindexing&quot;);</span>
<span class="lineNum">    3793 </span><span class="lineCov">        250 :     if (IsInParallelMode())</span>
<span class="lineNum">    3794 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cannot modify reindex state during a parallel operation&quot;);</span>
<span class="lineNum">    3795 </span><span class="lineCov">        250 :     pendingReindexedIndexes = list_copy(indexes);</span>
<span class="lineNum">    3796 </span><span class="lineCov">        250 : }</span>
<span class="lineNum">    3797 </span>            : 
<span class="lineNum">    3798 </span>            : /*
<span class="lineNum">    3799 </span>            :  * RemoveReindexPending
<span class="lineNum">    3800 </span>            :  *      Remove the given index from the pending list.
<a name="3801"><span class="lineNum">    3801 </span>            :  */</a>
<span class="lineNum">    3802 </span>            : static void
<span class="lineNum">    3803 </span><span class="lineCov">        842 : RemoveReindexPending(Oid indexOid)</span>
<span class="lineNum">    3804 </span>            : {
<span class="lineNum">    3805 </span><span class="lineCov">        842 :     if (IsInParallelMode())</span>
<span class="lineNum">    3806 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cannot modify reindex state during a parallel operation&quot;);</span>
<span class="lineNum">    3807 </span><span class="lineCov">        842 :     pendingReindexedIndexes = list_delete_oid(pendingReindexedIndexes,</span>
<span class="lineNum">    3808 </span>            :                                               indexOid);
<span class="lineNum">    3809 </span><span class="lineCov">        842 : }</span>
<span class="lineNum">    3810 </span>            : 
<span class="lineNum">    3811 </span>            : /*
<span class="lineNum">    3812 </span>            :  * ResetReindexPending
<span class="lineNum">    3813 </span>            :  *      Unset reindex-pending status.
<a name="3814"><span class="lineNum">    3814 </span>            :  */</a>
<span class="lineNum">    3815 </span>            : static void
<span class="lineNum">    3816 </span><span class="lineCov">       1216 : ResetReindexPending(void)</span>
<span class="lineNum">    3817 </span>            : {
<span class="lineNum">    3818 </span>            :     /* This may be called in leader error path */
<span class="lineNum">    3819 </span><span class="lineCov">       1216 :     pendingReindexedIndexes = NIL;</span>
<span class="lineNum">    3820 </span><span class="lineCov">       1216 : }</span>
<span class="lineNum">    3821 </span>            : 
<span class="lineNum">    3822 </span>            : /*
<span class="lineNum">    3823 </span>            :  * EstimateReindexStateSpace
<span class="lineNum">    3824 </span>            :  *      Estimate space needed to pass reindex state to parallel workers.
<a name="3825"><span class="lineNum">    3825 </span>            :  */</a>
<span class="lineNum">    3826 </span>            : Size
<span class="lineNum">    3827 </span><span class="lineCov">        214 : EstimateReindexStateSpace(void)</span>
<span class="lineNum">    3828 </span>            : {
<span class="lineNum">    3829 </span><span class="lineCov">        214 :     return offsetof(SerializedReindexState, pendingReindexedIndexes)</span>
<span class="lineNum">    3830 </span><span class="lineCov">        214 :         + mul_size(sizeof(Oid), list_length(pendingReindexedIndexes));</span>
<span class="lineNum">    3831 </span>            : }
<span class="lineNum">    3832 </span>            : 
<span class="lineNum">    3833 </span>            : /*
<span class="lineNum">    3834 </span>            :  * SerializeReindexState
<span class="lineNum">    3835 </span>            :  *      Serialize reindex state for parallel workers.
<a name="3836"><span class="lineNum">    3836 </span>            :  */</a>
<span class="lineNum">    3837 </span>            : void
<span class="lineNum">    3838 </span><span class="lineCov">        214 : SerializeReindexState(Size maxsize, char *start_address)</span>
<span class="lineNum">    3839 </span>            : {
<span class="lineNum">    3840 </span><span class="lineCov">        214 :     SerializedReindexState *sistate = (SerializedReindexState *) start_address;</span>
<span class="lineNum">    3841 </span><span class="lineCov">        214 :     int         c = 0;</span>
<span class="lineNum">    3842 </span>            :     ListCell   *lc;
<span class="lineNum">    3843 </span>            : 
<span class="lineNum">    3844 </span><span class="lineCov">        214 :     sistate-&gt;currentlyReindexedHeap = currentlyReindexedHeap;</span>
<span class="lineNum">    3845 </span><span class="lineCov">        214 :     sistate-&gt;currentlyReindexedIndex = currentlyReindexedIndex;</span>
<span class="lineNum">    3846 </span><span class="lineCov">        214 :     sistate-&gt;numPendingReindexedIndexes = list_length(pendingReindexedIndexes);</span>
<span class="lineNum">    3847 </span><span class="lineCov">        214 :     foreach(lc, pendingReindexedIndexes)</span>
<span class="lineNum">    3848 </span><span class="lineNoCov">          0 :         sistate-&gt;pendingReindexedIndexes[c++] = lfirst_oid(lc);</span>
<span class="lineNum">    3849 </span><span class="lineCov">        214 : }</span>
<span class="lineNum">    3850 </span>            : 
<span class="lineNum">    3851 </span>            : /*
<span class="lineNum">    3852 </span>            :  * RestoreReindexState
<span class="lineNum">    3853 </span>            :  *      Restore reindex state in a parallel worker.
<a name="3854"><span class="lineNum">    3854 </span>            :  */</a>
<span class="lineNum">    3855 </span>            : void
<span class="lineNum">    3856 </span><span class="lineCov">        746 : RestoreReindexState(void *reindexstate)</span>
<span class="lineNum">    3857 </span>            : {
<span class="lineNum">    3858 </span><span class="lineCov">        746 :     SerializedReindexState *sistate = (SerializedReindexState *) reindexstate;</span>
<span class="lineNum">    3859 </span><span class="lineCov">        746 :     int         c = 0;</span>
<span class="lineNum">    3860 </span>            :     MemoryContext oldcontext;
<span class="lineNum">    3861 </span>            : 
<span class="lineNum">    3862 </span><span class="lineCov">        746 :     currentlyReindexedHeap = sistate-&gt;currentlyReindexedHeap;</span>
<span class="lineNum">    3863 </span><span class="lineCov">        746 :     currentlyReindexedIndex = sistate-&gt;currentlyReindexedIndex;</span>
<span class="lineNum">    3864 </span>            : 
<span class="lineNum">    3865 </span><span class="lineCov">        746 :     Assert(pendingReindexedIndexes == NIL);</span>
<span class="lineNum">    3866 </span><span class="lineCov">        746 :     oldcontext = MemoryContextSwitchTo(TopMemoryContext);</span>
<span class="lineNum">    3867 </span><span class="lineCov">        746 :     for (c = 0; c &lt; sistate-&gt;numPendingReindexedIndexes; ++c)</span>
<span class="lineNum">    3868 </span><span class="lineNoCov">          0 :         pendingReindexedIndexes =</span>
<span class="lineNum">    3869 </span><span class="lineNoCov">          0 :             lappend_oid(pendingReindexedIndexes,</span>
<span class="lineNum">    3870 </span>            :                         sistate-&gt;pendingReindexedIndexes[c]);
<span class="lineNum">    3871 </span><span class="lineCov">        746 :     MemoryContextSwitchTo(oldcontext);</span>
<span class="lineNum">    3872 </span><span class="lineCov">        746 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
