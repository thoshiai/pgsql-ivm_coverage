<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/catalog/pg_proc.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">src/backend/catalog</a> - pg_proc.c<span style="font-size: 80%;"> (source / <a href="pg_proc.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">347</td>
            <td class="headerCovTableEntry">408</td>
            <td class="headerCovTableEntryMed">85.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">8</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntryMed">88.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * pg_proc.c
<span class="lineNum">       4 </span>            :  *    routines to support manipulation of the pg_proc relation
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * IDENTIFICATION
<span class="lineNum">      11 </span>            :  *    src/backend/catalog/pg_proc.c
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      14 </span>            :  */
<span class="lineNum">      15 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &quot;access/htup_details.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;access/table.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;access/xact.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;catalog/catalog.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;catalog/dependency.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;catalog/indexing.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;catalog/objectaccess.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;catalog/pg_language.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;catalog/pg_namespace.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;catalog/pg_proc.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;catalog/pg_transform.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;catalog/pg_type.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;commands/defrem.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;executor/functions.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;funcapi.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;mb/pg_wchar.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;miscadmin.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;nodes/nodeFuncs.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;parser/parse_type.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;tcop/pquery.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;tcop/tcopprot.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;utils/acl.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;utils/builtins.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;utils/lsyscache.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;utils/regproc.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;utils/rel.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;utils/syscache.h&quot;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : typedef struct
<span class="lineNum">      47 </span>            : {
<span class="lineNum">      48 </span>            :     char       *proname;
<span class="lineNum">      49 </span>            :     char       *prosrc;
<span class="lineNum">      50 </span>            : } parse_error_callback_arg;
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : static void sql_function_parse_error_callback(void *arg);
<span class="lineNum">      53 </span>            : static int  match_prosrc_to_query(const char *prosrc, const char *queryText,
<span class="lineNum">      54 </span>            :                                   int cursorpos);
<span class="lineNum">      55 </span>            : static bool match_prosrc_to_literal(const char *prosrc, const char *literal,
<span class="lineNum">      56 </span>            :                                     int cursorpos, int *newcursorpos);
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : /* ----------------------------------------------------------------
<span class="lineNum">      60 </span>            :  *      ProcedureCreate
<span class="lineNum">      61 </span>            :  *
<span class="lineNum">      62 </span>            :  * Note: allParameterTypes, parameterModes, parameterNames, trftypes, and proconfig
<span class="lineNum">      63 </span>            :  * are either arrays of the proper types or NULL.  We declare them Datum,
<span class="lineNum">      64 </span>            :  * not &quot;ArrayType *&quot;, to avoid importing array.h into pg_proc.h.
<span class="lineNum">      65 </span>            :  * ----------------------------------------------------------------
<a name="66"><span class="lineNum">      66 </span>            :  */</a>
<span class="lineNum">      67 </span>            : ObjectAddress
<span class="lineNum">      68 </span><span class="lineCov">       1628 : ProcedureCreate(const char *procedureName,</span>
<span class="lineNum">      69 </span>            :                 Oid procNamespace,
<span class="lineNum">      70 </span>            :                 bool replace,
<span class="lineNum">      71 </span>            :                 bool returnsSet,
<span class="lineNum">      72 </span>            :                 Oid returnType,
<span class="lineNum">      73 </span>            :                 Oid proowner,
<span class="lineNum">      74 </span>            :                 Oid languageObjectId,
<span class="lineNum">      75 </span>            :                 Oid languageValidator,
<span class="lineNum">      76 </span>            :                 const char *prosrc,
<span class="lineNum">      77 </span>            :                 const char *probin,
<span class="lineNum">      78 </span>            :                 char prokind,
<span class="lineNum">      79 </span>            :                 bool security_definer,
<span class="lineNum">      80 </span>            :                 bool isLeakProof,
<span class="lineNum">      81 </span>            :                 bool isStrict,
<span class="lineNum">      82 </span>            :                 char volatility,
<span class="lineNum">      83 </span>            :                 char parallel,
<span class="lineNum">      84 </span>            :                 oidvector *parameterTypes,
<span class="lineNum">      85 </span>            :                 Datum allParameterTypes,
<span class="lineNum">      86 </span>            :                 Datum parameterModes,
<span class="lineNum">      87 </span>            :                 Datum parameterNames,
<span class="lineNum">      88 </span>            :                 List *parameterDefaults,
<span class="lineNum">      89 </span>            :                 Datum trftypes,
<span class="lineNum">      90 </span>            :                 Datum proconfig,
<span class="lineNum">      91 </span>            :                 Oid prosupport,
<span class="lineNum">      92 </span>            :                 float4 procost,
<span class="lineNum">      93 </span>            :                 float4 prorows)
<span class="lineNum">      94 </span>            : {
<span class="lineNum">      95 </span>            :     Oid         retval;
<span class="lineNum">      96 </span>            :     int         parameterCount;
<span class="lineNum">      97 </span>            :     int         allParamCount;
<span class="lineNum">      98 </span>            :     Oid        *allParams;
<span class="lineNum">      99 </span><span class="lineCov">       1628 :     char       *paramModes = NULL;</span>
<span class="lineNum">     100 </span><span class="lineCov">       1628 :     bool        genericInParam = false;</span>
<span class="lineNum">     101 </span><span class="lineCov">       1628 :     bool        genericOutParam = false;</span>
<span class="lineNum">     102 </span><span class="lineCov">       1628 :     bool        anyrangeInParam = false;</span>
<span class="lineNum">     103 </span><span class="lineCov">       1628 :     bool        anyrangeOutParam = false;</span>
<span class="lineNum">     104 </span><span class="lineCov">       1628 :     bool        internalInParam = false;</span>
<span class="lineNum">     105 </span><span class="lineCov">       1628 :     bool        internalOutParam = false;</span>
<span class="lineNum">     106 </span><span class="lineCov">       1628 :     Oid         variadicType = InvalidOid;</span>
<span class="lineNum">     107 </span><span class="lineCov">       1628 :     Acl        *proacl = NULL;</span>
<span class="lineNum">     108 </span>            :     Relation    rel;
<span class="lineNum">     109 </span>            :     HeapTuple   tup;
<span class="lineNum">     110 </span>            :     HeapTuple   oldtup;
<span class="lineNum">     111 </span>            :     bool        nulls[Natts_pg_proc];
<span class="lineNum">     112 </span>            :     Datum       values[Natts_pg_proc];
<span class="lineNum">     113 </span>            :     bool        replaces[Natts_pg_proc];
<span class="lineNum">     114 </span>            :     NameData    procname;
<span class="lineNum">     115 </span>            :     TupleDesc   tupDesc;
<span class="lineNum">     116 </span>            :     bool        is_update;
<span class="lineNum">     117 </span>            :     ObjectAddress myself,
<span class="lineNum">     118 </span>            :                 referenced;
<span class="lineNum">     119 </span>            :     int         i;
<span class="lineNum">     120 </span>            :     Oid         trfid;
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :     /*
<span class="lineNum">     123 </span>            :      * sanity checks
<span class="lineNum">     124 </span>            :      */
<span class="lineNum">     125 </span><span class="lineCov">       1628 :     Assert(PointerIsValid(prosrc));</span>
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span><span class="lineCov">       1628 :     parameterCount = parameterTypes-&gt;dim1;</span>
<span class="lineNum">     128 </span><span class="lineCov">       1628 :     if (parameterCount &lt; 0 || parameterCount &gt; FUNC_MAX_ARGS)</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">     130 </span>            :                 (errcode(ERRCODE_TOO_MANY_ARGUMENTS),
<span class="lineNum">     131 </span>            :                  errmsg_plural(&quot;functions cannot have more than %d argument&quot;,
<span class="lineNum">     132 </span>            :                                &quot;functions cannot have more than %d arguments&quot;,
<span class="lineNum">     133 </span>            :                                FUNC_MAX_ARGS,
<span class="lineNum">     134 </span>            :                                FUNC_MAX_ARGS)));
<span class="lineNum">     135 </span>            :     /* note: the above is correct, we do NOT count output arguments */
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            :     /* Deconstruct array inputs */
<span class="lineNum">     138 </span><span class="lineCov">       1628 :     if (allParameterTypes != PointerGetDatum(NULL))</span>
<span class="lineNum">     139 </span>            :     {
<span class="lineNum">     140 </span>            :         /*
<span class="lineNum">     141 </span>            :          * We expect the array to be a 1-D OID array; verify that. We don't
<span class="lineNum">     142 </span>            :          * need to use deconstruct_array() since the array data is just going
<span class="lineNum">     143 </span>            :          * to look like a C array of OID values.
<span class="lineNum">     144 </span>            :          */
<span class="lineNum">     145 </span><span class="lineCov">        150 :         ArrayType  *allParamArray = (ArrayType *) DatumGetPointer(allParameterTypes);</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span><span class="lineCov">        150 :         allParamCount = ARR_DIMS(allParamArray)[0];</span>
<span class="lineNum">     148 </span><span class="lineCov">        150 :         if (ARR_NDIM(allParamArray) != 1 ||</span>
<span class="lineNum">     149 </span><span class="lineCov">        150 :             allParamCount &lt;= 0 ||</span>
<span class="lineNum">     150 </span><span class="lineCov">        300 :             ARR_HASNULL(allParamArray) ||</span>
<span class="lineNum">     151 </span><span class="lineCov">        150 :             ARR_ELEMTYPE(allParamArray) != OIDOID)</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;allParameterTypes is not a 1-D Oid array&quot;);</span>
<span class="lineNum">     153 </span><span class="lineCov">        150 :         allParams = (Oid *) ARR_DATA_PTR(allParamArray);</span>
<span class="lineNum">     154 </span><span class="lineCov">        150 :         Assert(allParamCount &gt;= parameterCount);</span>
<span class="lineNum">     155 </span>            :         /* we assume caller got the contents right */
<span class="lineNum">     156 </span>            :     }
<span class="lineNum">     157 </span>            :     else
<span class="lineNum">     158 </span>            :     {
<span class="lineNum">     159 </span><span class="lineCov">       1478 :         allParamCount = parameterCount;</span>
<span class="lineNum">     160 </span><span class="lineCov">       1478 :         allParams = parameterTypes-&gt;values;</span>
<span class="lineNum">     161 </span>            :     }
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span><span class="lineCov">       1628 :     if (parameterModes != PointerGetDatum(NULL))</span>
<span class="lineNum">     164 </span>            :     {
<span class="lineNum">     165 </span>            :         /*
<span class="lineNum">     166 </span>            :          * We expect the array to be a 1-D CHAR array; verify that. We don't
<span class="lineNum">     167 </span>            :          * need to use deconstruct_array() since the array data is just going
<span class="lineNum">     168 </span>            :          * to look like a C array of char values.
<span class="lineNum">     169 </span>            :          */
<span class="lineNum">     170 </span><span class="lineCov">        150 :         ArrayType  *modesArray = (ArrayType *) DatumGetPointer(parameterModes);</span>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineCov">        300 :         if (ARR_NDIM(modesArray) != 1 ||</span>
<span class="lineNum">     173 </span><span class="lineCov">        300 :             ARR_DIMS(modesArray)[0] != allParamCount ||</span>
<span class="lineNum">     174 </span><span class="lineCov">        300 :             ARR_HASNULL(modesArray) ||</span>
<span class="lineNum">     175 </span><span class="lineCov">        150 :             ARR_ELEMTYPE(modesArray) != CHAROID)</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;parameterModes is not a 1-D char array&quot;);</span>
<span class="lineNum">     177 </span><span class="lineCov">        150 :         paramModes = (char *) ARR_DATA_PTR(modesArray);</span>
<span class="lineNum">     178 </span>            :     }
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            :     /*
<span class="lineNum">     181 </span>            :      * Detect whether we have polymorphic or INTERNAL arguments.  The first
<span class="lineNum">     182 </span>            :      * loop checks input arguments, the second output arguments.
<span class="lineNum">     183 </span>            :      */
<span class="lineNum">     184 </span><span class="lineCov">       3208 :     for (i = 0; i &lt; parameterCount; i++)</span>
<span class="lineNum">     185 </span>            :     {
<span class="lineNum">     186 </span><span class="lineCov">       1580 :         switch (parameterTypes-&gt;values[i])</span>
<span class="lineNum">     187 </span>            :         {
<span class="lineNum">     188 </span>            :             case ANYARRAYOID:
<span class="lineNum">     189 </span>            :             case ANYELEMENTOID:
<span class="lineNum">     190 </span>            :             case ANYNONARRAYOID:
<span class="lineNum">     191 </span>            :             case ANYENUMOID:
<span class="lineNum">     192 </span><span class="lineCov">        154 :                 genericInParam = true;</span>
<span class="lineNum">     193 </span><span class="lineCov">        154 :                 break;</span>
<span class="lineNum">     194 </span>            :             case ANYRANGEOID:
<span class="lineNum">     195 </span><span class="lineCov">         12 :                 genericInParam = true;</span>
<span class="lineNum">     196 </span><span class="lineCov">         12 :                 anyrangeInParam = true;</span>
<span class="lineNum">     197 </span><span class="lineCov">         12 :                 break;</span>
<span class="lineNum">     198 </span>            :             case INTERNALOID:
<span class="lineNum">     199 </span><span class="lineCov">         18 :                 internalInParam = true;</span>
<span class="lineNum">     200 </span><span class="lineCov">         18 :                 break;</span>
<span class="lineNum">     201 </span>            :         }
<span class="lineNum">     202 </span>            :     }
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span><span class="lineCov">       1628 :     if (allParameterTypes != PointerGetDatum(NULL))</span>
<span class="lineNum">     205 </span>            :     {
<span class="lineNum">     206 </span><span class="lineCov">        592 :         for (i = 0; i &lt; allParamCount; i++)</span>
<span class="lineNum">     207 </span>            :         {
<span class="lineNum">     208 </span><span class="lineCov">        884 :             if (paramModes == NULL ||</span>
<span class="lineNum">     209 </span><span class="lineCov">        728 :                 paramModes[i] == PROARGMODE_IN ||</span>
<span class="lineNum">     210 </span><span class="lineCov">        286 :                 paramModes[i] == PROARGMODE_VARIADIC)</span>
<span class="lineNum">     211 </span><span class="lineCov">        186 :                 continue;       /* ignore input-only params */</span>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span><span class="lineCov">        256 :             switch (allParams[i])</span>
<span class="lineNum">     214 </span>            :             {
<span class="lineNum">     215 </span>            :                 case ANYARRAYOID:
<span class="lineNum">     216 </span>            :                 case ANYELEMENTOID:
<span class="lineNum">     217 </span>            :                 case ANYNONARRAYOID:
<span class="lineNum">     218 </span>            :                 case ANYENUMOID:
<span class="lineNum">     219 </span><span class="lineCov">         32 :                     genericOutParam = true;</span>
<span class="lineNum">     220 </span><span class="lineCov">         32 :                     break;</span>
<span class="lineNum">     221 </span>            :                 case ANYRANGEOID:
<span class="lineNum">     222 </span><span class="lineCov">         12 :                     genericOutParam = true;</span>
<span class="lineNum">     223 </span><span class="lineCov">         12 :                     anyrangeOutParam = true;</span>
<span class="lineNum">     224 </span><span class="lineCov">         12 :                     break;</span>
<span class="lineNum">     225 </span>            :                 case INTERNALOID:
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :                     internalOutParam = true;</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     228 </span>            :             }
<span class="lineNum">     229 </span>            :         }
<span class="lineNum">     230 </span>            :     }
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :     /*
<span class="lineNum">     233 </span>            :      * Do not allow polymorphic return type unless at least one input argument
<span class="lineNum">     234 </span>            :      * is polymorphic.  ANYRANGE return type is even stricter: must have an
<span class="lineNum">     235 </span>            :      * ANYRANGE input (since we can't deduce the specific range type from
<span class="lineNum">     236 </span>            :      * ANYELEMENT).  Also, do not allow return type INTERNAL unless at least
<span class="lineNum">     237 </span>            :      * one input argument is INTERNAL.
<span class="lineNum">     238 </span>            :      */
<span class="lineNum">     239 </span><span class="lineCov">       1628 :     if ((IsPolymorphicType(returnType) || genericOutParam)</span>
<span class="lineNum">     240 </span><span class="lineCov">         88 :         &amp;&amp; !genericInParam)</span>
<span class="lineNum">     241 </span><span class="lineCov">          4 :         ereport(ERROR,</span>
<span class="lineNum">     242 </span>            :                 (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">     243 </span>            :                  errmsg(&quot;cannot determine result data type&quot;),
<span class="lineNum">     244 </span>            :                  errdetail(&quot;A function returning a polymorphic type must have at least one polymorphic argument.&quot;)));
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineCov">       1638 :     if ((returnType == ANYRANGEOID || anyrangeOutParam) &amp;&amp;</span>
<span class="lineNum">     247 </span><span class="lineCov">         14 :         !anyrangeInParam)</span>
<span class="lineNum">     248 </span><span class="lineCov">          8 :         ereport(ERROR,</span>
<span class="lineNum">     249 </span>            :                 (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">     250 </span>            :                  errmsg(&quot;cannot determine result data type&quot;),
<span class="lineNum">     251 </span>            :                  errdetail(&quot;A function returning \&quot;anyrange\&quot; must have at least one \&quot;anyrange\&quot; argument.&quot;)));
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span><span class="lineCov">       1616 :     if ((returnType == INTERNALOID || internalOutParam) &amp;&amp; !internalInParam)</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">     255 </span>            :                 (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">     256 </span>            :                  errmsg(&quot;unsafe use of pseudo-type \&quot;internal\&quot;&quot;),
<span class="lineNum">     257 </span>            :                  errdetail(&quot;A function returning \&quot;internal\&quot; must have at least one \&quot;internal\&quot; argument.&quot;)));
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span><span class="lineCov">       1616 :     if (paramModes != NULL)</span>
<span class="lineNum">     260 </span>            :     {
<span class="lineNum">     261 </span>            :         /*
<span class="lineNum">     262 </span>            :          * Only the last input parameter can be variadic; if it is, save its
<span class="lineNum">     263 </span>            :          * element type.  Errors here are just elog since caller should have
<span class="lineNum">     264 </span>            :          * checked this already.
<span class="lineNum">     265 </span>            :          */
<span class="lineNum">     266 </span><span class="lineCov">        562 :         for (i = 0; i &lt; allParamCount; i++)</span>
<span class="lineNum">     267 </span>            :         {
<span class="lineNum">     268 </span><span class="lineCov">        420 :             switch (paramModes[i])</span>
<span class="lineNum">     269 </span>            :             {
<span class="lineNum">     270 </span>            :                 case PROARGMODE_IN:
<span class="lineNum">     271 </span>            :                 case PROARGMODE_INOUT:
<span class="lineNum">     272 </span><span class="lineCov">        168 :                     if (OidIsValid(variadicType))</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :                         elog(ERROR, &quot;variadic parameter must be last&quot;);</span>
<span class="lineNum">     274 </span><span class="lineCov">        168 :                     break;</span>
<span class="lineNum">     275 </span>            :                 case PROARGMODE_OUT:
<span class="lineNum">     276 </span>            :                 case PROARGMODE_TABLE:
<span class="lineNum">     277 </span>            :                     /* okay */
<span class="lineNum">     278 </span><span class="lineCov">        222 :                     break;</span>
<span class="lineNum">     279 </span>            :                 case PROARGMODE_VARIADIC:
<span class="lineNum">     280 </span><span class="lineCov">         30 :                     if (OidIsValid(variadicType))</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :                         elog(ERROR, &quot;variadic parameter must be last&quot;);</span>
<span class="lineNum">     282 </span><span class="lineCov">         30 :                     switch (allParams[i])</span>
<span class="lineNum">     283 </span>            :                     {
<span class="lineNum">     284 </span>            :                         case ANYOID:
<span class="lineNum">     285 </span><span class="lineCov">          2 :                             variadicType = ANYOID;</span>
<span class="lineNum">     286 </span><span class="lineCov">          2 :                             break;</span>
<span class="lineNum">     287 </span>            :                         case ANYARRAYOID:
<span class="lineNum">     288 </span><span class="lineCov">         10 :                             variadicType = ANYELEMENTOID;</span>
<span class="lineNum">     289 </span><span class="lineCov">         10 :                             break;</span>
<span class="lineNum">     290 </span>            :                         default:
<span class="lineNum">     291 </span><span class="lineCov">         18 :                             variadicType = get_element_type(allParams[i]);</span>
<span class="lineNum">     292 </span><span class="lineCov">         18 :                             if (!OidIsValid(variadicType))</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :                                 elog(ERROR, &quot;variadic parameter is not an array&quot;);</span>
<span class="lineNum">     294 </span><span class="lineCov">         18 :                             break;</span>
<span class="lineNum">     295 </span>            :                     }
<span class="lineNum">     296 </span><span class="lineCov">         30 :                     break;</span>
<span class="lineNum">     297 </span>            :                 default:
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :                     elog(ERROR, &quot;invalid parameter mode '%c'&quot;, paramModes[i]);</span>
<span class="lineNum">     299 </span>            :                     break;
<span class="lineNum">     300 </span>            :             }
<span class="lineNum">     301 </span>            :         }
<span class="lineNum">     302 </span>            :     }
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            :     /*
<span class="lineNum">     305 </span>            :      * All seems OK; prepare the data to be inserted into pg_proc.
<span class="lineNum">     306 </span>            :      */
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineCov">      48480 :     for (i = 0; i &lt; Natts_pg_proc; ++i)</span>
<span class="lineNum">     309 </span>            :     {
<span class="lineNum">     310 </span><span class="lineCov">      46864 :         nulls[i] = false;</span>
<span class="lineNum">     311 </span><span class="lineCov">      46864 :         values[i] = (Datum) 0;</span>
<span class="lineNum">     312 </span><span class="lineCov">      46864 :         replaces[i] = true;</span>
<span class="lineNum">     313 </span>            :     }
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span><span class="lineCov">       1616 :     namestrcpy(&amp;procname, procedureName);</span>
<span class="lineNum">     316 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_proname - 1] = NameGetDatum(&amp;procname);</span>
<span class="lineNum">     317 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_pronamespace - 1] = ObjectIdGetDatum(procNamespace);</span>
<span class="lineNum">     318 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_proowner - 1] = ObjectIdGetDatum(proowner);</span>
<span class="lineNum">     319 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_prolang - 1] = ObjectIdGetDatum(languageObjectId);</span>
<span class="lineNum">     320 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_procost - 1] = Float4GetDatum(procost);</span>
<span class="lineNum">     321 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_prorows - 1] = Float4GetDatum(prorows);</span>
<span class="lineNum">     322 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_provariadic - 1] = ObjectIdGetDatum(variadicType);</span>
<span class="lineNum">     323 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_prosupport - 1] = ObjectIdGetDatum(prosupport);</span>
<span class="lineNum">     324 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_prokind - 1] = CharGetDatum(prokind);</span>
<span class="lineNum">     325 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_prosecdef - 1] = BoolGetDatum(security_definer);</span>
<span class="lineNum">     326 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_proleakproof - 1] = BoolGetDatum(isLeakProof);</span>
<span class="lineNum">     327 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_proisstrict - 1] = BoolGetDatum(isStrict);</span>
<span class="lineNum">     328 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_proretset - 1] = BoolGetDatum(returnsSet);</span>
<span class="lineNum">     329 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_provolatile - 1] = CharGetDatum(volatility);</span>
<span class="lineNum">     330 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_proparallel - 1] = CharGetDatum(parallel);</span>
<span class="lineNum">     331 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_pronargs - 1] = UInt16GetDatum(parameterCount);</span>
<span class="lineNum">     332 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_pronargdefaults - 1] = UInt16GetDatum(list_length(parameterDefaults));</span>
<span class="lineNum">     333 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_prorettype - 1] = ObjectIdGetDatum(returnType);</span>
<span class="lineNum">     334 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_proargtypes - 1] = PointerGetDatum(parameterTypes);</span>
<span class="lineNum">     335 </span><span class="lineCov">       1616 :     if (allParameterTypes != PointerGetDatum(NULL))</span>
<span class="lineNum">     336 </span><span class="lineCov">        142 :         values[Anum_pg_proc_proallargtypes - 1] = allParameterTypes;</span>
<span class="lineNum">     337 </span>            :     else
<span class="lineNum">     338 </span><span class="lineCov">       1474 :         nulls[Anum_pg_proc_proallargtypes - 1] = true;</span>
<span class="lineNum">     339 </span><span class="lineCov">       1616 :     if (parameterModes != PointerGetDatum(NULL))</span>
<span class="lineNum">     340 </span><span class="lineCov">        142 :         values[Anum_pg_proc_proargmodes - 1] = parameterModes;</span>
<span class="lineNum">     341 </span>            :     else
<span class="lineNum">     342 </span><span class="lineCov">       1474 :         nulls[Anum_pg_proc_proargmodes - 1] = true;</span>
<span class="lineNum">     343 </span><span class="lineCov">       1616 :     if (parameterNames != PointerGetDatum(NULL))</span>
<span class="lineNum">     344 </span><span class="lineCov">        340 :         values[Anum_pg_proc_proargnames - 1] = parameterNames;</span>
<span class="lineNum">     345 </span>            :     else
<span class="lineNum">     346 </span><span class="lineCov">       1276 :         nulls[Anum_pg_proc_proargnames - 1] = true;</span>
<span class="lineNum">     347 </span><span class="lineCov">       1616 :     if (parameterDefaults != NIL)</span>
<span class="lineNum">     348 </span><span class="lineCov">         92 :         values[Anum_pg_proc_proargdefaults - 1] = CStringGetTextDatum(nodeToString(parameterDefaults));</span>
<span class="lineNum">     349 </span>            :     else
<span class="lineNum">     350 </span><span class="lineCov">       1524 :         nulls[Anum_pg_proc_proargdefaults - 1] = true;</span>
<span class="lineNum">     351 </span><span class="lineCov">       1616 :     if (trftypes != PointerGetDatum(NULL))</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :         values[Anum_pg_proc_protrftypes - 1] = trftypes;</span>
<span class="lineNum">     353 </span>            :     else
<span class="lineNum">     354 </span><span class="lineCov">       1616 :         nulls[Anum_pg_proc_protrftypes - 1] = true;</span>
<span class="lineNum">     355 </span><span class="lineCov">       1616 :     values[Anum_pg_proc_prosrc - 1] = CStringGetTextDatum(prosrc);</span>
<span class="lineNum">     356 </span><span class="lineCov">       1616 :     if (probin)</span>
<span class="lineNum">     357 </span><span class="lineCov">         50 :         values[Anum_pg_proc_probin - 1] = CStringGetTextDatum(probin);</span>
<span class="lineNum">     358 </span>            :     else
<span class="lineNum">     359 </span><span class="lineCov">       1566 :         nulls[Anum_pg_proc_probin - 1] = true;</span>
<span class="lineNum">     360 </span><span class="lineCov">       1616 :     if (proconfig != PointerGetDatum(NULL))</span>
<span class="lineNum">     361 </span><span class="lineCov">         14 :         values[Anum_pg_proc_proconfig - 1] = proconfig;</span>
<span class="lineNum">     362 </span>            :     else
<span class="lineNum">     363 </span><span class="lineCov">       1602 :         nulls[Anum_pg_proc_proconfig - 1] = true;</span>
<span class="lineNum">     364 </span>            :     /* proacl will be determined later */
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span><span class="lineCov">       1616 :     rel = table_open(ProcedureRelationId, RowExclusiveLock);</span>
<span class="lineNum">     367 </span><span class="lineCov">       1616 :     tupDesc = RelationGetDescr(rel);</span>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            :     /* Check for pre-existing definition */
<span class="lineNum">     370 </span><span class="lineCov">       1616 :     oldtup = SearchSysCache3(PROCNAMEARGSNSP,</span>
<span class="lineNum">     371 </span>            :                              PointerGetDatum(procedureName),
<span class="lineNum">     372 </span>            :                              PointerGetDatum(parameterTypes),
<span class="lineNum">     373 </span>            :                              ObjectIdGetDatum(procNamespace));
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span><span class="lineCov">       1616 :     if (HeapTupleIsValid(oldtup))</span>
<span class="lineNum">     376 </span>            :     {
<span class="lineNum">     377 </span>            :         /* There is one; okay to replace it? */
<span class="lineNum">     378 </span><span class="lineCov">        246 :         Form_pg_proc oldproc = (Form_pg_proc) GETSTRUCT(oldtup);</span>
<span class="lineNum">     379 </span>            :         Datum       proargnames;
<span class="lineNum">     380 </span>            :         bool        isnull;
<span class="lineNum">     381 </span>            :         const char *dropcmd;
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span><span class="lineCov">        246 :         if (!replace)</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">     385 </span>            :                     (errcode(ERRCODE_DUPLICATE_FUNCTION),
<span class="lineNum">     386 </span>            :                      errmsg(&quot;function \&quot;%s\&quot; already exists with same argument types&quot;,
<span class="lineNum">     387 </span>            :                             procedureName)));
<span class="lineNum">     388 </span><span class="lineCov">        246 :         if (!pg_proc_ownercheck(oldproc-&gt;oid, proowner))</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :             aclcheck_error(ACLCHECK_NOT_OWNER, OBJECT_FUNCTION,</span>
<span class="lineNum">     390 </span>            :                            procedureName);
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            :         /* Not okay to change routine kind */
<span class="lineNum">     393 </span><span class="lineCov">        246 :         if (oldproc-&gt;prokind != prokind)</span>
<span class="lineNum">     394 </span><span class="lineCov">          6 :             ereport(ERROR,</span>
<span class="lineNum">     395 </span>            :                     (errcode(ERRCODE_WRONG_OBJECT_TYPE),
<span class="lineNum">     396 </span>            :                      errmsg(&quot;cannot change routine kind&quot;),
<span class="lineNum">     397 </span>            :                      (oldproc-&gt;prokind == PROKIND_AGGREGATE ?
<span class="lineNum">     398 </span>            :                       errdetail(&quot;\&quot;%s\&quot; is an aggregate function.&quot;, procedureName) :
<span class="lineNum">     399 </span>            :                       oldproc-&gt;prokind == PROKIND_FUNCTION ?
<span class="lineNum">     400 </span>            :                       errdetail(&quot;\&quot;%s\&quot; is a function.&quot;, procedureName) :
<span class="lineNum">     401 </span>            :                       oldproc-&gt;prokind == PROKIND_PROCEDURE ?
<span class="lineNum">     402 </span>            :                       errdetail(&quot;\&quot;%s\&quot; is a procedure.&quot;, procedureName) :
<span class="lineNum">     403 </span>            :                       oldproc-&gt;prokind == PROKIND_WINDOW ?
<span class="lineNum">     404 </span>            :                       errdetail(&quot;\&quot;%s\&quot; is a window function.&quot;, procedureName) :
<span class="lineNum">     405 </span>            :                       0)));
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span><span class="lineCov">        240 :         dropcmd = (prokind == PROKIND_PROCEDURE ? &quot;DROP PROCEDURE&quot; :</span>
<span class="lineNum">     408 </span>            :                    prokind == PROKIND_AGGREGATE ? &quot;DROP AGGREGATE&quot; :
<span class="lineNum">     409 </span>            :                    &quot;DROP FUNCTION&quot;);
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :         /*
<span class="lineNum">     412 </span>            :          * Not okay to change the return type of the existing proc, since
<span class="lineNum">     413 </span>            :          * existing rules, views, etc may depend on the return type.
<span class="lineNum">     414 </span>            :          *
<span class="lineNum">     415 </span>            :          * In case of a procedure, a changing return type means that whether
<span class="lineNum">     416 </span>            :          * the procedure has output parameters was changed.  Since there is no
<span class="lineNum">     417 </span>            :          * user visible return type, we produce a more specific error message.
<span class="lineNum">     418 </span>            :          */
<span class="lineNum">     419 </span><span class="lineCov">        476 :         if (returnType != oldproc-&gt;prorettype ||</span>
<span class="lineNum">     420 </span><span class="lineCov">        236 :             returnsSet != oldproc-&gt;proretset)</span>
<span class="lineNum">     421 </span><span class="lineCov">          4 :             ereport(ERROR,</span>
<span class="lineNum">     422 </span>            :                     (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">     423 </span>            :                      prokind == PROKIND_PROCEDURE
<span class="lineNum">     424 </span>            :                      ? errmsg(&quot;cannot change whether a procedure has output parameters&quot;)
<span class="lineNum">     425 </span>            :                      : errmsg(&quot;cannot change return type of existing function&quot;),
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :             /*
<span class="lineNum">     428 </span>            :              * translator: first %s is DROP FUNCTION, DROP PROCEDURE, or DROP
<span class="lineNum">     429 </span>            :              * AGGREGATE
<span class="lineNum">     430 </span>            :              */
<span class="lineNum">     431 </span>            :                      errhint(&quot;Use %s %s first.&quot;,
<span class="lineNum">     432 </span>            :                              dropcmd,
<span class="lineNum">     433 </span>            :                              format_procedure(oldproc-&gt;oid))));
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            :         /*
<span class="lineNum">     436 </span>            :          * If it returns RECORD, check for possible change of record type
<span class="lineNum">     437 </span>            :          * implied by OUT parameters
<span class="lineNum">     438 </span>            :          */
<span class="lineNum">     439 </span><span class="lineCov">        236 :         if (returnType == RECORDOID)</span>
<span class="lineNum">     440 </span>            :         {
<span class="lineNum">     441 </span>            :             TupleDesc   olddesc;
<span class="lineNum">     442 </span>            :             TupleDesc   newdesc;
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineCov">         28 :             olddesc = build_function_result_tupdesc_t(oldtup);</span>
<span class="lineNum">     445 </span><span class="lineCov">         28 :             newdesc = build_function_result_tupdesc_d(prokind,</span>
<span class="lineNum">     446 </span>            :                                                       allParameterTypes,
<span class="lineNum">     447 </span>            :                                                       parameterModes,
<span class="lineNum">     448 </span>            :                                                       parameterNames);
<span class="lineNum">     449 </span><span class="lineCov">         28 :             if (olddesc == NULL &amp;&amp; newdesc == NULL)</span>
<span class="lineNum">     450 </span>            :                  /* ok, both are runtime-defined RECORDs */ ;
<span class="lineNum">     451 </span><span class="lineCov">         52 :             else if (olddesc == NULL || newdesc == NULL ||</span>
<span class="lineNum">     452 </span><span class="lineCov">         26 :                      !equalTupleDescs(olddesc, newdesc))</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :                 ereport(ERROR,</span>
<span class="lineNum">     454 </span>            :                         (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">     455 </span>            :                          errmsg(&quot;cannot change return type of existing function&quot;),
<span class="lineNum">     456 </span>            :                          errdetail(&quot;Row type defined by OUT parameters is different.&quot;),
<span class="lineNum">     457 </span>            :                 /* translator: first %s is DROP FUNCTION or DROP PROCEDURE */
<span class="lineNum">     458 </span>            :                          errhint(&quot;Use %s %s first.&quot;,
<span class="lineNum">     459 </span>            :                                  dropcmd,
<span class="lineNum">     460 </span>            :                                  format_procedure(oldproc-&gt;oid))));
<span class="lineNum">     461 </span>            :         }
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            :         /*
<span class="lineNum">     464 </span>            :          * If there were any named input parameters, check to make sure the
<span class="lineNum">     465 </span>            :          * names have not been changed, as this could break existing calls. We
<span class="lineNum">     466 </span>            :          * allow adding names to formerly unnamed parameters, though.
<span class="lineNum">     467 </span>            :          */
<span class="lineNum">     468 </span><span class="lineCov">        236 :         proargnames = SysCacheGetAttr(PROCNAMEARGSNSP, oldtup,</span>
<span class="lineNum">     469 </span>            :                                       Anum_pg_proc_proargnames,
<span class="lineNum">     470 </span>            :                                       &amp;isnull);
<span class="lineNum">     471 </span><span class="lineCov">        236 :         if (!isnull)</span>
<span class="lineNum">     472 </span>            :         {
<span class="lineNum">     473 </span>            :             Datum       proargmodes;
<span class="lineNum">     474 </span>            :             char      **old_arg_names;
<span class="lineNum">     475 </span>            :             char      **new_arg_names;
<span class="lineNum">     476 </span>            :             int         n_old_arg_names;
<span class="lineNum">     477 </span>            :             int         n_new_arg_names;
<span class="lineNum">     478 </span>            :             int         j;
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span><span class="lineCov">         44 :             proargmodes = SysCacheGetAttr(PROCNAMEARGSNSP, oldtup,</span>
<span class="lineNum">     481 </span>            :                                           Anum_pg_proc_proargmodes,
<span class="lineNum">     482 </span>            :                                           &amp;isnull);
<span class="lineNum">     483 </span><span class="lineCov">         44 :             if (isnull)</span>
<span class="lineNum">     484 </span><span class="lineCov">         12 :                 proargmodes = PointerGetDatum(NULL);    /* just to be sure */</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineCov">         44 :             n_old_arg_names = get_func_input_arg_names(proargnames,</span>
<span class="lineNum">     487 </span>            :                                                        proargmodes,
<span class="lineNum">     488 </span>            :                                                        &amp;old_arg_names);
<span class="lineNum">     489 </span><span class="lineCov">         44 :             n_new_arg_names = get_func_input_arg_names(parameterNames,</span>
<span class="lineNum">     490 </span>            :                                                        parameterModes,
<span class="lineNum">     491 </span>            :                                                        &amp;new_arg_names);
<span class="lineNum">     492 </span><span class="lineCov">        138 :             for (j = 0; j &lt; n_old_arg_names; j++)</span>
<span class="lineNum">     493 </span>            :             {
<span class="lineNum">     494 </span><span class="lineCov">        100 :                 if (old_arg_names[j] == NULL)</span>
<span class="lineNum">     495 </span><span class="lineCov">          2 :                     continue;</span>
<span class="lineNum">     496 </span><span class="lineCov">        194 :                 if (j &gt;= n_new_arg_names || new_arg_names[j] == NULL ||</span>
<span class="lineNum">     497 </span><span class="lineCov">         96 :                     strcmp(old_arg_names[j], new_arg_names[j]) != 0)</span>
<span class="lineNum">     498 </span><span class="lineCov">          6 :                     ereport(ERROR,</span>
<span class="lineNum">     499 </span>            :                             (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">     500 </span>            :                              errmsg(&quot;cannot change name of input parameter \&quot;%s\&quot;&quot;,
<span class="lineNum">     501 </span>            :                                     old_arg_names[j]),
<span class="lineNum">     502 </span>            :                     /* translator: first %s is DROP FUNCTION or DROP PROCEDURE */
<span class="lineNum">     503 </span>            :                              errhint(&quot;Use %s %s first.&quot;,
<span class="lineNum">     504 </span>            :                                      dropcmd,
<span class="lineNum">     505 </span>            :                                      format_procedure(oldproc-&gt;oid))));
<span class="lineNum">     506 </span>            :             }
<span class="lineNum">     507 </span>            :         }
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            :         /*
<span class="lineNum">     510 </span>            :          * If there are existing defaults, check compatibility: redefinition
<span class="lineNum">     511 </span>            :          * must not remove any defaults nor change their types.  (Removing a
<span class="lineNum">     512 </span>            :          * default might cause a function to fail to satisfy an existing call.
<span class="lineNum">     513 </span>            :          * Changing type would only be possible if the associated parameter is
<span class="lineNum">     514 </span>            :          * polymorphic, and in such cases a change of default type might alter
<span class="lineNum">     515 </span>            :          * the resolved output type of existing calls.)
<span class="lineNum">     516 </span>            :          */
<span class="lineNum">     517 </span><span class="lineCov">        230 :         if (oldproc-&gt;pronargdefaults != 0)</span>
<span class="lineNum">     518 </span>            :         {
<span class="lineNum">     519 </span>            :             Datum       proargdefaults;
<span class="lineNum">     520 </span>            :             List       *oldDefaults;
<span class="lineNum">     521 </span>            :             ListCell   *oldlc;
<span class="lineNum">     522 </span>            :             ListCell   *newlc;
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span><span class="lineCov">          2 :             if (list_length(parameterDefaults) &lt; oldproc-&gt;pronargdefaults)</span>
<span class="lineNum">     525 </span><span class="lineCov">          2 :                 ereport(ERROR,</span>
<span class="lineNum">     526 </span>            :                         (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">     527 </span>            :                          errmsg(&quot;cannot remove parameter defaults from existing function&quot;),
<span class="lineNum">     528 </span>            :                 /* translator: first %s is DROP FUNCTION or DROP PROCEDURE */
<span class="lineNum">     529 </span>            :                          errhint(&quot;Use %s %s first.&quot;,
<span class="lineNum">     530 </span>            :                                  dropcmd,
<span class="lineNum">     531 </span>            :                                  format_procedure(oldproc-&gt;oid))));
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :             proargdefaults = SysCacheGetAttr(PROCNAMEARGSNSP, oldtup,</span>
<span class="lineNum">     534 </span>            :                                              Anum_pg_proc_proargdefaults,
<span class="lineNum">     535 </span>            :                                              &amp;isnull);
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :             Assert(!isnull);</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :             oldDefaults = castNode(List, stringToNode(TextDatumGetCString(proargdefaults)));</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :             Assert(list_length(oldDefaults) == oldproc-&gt;pronargdefaults);</span>
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            :             /* new list can have more defaults than old, advance over 'em */
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :             newlc = list_nth_cell(parameterDefaults,</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :                                   list_length(parameterDefaults) -</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :                                   oldproc-&gt;pronargdefaults);</span>
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :             foreach(oldlc, oldDefaults)</span>
<span class="lineNum">     546 </span>            :             {
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :                 Node       *oldDef = (Node *) lfirst(oldlc);</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :                 Node       *newDef = (Node *) lfirst(newlc);</span>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :                 if (exprType(oldDef) != exprType(newDef))</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :                     ereport(ERROR,</span>
<span class="lineNum">     552 </span>            :                             (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">     553 </span>            :                              errmsg(&quot;cannot change data type of existing parameter default value&quot;),
<span class="lineNum">     554 </span>            :                     /* translator: first %s is DROP FUNCTION or DROP PROCEDURE */
<span class="lineNum">     555 </span>            :                              errhint(&quot;Use %s %s first.&quot;,
<span class="lineNum">     556 </span>            :                                      dropcmd,
<span class="lineNum">     557 </span>            :                                      format_procedure(oldproc-&gt;oid))));
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :                 newlc = lnext(parameterDefaults, newlc);</span>
<span class="lineNum">     559 </span>            :             }
<span class="lineNum">     560 </span>            :         }
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span>            :         /*
<span class="lineNum">     563 </span>            :          * Do not change existing oid, ownership or permissions, either.  Note
<span class="lineNum">     564 </span>            :          * dependency-update code below has to agree with this decision.
<span class="lineNum">     565 </span>            :          */
<span class="lineNum">     566 </span><span class="lineCov">        228 :         replaces[Anum_pg_proc_oid - 1] = false;</span>
<span class="lineNum">     567 </span><span class="lineCov">        228 :         replaces[Anum_pg_proc_proowner - 1] = false;</span>
<span class="lineNum">     568 </span><span class="lineCov">        228 :         replaces[Anum_pg_proc_proacl - 1] = false;</span>
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            :         /* Okay, do it... */
<span class="lineNum">     571 </span><span class="lineCov">        228 :         tup = heap_modify_tuple(oldtup, tupDesc, values, nulls, replaces);</span>
<span class="lineNum">     572 </span><span class="lineCov">        228 :         CatalogTupleUpdate(rel, &amp;tup-&gt;t_self, tup);</span>
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span><span class="lineCov">        228 :         ReleaseSysCache(oldtup);</span>
<span class="lineNum">     575 </span><span class="lineCov">        228 :         is_update = true;</span>
<span class="lineNum">     576 </span>            :     }
<span class="lineNum">     577 </span>            :     else
<span class="lineNum">     578 </span>            :     {
<span class="lineNum">     579 </span>            :         /* Creating a new procedure */
<span class="lineNum">     580 </span>            :         Oid         newOid;
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            :         /* First, get default permissions and set up proacl */
<span class="lineNum">     583 </span><span class="lineCov">       1370 :         proacl = get_user_default_acl(OBJECT_FUNCTION, proowner,</span>
<span class="lineNum">     584 </span>            :                                       procNamespace);
<span class="lineNum">     585 </span><span class="lineCov">       1370 :         if (proacl != NULL)</span>
<span class="lineNum">     586 </span><span class="lineCov">          6 :             values[Anum_pg_proc_proacl - 1] = PointerGetDatum(proacl);</span>
<span class="lineNum">     587 </span>            :         else
<span class="lineNum">     588 </span><span class="lineCov">       1364 :             nulls[Anum_pg_proc_proacl - 1] = true;</span>
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span><span class="lineCov">       1370 :         newOid = GetNewOidWithIndex(rel, ProcedureOidIndexId,</span>
<span class="lineNum">     591 </span>            :                                     Anum_pg_proc_oid);
<span class="lineNum">     592 </span><span class="lineCov">       1370 :         values[Anum_pg_proc_oid - 1] = ObjectIdGetDatum(newOid);</span>
<span class="lineNum">     593 </span><span class="lineCov">       1370 :         tup = heap_form_tuple(tupDesc, values, nulls);</span>
<span class="lineNum">     594 </span><span class="lineCov">       1370 :         CatalogTupleInsert(rel, tup);</span>
<span class="lineNum">     595 </span><span class="lineCov">       1370 :         is_update = false;</span>
<span class="lineNum">     596 </span>            :     }
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span><span class="lineCov">       1598 :     retval = ((Form_pg_proc) GETSTRUCT(tup))-&gt;oid;</span>
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            :     /*
<span class="lineNum">     602 </span>            :      * Create dependencies for the new function.  If we are updating an
<span class="lineNum">     603 </span>            :      * existing function, first delete any existing pg_depend entries.
<span class="lineNum">     604 </span>            :      * (However, since we are not changing ownership or permissions, the
<span class="lineNum">     605 </span>            :      * shared dependencies do *not* need to change, and we leave them alone.)
<span class="lineNum">     606 </span>            :      */
<span class="lineNum">     607 </span><span class="lineCov">       1598 :     if (is_update)</span>
<span class="lineNum">     608 </span><span class="lineCov">        228 :         deleteDependencyRecordsFor(ProcedureRelationId, retval, true);</span>
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span><span class="lineCov">       1598 :     myself.classId = ProcedureRelationId;</span>
<span class="lineNum">     611 </span><span class="lineCov">       1598 :     myself.objectId = retval;</span>
<span class="lineNum">     612 </span><span class="lineCov">       1598 :     myself.objectSubId = 0;</span>
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            :     /* dependency on namespace */
<span class="lineNum">     615 </span><span class="lineCov">       1598 :     referenced.classId = NamespaceRelationId;</span>
<span class="lineNum">     616 </span><span class="lineCov">       1598 :     referenced.objectId = procNamespace;</span>
<span class="lineNum">     617 </span><span class="lineCov">       1598 :     referenced.objectSubId = 0;</span>
<span class="lineNum">     618 </span><span class="lineCov">       1598 :     recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);</span>
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span>            :     /* dependency on implementation language */
<span class="lineNum">     621 </span><span class="lineCov">       1598 :     referenced.classId = LanguageRelationId;</span>
<span class="lineNum">     622 </span><span class="lineCov">       1598 :     referenced.objectId = languageObjectId;</span>
<span class="lineNum">     623 </span><span class="lineCov">       1598 :     referenced.objectSubId = 0;</span>
<span class="lineNum">     624 </span><span class="lineCov">       1598 :     recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);</span>
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            :     /* dependency on return type */
<span class="lineNum">     627 </span><span class="lineCov">       1598 :     referenced.classId = TypeRelationId;</span>
<span class="lineNum">     628 </span><span class="lineCov">       1598 :     referenced.objectId = returnType;</span>
<span class="lineNum">     629 </span><span class="lineCov">       1598 :     referenced.objectSubId = 0;</span>
<span class="lineNum">     630 </span><span class="lineCov">       1598 :     recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);</span>
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            :     /* dependency on transform used by return type, if any */
<span class="lineNum">     633 </span><span class="lineCov">       1598 :     if ((trfid = get_transform_oid(returnType, languageObjectId, true)))</span>
<span class="lineNum">     634 </span>            :     {
<span class="lineNum">     635 </span><span class="lineCov">         76 :         referenced.classId = TransformRelationId;</span>
<span class="lineNum">     636 </span><span class="lineCov">         76 :         referenced.objectId = trfid;</span>
<span class="lineNum">     637 </span><span class="lineCov">         76 :         referenced.objectSubId = 0;</span>
<span class="lineNum">     638 </span><span class="lineCov">         76 :         recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);</span>
<span class="lineNum">     639 </span>            :     }
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            :     /* dependency on parameter types */
<span class="lineNum">     642 </span><span class="lineCov">       3348 :     for (i = 0; i &lt; allParamCount; i++)</span>
<span class="lineNum">     643 </span>            :     {
<span class="lineNum">     644 </span><span class="lineCov">       1750 :         referenced.classId = TypeRelationId;</span>
<span class="lineNum">     645 </span><span class="lineCov">       1750 :         referenced.objectId = allParams[i];</span>
<span class="lineNum">     646 </span><span class="lineCov">       1750 :         referenced.objectSubId = 0;</span>
<span class="lineNum">     647 </span><span class="lineCov">       1750 :         recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);</span>
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span>            :         /* dependency on transform used by parameter type, if any */
<span class="lineNum">     650 </span><span class="lineCov">       1750 :         if ((trfid = get_transform_oid(allParams[i], languageObjectId, true)))</span>
<span class="lineNum">     651 </span>            :         {
<span class="lineNum">     652 </span><span class="lineCov">        164 :             referenced.classId = TransformRelationId;</span>
<span class="lineNum">     653 </span><span class="lineCov">        164 :             referenced.objectId = trfid;</span>
<span class="lineNum">     654 </span><span class="lineCov">        164 :             referenced.objectSubId = 0;</span>
<span class="lineNum">     655 </span><span class="lineCov">        164 :             recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);</span>
<span class="lineNum">     656 </span>            :         }
<span class="lineNum">     657 </span>            :     }
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            :     /* dependency on parameter default expressions */
<span class="lineNum">     660 </span><span class="lineCov">       1598 :     if (parameterDefaults)</span>
<span class="lineNum">     661 </span><span class="lineCov">         88 :         recordDependencyOnExpr(&amp;myself, (Node *) parameterDefaults,</span>
<span class="lineNum">     662 </span>            :                                NIL, DEPENDENCY_NORMAL);
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :     /* dependency on support function, if any */
<span class="lineNum">     665 </span><span class="lineCov">       1598 :     if (OidIsValid(prosupport))</span>
<span class="lineNum">     666 </span>            :     {
<span class="lineNum">     667 </span><span class="lineCov">          2 :         referenced.classId = ProcedureRelationId;</span>
<span class="lineNum">     668 </span><span class="lineCov">          2 :         referenced.objectId = prosupport;</span>
<span class="lineNum">     669 </span><span class="lineCov">          2 :         referenced.objectSubId = 0;</span>
<span class="lineNum">     670 </span><span class="lineCov">          2 :         recordDependencyOn(&amp;myself, &amp;referenced, DEPENDENCY_NORMAL);</span>
<span class="lineNum">     671 </span>            :     }
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            :     /* dependency on owner */
<span class="lineNum">     674 </span><span class="lineCov">       1598 :     if (!is_update)</span>
<span class="lineNum">     675 </span><span class="lineCov">       1370 :         recordDependencyOnOwner(ProcedureRelationId, retval, proowner);</span>
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            :     /* dependency on any roles mentioned in ACL */
<span class="lineNum">     678 </span><span class="lineCov">       1598 :     if (!is_update)</span>
<span class="lineNum">     679 </span><span class="lineCov">       1370 :         recordDependencyOnNewAcl(ProcedureRelationId, retval, 0,</span>
<span class="lineNum">     680 </span>            :                                  proowner, proacl);
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span>            :     /* dependency on extension */
<span class="lineNum">     683 </span><span class="lineCov">       1598 :     recordDependencyOnCurrentExtension(&amp;myself, is_update);</span>
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span><span class="lineCov">       1598 :     heap_freetuple(tup);</span>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            :     /* Post creation hook for new function */
<span class="lineNum">     688 </span><span class="lineCov">       1598 :     InvokeObjectPostCreateHook(ProcedureRelationId, retval, 0);</span>
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span><span class="lineCov">       1598 :     table_close(rel, RowExclusiveLock);</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :     /* Verify function body */
<span class="lineNum">     693 </span><span class="lineCov">       1598 :     if (OidIsValid(languageValidator))</span>
<span class="lineNum">     694 </span>            :     {
<span class="lineNum">     695 </span><span class="lineCov">       1456 :         ArrayType  *set_items = NULL;</span>
<span class="lineNum">     696 </span><span class="lineCov">       1456 :         int         save_nestlevel = 0;</span>
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            :         /* Advance command counter so new tuple can be seen by validator */
<span class="lineNum">     699 </span><span class="lineCov">       1456 :         CommandCounterIncrement();</span>
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            :         /*
<span class="lineNum">     702 </span>            :          * Set per-function configuration parameters so that the validation is
<span class="lineNum">     703 </span>            :          * done with the environment the function expects.  However, if
<span class="lineNum">     704 </span>            :          * check_function_bodies is off, we don't do this, because that would
<span class="lineNum">     705 </span>            :          * create dump ordering hazards that pg_dump doesn't know how to deal
<span class="lineNum">     706 </span>            :          * with.  (For example, a SET clause might refer to a not-yet-created
<span class="lineNum">     707 </span>            :          * text search configuration.)  This means that the validator
<span class="lineNum">     708 </span>            :          * shouldn't complain about anything that might depend on a GUC
<span class="lineNum">     709 </span>            :          * parameter when check_function_bodies is off.
<span class="lineNum">     710 </span>            :          */
<span class="lineNum">     711 </span><span class="lineCov">       1456 :         if (check_function_bodies)</span>
<span class="lineNum">     712 </span>            :         {
<span class="lineNum">     713 </span><span class="lineCov">       1454 :             set_items = (ArrayType *) DatumGetPointer(proconfig);</span>
<span class="lineNum">     714 </span><span class="lineCov">       1454 :             if (set_items)      /* Need a new GUC nesting level */</span>
<span class="lineNum">     715 </span>            :             {
<span class="lineNum">     716 </span><span class="lineCov">         12 :                 save_nestlevel = NewGUCNestLevel();</span>
<span class="lineNum">     717 </span><span class="lineCov">         12 :                 ProcessGUCArray(set_items,</span>
<span class="lineNum">     718 </span><span class="lineCov">         12 :                                 (superuser() ? PGC_SUSET : PGC_USERSET),</span>
<span class="lineNum">     719 </span>            :                                 PGC_S_SESSION,
<span class="lineNum">     720 </span>            :                                 GUC_ACTION_SAVE);
<span class="lineNum">     721 </span>            :             }
<span class="lineNum">     722 </span>            :         }
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span><span class="lineCov">       1454 :         OidFunctionCall1(languageValidator, ObjectIdGetDatum(retval));</span>
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span><span class="lineCov">       1404 :         if (set_items)</span>
<span class="lineNum">     727 </span><span class="lineCov">         10 :             AtEOXact_GUC(true, save_nestlevel);</span>
<span class="lineNum">     728 </span>            :     }
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span><span class="lineCov">       1546 :     return myself;</span>
<span class="lineNum">     731 </span>            : }
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span>            : /*
<span class="lineNum">     736 </span>            :  * Validator for internal functions
<span class="lineNum">     737 </span>            :  *
<span class="lineNum">     738 </span>            :  * Check that the given internal function name (the &quot;prosrc&quot; value) is
<span class="lineNum">     739 </span>            :  * a known builtin function.
<a name="740"><span class="lineNum">     740 </span>            :  */</a>
<span class="lineNum">     741 </span>            : Datum
<span class="lineNum">     742 </span><span class="lineCov">        152 : fmgr_internal_validator(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     743 </span>            : {
<span class="lineNum">     744 </span><span class="lineCov">        152 :     Oid         funcoid = PG_GETARG_OID(0);</span>
<span class="lineNum">     745 </span>            :     HeapTuple   tuple;
<span class="lineNum">     746 </span>            :     bool        isnull;
<span class="lineNum">     747 </span>            :     Datum       tmp;
<span class="lineNum">     748 </span>            :     char       *prosrc;
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span><span class="lineCov">        152 :     if (!CheckFunctionValidatorAccess(fcinfo-&gt;flinfo-&gt;fn_oid, funcoid))</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :         PG_RETURN_VOID();</span>
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            :     /*
<span class="lineNum">     754 </span>            :      * We do not honor check_function_bodies since it's unlikely the function
<span class="lineNum">     755 </span>            :      * name will be found later if it isn't there now.
<span class="lineNum">     756 </span>            :      */
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span><span class="lineCov">        152 :     tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));</span>
<span class="lineNum">     759 </span><span class="lineCov">        152 :     if (!HeapTupleIsValid(tuple))</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cache lookup failed for function %u&quot;, funcoid);</span>
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span><span class="lineCov">        152 :     tmp = SysCacheGetAttr(PROCOID, tuple, Anum_pg_proc_prosrc, &amp;isnull);</span>
<span class="lineNum">     763 </span><span class="lineCov">        152 :     if (isnull)</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;null prosrc&quot;);</span>
<span class="lineNum">     765 </span><span class="lineCov">        152 :     prosrc = TextDatumGetCString(tmp);</span>
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span><span class="lineCov">        152 :     if (fmgr_internal_function(prosrc) == InvalidOid)</span>
<span class="lineNum">     768 </span><span class="lineCov">          2 :         ereport(ERROR,</span>
<span class="lineNum">     769 </span>            :                 (errcode(ERRCODE_UNDEFINED_FUNCTION),
<span class="lineNum">     770 </span>            :                  errmsg(&quot;there is no built-in function named \&quot;%s\&quot;&quot;,
<span class="lineNum">     771 </span>            :                         prosrc)));
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span><span class="lineCov">        150 :     ReleaseSysCache(tuple);</span>
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span><span class="lineCov">        150 :     PG_RETURN_VOID();</span>
<span class="lineNum">     776 </span>            : }
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            : /*
<span class="lineNum">     781 </span>            :  * Validator for C language functions
<span class="lineNum">     782 </span>            :  *
<span class="lineNum">     783 </span>            :  * Make sure that the library file exists, is loadable, and contains
<span class="lineNum">     784 </span>            :  * the specified link symbol. Also check for a valid function
<span class="lineNum">     785 </span>            :  * information record.
<a name="786"><span class="lineNum">     786 </span>            :  */</a>
<span class="lineNum">     787 </span>            : Datum
<span class="lineNum">     788 </span><span class="lineCov">         50 : fmgr_c_validator(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     789 </span>            : {
<span class="lineNum">     790 </span><span class="lineCov">         50 :     Oid         funcoid = PG_GETARG_OID(0);</span>
<span class="lineNum">     791 </span>            :     void       *libraryhandle;
<span class="lineNum">     792 </span>            :     HeapTuple   tuple;
<span class="lineNum">     793 </span>            :     bool        isnull;
<span class="lineNum">     794 </span>            :     Datum       tmp;
<span class="lineNum">     795 </span>            :     char       *prosrc;
<span class="lineNum">     796 </span>            :     char       *probin;
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span><span class="lineCov">         50 :     if (!CheckFunctionValidatorAccess(fcinfo-&gt;flinfo-&gt;fn_oid, funcoid))</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :         PG_RETURN_VOID();</span>
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            :     /*
<span class="lineNum">     802 </span>            :      * It'd be most consistent to skip the check if !check_function_bodies,
<span class="lineNum">     803 </span>            :      * but the purpose of that switch is to be helpful for pg_dump loading,
<span class="lineNum">     804 </span>            :      * and for pg_dump loading it's much better if we *do* check.
<span class="lineNum">     805 </span>            :      */
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span><span class="lineCov">         50 :     tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));</span>
<span class="lineNum">     808 </span><span class="lineCov">         50 :     if (!HeapTupleIsValid(tuple))</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cache lookup failed for function %u&quot;, funcoid);</span>
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span><span class="lineCov">         50 :     tmp = SysCacheGetAttr(PROCOID, tuple, Anum_pg_proc_prosrc, &amp;isnull);</span>
<span class="lineNum">     812 </span><span class="lineCov">         50 :     if (isnull)</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;null prosrc for C function %u&quot;, funcoid);</span>
<span class="lineNum">     814 </span><span class="lineCov">         50 :     prosrc = TextDatumGetCString(tmp);</span>
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span><span class="lineCov">         50 :     tmp = SysCacheGetAttr(PROCOID, tuple, Anum_pg_proc_probin, &amp;isnull);</span>
<span class="lineNum">     817 </span><span class="lineCov">         50 :     if (isnull)</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;null probin for C function %u&quot;, funcoid);</span>
<span class="lineNum">     819 </span><span class="lineCov">         50 :     probin = TextDatumGetCString(tmp);</span>
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span><span class="lineCov">         50 :     (void) load_external_function(probin, prosrc, true, &amp;libraryhandle);</span>
<span class="lineNum">     822 </span><span class="lineCov">         46 :     (void) fetch_finfo_record(libraryhandle, prosrc);</span>
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span><span class="lineCov">         46 :     ReleaseSysCache(tuple);</span>
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span><span class="lineCov">         46 :     PG_RETURN_VOID();</span>
<span class="lineNum">     827 </span>            : }
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span>            : /*
<span class="lineNum">     831 </span>            :  * Validator for SQL language functions
<span class="lineNum">     832 </span>            :  *
<span class="lineNum">     833 </span>            :  * Parse it here in order to be sure that it contains no syntax errors.
<a name="834"><span class="lineNum">     834 </span>            :  */</a>
<span class="lineNum">     835 </span>            : Datum
<span class="lineNum">     836 </span><span class="lineCov">        494 : fmgr_sql_validator(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     837 </span>            : {
<span class="lineNum">     838 </span><span class="lineCov">        494 :     Oid         funcoid = PG_GETARG_OID(0);</span>
<span class="lineNum">     839 </span>            :     HeapTuple   tuple;
<span class="lineNum">     840 </span>            :     Form_pg_proc proc;
<span class="lineNum">     841 </span>            :     List       *raw_parsetree_list;
<span class="lineNum">     842 </span>            :     List       *querytree_list;
<span class="lineNum">     843 </span>            :     ListCell   *lc;
<span class="lineNum">     844 </span>            :     bool        isnull;
<span class="lineNum">     845 </span>            :     Datum       tmp;
<span class="lineNum">     846 </span>            :     char       *prosrc;
<span class="lineNum">     847 </span>            :     parse_error_callback_arg callback_arg;
<span class="lineNum">     848 </span>            :     ErrorContextCallback sqlerrcontext;
<span class="lineNum">     849 </span>            :     bool        haspolyarg;
<span class="lineNum">     850 </span>            :     int         i;
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span><span class="lineCov">        494 :     if (!CheckFunctionValidatorAccess(fcinfo-&gt;flinfo-&gt;fn_oid, funcoid))</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :         PG_RETURN_VOID();</span>
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span><span class="lineCov">        494 :     tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));</span>
<span class="lineNum">     856 </span><span class="lineCov">        494 :     if (!HeapTupleIsValid(tuple))</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cache lookup failed for function %u&quot;, funcoid);</span>
<span class="lineNum">     858 </span><span class="lineCov">        494 :     proc = (Form_pg_proc) GETSTRUCT(tuple);</span>
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            :     /* Disallow pseudotype result */
<span class="lineNum">     861 </span>            :     /* except for RECORD, VOID, or polymorphic */
<span class="lineNum">     862 </span><span class="lineCov">        636 :     if (get_typtype(proc-&gt;prorettype) == TYPTYPE_PSEUDO &amp;&amp;</span>
<span class="lineNum">     863 </span><span class="lineCov">        234 :         proc-&gt;prorettype != RECORDOID &amp;&amp;</span>
<span class="lineNum">     864 </span><span class="lineCov">        130 :         proc-&gt;prorettype != VOIDOID &amp;&amp;</span>
<span class="lineNum">     865 </span><span class="lineCov">         50 :         !IsPolymorphicType(proc-&gt;prorettype))</span>
<span class="lineNum">     866 </span><span class="lineCov">          2 :         ereport(ERROR,</span>
<span class="lineNum">     867 </span>            :                 (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">     868 </span>            :                  errmsg(&quot;SQL functions cannot return type %s&quot;,
<span class="lineNum">     869 </span>            :                         format_type_be(proc-&gt;prorettype))));
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            :     /* Disallow pseudotypes in arguments */
<span class="lineNum">     872 </span>            :     /* except for polymorphic */
<span class="lineNum">     873 </span><span class="lineCov">        492 :     haspolyarg = false;</span>
<span class="lineNum">     874 </span><span class="lineCov">       1102 :     for (i = 0; i &lt; proc-&gt;pronargs; i++)</span>
<span class="lineNum">     875 </span>            :     {
<span class="lineNum">     876 </span><span class="lineCov">        610 :         if (get_typtype(proc-&gt;proargtypes.values[i]) == TYPTYPE_PSEUDO)</span>
<span class="lineNum">     877 </span>            :         {
<span class="lineNum">     878 </span><span class="lineCov">         94 :             if (IsPolymorphicType(proc-&gt;proargtypes.values[i]))</span>
<span class="lineNum">     879 </span><span class="lineCov">         94 :                 haspolyarg = true;</span>
<span class="lineNum">     880 </span>            :             else
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :                 ereport(ERROR,</span>
<span class="lineNum">     882 </span>            :                         (errcode(ERRCODE_INVALID_FUNCTION_DEFINITION),
<span class="lineNum">     883 </span>            :                          errmsg(&quot;SQL functions cannot have arguments of type %s&quot;,
<span class="lineNum">     884 </span>            :                                 format_type_be(proc-&gt;proargtypes.values[i]))));
<span class="lineNum">     885 </span>            :         }
<span class="lineNum">     886 </span>            :     }
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span>            :     /* Postpone body checks if !check_function_bodies */
<span class="lineNum">     889 </span><span class="lineCov">        492 :     if (check_function_bodies)</span>
<span class="lineNum">     890 </span>            :     {
<span class="lineNum">     891 </span><span class="lineCov">        490 :         tmp = SysCacheGetAttr(PROCOID, tuple, Anum_pg_proc_prosrc, &amp;isnull);</span>
<span class="lineNum">     892 </span><span class="lineCov">        490 :         if (isnull)</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;null prosrc&quot;);</span>
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span><span class="lineCov">        490 :         prosrc = TextDatumGetCString(tmp);</span>
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span>            :         /*
<span class="lineNum">     898 </span>            :          * Setup error traceback support for ereport().
<span class="lineNum">     899 </span>            :          */
<span class="lineNum">     900 </span><span class="lineCov">        490 :         callback_arg.proname = NameStr(proc-&gt;proname);</span>
<span class="lineNum">     901 </span><span class="lineCov">        490 :         callback_arg.prosrc = prosrc;</span>
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span><span class="lineCov">        490 :         sqlerrcontext.callback = sql_function_parse_error_callback;</span>
<span class="lineNum">     904 </span><span class="lineCov">        490 :         sqlerrcontext.arg = (void *) &amp;callback_arg;</span>
<span class="lineNum">     905 </span><span class="lineCov">        490 :         sqlerrcontext.previous = error_context_stack;</span>
<span class="lineNum">     906 </span><span class="lineCov">        490 :         error_context_stack = &amp;sqlerrcontext;</span>
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            :         /*
<span class="lineNum">     909 </span>            :          * We can't do full prechecking of the function definition if there
<span class="lineNum">     910 </span>            :          * are any polymorphic input types, because actual datatypes of
<span class="lineNum">     911 </span>            :          * expression results will be unresolvable.  The check will be done at
<span class="lineNum">     912 </span>            :          * runtime instead.
<span class="lineNum">     913 </span>            :          *
<span class="lineNum">     914 </span>            :          * We can run the text through the raw parser though; this will at
<span class="lineNum">     915 </span>            :          * least catch silly syntactic errors.
<span class="lineNum">     916 </span>            :          */
<span class="lineNum">     917 </span><span class="lineCov">        490 :         raw_parsetree_list = pg_parse_query(prosrc);</span>
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span><span class="lineCov">        488 :         if (!haspolyarg)</span>
<span class="lineNum">     920 </span>            :         {
<span class="lineNum">     921 </span>            :             /*
<span class="lineNum">     922 </span>            :              * OK to do full precheck: analyze and rewrite the queries, then
<span class="lineNum">     923 </span>            :              * verify the result type.
<span class="lineNum">     924 </span>            :              */
<span class="lineNum">     925 </span>            :             SQLFunctionParseInfoPtr pinfo;
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span>            :             /* But first, set up parameter information */
<span class="lineNum">     928 </span><span class="lineCov">        416 :             pinfo = prepare_sql_fn_parse_info(tuple, NULL, InvalidOid);</span>
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span><span class="lineCov">        416 :             querytree_list = NIL;</span>
<span class="lineNum">     931 </span><span class="lineCov">        830 :             foreach(lc, raw_parsetree_list)</span>
<span class="lineNum">     932 </span>            :             {
<span class="lineNum">     933 </span><span class="lineCov">        418 :                 RawStmt    *parsetree = lfirst_node(RawStmt, lc);</span>
<span class="lineNum">     934 </span>            :                 List       *querytree_sublist;
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span><span class="lineCov">        418 :                 querytree_sublist = pg_analyze_and_rewrite_params(parsetree,</span>
<span class="lineNum">     937 </span>            :                                                                   prosrc,
<span class="lineNum">     938 </span>            :                                                                   (ParserSetupHook) sql_fn_parser_setup,
<span class="lineNum">     939 </span>            :                                                                   pinfo,
<span class="lineNum">     940 </span>            :                                                                   NULL);
<span class="lineNum">     941 </span><span class="lineCov">        414 :                 querytree_list = list_concat(querytree_list,</span>
<span class="lineNum">     942 </span>            :                                              querytree_sublist);
<span class="lineNum">     943 </span>            :             }
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span><span class="lineCov">        412 :             check_sql_fn_statements(querytree_list);</span>
<span class="lineNum">     946 </span><span class="lineCov">        410 :             (void) check_sql_fn_retval(funcoid, proc-&gt;prorettype,</span>
<span class="lineNum">     947 </span>            :                                        querytree_list,
<span class="lineNum">     948 </span>            :                                        NULL, NULL);
<span class="lineNum">     949 </span>            :         }
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span><span class="lineCov">        478 :         error_context_stack = sqlerrcontext.previous;</span>
<span class="lineNum">     952 </span>            :     }
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span><span class="lineCov">        480 :     ReleaseSysCache(tuple);</span>
<span class="lineNum">     955 </span>            : 
<span class="lineNum">     956 </span><span class="lineCov">        480 :     PG_RETURN_VOID();</span>
<span class="lineNum">     957 </span>            : }
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            : /*
<span class="lineNum">     960 </span>            :  * Error context callback for handling errors in SQL function definitions
<a name="961"><span class="lineNum">     961 </span>            :  */</a>
<span class="lineNum">     962 </span>            : static void
<span class="lineNum">     963 </span><span class="lineCov">         12 : sql_function_parse_error_callback(void *arg)</span>
<span class="lineNum">     964 </span>            : {
<span class="lineNum">     965 </span><span class="lineCov">         12 :     parse_error_callback_arg *callback_arg = (parse_error_callback_arg *) arg;</span>
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            :     /* See if it's a syntax error; if so, transpose to CREATE FUNCTION */
<span class="lineNum">     968 </span><span class="lineCov">         12 :     if (!function_parse_error_transpose(callback_arg-&gt;prosrc))</span>
<span class="lineNum">     969 </span>            :     {
<span class="lineNum">     970 </span>            :         /* If it's not a syntax error, push info onto context stack */
<span class="lineNum">     971 </span><span class="lineCov">          6 :         errcontext(&quot;SQL function \&quot;%s\&quot;&quot;, callback_arg-&gt;proname);</span>
<span class="lineNum">     972 </span>            :     }
<span class="lineNum">     973 </span><span class="lineCov">         12 : }</span>
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span>            : /*
<span class="lineNum">     976 </span>            :  * Adjust a syntax error occurring inside the function body of a CREATE
<span class="lineNum">     977 </span>            :  * FUNCTION or DO command.  This can be used by any function validator or
<span class="lineNum">     978 </span>            :  * anonymous-block handler, not only for SQL-language functions.
<span class="lineNum">     979 </span>            :  * It is assumed that the syntax error position is initially relative to the
<span class="lineNum">     980 </span>            :  * function body string (as passed in).  If possible, we adjust the position
<span class="lineNum">     981 </span>            :  * to reference the original command text; if we can't manage that, we set
<span class="lineNum">     982 </span>            :  * up an &quot;internal query&quot; syntax error instead.
<span class="lineNum">     983 </span>            :  *
<span class="lineNum">     984 </span>            :  * Returns true if a syntax error was processed, false if not.
<a name="985"><span class="lineNum">     985 </span>            :  */</a>
<span class="lineNum">     986 </span>            : bool
<span class="lineNum">     987 </span><span class="lineCov">         66 : function_parse_error_transpose(const char *prosrc)</span>
<span class="lineNum">     988 </span>            : {
<span class="lineNum">     989 </span>            :     int         origerrposition;
<span class="lineNum">     990 </span>            :     int         newerrposition;
<span class="lineNum">     991 </span>            :     const char *queryText;
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span>            :     /*
<span class="lineNum">     994 </span>            :      * Nothing to do unless we are dealing with a syntax error that has a
<span class="lineNum">     995 </span>            :      * cursor position.
<span class="lineNum">     996 </span>            :      *
<span class="lineNum">     997 </span>            :      * Some PLs may prefer to report the error position as an internal error
<span class="lineNum">     998 </span>            :      * to begin with, so check that too.
<span class="lineNum">     999 </span>            :      */
<span class="lineNum">    1000 </span><span class="lineCov">         66 :     origerrposition = geterrposition();</span>
<span class="lineNum">    1001 </span><span class="lineCov">         66 :     if (origerrposition &lt;= 0)</span>
<span class="lineNum">    1002 </span>            :     {
<span class="lineNum">    1003 </span><span class="lineCov">         56 :         origerrposition = getinternalerrposition();</span>
<span class="lineNum">    1004 </span><span class="lineCov">         56 :         if (origerrposition &lt;= 0)</span>
<span class="lineNum">    1005 </span><span class="lineCov">         12 :             return false;</span>
<span class="lineNum">    1006 </span>            :     }
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            :     /* We can get the original query text from the active portal (hack...) */
<span class="lineNum">    1009 </span><span class="lineCov">         54 :     Assert(ActivePortal &amp;&amp; ActivePortal-&gt;status == PORTAL_ACTIVE);</span>
<span class="lineNum">    1010 </span><span class="lineCov">         54 :     queryText = ActivePortal-&gt;sourceText;</span>
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span>            :     /* Try to locate the prosrc in the original text */
<span class="lineNum">    1013 </span><span class="lineCov">         54 :     newerrposition = match_prosrc_to_query(prosrc, queryText, origerrposition);</span>
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span><span class="lineCov">         54 :     if (newerrposition &gt; 0)</span>
<span class="lineNum">    1016 </span>            :     {
<span class="lineNum">    1017 </span>            :         /* Successful, so fix error position to reference original query */
<span class="lineNum">    1018 </span><span class="lineCov">         54 :         errposition(newerrposition);</span>
<span class="lineNum">    1019 </span>            :         /* Get rid of any report of the error as an &quot;internal query&quot; */
<span class="lineNum">    1020 </span><span class="lineCov">         54 :         internalerrposition(0);</span>
<span class="lineNum">    1021 </span><span class="lineCov">         54 :         internalerrquery(NULL);</span>
<span class="lineNum">    1022 </span>            :     }
<span class="lineNum">    1023 </span>            :     else
<span class="lineNum">    1024 </span>            :     {
<span class="lineNum">    1025 </span>            :         /*
<span class="lineNum">    1026 </span>            :          * If unsuccessful, convert the position to an internal position
<span class="lineNum">    1027 </span>            :          * marker and give the function text as the internal query.
<span class="lineNum">    1028 </span>            :          */
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :         errposition(0);</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :         internalerrposition(origerrposition);</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :         internalerrquery(prosrc);</span>
<span class="lineNum">    1032 </span>            :     }
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span><span class="lineCov">         54 :     return true;</span>
<span class="lineNum">    1035 </span>            : }
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span>            : /*
<span class="lineNum">    1038 </span>            :  * Try to locate the string literal containing the function body in the
<span class="lineNum">    1039 </span>            :  * given text of the CREATE FUNCTION or DO command.  If successful, return
<span class="lineNum">    1040 </span>            :  * the character (not byte) index within the command corresponding to the
<span class="lineNum">    1041 </span>            :  * given character index within the literal.  If not successful, return 0.
<a name="1042"><span class="lineNum">    1042 </span>            :  */</a>
<span class="lineNum">    1043 </span>            : static int
<span class="lineNum">    1044 </span><span class="lineCov">         54 : match_prosrc_to_query(const char *prosrc, const char *queryText,</span>
<span class="lineNum">    1045 </span>            :                       int cursorpos)
<span class="lineNum">    1046 </span>            : {
<span class="lineNum">    1047 </span>            :     /*
<span class="lineNum">    1048 </span>            :      * Rather than fully parsing the original command, we just scan the
<span class="lineNum">    1049 </span>            :      * command looking for $prosrc$ or 'prosrc'.  This could be fooled (though
<span class="lineNum">    1050 </span>            :      * not in any very probable scenarios), so fail if we find more than one
<span class="lineNum">    1051 </span>            :      * match.
<span class="lineNum">    1052 </span>            :      */
<span class="lineNum">    1053 </span><span class="lineCov">         54 :     int         prosrclen = strlen(prosrc);</span>
<span class="lineNum">    1054 </span><span class="lineCov">         54 :     int         querylen = strlen(queryText);</span>
<span class="lineNum">    1055 </span><span class="lineCov">         54 :     int         matchpos = 0;</span>
<span class="lineNum">    1056 </span>            :     int         curpos;
<span class="lineNum">    1057 </span>            :     int         newcursorpos;
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span><span class="lineCov">       4178 :     for (curpos = 0; curpos &lt; querylen - prosrclen; curpos++)</span>
<span class="lineNum">    1060 </span>            :     {
<span class="lineNum">    1061 </span><span class="lineCov">       4224 :         if (queryText[curpos] == '$' &amp;&amp;</span>
<span class="lineNum">    1062 </span><span class="lineCov">        150 :             strncmp(prosrc, &amp;queryText[curpos + 1], prosrclen) == 0 &amp;&amp;</span>
<span class="lineNum">    1063 </span><span class="lineCov">         50 :             queryText[curpos + 1 + prosrclen] == '$')</span>
<span class="lineNum">    1064 </span>            :         {
<span class="lineNum">    1065 </span>            :             /*
<span class="lineNum">    1066 </span>            :              * Found a $foo$ match.  Since there are no embedded quoting
<span class="lineNum">    1067 </span>            :              * characters in a dollar-quoted literal, we don't have to do any
<span class="lineNum">    1068 </span>            :              * fancy arithmetic; just offset by the starting position.
<span class="lineNum">    1069 </span>            :              */
<span class="lineNum">    1070 </span><span class="lineCov">         50 :             if (matchpos)</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :                 return 0;       /* multiple matches, fail */</span>
<span class="lineNum">    1072 </span><span class="lineCov">         50 :             matchpos = pg_mbstrlen_with_len(queryText, curpos + 1)</span>
<span class="lineNum">    1073 </span>            :                 + cursorpos;
<span class="lineNum">    1074 </span>            :         }
<span class="lineNum">    1075 </span><span class="lineCov">       4078 :         else if (queryText[curpos] == '\'' &amp;&amp;</span>
<span class="lineNum">    1076 </span><span class="lineCov">          4 :                  match_prosrc_to_literal(prosrc, &amp;queryText[curpos + 1],</span>
<span class="lineNum">    1077 </span>            :                                          cursorpos, &amp;newcursorpos))
<span class="lineNum">    1078 </span>            :         {
<span class="lineNum">    1079 </span>            :             /*
<span class="lineNum">    1080 </span>            :              * Found a 'foo' match.  match_prosrc_to_literal() has adjusted
<span class="lineNum">    1081 </span>            :              * for any quotes or backslashes embedded in the literal.
<span class="lineNum">    1082 </span>            :              */
<span class="lineNum">    1083 </span><span class="lineCov">          4 :             if (matchpos)</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :                 return 0;       /* multiple matches, fail */</span>
<span class="lineNum">    1085 </span><span class="lineCov">          8 :             matchpos = pg_mbstrlen_with_len(queryText, curpos + 1)</span>
<span class="lineNum">    1086 </span><span class="lineCov">          4 :                 + newcursorpos;</span>
<span class="lineNum">    1087 </span>            :         }
<span class="lineNum">    1088 </span>            :     }
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span><span class="lineCov">         54 :     return matchpos;</span>
<span class="lineNum">    1091 </span>            : }
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span>            : /*
<span class="lineNum">    1094 </span>            :  * Try to match the given source text to a single-quoted literal.
<span class="lineNum">    1095 </span>            :  * If successful, adjust newcursorpos to correspond to the character
<span class="lineNum">    1096 </span>            :  * (not byte) index corresponding to cursorpos in the source text.
<span class="lineNum">    1097 </span>            :  *
<span class="lineNum">    1098 </span>            :  * At entry, literal points just past a ' character.  We must check for the
<span class="lineNum">    1099 </span>            :  * trailing quote.
<a name="1100"><span class="lineNum">    1100 </span>            :  */</a>
<span class="lineNum">    1101 </span>            : static bool
<span class="lineNum">    1102 </span><span class="lineCov">          4 : match_prosrc_to_literal(const char *prosrc, const char *literal,</span>
<span class="lineNum">    1103 </span>            :                         int cursorpos, int *newcursorpos)
<span class="lineNum">    1104 </span>            : {
<span class="lineNum">    1105 </span><span class="lineCov">          4 :     int         newcp = cursorpos;</span>
<span class="lineNum">    1106 </span>            :     int         chlen;
<span class="lineNum">    1107 </span>            : 
<span class="lineNum">    1108 </span>            :     /*
<span class="lineNum">    1109 </span>            :      * This implementation handles backslashes and doubled quotes in the
<span class="lineNum">    1110 </span>            :      * string literal.  It does not handle the SQL syntax for literals
<span class="lineNum">    1111 </span>            :      * continued across line boundaries.
<span class="lineNum">    1112 </span>            :      *
<span class="lineNum">    1113 </span>            :      * We do the comparison a character at a time, not a byte at a time, so
<span class="lineNum">    1114 </span>            :      * that we can do the correct cursorpos math.
<span class="lineNum">    1115 </span>            :      */
<span class="lineNum">    1116 </span><span class="lineCov">         52 :     while (*prosrc)</span>
<span class="lineNum">    1117 </span>            :     {
<span class="lineNum">    1118 </span><span class="lineCov">         44 :         cursorpos--;            /* characters left before cursor */</span>
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            :         /*
<span class="lineNum">    1121 </span>            :          * Check for backslashes and doubled quotes in the literal; adjust
<span class="lineNum">    1122 </span>            :          * newcp when one is found before the cursor.
<span class="lineNum">    1123 </span>            :          */
<span class="lineNum">    1124 </span><span class="lineCov">         44 :         if (*literal == '\\')</span>
<span class="lineNum">    1125 </span>            :         {
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :             literal++;</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :             if (cursorpos &gt; 0)</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :                 newcp++;</span>
<span class="lineNum">    1129 </span>            :         }
<span class="lineNum">    1130 </span><span class="lineCov">         44 :         else if (*literal == '\'')</span>
<span class="lineNum">    1131 </span>            :         {
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :             if (literal[1] != '\'')</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :                 goto fail;</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :             literal++;</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :             if (cursorpos &gt; 0)</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :                 newcp++;</span>
<span class="lineNum">    1137 </span>            :         }
<span class="lineNum">    1138 </span><span class="lineCov">         44 :         chlen = pg_mblen(prosrc);</span>
<span class="lineNum">    1139 </span><span class="lineCov">         44 :         if (strncmp(prosrc, literal, chlen) != 0)</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :             goto fail;</span>
<span class="lineNum">    1141 </span><span class="lineCov">         44 :         prosrc += chlen;</span>
<span class="lineNum">    1142 </span><span class="lineCov">         44 :         literal += chlen;</span>
<span class="lineNum">    1143 </span>            :     }
<span class="lineNum">    1144 </span>            : 
<span class="lineNum">    1145 </span><span class="lineCov">          4 :     if (*literal == '\'' &amp;&amp; literal[1] != '\'')</span>
<span class="lineNum">    1146 </span>            :     {
<span class="lineNum">    1147 </span>            :         /* success */
<span class="lineNum">    1148 </span><span class="lineCov">          4 :         *newcursorpos = newcp;</span>
<span class="lineNum">    1149 </span><span class="lineCov">          4 :         return true;</span>
<span class="lineNum">    1150 </span>            :     }
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span>            : fail:
<span class="lineNum">    1153 </span>            :     /* Must set *newcursorpos to suppress compiler warning */
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :     *newcursorpos = newcp;</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1156 </span>            : }
<a name="1157"><span class="lineNum">    1157 </span>            : </a>
<span class="lineNum">    1158 </span>            : List *
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 : oid_array_to_list(Datum datum)</span>
<span class="lineNum">    1160 </span>            : {
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :     ArrayType  *array = DatumGetArrayTypeP(datum);</span>
<span class="lineNum">    1162 </span>            :     Datum      *values;
<span class="lineNum">    1163 </span>            :     int         nelems;
<span class="lineNum">    1164 </span>            :     int         i;
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :     List       *result = NIL;</span>
<span class="lineNum">    1166 </span>            : 
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :     deconstruct_array(array,</span>
<span class="lineNum">    1168 </span>            :                       OIDOID,
<span class="lineNum">    1169 </span>            :                       sizeof(Oid), true, 'i',
<span class="lineNum">    1170 </span>            :                       &amp;values, NULL, &amp;nelems);
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; nelems; i++)</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :         result = lappend_oid(result, values[i]);</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">    1174 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
