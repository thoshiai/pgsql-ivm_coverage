<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/access/transam/commit_ts.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/backend/access/transam</a> - commit_ts.c<span style="font-size: 80%;"> (source / <a href="commit_ts.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">67</td>
            <td class="headerCovTableEntry">289</td>
            <td class="headerCovTableEntryLo">23.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">13</td>
            <td class="headerCovTableEntry">29</td>
            <td class="headerCovTableEntryLo">44.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * commit_ts.c
<span class="lineNum">       4 </span>            :  *      PostgreSQL commit timestamp manager
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * This module is a pg_xact-like system that stores the commit timestamp
<span class="lineNum">       7 </span>            :  * for each transaction.
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  * XLOG interactions: this module generates an XLOG record whenever a new
<span class="lineNum">      10 </span>            :  * CommitTs page is initialized to zeroes.  Also, one XLOG record is
<span class="lineNum">      11 </span>            :  * generated for setting of values when the caller requests it; this allows
<span class="lineNum">      12 </span>            :  * us to support values coming from places other than transaction commit.
<span class="lineNum">      13 </span>            :  * Other writes of CommitTS come from recording of transaction commit in
<span class="lineNum">      14 </span>            :  * xact.c, which generates its own XLOG records for these events and will
<span class="lineNum">      15 </span>            :  * re-perform the status update on redo; so we need make no additional XLOG
<span class="lineNum">      16 </span>            :  * entry here.
<span class="lineNum">      17 </span>            :  *
<span class="lineNum">      18 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">      19 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">      20 </span>            :  *
<span class="lineNum">      21 </span>            :  * src/backend/access/transam/commit_ts.c
<span class="lineNum">      22 </span>            :  *
<span class="lineNum">      23 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      24 </span>            :  */
<span class="lineNum">      25 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : #include &quot;access/commit_ts.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;access/htup_details.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;access/slru.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;access/transam.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;catalog/pg_type.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;funcapi.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;miscadmin.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;pg_trace.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;storage/shmem.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;utils/builtins.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;utils/snapmgr.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;utils/timestamp.h&quot;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : /*
<span class="lineNum">      41 </span>            :  * Defines for CommitTs page sizes.  A page is the same BLCKSZ as is used
<span class="lineNum">      42 </span>            :  * everywhere else in Postgres.
<span class="lineNum">      43 </span>            :  *
<span class="lineNum">      44 </span>            :  * Note: because TransactionIds are 32 bits and wrap around at 0xFFFFFFFF,
<span class="lineNum">      45 </span>            :  * CommitTs page numbering also wraps around at
<span class="lineNum">      46 </span>            :  * 0xFFFFFFFF/COMMIT_TS_XACTS_PER_PAGE, and CommitTs segment numbering at
<span class="lineNum">      47 </span>            :  * 0xFFFFFFFF/COMMIT_TS_XACTS_PER_PAGE/SLRU_PAGES_PER_SEGMENT.  We need take no
<span class="lineNum">      48 </span>            :  * explicit notice of that fact in this module, except when comparing segment
<span class="lineNum">      49 </span>            :  * and page numbers in TruncateCommitTs (see CommitTsPagePrecedes).
<span class="lineNum">      50 </span>            :  */
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : /*
<span class="lineNum">      53 </span>            :  * We need 8+2 bytes per xact.  Note that enlarging this struct might mean
<span class="lineNum">      54 </span>            :  * the largest possible file name is more than 5 chars long; see
<span class="lineNum">      55 </span>            :  * SlruScanDirectory.
<span class="lineNum">      56 </span>            :  */
<span class="lineNum">      57 </span>            : typedef struct CommitTimestampEntry
<span class="lineNum">      58 </span>            : {
<span class="lineNum">      59 </span>            :     TimestampTz time;
<span class="lineNum">      60 </span>            :     RepOriginId nodeid;
<span class="lineNum">      61 </span>            : } CommitTimestampEntry;
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : #define SizeOfCommitTimestampEntry (offsetof(CommitTimestampEntry, nodeid) + \
<span class="lineNum">      64 </span>            :                                     sizeof(RepOriginId))
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : #define COMMIT_TS_XACTS_PER_PAGE \
<span class="lineNum">      67 </span>            :     (BLCKSZ / SizeOfCommitTimestampEntry)
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : #define TransactionIdToCTsPage(xid) \
<span class="lineNum">      70 </span>            :     ((xid) / (TransactionId) COMMIT_TS_XACTS_PER_PAGE)
<span class="lineNum">      71 </span>            : #define TransactionIdToCTsEntry(xid)    \
<span class="lineNum">      72 </span>            :     ((xid) % (TransactionId) COMMIT_TS_XACTS_PER_PAGE)
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : /*
<span class="lineNum">      75 </span>            :  * Link to shared-memory data structures for CommitTs control
<span class="lineNum">      76 </span>            :  */
<span class="lineNum">      77 </span>            : static SlruCtlData CommitTsCtlData;
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : #define CommitTsCtl (&amp;CommitTsCtlData)
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : /*
<span class="lineNum">      82 </span>            :  * We keep a cache of the last value set in shared memory.
<span class="lineNum">      83 </span>            :  *
<span class="lineNum">      84 </span>            :  * This is also good place to keep the activation status.  We keep this
<span class="lineNum">      85 </span>            :  * separate from the GUC so that the standby can activate the module if the
<span class="lineNum">      86 </span>            :  * primary has it active independently of the value of the GUC.
<span class="lineNum">      87 </span>            :  *
<span class="lineNum">      88 </span>            :  * This is protected by CommitTsLock.  In some places, we use commitTsActive
<span class="lineNum">      89 </span>            :  * without acquiring the lock; where this happens, a comment explains the
<span class="lineNum">      90 </span>            :  * rationale for it.
<span class="lineNum">      91 </span>            :  */
<span class="lineNum">      92 </span>            : typedef struct CommitTimestampShared
<span class="lineNum">      93 </span>            : {
<span class="lineNum">      94 </span>            :     TransactionId xidLastCommit;
<span class="lineNum">      95 </span>            :     CommitTimestampEntry dataLastCommit;
<span class="lineNum">      96 </span>            :     bool        commitTsActive;
<span class="lineNum">      97 </span>            : } CommitTimestampShared;
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            : CommitTimestampShared *commitTsShared;
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : /* GUC variable */
<span class="lineNum">     103 </span>            : bool        track_commit_timestamp;
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : static void SetXidCommitTsInPage(TransactionId xid, int nsubxids,
<span class="lineNum">     106 </span>            :                                  TransactionId *subxids, TimestampTz ts,
<span class="lineNum">     107 </span>            :                                  RepOriginId nodeid, int pageno);
<span class="lineNum">     108 </span>            : static void TransactionIdSetCommitTs(TransactionId xid, TimestampTz ts,
<span class="lineNum">     109 </span>            :                                      RepOriginId nodeid, int slotno);
<span class="lineNum">     110 </span>            : static void error_commit_ts_disabled(void);
<span class="lineNum">     111 </span>            : static int  ZeroCommitTsPage(int pageno, bool writeXlog);
<span class="lineNum">     112 </span>            : static bool CommitTsPagePrecedes(int page1, int page2);
<span class="lineNum">     113 </span>            : static void ActivateCommitTs(void);
<span class="lineNum">     114 </span>            : static void DeactivateCommitTs(void);
<span class="lineNum">     115 </span>            : static void WriteZeroPageXlogRec(int pageno);
<span class="lineNum">     116 </span>            : static void WriteTruncateXlogRec(int pageno, TransactionId oldestXid);
<span class="lineNum">     117 </span>            : static void WriteSetTimestampXlogRec(TransactionId mainxid, int nsubxids,
<span class="lineNum">     118 </span>            :                                      TransactionId *subxids, TimestampTz timestamp,
<span class="lineNum">     119 </span>            :                                      RepOriginId nodeid);
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            : /*
<span class="lineNum">     122 </span>            :  * TransactionTreeSetCommitTsData
<span class="lineNum">     123 </span>            :  *
<span class="lineNum">     124 </span>            :  * Record the final commit timestamp of transaction entries in the commit log
<span class="lineNum">     125 </span>            :  * for a transaction and its subtransaction tree, as efficiently as possible.
<span class="lineNum">     126 </span>            :  *
<span class="lineNum">     127 </span>            :  * xid is the top level transaction id.
<span class="lineNum">     128 </span>            :  *
<span class="lineNum">     129 </span>            :  * subxids is an array of xids of length nsubxids, representing subtransactions
<span class="lineNum">     130 </span>            :  * in the tree of xid. In various cases nsubxids may be zero.
<span class="lineNum">     131 </span>            :  * The reason why tracking just the parent xid commit timestamp is not enough
<span class="lineNum">     132 </span>            :  * is that the subtrans SLRU does not stay valid across crashes (it's not
<span class="lineNum">     133 </span>            :  * permanent) so we need to keep the information about them here. If the
<span class="lineNum">     134 </span>            :  * subtrans implementation changes in the future, we might want to revisit the
<span class="lineNum">     135 </span>            :  * decision of storing timestamp info for each subxid.
<span class="lineNum">     136 </span>            :  *
<span class="lineNum">     137 </span>            :  * The write_xlog parameter tells us whether to include an XLog record of this
<span class="lineNum">     138 </span>            :  * or not.  Normally, this is called from transaction commit routines (both
<span class="lineNum">     139 </span>            :  * normal and prepared) and the information will be stored in the transaction
<span class="lineNum">     140 </span>            :  * commit XLog record, and so they should pass &quot;false&quot; for this.  The XLog redo
<span class="lineNum">     141 </span>            :  * code should use &quot;false&quot; here as well.  Other callers probably want to pass
<span class="lineNum">     142 </span>            :  * true, so that the given values persist in case of crashes.
<a name="143"><span class="lineNum">     143 </span>            :  */</a>
<span class="lineNum">     144 </span>            : void
<span class="lineNum">     145 </span><span class="lineCov">      26430 : TransactionTreeSetCommitTsData(TransactionId xid, int nsubxids,</span>
<span class="lineNum">     146 </span>            :                                TransactionId *subxids, TimestampTz timestamp,
<span class="lineNum">     147 </span>            :                                RepOriginId nodeid, bool write_xlog)
<span class="lineNum">     148 </span>            : {
<span class="lineNum">     149 </span>            :     int         i;
<span class="lineNum">     150 </span>            :     TransactionId headxid;
<span class="lineNum">     151 </span>            :     TransactionId newestXact;
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            :     /*
<span class="lineNum">     154 </span>            :      * No-op if the module is not active.
<span class="lineNum">     155 </span>            :      *
<span class="lineNum">     156 </span>            :      * An unlocked read here is fine, because in a standby (the only place
<span class="lineNum">     157 </span>            :      * where the flag can change in flight) this routine is only called by the
<span class="lineNum">     158 </span>            :      * recovery process, which is also the only process which can change the
<span class="lineNum">     159 </span>            :      * flag.
<span class="lineNum">     160 </span>            :      */
<span class="lineNum">     161 </span><span class="lineCov">      26430 :     if (!commitTsShared-&gt;commitTsActive)</span>
<span class="lineNum">     162 </span><span class="lineCov">      52860 :         return;</span>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :     /*
<span class="lineNum">     165 </span>            :      * Comply with the WAL-before-data rule: if caller specified it wants this
<span class="lineNum">     166 </span>            :      * value to be recorded in WAL, do so before touching the data.
<span class="lineNum">     167 </span>            :      */
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :     if (write_xlog)</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :         WriteSetTimestampXlogRec(xid, nsubxids, subxids, timestamp, nodeid);</span>
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            :     /*
<span class="lineNum">     172 </span>            :      * Figure out the latest Xid in this batch: either the last subxid if
<span class="lineNum">     173 </span>            :      * there's any, otherwise the parent xid.
<span class="lineNum">     174 </span>            :      */
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :     if (nsubxids &gt; 0)</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :         newestXact = subxids[nsubxids - 1];</span>
<span class="lineNum">     177 </span>            :     else
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :         newestXact = xid;</span>
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            :     /*
<span class="lineNum">     181 </span>            :      * We split the xids to set the timestamp to in groups belonging to the
<span class="lineNum">     182 </span>            :      * same SLRU page; the first element in each such set is its head.  The
<span class="lineNum">     183 </span>            :      * first group has the main XID as the head; subsequent sets use the first
<span class="lineNum">     184 </span>            :      * subxid not on the previous page as head.  This way, we only have to
<span class="lineNum">     185 </span>            :      * lock/modify each SLRU page once.
<span class="lineNum">     186 </span>            :      */
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     for (i = 0, headxid = xid;;)</span>
<span class="lineNum">     188 </span>            :     {
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :         int         pageno = TransactionIdToCTsPage(headxid);</span>
<span class="lineNum">     190 </span>            :         int         j;
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :         for (j = i; j &lt; nsubxids; j++)</span>
<span class="lineNum">     193 </span>            :         {
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :             if (TransactionIdToCTsPage(subxids[j]) != pageno)</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     196 </span>            :         }
<span class="lineNum">     197 </span>            :         /* subxids[i..j] are on the same page as the head */
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :         SetXidCommitTsInPage(headxid, j - i, subxids + i, timestamp, nodeid,</span>
<span class="lineNum">     200 </span>            :                              pageno);
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            :         /* if we wrote out all subxids, we're done. */
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :         if (j + 1 &gt;= nsubxids)</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :         /*
<span class="lineNum">     207 </span>            :          * Set the new head and skip over it, as well as over the subxids we
<span class="lineNum">     208 </span>            :          * just wrote.
<span class="lineNum">     209 </span>            :          */
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :         headxid = subxids[j];</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         i += j - i + 1;</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :     /* update the cached value in shared memory */
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :     LWLockAcquire(CommitTsLock, LW_EXCLUSIVE);</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     commitTsShared-&gt;xidLastCommit = xid;</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :     commitTsShared-&gt;dataLastCommit.time = timestamp;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     commitTsShared-&gt;dataLastCommit.nodeid = nodeid;</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :     /* and move forwards our endpoint, if needed */
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     if (TransactionIdPrecedes(ShmemVariableCache-&gt;newestCommitTsXid, newestXact))</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         ShmemVariableCache-&gt;newestCommitTsXid = newestXact;</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     LWLockRelease(CommitTsLock);</span>
<span class="lineNum">     224 </span>            : }
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            : /*
<span class="lineNum">     227 </span>            :  * Record the commit timestamp of transaction entries in the commit log for all
<span class="lineNum">     228 </span>            :  * entries on a single page.  Atomic only on this page.
<a name="229"><span class="lineNum">     229 </span>            :  */</a>
<span class="lineNum">     230 </span>            : static void
<span class="lineNum">     231 </span><span class="lineNoCov">          0 : SetXidCommitTsInPage(TransactionId xid, int nsubxids,</span>
<span class="lineNum">     232 </span>            :                      TransactionId *subxids, TimestampTz ts,
<span class="lineNum">     233 </span>            :                      RepOriginId nodeid, int pageno)
<span class="lineNum">     234 </span>            : {
<span class="lineNum">     235 </span>            :     int         slotno;
<span class="lineNum">     236 </span>            :     int         i;
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     LWLockAcquire(CommitTsControlLock, LW_EXCLUSIVE);</span>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :     slotno = SimpleLruReadPage(CommitTsCtl, pageno, true, xid);</span>
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     TransactionIdSetCommitTs(xid, ts, nodeid, slotno);</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; nsubxids; i++)</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :         TransactionIdSetCommitTs(subxids[i], ts, nodeid, slotno);</span>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :     CommitTsCtl-&gt;shared-&gt;page_dirty[slotno] = true;</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :     LWLockRelease(CommitTsControlLock);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            : /*
<span class="lineNum">     252 </span>            :  * Sets the commit timestamp of a single transaction.
<span class="lineNum">     253 </span>            :  *
<span class="lineNum">     254 </span>            :  * Must be called with CommitTsControlLock held
<a name="255"><span class="lineNum">     255 </span>            :  */</a>
<span class="lineNum">     256 </span>            : static void
<span class="lineNum">     257 </span><span class="lineNoCov">          0 : TransactionIdSetCommitTs(TransactionId xid, TimestampTz ts,</span>
<span class="lineNum">     258 </span>            :                          RepOriginId nodeid, int slotno)
<span class="lineNum">     259 </span>            : {
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     int         entryno = TransactionIdToCTsEntry(xid);</span>
<span class="lineNum">     261 </span>            :     CommitTimestampEntry entry;
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     Assert(TransactionIdIsNormal(xid));</span>
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :     entry.time = ts;</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     entry.nodeid = nodeid;</span>
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :     memcpy(CommitTsCtl-&gt;shared-&gt;page_buffer[slotno] +</span>
<span class="lineNum">     269 </span>            :            SizeOfCommitTimestampEntry * entryno,
<span class="lineNum">     270 </span>            :            &amp;entry, SizeOfCommitTimestampEntry);
<span class="lineNum">     271 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            : /*
<span class="lineNum">     274 </span>            :  * Interrogate the commit timestamp of a transaction.
<span class="lineNum">     275 </span>            :  *
<span class="lineNum">     276 </span>            :  * The return value indicates whether a commit timestamp record was found for
<span class="lineNum">     277 </span>            :  * the given xid.  The timestamp value is returned in *ts (which may not be
<span class="lineNum">     278 </span>            :  * null), and the origin node for the Xid is returned in *nodeid, if it's not
<span class="lineNum">     279 </span>            :  * null.
<a name="280"><span class="lineNum">     280 </span>            :  */</a>
<span class="lineNum">     281 </span>            : bool
<span class="lineNum">     282 </span><span class="lineNoCov">          0 : TransactionIdGetCommitTsData(TransactionId xid, TimestampTz *ts,</span>
<span class="lineNum">     283 </span>            :                              RepOriginId *nodeid)
<span class="lineNum">     284 </span>            : {
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     int         pageno = TransactionIdToCTsPage(xid);</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     int         entryno = TransactionIdToCTsEntry(xid);</span>
<span class="lineNum">     287 </span>            :     int         slotno;
<span class="lineNum">     288 </span>            :     CommitTimestampEntry entry;
<span class="lineNum">     289 </span>            :     TransactionId oldestCommitTsXid;
<span class="lineNum">     290 </span>            :     TransactionId newestCommitTsXid;
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     if (!TransactionIdIsValid(xid))</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">     294 </span>            :                 (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
<span class="lineNum">     295 </span>            :                  errmsg(&quot;cannot retrieve commit timestamp for transaction %u&quot;, xid)));
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     else if (!TransactionIdIsNormal(xid))</span>
<span class="lineNum">     297 </span>            :     {
<span class="lineNum">     298 </span>            :         /* frozen and bootstrap xids are always committed far in the past */
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         *ts = 0;</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :         if (nodeid)</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :             *nodeid = 0;</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     303 </span>            :     }
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     LWLockAcquire(CommitTsLock, LW_SHARED);</span>
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :     /* Error if module not enabled */
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     if (!commitTsShared-&gt;commitTsActive)</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :         error_commit_ts_disabled();</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :     /*
<span class="lineNum">     312 </span>            :      * If we're asked for the cached value, return that.  Otherwise, fall
<span class="lineNum">     313 </span>            :      * through to read from SLRU.
<span class="lineNum">     314 </span>            :      */
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     if (commitTsShared-&gt;xidLastCommit == xid)</span>
<span class="lineNum">     316 </span>            :     {
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :         *ts = commitTsShared-&gt;dataLastCommit.time;</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :         if (nodeid)</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :             *nodeid = commitTsShared-&gt;dataLastCommit.nodeid;</span>
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :         LWLockRelease(CommitTsLock);</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         return *ts != 0;</span>
<span class="lineNum">     323 </span>            :     }
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :     oldestCommitTsXid = ShmemVariableCache-&gt;oldestCommitTsXid;</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     newestCommitTsXid = ShmemVariableCache-&gt;newestCommitTsXid;</span>
<span class="lineNum">     327 </span>            :     /* neither is invalid, or both are */
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :     Assert(TransactionIdIsValid(oldestCommitTsXid) == TransactionIdIsValid(newestCommitTsXid));</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     LWLockRelease(CommitTsLock);</span>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            :     /*
<span class="lineNum">     332 </span>            :      * Return empty if the requested value is outside our valid range.
<span class="lineNum">     333 </span>            :      */
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :     if (!TransactionIdIsValid(oldestCommitTsXid) ||</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :         TransactionIdPrecedes(xid, oldestCommitTsXid) ||</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :         TransactionIdPrecedes(newestCommitTsXid, xid))</span>
<span class="lineNum">     337 </span>            :     {
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         *ts = 0;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :         if (nodeid)</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :             *nodeid = InvalidRepOriginId;</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     342 </span>            :     }
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            :     /* lock is acquired by SimpleLruReadPage_ReadOnly */
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     slotno = SimpleLruReadPage_ReadOnly(CommitTsCtl, pageno, xid);</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     memcpy(&amp;entry,</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :            CommitTsCtl-&gt;shared-&gt;page_buffer[slotno] +</span>
<span class="lineNum">     348 </span>            :            SizeOfCommitTimestampEntry * entryno,
<span class="lineNum">     349 </span>            :            SizeOfCommitTimestampEntry);
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     *ts = entry.time;</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :     if (nodeid)</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :         *nodeid = entry.nodeid;</span>
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     LWLockRelease(CommitTsControlLock);</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :     return *ts != 0;</span>
<span class="lineNum">     357 </span>            : }
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            : /*
<span class="lineNum">     360 </span>            :  * Return the Xid of the latest committed transaction.  (As far as this module
<span class="lineNum">     361 </span>            :  * is concerned, anyway; it's up to the caller to ensure the value is useful
<span class="lineNum">     362 </span>            :  * for its purposes.)
<span class="lineNum">     363 </span>            :  *
<span class="lineNum">     364 </span>            :  * ts and extra are filled with the corresponding data; they can be passed
<span class="lineNum">     365 </span>            :  * as NULL if not wanted.
<a name="366"><span class="lineNum">     366 </span>            :  */</a>
<span class="lineNum">     367 </span>            : TransactionId
<span class="lineNum">     368 </span><span class="lineNoCov">          0 : GetLatestCommitTsData(TimestampTz *ts, RepOriginId *nodeid)</span>
<span class="lineNum">     369 </span>            : {
<span class="lineNum">     370 </span>            :     TransactionId xid;
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :     LWLockAcquire(CommitTsLock, LW_SHARED);</span>
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            :     /* Error if module not enabled */
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     if (!commitTsShared-&gt;commitTsActive)</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         error_commit_ts_disabled();</span>
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     xid = commitTsShared-&gt;xidLastCommit;</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     if (ts)</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         *ts = commitTsShared-&gt;dataLastCommit.time;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     if (nodeid)</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :         *nodeid = commitTsShared-&gt;dataLastCommit.nodeid;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     LWLockRelease(CommitTsLock);</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :     return xid;</span>
<span class="lineNum">     386 </span>            : }
<a name="387"><span class="lineNum">     387 </span>            : </a>
<span class="lineNum">     388 </span>            : static void
<span class="lineNum">     389 </span><span class="lineNoCov">          0 : error_commit_ts_disabled(void)</span>
<span class="lineNum">     390 </span>            : {
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     ereport(ERROR,</span>
<span class="lineNum">     392 </span>            :             (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),
<span class="lineNum">     393 </span>            :              errmsg(&quot;could not get commit timestamp data&quot;),
<span class="lineNum">     394 </span>            :              RecoveryInProgress() ?
<span class="lineNum">     395 </span>            :              errhint(&quot;Make sure the configuration parameter \&quot;%s\&quot; is set on the master server.&quot;,
<span class="lineNum">     396 </span>            :                      &quot;track_commit_timestamp&quot;) :
<span class="lineNum">     397 </span>            :              errhint(&quot;Make sure the configuration parameter \&quot;%s\&quot; is set.&quot;,
<span class="lineNum">     398 </span>            :                      &quot;track_commit_timestamp&quot;)));
<span class="lineNum">     399 </span>            : }
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            : /*
<span class="lineNum">     402 </span>            :  * SQL-callable wrapper to obtain commit time of a transaction
<a name="403"><span class="lineNum">     403 </span>            :  */</a>
<span class="lineNum">     404 </span>            : Datum
<span class="lineNum">     405 </span><span class="lineNoCov">          0 : pg_xact_commit_timestamp(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     406 </span>            : {
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     TransactionId xid = PG_GETARG_UINT32(0);</span>
<span class="lineNum">     408 </span>            :     TimestampTz ts;
<span class="lineNum">     409 </span>            :     bool        found;
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :     found = TransactionIdGetCommitTsData(xid, &amp;ts, NULL);</span>
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     if (!found)</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :         PG_RETURN_NULL();</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     PG_RETURN_TIMESTAMPTZ(ts);</span>
<span class="lineNum">     417 </span>            : }
<span class="lineNum">     418 </span>            : 
<a name="419"><span class="lineNum">     419 </span>            : </a>
<span class="lineNum">     420 </span>            : Datum
<span class="lineNum">     421 </span><span class="lineNoCov">          0 : pg_last_committed_xact(PG_FUNCTION_ARGS)</span>
<span class="lineNum">     422 </span>            : {
<span class="lineNum">     423 </span>            :     TransactionId xid;
<span class="lineNum">     424 </span>            :     TimestampTz ts;
<span class="lineNum">     425 </span>            :     Datum       values[2];
<span class="lineNum">     426 </span>            :     bool        nulls[2];
<span class="lineNum">     427 </span>            :     TupleDesc   tupdesc;
<span class="lineNum">     428 </span>            :     HeapTuple   htup;
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :     /* and construct a tuple with our data */
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :     xid = GetLatestCommitTsData(&amp;ts, NULL);</span>
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            :     /*
<span class="lineNum">     434 </span>            :      * Construct a tuple descriptor for the result row.  This must match this
<span class="lineNum">     435 </span>            :      * function's pg_proc entry!
<span class="lineNum">     436 </span>            :      */
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :     tupdesc = CreateTemplateTupleDesc(2);</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     TupleDescInitEntry(tupdesc, (AttrNumber) 1, &quot;xid&quot;,</span>
<span class="lineNum">     439 </span>            :                        XIDOID, -1, 0);
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :     TupleDescInitEntry(tupdesc, (AttrNumber) 2, &quot;timestamp&quot;,</span>
<span class="lineNum">     441 </span>            :                        TIMESTAMPTZOID, -1, 0);
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :     tupdesc = BlessTupleDesc(tupdesc);</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     if (!TransactionIdIsNormal(xid))</span>
<span class="lineNum">     445 </span>            :     {
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :         memset(nulls, true, sizeof(nulls));</span>
<span class="lineNum">     447 </span>            :     }
<span class="lineNum">     448 </span>            :     else
<span class="lineNum">     449 </span>            :     {
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :         values[0] = TransactionIdGetDatum(xid);</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :         nulls[0] = false;</span>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :         values[1] = TimestampTzGetDatum(ts);</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :         nulls[1] = false;</span>
<span class="lineNum">     455 </span>            :     }
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     htup = heap_form_tuple(tupdesc, values, nulls);</span>
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     PG_RETURN_DATUM(HeapTupleGetDatum(htup));</span>
<span class="lineNum">     460 </span>            : }
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            : /*
<span class="lineNum">     464 </span>            :  * Number of shared CommitTS buffers.
<span class="lineNum">     465 </span>            :  *
<span class="lineNum">     466 </span>            :  * We use a very similar logic as for the number of CLOG buffers; see comments
<span class="lineNum">     467 </span>            :  * in CLOGShmemBuffers.
<a name="468"><span class="lineNum">     468 </span>            :  */</a>
<span class="lineNum">     469 </span>            : Size
<span class="lineNum">     470 </span><span class="lineCov">       2456 : CommitTsShmemBuffers(void)</span>
<span class="lineNum">     471 </span>            : {
<span class="lineNum">     472 </span><span class="lineCov">       2456 :     return Min(16, Max(4, NBuffers / 1024));</span>
<span class="lineNum">     473 </span>            : }
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            : /*
<span class="lineNum">     476 </span>            :  * Shared memory sizing for CommitTs
<a name="477"><span class="lineNum">     477 </span>            :  */</a>
<span class="lineNum">     478 </span>            : Size
<span class="lineNum">     479 </span><span class="lineCov">       1228 : CommitTsShmemSize(void)</span>
<span class="lineNum">     480 </span>            : {
<span class="lineNum">     481 </span><span class="lineCov">       1228 :     return SimpleLruShmemSize(CommitTsShmemBuffers(), 0) +</span>
<span class="lineNum">     482 </span>            :         sizeof(CommitTimestampShared);
<span class="lineNum">     483 </span>            : }
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            : /*
<span class="lineNum">     486 </span>            :  * Initialize CommitTs at system startup (postmaster start or standalone
<span class="lineNum">     487 </span>            :  * backend)
<a name="488"><span class="lineNum">     488 </span>            :  */</a>
<span class="lineNum">     489 </span>            : void
<span class="lineNum">     490 </span><span class="lineCov">       1228 : CommitTsShmemInit(void)</span>
<span class="lineNum">     491 </span>            : {
<span class="lineNum">     492 </span>            :     bool        found;
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span><span class="lineCov">       1228 :     CommitTsCtl-&gt;PagePrecedes = CommitTsPagePrecedes;</span>
<span class="lineNum">     495 </span><span class="lineCov">       1228 :     SimpleLruInit(CommitTsCtl, &quot;commit_timestamp&quot;, CommitTsShmemBuffers(), 0,</span>
<span class="lineNum">     496 </span><span class="lineCov">       1228 :                   CommitTsControlLock, &quot;pg_commit_ts&quot;,</span>
<span class="lineNum">     497 </span>            :                   LWTRANCHE_COMMITTS_BUFFERS);
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span><span class="lineCov">       1228 :     commitTsShared = ShmemInitStruct(&quot;CommitTs shared&quot;,</span>
<span class="lineNum">     500 </span>            :                                      sizeof(CommitTimestampShared),
<span class="lineNum">     501 </span>            :                                      &amp;found);
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span><span class="lineCov">       1228 :     if (!IsUnderPostmaster)</span>
<span class="lineNum">     504 </span>            :     {
<span class="lineNum">     505 </span><span class="lineCov">       1228 :         Assert(!found);</span>
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineCov">       1228 :         commitTsShared-&gt;xidLastCommit = InvalidTransactionId;</span>
<span class="lineNum">     508 </span><span class="lineCov">       1228 :         TIMESTAMP_NOBEGIN(commitTsShared-&gt;dataLastCommit.time);</span>
<span class="lineNum">     509 </span><span class="lineCov">       1228 :         commitTsShared-&gt;dataLastCommit.nodeid = InvalidRepOriginId;</span>
<span class="lineNum">     510 </span><span class="lineCov">       1228 :         commitTsShared-&gt;commitTsActive = false;</span>
<span class="lineNum">     511 </span>            :     }
<span class="lineNum">     512 </span>            :     else
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :         Assert(found);</span>
<span class="lineNum">     514 </span><span class="lineCov">       1228 : }</span>
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span>            : /*
<span class="lineNum">     517 </span>            :  * This function must be called ONCE on system install.
<span class="lineNum">     518 </span>            :  *
<span class="lineNum">     519 </span>            :  * (The CommitTs directory is assumed to have been created by initdb, and
<span class="lineNum">     520 </span>            :  * CommitTsShmemInit must have been called already.)
<a name="521"><span class="lineNum">     521 </span>            :  */</a>
<span class="lineNum">     522 </span>            : void
<span class="lineNum">     523 </span><span class="lineCov">          2 : BootStrapCommitTs(void)</span>
<span class="lineNum">     524 </span>            : {
<span class="lineNum">     525 </span>            :     /*
<span class="lineNum">     526 </span>            :      * Nothing to do here at present, unlike most other SLRU modules; segments
<span class="lineNum">     527 </span>            :      * are created when the server is started with this module enabled. See
<span class="lineNum">     528 </span>            :      * ActivateCommitTs.
<span class="lineNum">     529 </span>            :      */
<span class="lineNum">     530 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            : /*
<span class="lineNum">     533 </span>            :  * Initialize (or reinitialize) a page of CommitTs to zeroes.
<span class="lineNum">     534 </span>            :  * If writeXlog is true, also emit an XLOG record saying we did this.
<span class="lineNum">     535 </span>            :  *
<span class="lineNum">     536 </span>            :  * The page is not actually written, just set up in shared memory.
<span class="lineNum">     537 </span>            :  * The slot number of the new page is returned.
<span class="lineNum">     538 </span>            :  *
<span class="lineNum">     539 </span>            :  * Control lock must be held at entry, and will be held at exit.
<a name="540"><span class="lineNum">     540 </span>            :  */</a>
<span class="lineNum">     541 </span>            : static int
<span class="lineNum">     542 </span><span class="lineNoCov">          0 : ZeroCommitTsPage(int pageno, bool writeXlog)</span>
<span class="lineNum">     543 </span>            : {
<span class="lineNum">     544 </span>            :     int         slotno;
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     slotno = SimpleLruZeroPage(CommitTsCtl, pageno);</span>
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :     if (writeXlog)</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :         WriteZeroPageXlogRec(pageno);</span>
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     return slotno;</span>
<span class="lineNum">     552 </span>            : }
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            : /*
<span class="lineNum">     555 </span>            :  * This must be called ONCE during postmaster or standalone-backend startup,
<span class="lineNum">     556 </span>            :  * after StartupXLOG has initialized ShmemVariableCache-&gt;nextFullXid.
<a name="557"><span class="lineNum">     557 </span>            :  */</a>
<span class="lineNum">     558 </span>            : void
<span class="lineNum">     559 </span><span class="lineNoCov">          0 : StartupCommitTs(void)</span>
<span class="lineNum">     560 </span>            : {
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :     ActivateCommitTs();</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            : /*
<span class="lineNum">     565 </span>            :  * This must be called ONCE during postmaster or standalone-backend startup,
<span class="lineNum">     566 </span>            :  * after recovery has finished.
<a name="567"><span class="lineNum">     567 </span>            :  */</a>
<span class="lineNum">     568 </span>            : void
<span class="lineNum">     569 </span><span class="lineCov">          6 : CompleteCommitTsInitialization(void)</span>
<span class="lineNum">     570 </span>            : {
<span class="lineNum">     571 </span>            :     /*
<span class="lineNum">     572 </span>            :      * If the feature is not enabled, turn it off for good.  This also removes
<span class="lineNum">     573 </span>            :      * any leftover data.
<span class="lineNum">     574 </span>            :      *
<span class="lineNum">     575 </span>            :      * Conversely, we activate the module if the feature is enabled.  This is
<span class="lineNum">     576 </span>            :      * necessary for primary and standby as the activation depends on the
<span class="lineNum">     577 </span>            :      * control file contents at the beginning of recovery or when a
<span class="lineNum">     578 </span>            :      * XLOG_PARAMETER_CHANGE is replayed.
<span class="lineNum">     579 </span>            :      */
<span class="lineNum">     580 </span><span class="lineCov">          6 :     if (!track_commit_timestamp)</span>
<span class="lineNum">     581 </span><span class="lineCov">          6 :         DeactivateCommitTs();</span>
<span class="lineNum">     582 </span>            :     else
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :         ActivateCommitTs();</span>
<span class="lineNum">     584 </span><span class="lineCov">          6 : }</span>
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            : /*
<span class="lineNum">     587 </span>            :  * Activate or deactivate CommitTs' upon reception of a XLOG_PARAMETER_CHANGE
<span class="lineNum">     588 </span>            :  * XLog record during recovery.
<a name="589"><span class="lineNum">     589 </span>            :  */</a>
<span class="lineNum">     590 </span>            : void
<span class="lineNum">     591 </span><span class="lineNoCov">          0 : CommitTsParameterChange(bool newvalue, bool oldvalue)</span>
<span class="lineNum">     592 </span>            : {
<span class="lineNum">     593 </span>            :     /*
<span class="lineNum">     594 </span>            :      * If the commit_ts module is disabled in this server and we get word from
<span class="lineNum">     595 </span>            :      * the master server that it is enabled there, activate it so that we can
<span class="lineNum">     596 </span>            :      * replay future WAL records involving it; also mark it as active on
<span class="lineNum">     597 </span>            :      * pg_control.  If the old value was already set, we already did this, so
<span class="lineNum">     598 </span>            :      * don't do anything.
<span class="lineNum">     599 </span>            :      *
<span class="lineNum">     600 </span>            :      * If the module is disabled in the master, disable it here too, unless
<span class="lineNum">     601 </span>            :      * the module is enabled locally.
<span class="lineNum">     602 </span>            :      *
<span class="lineNum">     603 </span>            :      * Note this only runs in the recovery process, so an unlocked read is
<span class="lineNum">     604 </span>            :      * fine.
<span class="lineNum">     605 </span>            :      */
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     if (newvalue)</span>
<span class="lineNum">     607 </span>            :     {
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :         if (!commitTsShared-&gt;commitTsActive)</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :             ActivateCommitTs();</span>
<span class="lineNum">     610 </span>            :     }
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :     else if (commitTsShared-&gt;commitTsActive)</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :         DeactivateCommitTs();</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span>            : /*
<span class="lineNum">     616 </span>            :  * Activate this module whenever necessary.
<span class="lineNum">     617 </span>            :  *      This must happen during postmaster or standalone-backend startup,
<span class="lineNum">     618 </span>            :  *      or during WAL replay anytime the track_commit_timestamp setting is
<span class="lineNum">     619 </span>            :  *      changed in the master.
<span class="lineNum">     620 </span>            :  *
<span class="lineNum">     621 </span>            :  * The reason why this SLRU needs separate activation/deactivation functions is
<span class="lineNum">     622 </span>            :  * that it can be enabled/disabled during start and the activation/deactivation
<span class="lineNum">     623 </span>            :  * on master is propagated to standby via replay. Other SLRUs don't have this
<span class="lineNum">     624 </span>            :  * property and they can be just initialized during normal startup.
<span class="lineNum">     625 </span>            :  *
<span class="lineNum">     626 </span>            :  * This is in charge of creating the currently active segment, if it's not
<span class="lineNum">     627 </span>            :  * already there.  The reason for this is that the server might have been
<span class="lineNum">     628 </span>            :  * running with this module disabled for a while and thus might have skipped
<span class="lineNum">     629 </span>            :  * the normal creation point.
<a name="630"><span class="lineNum">     630 </span>            :  */</a>
<span class="lineNum">     631 </span>            : static void
<span class="lineNum">     632 </span><span class="lineNoCov">          0 : ActivateCommitTs(void)</span>
<span class="lineNum">     633 </span>            : {
<span class="lineNum">     634 </span>            :     TransactionId xid;
<span class="lineNum">     635 </span>            :     int         pageno;
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :     /* If we've done this already, there's nothing to do */
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :     LWLockAcquire(CommitTsLock, LW_EXCLUSIVE);</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :     if (commitTsShared-&gt;commitTsActive)</span>
<span class="lineNum">     640 </span>            :     {
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :         LWLockRelease(CommitTsLock);</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     643 </span>            :     }
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     LWLockRelease(CommitTsLock);</span>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :     xid = XidFromFullTransactionId(ShmemVariableCache-&gt;nextFullXid);</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     pageno = TransactionIdToCTsPage(xid);</span>
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span>            :     /*
<span class="lineNum">     650 </span>            :      * Re-Initialize our idea of the latest page number.
<span class="lineNum">     651 </span>            :      */
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :     LWLockAcquire(CommitTsControlLock, LW_EXCLUSIVE);</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     CommitTsCtl-&gt;shared-&gt;latest_page_number = pageno;</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     LWLockRelease(CommitTsControlLock);</span>
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :     /*
<span class="lineNum">     657 </span>            :      * If CommitTs is enabled, but it wasn't in the previous server run, we
<span class="lineNum">     658 </span>            :      * need to set the oldest and newest values to the next Xid; that way, we
<span class="lineNum">     659 </span>            :      * will not try to read data that might not have been set.
<span class="lineNum">     660 </span>            :      *
<span class="lineNum">     661 </span>            :      * XXX does this have a problem if a server is started with commitTs
<span class="lineNum">     662 </span>            :      * enabled, then started with commitTs disabled, then restarted with it
<span class="lineNum">     663 </span>            :      * enabled again?  It doesn't look like it does, because there should be a
<span class="lineNum">     664 </span>            :      * checkpoint that sets the value to InvalidTransactionId at end of
<span class="lineNum">     665 </span>            :      * recovery; and so any chance of injecting new transactions without
<span class="lineNum">     666 </span>            :      * CommitTs values would occur after the oldestCommitTsXid has been set to
<span class="lineNum">     667 </span>            :      * Invalid temporarily.
<span class="lineNum">     668 </span>            :      */
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :     LWLockAcquire(CommitTsLock, LW_EXCLUSIVE);</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     if (ShmemVariableCache-&gt;oldestCommitTsXid == InvalidTransactionId)</span>
<span class="lineNum">     671 </span>            :     {
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :         ShmemVariableCache-&gt;oldestCommitTsXid =</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :             ShmemVariableCache-&gt;newestCommitTsXid = ReadNewTransactionId();</span>
<span class="lineNum">     674 </span>            :     }
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :     LWLockRelease(CommitTsLock);</span>
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            :     /* Create the current segment file, if necessary */
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     if (!SimpleLruDoesPhysicalPageExist(CommitTsCtl, pageno))</span>
<span class="lineNum">     679 </span>            :     {
<span class="lineNum">     680 </span>            :         int         slotno;
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :         LWLockAcquire(CommitTsControlLock, LW_EXCLUSIVE);</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :         slotno = ZeroCommitTsPage(pageno, false);</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :         SimpleLruWritePage(CommitTsCtl, slotno);</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :         Assert(!CommitTsCtl-&gt;shared-&gt;page_dirty[slotno]);</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :         LWLockRelease(CommitTsControlLock);</span>
<span class="lineNum">     687 </span>            :     }
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            :     /* Change the activation status in shared memory. */
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     LWLockAcquire(CommitTsLock, LW_EXCLUSIVE);</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :     commitTsShared-&gt;commitTsActive = true;</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :     LWLockRelease(CommitTsLock);</span>
<span class="lineNum">     693 </span>            : }
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            : /*
<span class="lineNum">     696 </span>            :  * Deactivate this module.
<span class="lineNum">     697 </span>            :  *
<span class="lineNum">     698 </span>            :  * This must be called when the track_commit_timestamp parameter is turned off.
<span class="lineNum">     699 </span>            :  * This happens during postmaster or standalone-backend startup, or during WAL
<span class="lineNum">     700 </span>            :  * replay.
<span class="lineNum">     701 </span>            :  *
<span class="lineNum">     702 </span>            :  * Resets CommitTs into invalid state to make sure we don't hand back
<span class="lineNum">     703 </span>            :  * possibly-invalid data; also removes segments of old data.
<a name="704"><span class="lineNum">     704 </span>            :  */</a>
<span class="lineNum">     705 </span>            : static void
<span class="lineNum">     706 </span><span class="lineCov">          6 : DeactivateCommitTs(void)</span>
<span class="lineNum">     707 </span>            : {
<span class="lineNum">     708 </span>            :     /*
<span class="lineNum">     709 </span>            :      * Cleanup the status in the shared memory.
<span class="lineNum">     710 </span>            :      *
<span class="lineNum">     711 </span>            :      * We reset everything in the commitTsShared record to prevent user from
<span class="lineNum">     712 </span>            :      * getting confusing data about last committed transaction on the standby
<span class="lineNum">     713 </span>            :      * when the module was activated repeatedly on the primary.
<span class="lineNum">     714 </span>            :      */
<span class="lineNum">     715 </span><span class="lineCov">          6 :     LWLockAcquire(CommitTsLock, LW_EXCLUSIVE);</span>
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span><span class="lineCov">          6 :     commitTsShared-&gt;commitTsActive = false;</span>
<span class="lineNum">     718 </span><span class="lineCov">          6 :     commitTsShared-&gt;xidLastCommit = InvalidTransactionId;</span>
<span class="lineNum">     719 </span><span class="lineCov">          6 :     TIMESTAMP_NOBEGIN(commitTsShared-&gt;dataLastCommit.time);</span>
<span class="lineNum">     720 </span><span class="lineCov">          6 :     commitTsShared-&gt;dataLastCommit.nodeid = InvalidRepOriginId;</span>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span><span class="lineCov">          6 :     ShmemVariableCache-&gt;oldestCommitTsXid = InvalidTransactionId;</span>
<span class="lineNum">     723 </span><span class="lineCov">          6 :     ShmemVariableCache-&gt;newestCommitTsXid = InvalidTransactionId;</span>
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span><span class="lineCov">          6 :     LWLockRelease(CommitTsLock);</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            :     /*
<span class="lineNum">     728 </span>            :      * Remove *all* files.  This is necessary so that there are no leftover
<span class="lineNum">     729 </span>            :      * files; in the case where this feature is later enabled after running
<span class="lineNum">     730 </span>            :      * with it disabled for some time there may be a gap in the file sequence.
<span class="lineNum">     731 </span>            :      * (We can probably tolerate out-of-sequence files, as they are going to
<span class="lineNum">     732 </span>            :      * be overwritten anyway when we wrap around, but it seems better to be
<span class="lineNum">     733 </span>            :      * tidy.)
<span class="lineNum">     734 </span>            :      */
<span class="lineNum">     735 </span><span class="lineCov">          6 :     LWLockAcquire(CommitTsControlLock, LW_EXCLUSIVE);</span>
<span class="lineNum">     736 </span><span class="lineCov">          6 :     (void) SlruScanDirectory(CommitTsCtl, SlruScanDirCbDeleteAll, NULL);</span>
<span class="lineNum">     737 </span><span class="lineCov">          6 :     LWLockRelease(CommitTsControlLock);</span>
<span class="lineNum">     738 </span><span class="lineCov">          6 : }</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            : /*
<span class="lineNum">     741 </span>            :  * This must be called ONCE during postmaster or standalone-backend shutdown
<a name="742"><span class="lineNum">     742 </span>            :  */</a>
<span class="lineNum">     743 </span>            : void
<span class="lineNum">     744 </span><span class="lineCov">          6 : ShutdownCommitTs(void)</span>
<span class="lineNum">     745 </span>            : {
<span class="lineNum">     746 </span>            :     /* Flush dirty CommitTs pages to disk */
<span class="lineNum">     747 </span><span class="lineCov">          6 :     SimpleLruFlush(CommitTsCtl, false);</span>
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span>            :     /*
<span class="lineNum">     750 </span>            :      * fsync pg_commit_ts to ensure that any files flushed previously are
<span class="lineNum">     751 </span>            :      * durably on disk.
<span class="lineNum">     752 </span>            :      */
<span class="lineNum">     753 </span><span class="lineCov">          6 :     fsync_fname(&quot;pg_commit_ts&quot;, true);</span>
<span class="lineNum">     754 </span><span class="lineCov">          6 : }</span>
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span>            : /*
<span class="lineNum">     757 </span>            :  * Perform a checkpoint --- either during shutdown, or on-the-fly
<a name="758"><span class="lineNum">     758 </span>            :  */</a>
<span class="lineNum">     759 </span>            : void
<span class="lineNum">     760 </span><span class="lineCov">         22 : CheckPointCommitTs(void)</span>
<span class="lineNum">     761 </span>            : {
<span class="lineNum">     762 </span>            :     /* Flush dirty CommitTs pages to disk */
<span class="lineNum">     763 </span><span class="lineCov">         22 :     SimpleLruFlush(CommitTsCtl, true);</span>
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            :     /*
<span class="lineNum">     766 </span>            :      * fsync pg_commit_ts to ensure that any files flushed previously are
<span class="lineNum">     767 </span>            :      * durably on disk.
<span class="lineNum">     768 </span>            :      */
<span class="lineNum">     769 </span><span class="lineCov">         22 :     fsync_fname(&quot;pg_commit_ts&quot;, true);</span>
<span class="lineNum">     770 </span><span class="lineCov">         22 : }</span>
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            : /*
<span class="lineNum">     773 </span>            :  * Make sure that CommitTs has room for a newly-allocated XID.
<span class="lineNum">     774 </span>            :  *
<span class="lineNum">     775 </span>            :  * NB: this is called while holding XidGenLock.  We want it to be very fast
<span class="lineNum">     776 </span>            :  * most of the time; even when it's not so fast, no actual I/O need happen
<span class="lineNum">     777 </span>            :  * unless we're forced to write out a dirty CommitTs or xlog page to make room
<span class="lineNum">     778 </span>            :  * in shared memory.
<span class="lineNum">     779 </span>            :  *
<span class="lineNum">     780 </span>            :  * NB: the current implementation relies on track_commit_timestamp being
<span class="lineNum">     781 </span>            :  * PGC_POSTMASTER.
<a name="782"><span class="lineNum">     782 </span>            :  */</a>
<span class="lineNum">     783 </span>            : void
<span class="lineNum">     784 </span><span class="lineCov">      28800 : ExtendCommitTs(TransactionId newestXact)</span>
<span class="lineNum">     785 </span>            : {
<span class="lineNum">     786 </span>            :     int         pageno;
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span>            :     /*
<span class="lineNum">     789 </span>            :      * Nothing to do if module not enabled.  Note we do an unlocked read of
<span class="lineNum">     790 </span>            :      * the flag here, which is okay because this routine is only called from
<span class="lineNum">     791 </span>            :      * GetNewTransactionId, which is never called in a standby.
<span class="lineNum">     792 </span>            :      */
<span class="lineNum">     793 </span><span class="lineCov">      28800 :     Assert(!InRecovery);</span>
<span class="lineNum">     794 </span><span class="lineCov">      28800 :     if (!commitTsShared-&gt;commitTsActive)</span>
<span class="lineNum">     795 </span><span class="lineCov">      28800 :         return;</span>
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :     /*
<span class="lineNum">     798 </span>            :      * No work except at first XID of a page.  But beware: just after
<span class="lineNum">     799 </span>            :      * wraparound, the first XID of page zero is FirstNormalTransactionId.
<span class="lineNum">     800 </span>            :      */
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :     if (TransactionIdToCTsEntry(newestXact) != 0 &amp;&amp;</span>
<span class="lineNum">     802 </span>            :         !TransactionIdEquals(newestXact, FirstNormalTransactionId))
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :     pageno = TransactionIdToCTsPage(newestXact);</span>
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     LWLockAcquire(CommitTsControlLock, LW_EXCLUSIVE);</span>
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :     /* Zero the page and make an XLOG entry about it */
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     ZeroCommitTsPage(pageno, !InRecovery);</span>
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :     LWLockRelease(CommitTsControlLock);</span>
<span class="lineNum">     813 </span>            : }
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            : /*
<span class="lineNum">     816 </span>            :  * Remove all CommitTs segments before the one holding the passed
<span class="lineNum">     817 </span>            :  * transaction ID.
<span class="lineNum">     818 </span>            :  *
<span class="lineNum">     819 </span>            :  * Note that we don't need to flush XLOG here.
<a name="820"><span class="lineNum">     820 </span>            :  */</a>
<span class="lineNum">     821 </span>            : void
<span class="lineNum">     822 </span><span class="lineCov">          4 : TruncateCommitTs(TransactionId oldestXact)</span>
<span class="lineNum">     823 </span>            : {
<span class="lineNum">     824 </span>            :     int         cutoffPage;
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span>            :     /*
<span class="lineNum">     827 </span>            :      * The cutoff point is the start of the segment containing oldestXact. We
<span class="lineNum">     828 </span>            :      * pass the *page* containing oldestXact to SimpleLruTruncate.
<span class="lineNum">     829 </span>            :      */
<span class="lineNum">     830 </span><span class="lineCov">          4 :     cutoffPage = TransactionIdToCTsPage(oldestXact);</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :     /* Check to see if there's any files that could be removed */
<span class="lineNum">     833 </span><span class="lineCov">          4 :     if (!SlruScanDirectory(CommitTsCtl, SlruScanDirCbReportPresence,</span>
<span class="lineNum">     834 </span>            :                            &amp;cutoffPage))
<span class="lineNum">     835 </span><span class="lineCov">          8 :         return;                 /* nothing to remove */</span>
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span>            :     /* Write XLOG record */
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :     WriteTruncateXlogRec(cutoffPage, oldestXact);</span>
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span>            :     /* Now we can remove the old CommitTs segment(s) */
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :     SimpleLruTruncate(CommitTsCtl, cutoffPage);</span>
<span class="lineNum">     842 </span>            : }
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            : /*
<span class="lineNum">     845 </span>            :  * Set the limit values between which commit TS can be consulted.
<a name="846"><span class="lineNum">     846 </span>            :  */</a>
<span class="lineNum">     847 </span>            : void
<span class="lineNum">     848 </span><span class="lineCov">          8 : SetCommitTsLimit(TransactionId oldestXact, TransactionId newestXact)</span>
<span class="lineNum">     849 </span>            : {
<span class="lineNum">     850 </span>            :     /*
<span class="lineNum">     851 </span>            :      * Be careful not to overwrite values that are either further into the
<span class="lineNum">     852 </span>            :      * &quot;future&quot; or signal a disabled committs.
<span class="lineNum">     853 </span>            :      */
<span class="lineNum">     854 </span><span class="lineCov">          8 :     LWLockAcquire(CommitTsLock, LW_EXCLUSIVE);</span>
<span class="lineNum">     855 </span><span class="lineCov">          8 :     if (ShmemVariableCache-&gt;oldestCommitTsXid != InvalidTransactionId)</span>
<span class="lineNum">     856 </span>            :     {
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :         if (TransactionIdPrecedes(ShmemVariableCache-&gt;oldestCommitTsXid, oldestXact))</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :             ShmemVariableCache-&gt;oldestCommitTsXid = oldestXact;</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :         if (TransactionIdPrecedes(newestXact, ShmemVariableCache-&gt;newestCommitTsXid))</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :             ShmemVariableCache-&gt;newestCommitTsXid = newestXact;</span>
<span class="lineNum">     861 </span>            :     }
<span class="lineNum">     862 </span>            :     else
<span class="lineNum">     863 </span>            :     {
<span class="lineNum">     864 </span><span class="lineCov">          8 :         Assert(ShmemVariableCache-&gt;newestCommitTsXid == InvalidTransactionId);</span>
<span class="lineNum">     865 </span><span class="lineCov">          8 :         ShmemVariableCache-&gt;oldestCommitTsXid = oldestXact;</span>
<span class="lineNum">     866 </span><span class="lineCov">          8 :         ShmemVariableCache-&gt;newestCommitTsXid = newestXact;</span>
<span class="lineNum">     867 </span>            :     }
<span class="lineNum">     868 </span><span class="lineCov">          8 :     LWLockRelease(CommitTsLock);</span>
<span class="lineNum">     869 </span><span class="lineCov">          8 : }</span>
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            : /*
<span class="lineNum">     872 </span>            :  * Move forwards the oldest commitTS value that can be consulted
<a name="873"><span class="lineNum">     873 </span>            :  */</a>
<span class="lineNum">     874 </span>            : void
<span class="lineNum">     875 </span><span class="lineCov">          4 : AdvanceOldestCommitTsXid(TransactionId oldestXact)</span>
<span class="lineNum">     876 </span>            : {
<span class="lineNum">     877 </span><span class="lineCov">          4 :     LWLockAcquire(CommitTsLock, LW_EXCLUSIVE);</span>
<span class="lineNum">     878 </span><span class="lineCov">          4 :     if (ShmemVariableCache-&gt;oldestCommitTsXid != InvalidTransactionId &amp;&amp;</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :         TransactionIdPrecedes(ShmemVariableCache-&gt;oldestCommitTsXid, oldestXact))</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :         ShmemVariableCache-&gt;oldestCommitTsXid = oldestXact;</span>
<span class="lineNum">     881 </span><span class="lineCov">          4 :     LWLockRelease(CommitTsLock);</span>
<span class="lineNum">     882 </span><span class="lineCov">          4 : }</span>
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            : /*
<span class="lineNum">     886 </span>            :  * Decide which of two commitTS page numbers is &quot;older&quot; for truncation
<span class="lineNum">     887 </span>            :  * purposes.
<span class="lineNum">     888 </span>            :  *
<span class="lineNum">     889 </span>            :  * We need to use comparison of TransactionIds here in order to do the right
<span class="lineNum">     890 </span>            :  * thing with wraparound XID arithmetic.  However, if we are asked about
<span class="lineNum">     891 </span>            :  * page number zero, we don't want to hand InvalidTransactionId to
<span class="lineNum">     892 </span>            :  * TransactionIdPrecedes: it'll get weird about permanent xact IDs.  So,
<span class="lineNum">     893 </span>            :  * offset both xids by FirstNormalTransactionId to avoid that.
<a name="894"><span class="lineNum">     894 </span>            :  */</a>
<span class="lineNum">     895 </span>            : static bool
<span class="lineNum">     896 </span><span class="lineNoCov">          0 : CommitTsPagePrecedes(int page1, int page2)</span>
<span class="lineNum">     897 </span>            : {
<span class="lineNum">     898 </span>            :     TransactionId xid1;
<span class="lineNum">     899 </span>            :     TransactionId xid2;
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     xid1 = ((TransactionId) page1) * COMMIT_TS_XACTS_PER_PAGE;</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :     xid1 += FirstNormalTransactionId;</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :     xid2 = ((TransactionId) page2) * COMMIT_TS_XACTS_PER_PAGE;</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :     xid2 += FirstNormalTransactionId;</span>
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     return TransactionIdPrecedes(xid1, xid2);</span>
<span class="lineNum">     907 </span>            : }
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span>            : /*
<span class="lineNum">     911 </span>            :  * Write a ZEROPAGE xlog record
<a name="912"><span class="lineNum">     912 </span>            :  */</a>
<span class="lineNum">     913 </span>            : static void
<span class="lineNum">     914 </span><span class="lineNoCov">          0 : WriteZeroPageXlogRec(int pageno)</span>
<span class="lineNum">     915 </span>            : {
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :     XLogBeginInsert();</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :     XLogRegisterData((char *) (&amp;pageno), sizeof(int));</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :     (void) XLogInsert(RM_COMMIT_TS_ID, COMMIT_TS_ZEROPAGE);</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span>            : /*
<span class="lineNum">     922 </span>            :  * Write a TRUNCATE xlog record
<a name="923"><span class="lineNum">     923 </span>            :  */</a>
<span class="lineNum">     924 </span>            : static void
<span class="lineNum">     925 </span><span class="lineNoCov">          0 : WriteTruncateXlogRec(int pageno, TransactionId oldestXid)</span>
<span class="lineNum">     926 </span>            : {
<span class="lineNum">     927 </span>            :     xl_commit_ts_truncate xlrec;
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :     xlrec.pageno = pageno;</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :     xlrec.oldestXid = oldestXid;</span>
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :     XLogBeginInsert();</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :     XLogRegisterData((char *) (&amp;xlrec), SizeOfCommitTsTruncate);</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :     (void) XLogInsert(RM_COMMIT_TS_ID, COMMIT_TS_TRUNCATE);</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span>            : /*
<span class="lineNum">     938 </span>            :  * Write a SETTS xlog record
<a name="939"><span class="lineNum">     939 </span>            :  */</a>
<span class="lineNum">     940 </span>            : static void
<span class="lineNum">     941 </span><span class="lineNoCov">          0 : WriteSetTimestampXlogRec(TransactionId mainxid, int nsubxids,</span>
<span class="lineNum">     942 </span>            :                          TransactionId *subxids, TimestampTz timestamp,
<span class="lineNum">     943 </span>            :                          RepOriginId nodeid)
<span class="lineNum">     944 </span>            : {
<span class="lineNum">     945 </span>            :     xl_commit_ts_set record;
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     record.timestamp = timestamp;</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :     record.nodeid = nodeid;</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     record.mainxid = mainxid;</span>
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :     XLogBeginInsert();</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     XLogRegisterData((char *) &amp;record,</span>
<span class="lineNum">     953 </span>            :                      offsetof(xl_commit_ts_set, mainxid) +
<span class="lineNum">     954 </span>            :                      sizeof(TransactionId));
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     XLogRegisterData((char *) subxids, nsubxids * sizeof(TransactionId));</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :     XLogInsert(RM_COMMIT_TS_ID, COMMIT_TS_SETTS);</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            : /*
<span class="lineNum">     960 </span>            :  * CommitTS resource manager's routines
<a name="961"><span class="lineNum">     961 </span>            :  */</a>
<span class="lineNum">     962 </span>            : void
<span class="lineNum">     963 </span><span class="lineNoCov">          0 : commit_ts_redo(XLogReaderState *record)</span>
<span class="lineNum">     964 </span>            : {
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :     uint8       info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;</span>
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            :     /* Backup blocks are not used in commit_ts records */
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :     Assert(!XLogRecHasAnyBlockRefs(record));</span>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :     if (info == COMMIT_TS_ZEROPAGE)</span>
<span class="lineNum">     971 </span>            :     {
<span class="lineNum">     972 </span>            :         int         pageno;
<span class="lineNum">     973 </span>            :         int         slotno;
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :         memcpy(&amp;pageno, XLogRecGetData(record), sizeof(int));</span>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :         LWLockAcquire(CommitTsControlLock, LW_EXCLUSIVE);</span>
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :         slotno = ZeroCommitTsPage(pageno, false);</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :         SimpleLruWritePage(CommitTsCtl, slotno);</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :         Assert(!CommitTsCtl-&gt;shared-&gt;page_dirty[slotno]);</span>
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :         LWLockRelease(CommitTsControlLock);</span>
<span class="lineNum">     984 </span>            :     }
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :     else if (info == COMMIT_TS_TRUNCATE)</span>
<span class="lineNum">     986 </span>            :     {
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :         xl_commit_ts_truncate *trunc = (xl_commit_ts_truncate *) XLogRecGetData(record);</span>
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :         AdvanceOldestCommitTsXid(trunc-&gt;oldestXid);</span>
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            :         /*
<span class="lineNum">     992 </span>            :          * During XLOG replay, latest_page_number isn't set up yet; insert a
<span class="lineNum">     993 </span>            :          * suitable value to bypass the sanity test in SimpleLruTruncate.
<span class="lineNum">     994 </span>            :          */
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :         CommitTsCtl-&gt;shared-&gt;latest_page_number = trunc-&gt;pageno;</span>
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :         SimpleLruTruncate(CommitTsCtl, trunc-&gt;pageno);</span>
<span class="lineNum">     998 </span>            :     }
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :     else if (info == COMMIT_TS_SETTS)</span>
<span class="lineNum">    1000 </span>            :     {
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :         xl_commit_ts_set *setts = (xl_commit_ts_set *) XLogRecGetData(record);</span>
<span class="lineNum">    1002 </span>            :         int         nsubxids;
<span class="lineNum">    1003 </span>            :         TransactionId *subxids;
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :         nsubxids = ((XLogRecGetDataLen(record) - SizeOfCommitTsSet) /</span>
<span class="lineNum">    1006 </span>            :                     sizeof(TransactionId));
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :         if (nsubxids &gt; 0)</span>
<span class="lineNum">    1008 </span>            :         {
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :             subxids = palloc(sizeof(TransactionId) * nsubxids);</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :             memcpy(subxids,</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :                    XLogRecGetData(record) + SizeOfCommitTsSet,</span>
<span class="lineNum">    1012 </span>            :                    sizeof(TransactionId) * nsubxids);
<span class="lineNum">    1013 </span>            :         }
<span class="lineNum">    1014 </span>            :         else
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :             subxids = NULL;</span>
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :         TransactionTreeSetCommitTsData(setts-&gt;mainxid, nsubxids, subxids,</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :                                        setts-&gt;timestamp, setts-&gt;nodeid, true);</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :         if (subxids)</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :             pfree(subxids);</span>
<span class="lineNum">    1021 </span>            :     }
<span class="lineNum">    1022 </span>            :     else
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :         elog(PANIC, &quot;commit_ts_redo: unknown op code %u&quot;, info);</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
