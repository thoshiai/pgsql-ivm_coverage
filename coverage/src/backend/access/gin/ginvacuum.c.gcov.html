<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/access/gin/ginvacuum.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/backend/access/gin</a> - ginvacuum.c<span style="font-size: 80%;"> (source / <a href="ginvacuum.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">44</td>
            <td class="headerCovTableEntry">297</td>
            <td class="headerCovTableEntryLo">14.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntryLo">11.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * ginvacuum.c
<span class="lineNum">       4 </span>            :  *    delete &amp; vacuum routines for the postgres GIN
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       8 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * IDENTIFICATION
<span class="lineNum">      11 </span>            :  *          src/backend/access/gin/ginvacuum.c
<span class="lineNum">      12 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      13 </span>            :  */
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : #include &quot;access/gin_private.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;access/ginxlog.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;access/xloginsert.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;commands/vacuum.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;miscadmin.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;postmaster/autovacuum.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;storage/indexfsm.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;storage/lmgr.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;storage/predicate.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;utils/memutils.h&quot;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : struct GinVacuumState
<span class="lineNum">      29 </span>            : {
<span class="lineNum">      30 </span>            :     Relation    index;
<span class="lineNum">      31 </span>            :     IndexBulkDeleteResult *result;
<span class="lineNum">      32 </span>            :     IndexBulkDeleteCallback callback;
<span class="lineNum">      33 </span>            :     void       *callback_state;
<span class="lineNum">      34 </span>            :     GinState    ginstate;
<span class="lineNum">      35 </span>            :     BufferAccessStrategy strategy;
<span class="lineNum">      36 </span>            :     MemoryContext tmpCxt;
<span class="lineNum">      37 </span>            : };
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : /*
<span class="lineNum">      40 </span>            :  * Vacuums an uncompressed posting list. The size of the must can be specified
<span class="lineNum">      41 </span>            :  * in number of items (nitems).
<span class="lineNum">      42 </span>            :  *
<span class="lineNum">      43 </span>            :  * If none of the items need to be removed, returns NULL. Otherwise returns
<span class="lineNum">      44 </span>            :  * a new palloc'd array with the remaining items. The number of remaining
<span class="lineNum">      45 </span>            :  * items is returned in *nremaining.
<a name="46"><span class="lineNum">      46 </span>            :  */</a>
<span class="lineNum">      47 </span>            : ItemPointer
<span class="lineNum">      48 </span><span class="lineNoCov">          0 : ginVacuumItemPointers(GinVacuumState *gvs, ItemPointerData *items,</span>
<span class="lineNum">      49 </span>            :                       int nitem, int *nremaining)
<span class="lineNum">      50 </span>            : {
<span class="lineNum">      51 </span>            :     int         i,
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :                 remaining = 0;</span>
<span class="lineNum">      53 </span><span class="lineNoCov">          0 :     ItemPointer tmpitems = NULL;</span>
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            :     /*
<span class="lineNum">      56 </span>            :      * Iterate over TIDs array
<span class="lineNum">      57 </span>            :      */
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; nitem; i++)</span>
<span class="lineNum">      59 </span>            :     {
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :         if (gvs-&gt;callback(items + i, gvs-&gt;callback_state))</span>
<span class="lineNum">      61 </span>            :         {
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :             gvs-&gt;result-&gt;tuples_removed += 1;</span>
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :             if (!tmpitems)</span>
<span class="lineNum">      64 </span>            :             {
<span class="lineNum">      65 </span>            :                 /*
<span class="lineNum">      66 </span>            :                  * First TID to be deleted: allocate memory to hold the
<span class="lineNum">      67 </span>            :                  * remaining items.
<span class="lineNum">      68 </span>            :                  */
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :                 tmpitems = palloc(sizeof(ItemPointerData) * nitem);</span>
<span class="lineNum">      70 </span><span class="lineNoCov">          0 :                 memcpy(tmpitems, items, sizeof(ItemPointerData) * i);</span>
<span class="lineNum">      71 </span>            :             }
<span class="lineNum">      72 </span>            :         }
<span class="lineNum">      73 </span>            :         else
<span class="lineNum">      74 </span>            :         {
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :             gvs-&gt;result-&gt;num_index_tuples += 1;</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :             if (tmpitems)</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :                 tmpitems[remaining] = items[i];</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :             remaining++;</span>
<span class="lineNum">      79 </span>            :         }
<span class="lineNum">      80 </span>            :     }
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :     *nremaining = remaining;</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :     return tmpitems;</span>
<span class="lineNum">      84 </span>            : }
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : /*
<span class="lineNum">      87 </span>            :  * Create a WAL record for vacuuming entry tree leaf page.
<a name="88"><span class="lineNum">      88 </span>            :  */</a>
<span class="lineNum">      89 </span>            : static void
<span class="lineNum">      90 </span><span class="lineNoCov">          0 : xlogVacuumPage(Relation index, Buffer buffer)</span>
<span class="lineNum">      91 </span>            : {
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :     Page        page = BufferGetPage(buffer);</span>
<span class="lineNum">      93 </span>            :     XLogRecPtr  recptr;
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            :     /* This is only used for entry tree leaf pages. */
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :     Assert(!GinPageIsData(page));</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :     Assert(GinPageIsLeaf(page));</span>
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :     if (!RelationNeedsWAL(index))</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :     /*
<span class="lineNum">     103 </span>            :      * Always create a full image, we don't track the changes on the page at
<span class="lineNum">     104 </span>            :      * any more fine-grained level. This could obviously be improved...
<span class="lineNum">     105 </span>            :      */
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :     XLogBeginInsert();</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :     XLogRegisterBuffer(0, buffer, REGBUF_FORCE_IMAGE | REGBUF_STANDARD);</span>
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     recptr = XLogInsert(RM_GIN_ID, XLOG_GIN_VACUUM_PAGE);</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :     PageSetLSN(page, recptr);</span>
<span class="lineNum">     111 </span>            : }
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : typedef struct DataPageDeleteStack
<span class="lineNum">     115 </span>            : {
<span class="lineNum">     116 </span>            :     struct DataPageDeleteStack *child;
<span class="lineNum">     117 </span>            :     struct DataPageDeleteStack *parent;
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            :     BlockNumber blkno;          /* current block number */
<span class="lineNum">     120 </span>            :     Buffer      leftBuffer;     /* pinned and locked rightest non-deleted page
<span class="lineNum">     121 </span>            :                                  * on left */
<span class="lineNum">     122 </span>            :     bool        isRoot;
<span class="lineNum">     123 </span>            : } DataPageDeleteStack;
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : /*
<span class="lineNum">     127 </span>            :  * Delete a posting tree page.
<a name="128"><span class="lineNum">     128 </span>            :  */</a>
<span class="lineNum">     129 </span>            : static void
<span class="lineNum">     130 </span><span class="lineNoCov">          0 : ginDeletePage(GinVacuumState *gvs, BlockNumber deleteBlkno, BlockNumber leftBlkno,</span>
<span class="lineNum">     131 </span>            :               BlockNumber parentBlkno, OffsetNumber myoff, bool isParentRoot)
<span class="lineNum">     132 </span>            : {
<span class="lineNum">     133 </span>            :     Buffer      dBuffer;
<span class="lineNum">     134 </span>            :     Buffer      lBuffer;
<span class="lineNum">     135 </span>            :     Buffer      pBuffer;
<span class="lineNum">     136 </span>            :     Page        page,
<span class="lineNum">     137 </span>            :                 parentPage;
<span class="lineNum">     138 </span>            :     BlockNumber rightlink;
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            :     /*
<span class="lineNum">     141 </span>            :      * This function MUST be called only if someone of parent pages hold
<span class="lineNum">     142 </span>            :      * exclusive cleanup lock. This guarantees that no insertions currently
<span class="lineNum">     143 </span>            :      * happen in this subtree. Caller also acquires Exclusive locks on
<span class="lineNum">     144 </span>            :      * deletable, parent and left pages.
<span class="lineNum">     145 </span>            :      */
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :     lBuffer = ReadBufferExtended(gvs-&gt;index, MAIN_FORKNUM, leftBlkno,</span>
<span class="lineNum">     147 </span>            :                                  RBM_NORMAL, gvs-&gt;strategy);
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :     dBuffer = ReadBufferExtended(gvs-&gt;index, MAIN_FORKNUM, deleteBlkno,</span>
<span class="lineNum">     149 </span>            :                                  RBM_NORMAL, gvs-&gt;strategy);
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :     pBuffer = ReadBufferExtended(gvs-&gt;index, MAIN_FORKNUM, parentBlkno,</span>
<span class="lineNum">     151 </span>            :                                  RBM_NORMAL, gvs-&gt;strategy);
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     page = BufferGetPage(dBuffer);</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :     rightlink = GinPageGetOpaque(page)-&gt;rightlink;</span>
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            :     /*
<span class="lineNum">     157 </span>            :      * Any insert which would have gone on the leaf block will now go to its
<span class="lineNum">     158 </span>            :      * right sibling.
<span class="lineNum">     159 </span>            :      */
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :     PredicateLockPageCombine(gvs-&gt;index, deleteBlkno, rightlink);</span>
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     START_CRIT_SECTION();</span>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :     /* Unlink the page by changing left sibling's rightlink */
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     page = BufferGetPage(lBuffer);</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :     GinPageGetOpaque(page)-&gt;rightlink = rightlink;</span>
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            :     /* For deleted page remember last xid which could knew its address */
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :     GinPageSetDeleteXid(page, ReadNewTransactionId());</span>
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            :     /* Delete downlink from parent */
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :     parentPage = BufferGetPage(pBuffer);</span>
<span class="lineNum">     173 </span>            : #ifdef USE_ASSERT_CHECKING
<span class="lineNum">     174 </span>            :     do
<span class="lineNum">     175 </span>            :     {
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :         PostingItem *tod = GinDataPageGetPostingItem(parentPage, myoff);</span>
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :         Assert(PostingItemGetBlockNumber(tod) == deleteBlkno);</span>
<span class="lineNum">     179 </span>            :     } while (0);
<span class="lineNum">     180 </span>            : #endif
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :     GinPageDeletePostingItem(parentPage, myoff);</span>
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     page = BufferGetPage(dBuffer);</span>
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            :     /*
<span class="lineNum">     186 </span>            :      * we shouldn't change rightlink field to save workability of running
<span class="lineNum">     187 </span>            :      * search scan
<span class="lineNum">     188 </span>            :      */
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     GinPageSetDeleted(page);</span>
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     MarkBufferDirty(pBuffer);</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     MarkBufferDirty(lBuffer);</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     MarkBufferDirty(dBuffer);</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     if (RelationNeedsWAL(gvs-&gt;index))</span>
<span class="lineNum">     196 </span>            :     {
<span class="lineNum">     197 </span>            :         XLogRecPtr  recptr;
<span class="lineNum">     198 </span>            :         ginxlogDeletePage data;
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :         /*
<span class="lineNum">     201 </span>            :          * We can't pass REGBUF_STANDARD for the deleted page, because we
<span class="lineNum">     202 </span>            :          * didn't set pd_lower on pre-9.4 versions. The page might've been
<span class="lineNum">     203 </span>            :          * binary-upgraded from an older version, and hence not have pd_lower
<span class="lineNum">     204 </span>            :          * set correctly. Ditto for the left page, but removing the item from
<span class="lineNum">     205 </span>            :          * the parent updated its pd_lower, so we know that's OK at this
<span class="lineNum">     206 </span>            :          * point.
<span class="lineNum">     207 </span>            :          */
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :         XLogBeginInsert();</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :         XLogRegisterBuffer(0, dBuffer, 0);</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :         XLogRegisterBuffer(1, pBuffer, REGBUF_STANDARD);</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         XLogRegisterBuffer(2, lBuffer, 0);</span>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :         data.parentOffset = myoff;</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :         data.rightLink = GinPageGetOpaque(page)-&gt;rightlink;</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :         data.deleteXid = GinPageGetDeleteXid(page);</span>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :         XLogRegisterData((char *) &amp;data, sizeof(ginxlogDeletePage));</span>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :         recptr = XLogInsert(RM_GIN_ID, XLOG_GIN_DELETE_PAGE);</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :         PageSetLSN(page, recptr);</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :         PageSetLSN(parentPage, recptr);</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :         PageSetLSN(BufferGetPage(lBuffer), recptr);</span>
<span class="lineNum">     223 </span>            :     }
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :     ReleaseBuffer(pBuffer);</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     ReleaseBuffer(lBuffer);</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     ReleaseBuffer(dBuffer);</span>
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     END_CRIT_SECTION();</span>
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     gvs-&gt;result-&gt;pages_deleted++;</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            : /*
<span class="lineNum">     236 </span>            :  * Scans posting tree and deletes empty pages.  Caller must lock root page for
<span class="lineNum">     237 </span>            :  * cleanup.  During scan path from root to current page is kept exclusively
<span class="lineNum">     238 </span>            :  * locked.  Also keep left page exclusively locked, because ginDeletePage()
<span class="lineNum">     239 </span>            :  * needs it.  If we try to relock left page later, it could deadlock with
<span class="lineNum">     240 </span>            :  * ginStepRight().
<a name="241"><span class="lineNum">     241 </span>            :  */</a>
<span class="lineNum">     242 </span>            : static bool
<span class="lineNum">     243 </span><span class="lineNoCov">          0 : ginScanToDelete(GinVacuumState *gvs, BlockNumber blkno, bool isRoot,</span>
<span class="lineNum">     244 </span>            :                 DataPageDeleteStack *parent, OffsetNumber myoff)
<span class="lineNum">     245 </span>            : {
<span class="lineNum">     246 </span>            :     DataPageDeleteStack *me;
<span class="lineNum">     247 </span>            :     Buffer      buffer;
<span class="lineNum">     248 </span>            :     Page        page;
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     bool        meDelete = false;</span>
<span class="lineNum">     250 </span>            :     bool        isempty;
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     if (isRoot)</span>
<span class="lineNum">     253 </span>            :     {
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :         me = parent;</span>
<span class="lineNum">     255 </span>            :     }
<span class="lineNum">     256 </span>            :     else
<span class="lineNum">     257 </span>            :     {
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :         if (!parent-&gt;child)</span>
<span class="lineNum">     259 </span>            :         {
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :             me = (DataPageDeleteStack *) palloc0(sizeof(DataPageDeleteStack));</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :             me-&gt;parent = parent;</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :             parent-&gt;child = me;</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :             me-&gt;leftBuffer = InvalidBuffer;</span>
<span class="lineNum">     264 </span>            :         }
<span class="lineNum">     265 </span>            :         else
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :             me = parent-&gt;child;</span>
<span class="lineNum">     267 </span>            :     }
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :     buffer = ReadBufferExtended(gvs-&gt;index, MAIN_FORKNUM, blkno,</span>
<span class="lineNum">     270 </span>            :                                 RBM_NORMAL, gvs-&gt;strategy);
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :     if (!isRoot)</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :         LockBuffer(buffer, GIN_EXCLUSIVE);</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :     page = BufferGetPage(buffer);</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :     Assert(GinPageIsData(page));</span>
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :     if (!GinPageIsLeaf(page))</span>
<span class="lineNum">     280 </span>            :     {
<span class="lineNum">     281 </span>            :         OffsetNumber i;
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         me-&gt;blkno = blkno;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         for (i = FirstOffsetNumber; i &lt;= GinPageGetOpaque(page)-&gt;maxoff; i++)</span>
<span class="lineNum">     285 </span>            :         {
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :             PostingItem *pitem = GinDataPageGetPostingItem(page, i);</span>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :             if (ginScanToDelete(gvs, PostingItemGetBlockNumber(pitem), false, me, i))</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :                 i--;</span>
<span class="lineNum">     290 </span>            :         }
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :         if (GinPageRightMost(page) &amp;&amp; BufferIsValid(me-&gt;child-&gt;leftBuffer))</span>
<span class="lineNum">     293 </span>            :         {
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :             UnlockReleaseBuffer(me-&gt;child-&gt;leftBuffer);</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :             me-&gt;child-&gt;leftBuffer = InvalidBuffer;</span>
<span class="lineNum">     296 </span>            :         }
<span class="lineNum">     297 </span>            :     }
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :     if (GinPageIsLeaf(page))</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :         isempty = GinDataLeafPageIsEmpty(page);</span>
<span class="lineNum">     301 </span>            :     else
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         isempty = GinPageGetOpaque(page)-&gt;maxoff &lt; FirstOffsetNumber;</span>
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     if (isempty)</span>
<span class="lineNum">     305 </span>            :     {
<span class="lineNum">     306 </span>            :         /* we never delete the left- or rightmost branch */
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :         if (BufferIsValid(me-&gt;leftBuffer) &amp;&amp; !GinPageRightMost(page))</span>
<span class="lineNum">     308 </span>            :         {
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :             Assert(!isRoot);</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :             ginDeletePage(gvs, blkno, BufferGetBlockNumber(me-&gt;leftBuffer),</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :                           me-&gt;parent-&gt;blkno, myoff, me-&gt;parent-&gt;isRoot);</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :             meDelete = true;</span>
<span class="lineNum">     313 </span>            :         }
<span class="lineNum">     314 </span>            :     }
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     if (!meDelete)</span>
<span class="lineNum">     317 </span>            :     {
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :         if (BufferIsValid(me-&gt;leftBuffer))</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :             UnlockReleaseBuffer(me-&gt;leftBuffer);</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :         me-&gt;leftBuffer = buffer;</span>
<span class="lineNum">     321 </span>            :     }
<span class="lineNum">     322 </span>            :     else
<span class="lineNum">     323 </span>            :     {
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         if (!isRoot)</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :             LockBuffer(buffer, GIN_UNLOCK);</span>
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         ReleaseBuffer(buffer);</span>
<span class="lineNum">     328 </span>            :     }
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :     if (isRoot)</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :         ReleaseBuffer(buffer);</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     return meDelete;</span>
<span class="lineNum">     334 </span>            : }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            : /*
<span class="lineNum">     338 </span>            :  * Scan through posting tree leafs, delete empty tuples.  Returns true if there
<span class="lineNum">     339 </span>            :  * is at least one empty page.
<a name="340"><span class="lineNum">     340 </span>            :  */</a>
<span class="lineNum">     341 </span>            : static bool
<span class="lineNum">     342 </span><span class="lineNoCov">          0 : ginVacuumPostingTreeLeaves(GinVacuumState *gvs, BlockNumber blkno)</span>
<span class="lineNum">     343 </span>            : {
<span class="lineNum">     344 </span>            :     Buffer      buffer;
<span class="lineNum">     345 </span>            :     Page        page;
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     bool        hasVoidPage = false;</span>
<span class="lineNum">     347 </span>            :     MemoryContext oldCxt;
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :     /* Find leftmost leaf page of posting tree and lock it in exclusive mode */
<span class="lineNum">     350 </span>            :     while (true)
<span class="lineNum">     351 </span>            :     {
<span class="lineNum">     352 </span>            :         PostingItem *pitem;
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         buffer = ReadBufferExtended(gvs-&gt;index, MAIN_FORKNUM, blkno,</span>
<span class="lineNum">     355 </span>            :                                     RBM_NORMAL, gvs-&gt;strategy);
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         LockBuffer(buffer, GIN_SHARE);</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :         page = BufferGetPage(buffer);</span>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :         Assert(GinPageIsData(page));</span>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         if (GinPageIsLeaf(page))</span>
<span class="lineNum">     362 </span>            :         {
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :             LockBuffer(buffer, GIN_UNLOCK);</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :             LockBuffer(buffer, GIN_EXCLUSIVE);</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     366 </span>            :         }
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :         Assert(PageGetMaxOffsetNumber(page) &gt;= FirstOffsetNumber);</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :         pitem = GinDataPageGetPostingItem(page, FirstOffsetNumber);</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :         blkno = PostingItemGetBlockNumber(pitem);</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :         Assert(blkno != InvalidBlockNumber);</span>
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :         UnlockReleaseBuffer(buffer);</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            :     /* Iterate all posting tree leaves using rightlinks and vacuum them */
<span class="lineNum">     378 </span>            :     while (true)
<span class="lineNum">     379 </span>            :     {
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :         oldCxt = MemoryContextSwitchTo(gvs-&gt;tmpCxt);</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         ginVacuumPostingTreeLeaf(gvs-&gt;index, buffer, gvs);</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :         MemoryContextSwitchTo(oldCxt);</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :         MemoryContextReset(gvs-&gt;tmpCxt);</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         if (GinDataLeafPageIsEmpty(page))</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :             hasVoidPage = true;</span>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :         blkno = GinPageGetOpaque(page)-&gt;rightlink;</span>
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :         UnlockReleaseBuffer(buffer);</span>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :         if (blkno == InvalidBlockNumber)</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :         buffer = ReadBufferExtended(gvs-&gt;index, MAIN_FORKNUM, blkno,</span>
<span class="lineNum">     396 </span>            :                                     RBM_NORMAL, gvs-&gt;strategy);
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :         LockBuffer(buffer, GIN_EXCLUSIVE);</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :         page = BufferGetPage(buffer);</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :     return hasVoidPage;</span>
<span class="lineNum">     402 </span>            : }
<a name="403"><span class="lineNum">     403 </span>            : </a>
<span class="lineNum">     404 </span>            : static void
<span class="lineNum">     405 </span><span class="lineNoCov">          0 : ginVacuumPostingTree(GinVacuumState *gvs, BlockNumber rootBlkno)</span>
<span class="lineNum">     406 </span>            : {
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     if (ginVacuumPostingTreeLeaves(gvs, rootBlkno))</span>
<span class="lineNum">     408 </span>            :     {
<span class="lineNum">     409 </span>            :         /*
<span class="lineNum">     410 </span>            :          * There is at least one empty page.  So we have to rescan the tree
<span class="lineNum">     411 </span>            :          * deleting empty pages.
<span class="lineNum">     412 </span>            :          */
<span class="lineNum">     413 </span>            :         Buffer      buffer;
<span class="lineNum">     414 </span>            :         DataPageDeleteStack root,
<span class="lineNum">     415 </span>            :                    *ptr,
<span class="lineNum">     416 </span>            :                    *tmp;
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :         buffer = ReadBufferExtended(gvs-&gt;index, MAIN_FORKNUM, rootBlkno,</span>
<span class="lineNum">     419 </span>            :                                     RBM_NORMAL, gvs-&gt;strategy);
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            :         /*
<span class="lineNum">     422 </span>            :          * Lock posting tree root for cleanup to ensure there are no
<span class="lineNum">     423 </span>            :          * concurrent inserts.
<span class="lineNum">     424 </span>            :          */
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :         LockBufferForCleanup(buffer);</span>
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :         memset(&amp;root, 0, sizeof(DataPageDeleteStack));</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :         root.leftBuffer = InvalidBuffer;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :         root.isRoot = true;</span>
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :         ginScanToDelete(gvs, rootBlkno, true, &amp;root, InvalidOffsetNumber);</span>
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :         ptr = root.child;</span>
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :         while (ptr)</span>
<span class="lineNum">     436 </span>            :         {
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :             tmp = ptr-&gt;child;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :             pfree(ptr);</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :             ptr = tmp;</span>
<span class="lineNum">     440 </span>            :         }
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :         UnlockReleaseBuffer(buffer);</span>
<span class="lineNum">     443 </span>            :     }
<span class="lineNum">     444 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : /*
<span class="lineNum">     447 </span>            :  * returns modified page or NULL if page isn't modified.
<span class="lineNum">     448 </span>            :  * Function works with original page until first change is occurred,
<span class="lineNum">     449 </span>            :  * then page is copied into temporary one.
<a name="450"><span class="lineNum">     450 </span>            :  */</a>
<span class="lineNum">     451 </span>            : static Page
<span class="lineNum">     452 </span><span class="lineNoCov">          0 : ginVacuumEntryPage(GinVacuumState *gvs, Buffer buffer, BlockNumber *roots, uint32 *nroot)</span>
<span class="lineNum">     453 </span>            : {
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :     Page        origpage = BufferGetPage(buffer),</span>
<span class="lineNum">     455 </span>            :                 tmppage;
<span class="lineNum">     456 </span>            :     OffsetNumber i,
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :                 maxoff = PageGetMaxOffsetNumber(origpage);</span>
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :     tmppage = origpage;</span>
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     *nroot = 0;</span>
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :     for (i = FirstOffsetNumber; i &lt;= maxoff; i++)</span>
<span class="lineNum">     464 </span>            :     {
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :         IndexTuple  itup = (IndexTuple) PageGetItem(tmppage, PageGetItemId(tmppage, i));</span>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :         if (GinIsPostingTree(itup))</span>
<span class="lineNum">     468 </span>            :         {
<span class="lineNum">     469 </span>            :             /*
<span class="lineNum">     470 </span>            :              * store posting tree's roots for further processing, we can't
<span class="lineNum">     471 </span>            :              * vacuum it just now due to risk of deadlocks with scans/inserts
<span class="lineNum">     472 </span>            :              */
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :             roots[*nroot] = GinGetDownlink(itup);</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :             (*nroot)++;</span>
<span class="lineNum">     475 </span>            :         }
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :         else if (GinGetNPosting(itup) &gt; 0)</span>
<span class="lineNum">     477 </span>            :         {
<span class="lineNum">     478 </span>            :             int         nitems;
<span class="lineNum">     479 </span>            :             ItemPointer items_orig;
<span class="lineNum">     480 </span>            :             bool        free_items_orig;
<span class="lineNum">     481 </span>            :             ItemPointer items;
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            :             /* Get list of item pointers from the tuple. */
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :             if (GinItupIsCompressed(itup))</span>
<span class="lineNum">     485 </span>            :             {
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :                 items_orig = ginPostingListDecode((GinPostingList *) GinGetPosting(itup), &amp;nitems);</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :                 free_items_orig = true;</span>
<span class="lineNum">     488 </span>            :             }
<span class="lineNum">     489 </span>            :             else
<span class="lineNum">     490 </span>            :             {
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :                 items_orig = (ItemPointer) GinGetPosting(itup);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :                 nitems = GinGetNPosting(itup);</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :                 free_items_orig = false;</span>
<span class="lineNum">     494 </span>            :             }
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            :             /* Remove any items from the list that need to be vacuumed. */
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :             items = ginVacuumItemPointers(gvs, items_orig, nitems, &amp;nitems);</span>
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :             if (free_items_orig)</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :                 pfree(items_orig);</span>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            :             /* If any item pointers were removed, recreate the tuple. */
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :             if (items)</span>
<span class="lineNum">     504 </span>            :             {
<span class="lineNum">     505 </span>            :                 OffsetNumber attnum;
<span class="lineNum">     506 </span>            :                 Datum       key;
<span class="lineNum">     507 </span>            :                 GinNullCategory category;
<span class="lineNum">     508 </span>            :                 GinPostingList *plist;
<span class="lineNum">     509 </span>            :                 int         plistsize;
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :                 if (nitems &gt; 0)</span>
<span class="lineNum">     512 </span>            :                 {
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :                     plist = ginCompressPostingList(items, nitems, GinMaxItemSize, NULL);</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :                     plistsize = SizeOfGinPostingList(plist);</span>
<span class="lineNum">     515 </span>            :                 }
<span class="lineNum">     516 </span>            :                 else
<span class="lineNum">     517 </span>            :                 {
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :                     plist = NULL;</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :                     plistsize = 0;</span>
<span class="lineNum">     520 </span>            :                 }
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            :                 /*
<span class="lineNum">     523 </span>            :                  * if we already created a temporary page, make changes in
<span class="lineNum">     524 </span>            :                  * place
<span class="lineNum">     525 </span>            :                  */
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :                 if (tmppage == origpage)</span>
<span class="lineNum">     527 </span>            :                 {
<span class="lineNum">     528 </span>            :                     /*
<span class="lineNum">     529 </span>            :                      * On first difference, create a temporary copy of the
<span class="lineNum">     530 </span>            :                      * page and copy the tuple's posting list to it.
<span class="lineNum">     531 </span>            :                      */
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :                     tmppage = PageGetTempPageCopy(origpage);</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            :                     /* set itup pointer to new page */
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :                     itup = (IndexTuple) PageGetItem(tmppage, PageGetItemId(tmppage, i));</span>
<span class="lineNum">     536 </span>            :                 }
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :                 attnum = gintuple_get_attrnum(&amp;gvs-&gt;ginstate, itup);</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :                 key = gintuple_get_key(&amp;gvs-&gt;ginstate, itup, &amp;category);</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                 itup = GinFormTuple(&amp;gvs-&gt;ginstate, attnum, key, category,</span>
<span class="lineNum">     541 </span>            :                                     (char *) plist, plistsize,
<span class="lineNum">     542 </span>            :                                     nitems, true);
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :                 if (plist)</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :                     pfree(plist);</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                 PageIndexTupleDelete(tmppage, i);</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :                 if (PageAddItem(tmppage, (Item) itup, IndexTupleSize(itup), i, false, false) != i)</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :                     elog(ERROR, &quot;failed to add item to index page in \&quot;%s\&quot;&quot;,</span>
<span class="lineNum">     549 </span>            :                          RelationGetRelationName(gvs-&gt;index));
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :                 pfree(itup);</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :                 pfree(items);</span>
<span class="lineNum">     553 </span>            :             }
<span class="lineNum">     554 </span>            :         }
<span class="lineNum">     555 </span>            :     }
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     return (tmppage == origpage) ? NULL : tmppage;</span>
<span class="lineNum">     558 </span>            : }
<a name="559"><span class="lineNum">     559 </span>            : </a>
<span class="lineNum">     560 </span>            : IndexBulkDeleteResult *
<span class="lineNum">     561 </span><span class="lineNoCov">          0 : ginbulkdelete(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,</span>
<span class="lineNum">     562 </span>            :               IndexBulkDeleteCallback callback, void *callback_state)
<span class="lineNum">     563 </span>            : {
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :     Relation    index = info-&gt;index;</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :     BlockNumber blkno = GIN_ROOT_BLKNO;</span>
<span class="lineNum">     566 </span>            :     GinVacuumState gvs;
<span class="lineNum">     567 </span>            :     Buffer      buffer;
<span class="lineNum">     568 </span>            :     BlockNumber rootOfPostingTree[BLCKSZ / (sizeof(IndexTupleData) + sizeof(ItemId))];
<span class="lineNum">     569 </span>            :     uint32      nRoot;
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     gvs.tmpCxt = AllocSetContextCreate(CurrentMemoryContext,</span>
<span class="lineNum">     572 </span>            :                                        &quot;Gin vacuum temporary context&quot;,
<span class="lineNum">     573 </span>            :                                        ALLOCSET_DEFAULT_SIZES);
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :     gvs.index = index;</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :     gvs.callback = callback;</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :     gvs.callback_state = callback_state;</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :     gvs.strategy = info-&gt;strategy;</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :     initGinState(&amp;gvs.ginstate, index);</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            :     /* first time through? */
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :     if (stats == NULL)</span>
<span class="lineNum">     582 </span>            :     {
<span class="lineNum">     583 </span>            :         /* Yes, so initialize stats to zeroes */
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :         stats = (IndexBulkDeleteResult *) palloc0(sizeof(IndexBulkDeleteResult));</span>
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            :         /*
<span class="lineNum">     587 </span>            :          * and cleanup any pending inserts
<span class="lineNum">     588 </span>            :          */
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :         ginInsertCleanup(&amp;gvs.ginstate, !IsAutoVacuumWorkerProcess(),</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :                          false, true, stats);</span>
<span class="lineNum">     591 </span>            :     }
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span>            :     /* we'll re-count the tuples each time */
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :     stats-&gt;num_index_tuples = 0;</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :     gvs.result = stats;</span>
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     buffer = ReadBufferExtended(index, MAIN_FORKNUM, blkno,</span>
<span class="lineNum">     598 </span>            :                                 RBM_NORMAL, info-&gt;strategy);
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span>            :     /* find leaf page */
<span class="lineNum">     601 </span>            :     for (;;)
<span class="lineNum">     602 </span>            :     {
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :         Page        page = BufferGetPage(buffer);</span>
<span class="lineNum">     604 </span>            :         IndexTuple  itup;
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :         LockBuffer(buffer, GIN_SHARE);</span>
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :         Assert(!GinPageIsData(page));</span>
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :         if (GinPageIsLeaf(page))</span>
<span class="lineNum">     611 </span>            :         {
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :             LockBuffer(buffer, GIN_UNLOCK);</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :             LockBuffer(buffer, GIN_EXCLUSIVE);</span>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :             if (blkno == GIN_ROOT_BLKNO &amp;&amp; !GinPageIsLeaf(page))</span>
<span class="lineNum">     616 </span>            :             {
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :                 LockBuffer(buffer, GIN_UNLOCK);</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :                 continue;       /* check it one more */</span>
<span class="lineNum">     619 </span>            :             }
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     621 </span>            :         }
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :         Assert(PageGetMaxOffsetNumber(page) &gt;= FirstOffsetNumber);</span>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :         itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, FirstOffsetNumber));</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :         blkno = GinGetDownlink(itup);</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :         Assert(blkno != InvalidBlockNumber);</span>
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :         UnlockReleaseBuffer(buffer);</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :         buffer = ReadBufferExtended(index, MAIN_FORKNUM, blkno,</span>
<span class="lineNum">     631 </span>            :                                     RBM_NORMAL, info-&gt;strategy);
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :     /* right now we found leftmost page in entry's BTree */
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            :     for (;;)
<span class="lineNum">     637 </span>            :     {
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :         Page        page = BufferGetPage(buffer);</span>
<span class="lineNum">     639 </span>            :         Page        resPage;
<span class="lineNum">     640 </span>            :         uint32      i;
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :         Assert(!GinPageIsData(page));</span>
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :         resPage = ginVacuumEntryPage(&amp;gvs, buffer, rootOfPostingTree, &amp;nRoot);</span>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :         blkno = GinPageGetOpaque(page)-&gt;rightlink;</span>
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :         if (resPage)</span>
<span class="lineNum">     649 </span>            :         {
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :             START_CRIT_SECTION();</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :             PageRestoreTempPage(resPage, page);</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :             MarkBufferDirty(buffer);</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :             xlogVacuumPage(gvs.index, buffer);</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :             UnlockReleaseBuffer(buffer);</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :             END_CRIT_SECTION();</span>
<span class="lineNum">     656 </span>            :         }
<span class="lineNum">     657 </span>            :         else
<span class="lineNum">     658 </span>            :         {
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :             UnlockReleaseBuffer(buffer);</span>
<span class="lineNum">     660 </span>            :         }
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         vacuum_delay_point();</span>
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; nRoot; i++)</span>
<span class="lineNum">     665 </span>            :         {
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :             ginVacuumPostingTree(&amp;gvs, rootOfPostingTree[i]);</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :             vacuum_delay_point();</span>
<span class="lineNum">     668 </span>            :         }
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :         if (blkno == InvalidBlockNumber)    /* rightmost page */</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :         buffer = ReadBufferExtended(index, MAIN_FORKNUM, blkno,</span>
<span class="lineNum">     674 </span>            :                                     RBM_NORMAL, info-&gt;strategy);
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :         LockBuffer(buffer, GIN_EXCLUSIVE);</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     MemoryContextDelete(gvs.tmpCxt);</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     return gvs.result;</span>
<span class="lineNum">     681 </span>            : }
<a name="682"><span class="lineNum">     682 </span>            : </a>
<span class="lineNum">     683 </span>            : IndexBulkDeleteResult *
<span class="lineNum">     684 </span><span class="lineCov">         10 : ginvacuumcleanup(IndexVacuumInfo *info, IndexBulkDeleteResult *stats)</span>
<span class="lineNum">     685 </span>            : {
<span class="lineNum">     686 </span><span class="lineCov">         10 :     Relation    index = info-&gt;index;</span>
<span class="lineNum">     687 </span>            :     bool        needLock;
<span class="lineNum">     688 </span>            :     BlockNumber npages,
<span class="lineNum">     689 </span>            :                 blkno;
<span class="lineNum">     690 </span>            :     BlockNumber totFreePages;
<span class="lineNum">     691 </span>            :     GinState    ginstate;
<span class="lineNum">     692 </span>            :     GinStatsData idxStat;
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span>            :     /*
<span class="lineNum">     695 </span>            :      * In an autovacuum analyze, we want to clean up pending insertions.
<span class="lineNum">     696 </span>            :      * Otherwise, an ANALYZE-only call is a no-op.
<span class="lineNum">     697 </span>            :      */
<span class="lineNum">     698 </span><span class="lineCov">         10 :     if (info-&gt;analyze_only)</span>
<span class="lineNum">     699 </span>            :     {
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :         if (IsAutoVacuumWorkerProcess())</span>
<span class="lineNum">     701 </span>            :         {
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :             initGinState(&amp;ginstate, index);</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :             ginInsertCleanup(&amp;ginstate, false, true, true, stats);</span>
<span class="lineNum">     704 </span>            :         }
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :         return stats;</span>
<span class="lineNum">     706 </span>            :     }
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            :     /*
<span class="lineNum">     709 </span>            :      * Set up all-zero stats and cleanup pending inserts if ginbulkdelete
<span class="lineNum">     710 </span>            :      * wasn't called
<span class="lineNum">     711 </span>            :      */
<span class="lineNum">     712 </span><span class="lineCov">         10 :     if (stats == NULL)</span>
<span class="lineNum">     713 </span>            :     {
<span class="lineNum">     714 </span><span class="lineCov">         10 :         stats = (IndexBulkDeleteResult *) palloc0(sizeof(IndexBulkDeleteResult));</span>
<span class="lineNum">     715 </span><span class="lineCov">         10 :         initGinState(&amp;ginstate, index);</span>
<span class="lineNum">     716 </span><span class="lineCov">         20 :         ginInsertCleanup(&amp;ginstate, !IsAutoVacuumWorkerProcess(),</span>
<span class="lineNum">     717 </span><span class="lineCov">         10 :                          false, true, stats);</span>
<span class="lineNum">     718 </span>            :     }
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span><span class="lineCov">         10 :     memset(&amp;idxStat, 0, sizeof(idxStat));</span>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :     /*
<span class="lineNum">     723 </span>            :      * XXX we always report the heap tuple count as the number of index
<span class="lineNum">     724 </span>            :      * entries.  This is bogus if the index is partial, but it's real hard to
<span class="lineNum">     725 </span>            :      * tell how many distinct heap entries are referenced by a GIN index.
<span class="lineNum">     726 </span>            :      */
<span class="lineNum">     727 </span><span class="lineCov">         10 :     stats-&gt;num_index_tuples = info-&gt;num_heap_tuples;</span>
<span class="lineNum">     728 </span><span class="lineCov">         10 :     stats-&gt;estimated_count = info-&gt;estimated_count;</span>
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            :     /*
<span class="lineNum">     731 </span>            :      * Need lock unless it's local to this backend.
<span class="lineNum">     732 </span>            :      */
<span class="lineNum">     733 </span><span class="lineCov">         10 :     needLock = !RELATION_IS_LOCAL(index);</span>
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span><span class="lineCov">         10 :     if (needLock)</span>
<span class="lineNum">     736 </span><span class="lineCov">         10 :         LockRelationForExtension(index, ExclusiveLock);</span>
<span class="lineNum">     737 </span><span class="lineCov">         10 :     npages = RelationGetNumberOfBlocks(index);</span>
<span class="lineNum">     738 </span><span class="lineCov">         10 :     if (needLock)</span>
<span class="lineNum">     739 </span><span class="lineCov">         10 :         UnlockRelationForExtension(index, ExclusiveLock);</span>
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineCov">         10 :     totFreePages = 0;</span>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span><span class="lineCov">       1832 :     for (blkno = GIN_ROOT_BLKNO; blkno &lt; npages; blkno++)</span>
<span class="lineNum">     744 </span>            :     {
<span class="lineNum">     745 </span>            :         Buffer      buffer;
<span class="lineNum">     746 </span>            :         Page        page;
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span><span class="lineCov">       1822 :         vacuum_delay_point();</span>
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span><span class="lineCov">       1822 :         buffer = ReadBufferExtended(index, MAIN_FORKNUM, blkno,</span>
<span class="lineNum">     751 </span>            :                                     RBM_NORMAL, info-&gt;strategy);
<span class="lineNum">     752 </span><span class="lineCov">       1822 :         LockBuffer(buffer, GIN_SHARE);</span>
<span class="lineNum">     753 </span><span class="lineCov">       1822 :         page = (Page) BufferGetPage(buffer);</span>
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span><span class="lineCov">       1822 :         if (GinPageIsRecyclable(page))</span>
<span class="lineNum">     756 </span>            :         {
<span class="lineNum">     757 </span><span class="lineCov">        926 :             Assert(blkno != GIN_ROOT_BLKNO);</span>
<span class="lineNum">     758 </span><span class="lineCov">        926 :             RecordFreeIndexPage(index, blkno);</span>
<span class="lineNum">     759 </span><span class="lineCov">        926 :             totFreePages++;</span>
<span class="lineNum">     760 </span>            :         }
<span class="lineNum">     761 </span><span class="lineCov">        896 :         else if (GinPageIsData(page))</span>
<span class="lineNum">     762 </span>            :         {
<span class="lineNum">     763 </span><span class="lineCov">         52 :             idxStat.nDataPages++;</span>
<span class="lineNum">     764 </span>            :         }
<span class="lineNum">     765 </span><span class="lineCov">        844 :         else if (!GinPageIsList(page))</span>
<span class="lineNum">     766 </span>            :         {
<span class="lineNum">     767 </span><span class="lineCov">        844 :             idxStat.nEntryPages++;</span>
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span><span class="lineCov">        844 :             if (GinPageIsLeaf(page))</span>
<span class="lineNum">     770 </span><span class="lineCov">        836 :                 idxStat.nEntries += PageGetMaxOffsetNumber(page);</span>
<span class="lineNum">     771 </span>            :         }
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span><span class="lineCov">       1822 :         UnlockReleaseBuffer(buffer);</span>
<span class="lineNum">     774 </span>            :     }
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span>            :     /* Update the metapage with accurate page and entry counts */
<span class="lineNum">     777 </span><span class="lineCov">         10 :     idxStat.nTotalPages = npages;</span>
<span class="lineNum">     778 </span><span class="lineCov">         10 :     ginUpdateStats(info-&gt;index, &amp;idxStat, false);</span>
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            :     /* Finally, vacuum the FSM */
<span class="lineNum">     781 </span><span class="lineCov">         10 :     IndexFreeSpaceMapVacuum(info-&gt;index);</span>
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span><span class="lineCov">         10 :     stats-&gt;pages_free = totFreePages;</span>
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span><span class="lineCov">         10 :     if (needLock)</span>
<span class="lineNum">     786 </span><span class="lineCov">         10 :         LockRelationForExtension(index, ExclusiveLock);</span>
<span class="lineNum">     787 </span><span class="lineCov">         10 :     stats-&gt;num_pages = RelationGetNumberOfBlocks(index);</span>
<span class="lineNum">     788 </span><span class="lineCov">         10 :     if (needLock)</span>
<span class="lineNum">     789 </span><span class="lineCov">         10 :         UnlockRelationForExtension(index, ExclusiveLock);</span>
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span><span class="lineCov">         10 :     return stats;</span>
<span class="lineNum">     792 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
