<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - PostgreSQL 13devel - src/backend/access/nbtree/nbtinsert.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/backend/access/nbtree</a> - nbtinsert.c<span style="font-size: 80%;"> (source / <a href="nbtinsert.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">PostgreSQL 13devel</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">512</td>
            <td class="headerCovTableEntry">651</td>
            <td class="headerCovTableEntryMed">78.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-27 09:34:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntryMed">83.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * nbtinsert.c
<span class="lineNum">       4 </span>            :  *    Item insertion in Lehman and Yao btrees for Postgres.
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
<span class="lineNum">       7 </span>            :  * Portions Copyright (c) 1994, Regents of the University of California
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * IDENTIFICATION
<span class="lineNum">      11 </span>            :  *    src/backend/access/nbtree/nbtinsert.c
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  *-------------------------------------------------------------------------
<span class="lineNum">      14 </span>            :  */
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &quot;postgres.h&quot;
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #include &quot;access/nbtree.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;access/nbtxlog.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;access/tableam.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;access/transam.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;access/xloginsert.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;miscadmin.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;storage/lmgr.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;storage/predicate.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;storage/smgr.h&quot;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : /* Minimum tree height for application of fastpath optimization */
<span class="lineNum">      29 </span>            : #define BTREE_FASTPATH_MIN_LEVEL    2
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : static Buffer _bt_newroot(Relation rel, Buffer lbuf, Buffer rbuf);
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : static TransactionId _bt_check_unique(Relation rel, BTInsertState insertstate,
<span class="lineNum">      35 </span>            :                                       Relation heapRel,
<span class="lineNum">      36 </span>            :                                       IndexUniqueCheck checkUnique, bool *is_unique,
<span class="lineNum">      37 </span>            :                                       uint32 *speculativeToken);
<span class="lineNum">      38 </span>            : static OffsetNumber _bt_findinsertloc(Relation rel,
<span class="lineNum">      39 </span>            :                                       BTInsertState insertstate,
<span class="lineNum">      40 </span>            :                                       bool checkingunique,
<span class="lineNum">      41 </span>            :                                       BTStack stack,
<span class="lineNum">      42 </span>            :                                       Relation heapRel);
<span class="lineNum">      43 </span>            : static void _bt_stepright(Relation rel, BTInsertState insertstate, BTStack stack);
<span class="lineNum">      44 </span>            : static void _bt_insertonpg(Relation rel, BTScanInsert itup_key,
<span class="lineNum">      45 </span>            :                            Buffer buf,
<span class="lineNum">      46 </span>            :                            Buffer cbuf,
<span class="lineNum">      47 </span>            :                            BTStack stack,
<span class="lineNum">      48 </span>            :                            IndexTuple itup,
<span class="lineNum">      49 </span>            :                            OffsetNumber newitemoff,
<span class="lineNum">      50 </span>            :                            bool split_only_page);
<span class="lineNum">      51 </span>            : static Buffer _bt_split(Relation rel, BTScanInsert itup_key, Buffer buf,
<span class="lineNum">      52 </span>            :                         Buffer cbuf, OffsetNumber newitemoff, Size newitemsz,
<span class="lineNum">      53 </span>            :                         IndexTuple newitem);
<span class="lineNum">      54 </span>            : static void _bt_insert_parent(Relation rel, Buffer buf, Buffer rbuf,
<span class="lineNum">      55 </span>            :                               BTStack stack, bool is_root, bool is_only);
<span class="lineNum">      56 </span>            : static bool _bt_pgaddtup(Page page, Size itemsize, IndexTuple itup,
<span class="lineNum">      57 </span>            :                          OffsetNumber itup_off);
<span class="lineNum">      58 </span>            : static void _bt_vacuum_one_page(Relation rel, Buffer buffer, Relation heapRel);
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : /*
<span class="lineNum">      61 </span>            :  *  _bt_doinsert() -- Handle insertion of a single index tuple in the tree.
<span class="lineNum">      62 </span>            :  *
<span class="lineNum">      63 </span>            :  *      This routine is called by the public interface routine, btinsert.
<span class="lineNum">      64 </span>            :  *      By here, itup is filled in, including the TID.
<span class="lineNum">      65 </span>            :  *
<span class="lineNum">      66 </span>            :  *      If checkUnique is UNIQUE_CHECK_NO or UNIQUE_CHECK_PARTIAL, this
<span class="lineNum">      67 </span>            :  *      will allow duplicates.  Otherwise (UNIQUE_CHECK_YES or
<span class="lineNum">      68 </span>            :  *      UNIQUE_CHECK_EXISTING) it will throw error for a duplicate.
<span class="lineNum">      69 </span>            :  *      For UNIQUE_CHECK_EXISTING we merely run the duplicate check, and
<span class="lineNum">      70 </span>            :  *      don't actually insert.
<span class="lineNum">      71 </span>            :  *
<span class="lineNum">      72 </span>            :  *      The result value is only significant for UNIQUE_CHECK_PARTIAL:
<span class="lineNum">      73 </span>            :  *      it must be true if the entry is known unique, else false.
<span class="lineNum">      74 </span>            :  *      (In the current implementation we'll also return true after a
<span class="lineNum">      75 </span>            :  *      successful UNIQUE_CHECK_YES or UNIQUE_CHECK_EXISTING call, but
<span class="lineNum">      76 </span>            :  *      that's just a coding artifact.)
<a name="77"><span class="lineNum">      77 </span>            :  */</a>
<span class="lineNum">      78 </span>            : bool
<span class="lineNum">      79 </span><span class="lineCov">     633802 : _bt_doinsert(Relation rel, IndexTuple itup,</span>
<span class="lineNum">      80 </span>            :              IndexUniqueCheck checkUnique, Relation heapRel)
<span class="lineNum">      81 </span>            : {
<span class="lineNum">      82 </span><span class="lineCov">     633802 :     bool        is_unique = false;</span>
<span class="lineNum">      83 </span>            :     BTInsertStateData insertstate;
<span class="lineNum">      84 </span>            :     BTScanInsert itup_key;
<span class="lineNum">      85 </span><span class="lineCov">     633802 :     BTStack     stack = NULL;</span>
<span class="lineNum">      86 </span>            :     Buffer      buf;
<span class="lineNum">      87 </span>            :     bool        fastpath;
<span class="lineNum">      88 </span><span class="lineCov">     633802 :     bool        checkingunique = (checkUnique != UNIQUE_CHECK_NO);</span>
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            :     /* we need an insertion scan key to do our search, so build one */
<span class="lineNum">      91 </span><span class="lineCov">     633802 :     itup_key = _bt_mkscankey(rel, itup);</span>
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span><span class="lineCov">     633802 :     if (checkingunique)</span>
<span class="lineNum">      94 </span>            :     {
<span class="lineNum">      95 </span><span class="lineCov">     378744 :         if (!itup_key-&gt;anynullkeys)</span>
<span class="lineNum">      96 </span>            :         {
<span class="lineNum">      97 </span>            :             /* No (heapkeyspace) scantid until uniqueness established */
<span class="lineNum">      98 </span><span class="lineCov">     378696 :             itup_key-&gt;scantid = NULL;</span>
<span class="lineNum">      99 </span>            :         }
<span class="lineNum">     100 </span>            :         else
<span class="lineNum">     101 </span>            :         {
<span class="lineNum">     102 </span>            :             /*
<span class="lineNum">     103 </span>            :              * Scan key for new tuple contains NULL key values.  Bypass
<span class="lineNum">     104 </span>            :              * checkingunique steps.  They are unnecessary because core code
<span class="lineNum">     105 </span>            :              * considers NULL unequal to every value, including NULL.
<span class="lineNum">     106 </span>            :              *
<span class="lineNum">     107 </span>            :              * This optimization avoids O(N^2) behavior within the
<span class="lineNum">     108 </span>            :              * _bt_findinsertloc() heapkeyspace path when a unique index has a
<span class="lineNum">     109 </span>            :              * large number of &quot;duplicates&quot; with NULL key values.
<span class="lineNum">     110 </span>            :              */
<span class="lineNum">     111 </span><span class="lineCov">         48 :             checkingunique = false;</span>
<span class="lineNum">     112 </span>            :             /* Tuple is unique in the sense that core code cares about */
<span class="lineNum">     113 </span><span class="lineCov">         48 :             Assert(checkUnique != UNIQUE_CHECK_EXISTING);</span>
<span class="lineNum">     114 </span><span class="lineCov">         48 :             is_unique = true;</span>
<span class="lineNum">     115 </span>            :         }
<span class="lineNum">     116 </span>            :     }
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            :     /*
<span class="lineNum">     119 </span>            :      * Fill in the BTInsertState working area, to track the current page and
<span class="lineNum">     120 </span>            :      * position within the page to insert on
<span class="lineNum">     121 </span>            :      */
<span class="lineNum">     122 </span><span class="lineCov">     633802 :     insertstate.itup = itup;</span>
<span class="lineNum">     123 </span>            :     /* PageAddItem will MAXALIGN(), but be consistent */
<span class="lineNum">     124 </span><span class="lineCov">     633802 :     insertstate.itemsz = MAXALIGN(IndexTupleSize(itup));</span>
<span class="lineNum">     125 </span><span class="lineCov">     633802 :     insertstate.itup_key = itup_key;</span>
<span class="lineNum">     126 </span><span class="lineCov">     633802 :     insertstate.bounds_valid = false;</span>
<span class="lineNum">     127 </span><span class="lineCov">     633802 :     insertstate.buf = InvalidBuffer;</span>
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            :     /*
<span class="lineNum">     130 </span>            :      * It's very common to have an index on an auto-incremented or
<span class="lineNum">     131 </span>            :      * monotonically increasing value. In such cases, every insertion happens
<span class="lineNum">     132 </span>            :      * towards the end of the index. We try to optimize that case by caching
<span class="lineNum">     133 </span>            :      * the right-most leaf of the index. If our cached block is still the
<span class="lineNum">     134 </span>            :      * rightmost leaf, has enough free space to accommodate a new entry and
<span class="lineNum">     135 </span>            :      * the insertion key is strictly greater than the first key in this page,
<span class="lineNum">     136 </span>            :      * then we can safely conclude that the new key will be inserted in the
<span class="lineNum">     137 </span>            :      * cached block. So we simply search within the cached block and insert
<span class="lineNum">     138 </span>            :      * the key at the appropriate location. We call it a fastpath.
<span class="lineNum">     139 </span>            :      *
<span class="lineNum">     140 </span>            :      * Testing has revealed, though, that the fastpath can result in increased
<span class="lineNum">     141 </span>            :      * contention on the exclusive-lock on the rightmost leaf page. So we
<span class="lineNum">     142 </span>            :      * conditionally check if the lock is available. If it's not available
<span class="lineNum">     143 </span>            :      * then we simply abandon the fastpath and take the regular path. This
<span class="lineNum">     144 </span>            :      * makes sense because unavailability of the lock also signals that some
<span class="lineNum">     145 </span>            :      * other backend might be concurrently inserting into the page, thus
<span class="lineNum">     146 </span>            :      * reducing our chances to finding an insertion place in this page.
<span class="lineNum">     147 </span>            :      */
<span class="lineNum">     148 </span>            : top:
<span class="lineNum">     149 </span><span class="lineCov">     633802 :     fastpath = false;</span>
<span class="lineNum">     150 </span><span class="lineCov">     633802 :     if (RelationGetTargetBlock(rel) != InvalidBlockNumber)</span>
<span class="lineNum">     151 </span>            :     {
<span class="lineNum">     152 </span>            :         Page        page;
<span class="lineNum">     153 </span>            :         BTPageOpaque lpageop;
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            :         /*
<span class="lineNum">     156 </span>            :          * Conditionally acquire exclusive lock on the buffer before doing any
<span class="lineNum">     157 </span>            :          * checks. If we don't get the lock, we simply follow slowpath. If we
<span class="lineNum">     158 </span>            :          * do get the lock, this ensures that the index state cannot change,
<span class="lineNum">     159 </span>            :          * as far as the rightmost part of the index is concerned.
<span class="lineNum">     160 </span>            :          */
<span class="lineNum">     161 </span><span class="lineCov">         16 :         buf = ReadBuffer(rel, RelationGetTargetBlock(rel));</span>
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span><span class="lineCov">         16 :         if (ConditionalLockBuffer(buf))</span>
<span class="lineNum">     164 </span>            :         {
<span class="lineNum">     165 </span><span class="lineCov">         16 :             _bt_checkpage(rel, buf);</span>
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span><span class="lineCov">         16 :             page = BufferGetPage(buf);</span>
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span><span class="lineCov">         16 :             lpageop = (BTPageOpaque) PageGetSpecialPointer(page);</span>
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            :             /*
<span class="lineNum">     172 </span>            :              * Check if the page is still the rightmost leaf page, has enough
<span class="lineNum">     173 </span>            :              * free space to accommodate the new tuple, and the insertion scan
<span class="lineNum">     174 </span>            :              * key is strictly greater than the first key on the page.
<span class="lineNum">     175 </span>            :              */
<span class="lineNum">     176 </span><span class="lineCov">         32 :             if (P_ISLEAF(lpageop) &amp;&amp; P_RIGHTMOST(lpageop) &amp;&amp;</span>
<span class="lineNum">     177 </span><span class="lineCov">         32 :                 !P_IGNORE(lpageop) &amp;&amp;</span>
<span class="lineNum">     178 </span><span class="lineCov">         24 :                 (PageGetFreeSpace(page) &gt; insertstate.itemsz) &amp;&amp;</span>
<span class="lineNum">     179 </span><span class="lineCov">         16 :                 PageGetMaxOffsetNumber(page) &gt;= P_FIRSTDATAKEY(lpageop) &amp;&amp;</span>
<span class="lineNum">     180 </span><span class="lineCov">          8 :                 _bt_compare(rel, itup_key, page, P_FIRSTDATAKEY(lpageop)) &gt; 0)</span>
<span class="lineNum">     181 </span>            :             {
<span class="lineNum">     182 </span>            :                 /*
<span class="lineNum">     183 </span>            :                  * The right-most block should never have an incomplete split.
<span class="lineNum">     184 </span>            :                  * But be paranoid and check for it anyway.
<span class="lineNum">     185 </span>            :                  */
<span class="lineNum">     186 </span><span class="lineCov">          8 :                 Assert(!P_INCOMPLETE_SPLIT(lpageop));</span>
<span class="lineNum">     187 </span><span class="lineCov">          8 :                 fastpath = true;</span>
<span class="lineNum">     188 </span>            :             }
<span class="lineNum">     189 </span>            :             else
<span class="lineNum">     190 </span>            :             {
<span class="lineNum">     191 </span><span class="lineCov">          8 :                 _bt_relbuf(rel, buf);</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :                 /*
<span class="lineNum">     194 </span>            :                  * Something did not work out. Just forget about the cached
<span class="lineNum">     195 </span>            :                  * block and follow the normal path. It might be set again if
<span class="lineNum">     196 </span>            :                  * the conditions are favourable.
<span class="lineNum">     197 </span>            :                  */
<span class="lineNum">     198 </span><span class="lineCov">          8 :                 RelationSetTargetBlock(rel, InvalidBlockNumber);</span>
<span class="lineNum">     199 </span>            :             }
<span class="lineNum">     200 </span>            :         }
<span class="lineNum">     201 </span>            :         else
<span class="lineNum">     202 </span>            :         {
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :             ReleaseBuffer(buf);</span>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :             /*
<span class="lineNum">     206 </span>            :              * If someone's holding a lock, it's likely to change anyway, so
<span class="lineNum">     207 </span>            :              * don't try again until we get an updated rightmost leaf.
<span class="lineNum">     208 </span>            :              */
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :             RelationSetTargetBlock(rel, InvalidBlockNumber);</span>
<span class="lineNum">     210 </span>            :         }
<span class="lineNum">     211 </span>            :     }
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span><span class="lineCov">     633802 :     if (!fastpath)</span>
<span class="lineNum">     214 </span>            :     {
<span class="lineNum">     215 </span>            :         /*
<span class="lineNum">     216 </span>            :          * Find the first page containing this key.  Buffer returned by
<span class="lineNum">     217 </span>            :          * _bt_search() is locked in exclusive mode.
<span class="lineNum">     218 </span>            :          */
<span class="lineNum">     219 </span><span class="lineCov">     633794 :         stack = _bt_search(rel, itup_key, &amp;buf, BT_WRITE, NULL);</span>
<span class="lineNum">     220 </span>            :     }
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span><span class="lineCov">     633802 :     insertstate.buf = buf;</span>
<span class="lineNum">     223 </span><span class="lineCov">     633802 :     buf = InvalidBuffer;        /* insertstate.buf now owns the buffer */</span>
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :     /*
<span class="lineNum">     226 </span>            :      * If we're not allowing duplicates, make sure the key isn't already in
<span class="lineNum">     227 </span>            :      * the index.
<span class="lineNum">     228 </span>            :      *
<span class="lineNum">     229 </span>            :      * NOTE: obviously, _bt_check_unique can only detect keys that are already
<span class="lineNum">     230 </span>            :      * in the index; so it cannot defend against concurrent insertions of the
<span class="lineNum">     231 </span>            :      * same key.  We protect against that by means of holding a write lock on
<span class="lineNum">     232 </span>            :      * the first page the value could be on, with omitted/-inf value for the
<span class="lineNum">     233 </span>            :      * implicit heap TID tiebreaker attribute.  Any other would-be inserter of
<span class="lineNum">     234 </span>            :      * the same key must acquire a write lock on the same page, so only one
<span class="lineNum">     235 </span>            :      * would-be inserter can be making the check at one time.  Furthermore,
<span class="lineNum">     236 </span>            :      * once we are past the check we hold write locks continuously until we
<span class="lineNum">     237 </span>            :      * have performed our insertion, so no later inserter can fail to see our
<span class="lineNum">     238 </span>            :      * insertion.  (This requires some care in _bt_findinsertloc.)
<span class="lineNum">     239 </span>            :      *
<span class="lineNum">     240 </span>            :      * If we must wait for another xact, we release the lock while waiting,
<span class="lineNum">     241 </span>            :      * and then must start over completely.
<span class="lineNum">     242 </span>            :      *
<span class="lineNum">     243 </span>            :      * For a partial uniqueness check, we don't wait for the other xact. Just
<span class="lineNum">     244 </span>            :      * let the tuple in and return false for possibly non-unique, or true for
<span class="lineNum">     245 </span>            :      * definitely unique.
<span class="lineNum">     246 </span>            :      */
<span class="lineNum">     247 </span><span class="lineCov">     633802 :     if (checkingunique)</span>
<span class="lineNum">     248 </span>            :     {
<span class="lineNum">     249 </span>            :         TransactionId xwait;
<span class="lineNum">     250 </span>            :         uint32      speculativeToken;
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span><span class="lineCov">     378696 :         xwait = _bt_check_unique(rel, &amp;insertstate, heapRel, checkUnique,</span>
<span class="lineNum">     253 </span>            :                                  &amp;is_unique, &amp;speculativeToken);
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span><span class="lineCov">     378598 :         if (TransactionIdIsValid(xwait))</span>
<span class="lineNum">     256 </span>            :         {
<span class="lineNum">     257 </span>            :             /* Have to wait for the other guy ... */
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :             _bt_relbuf(rel, insertstate.buf);</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :             insertstate.buf = InvalidBuffer;</span>
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :             /*
<span class="lineNum">     262 </span>            :              * If it's a speculative insertion, wait for it to finish (ie. to
<span class="lineNum">     263 </span>            :              * go ahead with the insertion, or kill the tuple).  Otherwise
<span class="lineNum">     264 </span>            :              * wait for the transaction to finish as usual.
<span class="lineNum">     265 </span>            :              */
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :             if (speculativeToken)</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :                 SpeculativeInsertionWait(xwait, speculativeToken);</span>
<span class="lineNum">     268 </span>            :             else
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :                 XactLockTableWait(xwait, rel, &amp;itup-&gt;t_tid, XLTW_InsertIndex);</span>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :             /* start over... */
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :             if (stack)</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :                 _bt_freestack(stack);</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :             goto top;</span>
<span class="lineNum">     275 </span>            :         }
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :         /* Uniqueness is established -- restore heap tid as scantid */
<span class="lineNum">     278 </span><span class="lineCov">     378598 :         if (itup_key-&gt;heapkeyspace)</span>
<span class="lineNum">     279 </span><span class="lineCov">     378598 :             itup_key-&gt;scantid = &amp;itup-&gt;t_tid;</span>
<span class="lineNum">     280 </span>            :     }
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span><span class="lineCov">     633704 :     if (checkUnique != UNIQUE_CHECK_EXISTING)</span>
<span class="lineNum">     283 </span>            :     {
<span class="lineNum">     284 </span>            :         OffsetNumber newitemoff;
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :         /*
<span class="lineNum">     287 </span>            :          * The only conflict predicate locking cares about for indexes is when
<span class="lineNum">     288 </span>            :          * an index tuple insert conflicts with an existing lock.  We don't
<span class="lineNum">     289 </span>            :          * know the actual page we're going to insert on for sure just yet in
<span class="lineNum">     290 </span>            :          * checkingunique and !heapkeyspace cases, but it's okay to use the
<span class="lineNum">     291 </span>            :          * first page the value could be on (with scantid omitted) instead.
<span class="lineNum">     292 </span>            :          */
<span class="lineNum">     293 </span><span class="lineCov">     633686 :         CheckForSerializableConflictIn(rel, NULL, insertstate.buf);</span>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :         /*
<span class="lineNum">     296 </span>            :          * Do the insertion.  Note that insertstate contains cached binary
<span class="lineNum">     297 </span>            :          * search bounds established within _bt_check_unique when insertion is
<span class="lineNum">     298 </span>            :          * checkingunique.
<span class="lineNum">     299 </span>            :          */
<span class="lineNum">     300 </span><span class="lineCov">     633686 :         newitemoff = _bt_findinsertloc(rel, &amp;insertstate, checkingunique,</span>
<span class="lineNum">     301 </span>            :                                        stack, heapRel);
<span class="lineNum">     302 </span><span class="lineCov">     633686 :         _bt_insertonpg(rel, itup_key, insertstate.buf, InvalidBuffer, stack,</span>
<span class="lineNum">     303 </span>            :                        itup, newitemoff, false);
<span class="lineNum">     304 </span>            :     }
<span class="lineNum">     305 </span>            :     else
<span class="lineNum">     306 </span>            :     {
<span class="lineNum">     307 </span>            :         /* just release the buffer */
<span class="lineNum">     308 </span><span class="lineCov">         18 :         _bt_relbuf(rel, insertstate.buf);</span>
<span class="lineNum">     309 </span>            :     }
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :     /* be tidy */
<span class="lineNum">     312 </span><span class="lineCov">     633704 :     if (stack)</span>
<span class="lineNum">     313 </span><span class="lineCov">     585820 :         _bt_freestack(stack);</span>
<span class="lineNum">     314 </span><span class="lineCov">     633704 :     pfree(itup_key);</span>
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span><span class="lineCov">     633704 :     return is_unique;</span>
<span class="lineNum">     317 </span>            : }
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            : /*
<span class="lineNum">     320 </span>            :  *  _bt_check_unique() -- Check for violation of unique index constraint
<span class="lineNum">     321 </span>            :  *
<span class="lineNum">     322 </span>            :  * Returns InvalidTransactionId if there is no conflict, else an xact ID
<span class="lineNum">     323 </span>            :  * we must wait for to see if it commits a conflicting tuple.   If an actual
<span class="lineNum">     324 </span>            :  * conflict is detected, no return --- just ereport().  If an xact ID is
<span class="lineNum">     325 </span>            :  * returned, and the conflicting tuple still has a speculative insertion in
<span class="lineNum">     326 </span>            :  * progress, *speculativeToken is set to non-zero, and the caller can wait for
<span class="lineNum">     327 </span>            :  * the verdict on the insertion using SpeculativeInsertionWait().
<span class="lineNum">     328 </span>            :  *
<span class="lineNum">     329 </span>            :  * However, if checkUnique == UNIQUE_CHECK_PARTIAL, we always return
<span class="lineNum">     330 </span>            :  * InvalidTransactionId because we don't want to wait.  In this case we
<span class="lineNum">     331 </span>            :  * set *is_unique to false if there is a potential conflict, and the
<span class="lineNum">     332 </span>            :  * core code must redo the uniqueness check later.
<span class="lineNum">     333 </span>            :  *
<span class="lineNum">     334 </span>            :  * As a side-effect, sets state in insertstate that can later be used by
<span class="lineNum">     335 </span>            :  * _bt_findinsertloc() to reuse most of the binary search work we do
<span class="lineNum">     336 </span>            :  * here.
<span class="lineNum">     337 </span>            :  *
<span class="lineNum">     338 </span>            :  * Do not call here when there are NULL values in scan key.  NULL should be
<span class="lineNum">     339 </span>            :  * considered unequal to NULL when checking for duplicates, but we are not
<span class="lineNum">     340 </span>            :  * prepared to handle that correctly.
<a name="341"><span class="lineNum">     341 </span>            :  */</a>
<span class="lineNum">     342 </span>            : static TransactionId
<span class="lineNum">     343 </span><span class="lineCov">     378696 : _bt_check_unique(Relation rel, BTInsertState insertstate, Relation heapRel,</span>
<span class="lineNum">     344 </span>            :                  IndexUniqueCheck checkUnique, bool *is_unique,
<span class="lineNum">     345 </span>            :                  uint32 *speculativeToken)
<span class="lineNum">     346 </span>            : {
<span class="lineNum">     347 </span><span class="lineCov">     378696 :     IndexTuple  itup = insertstate-&gt;itup;</span>
<span class="lineNum">     348 </span><span class="lineCov">     378696 :     BTScanInsert itup_key = insertstate-&gt;itup_key;</span>
<span class="lineNum">     349 </span>            :     SnapshotData SnapshotDirty;
<span class="lineNum">     350 </span>            :     OffsetNumber offset;
<span class="lineNum">     351 </span>            :     OffsetNumber maxoff;
<span class="lineNum">     352 </span>            :     Page        page;
<span class="lineNum">     353 </span>            :     BTPageOpaque opaque;
<span class="lineNum">     354 </span><span class="lineCov">     378696 :     Buffer      nbuf = InvalidBuffer;</span>
<span class="lineNum">     355 </span><span class="lineCov">     378696 :     bool        found = false;</span>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            :     /* Assume unique until we find a duplicate */
<span class="lineNum">     358 </span><span class="lineCov">     378696 :     *is_unique = true;</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span><span class="lineCov">     378696 :     InitDirtySnapshot(SnapshotDirty);</span>
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span><span class="lineCov">     378696 :     page = BufferGetPage(insertstate-&gt;buf);</span>
<span class="lineNum">     363 </span><span class="lineCov">     378696 :     opaque = (BTPageOpaque) PageGetSpecialPointer(page);</span>
<span class="lineNum">     364 </span><span class="lineCov">     378696 :     maxoff = PageGetMaxOffsetNumber(page);</span>
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            :     /*
<span class="lineNum">     367 </span>            :      * Find the first tuple with the same key.
<span class="lineNum">     368 </span>            :      *
<span class="lineNum">     369 </span>            :      * This also saves the binary search bounds in insertstate.  We use them
<span class="lineNum">     370 </span>            :      * in the fastpath below, but also in the _bt_findinsertloc() call later.
<span class="lineNum">     371 </span>            :      */
<span class="lineNum">     372 </span><span class="lineCov">     378696 :     Assert(!insertstate-&gt;bounds_valid);</span>
<span class="lineNum">     373 </span><span class="lineCov">     378696 :     offset = _bt_binsrch_insert(rel, insertstate);</span>
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            :     /*
<span class="lineNum">     376 </span>            :      * Scan over all equal tuples, looking for live conflicts.
<span class="lineNum">     377 </span>            :      */
<span class="lineNum">     378 </span><span class="lineCov">     378696 :     Assert(!insertstate-&gt;bounds_valid || insertstate-&gt;low == offset);</span>
<span class="lineNum">     379 </span><span class="lineCov">     378696 :     Assert(!itup_key-&gt;anynullkeys);</span>
<span class="lineNum">     380 </span><span class="lineCov">     378696 :     Assert(itup_key-&gt;scantid == NULL);</span>
<span class="lineNum">     381 </span>            :     for (;;)
<span class="lineNum">     382 </span>            :     {
<span class="lineNum">     383 </span>            :         ItemId      curitemid;
<span class="lineNum">     384 </span>            :         IndexTuple  curitup;
<span class="lineNum">     385 </span>            :         BlockNumber nblkno;
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            :         /*
<span class="lineNum">     388 </span>            :          * make sure the offset points to an actual item before trying to
<span class="lineNum">     389 </span>            :          * examine it...
<span class="lineNum">     390 </span>            :          */
<span class="lineNum">     391 </span><span class="lineCov">     454058 :         if (offset &lt;= maxoff)</span>
<span class="lineNum">     392 </span>            :         {
<span class="lineNum">     393 </span>            :             /*
<span class="lineNum">     394 </span>            :              * Fastpath: In most cases, we can use cached search bounds to
<span class="lineNum">     395 </span>            :              * limit our consideration to items that are definitely
<span class="lineNum">     396 </span>            :              * duplicates.  This fastpath doesn't apply when the original page
<span class="lineNum">     397 </span>            :              * is empty, or when initial offset is past the end of the
<span class="lineNum">     398 </span>            :              * original page, which may indicate that we need to examine a
<span class="lineNum">     399 </span>            :              * second or subsequent page.
<span class="lineNum">     400 </span>            :              *
<span class="lineNum">     401 </span>            :              * Note that this optimization allows us to avoid calling
<span class="lineNum">     402 </span>            :              * _bt_compare() directly when there are no duplicates, as long as
<span class="lineNum">     403 </span>            :              * the offset where the key will go is not at the end of the page.
<span class="lineNum">     404 </span>            :              */
<span class="lineNum">     405 </span><span class="lineCov">     257210 :             if (nbuf == InvalidBuffer &amp;&amp; offset == insertstate-&gt;stricthigh)</span>
<span class="lineNum">     406 </span>            :             {
<span class="lineNum">     407 </span><span class="lineCov">     169970 :                 Assert(insertstate-&gt;bounds_valid);</span>
<span class="lineNum">     408 </span><span class="lineCov">     169970 :                 Assert(insertstate-&gt;low &gt;= P_FIRSTDATAKEY(opaque));</span>
<span class="lineNum">     409 </span><span class="lineCov">     169970 :                 Assert(insertstate-&gt;low &lt;= insertstate-&gt;stricthigh);</span>
<span class="lineNum">     410 </span><span class="lineCov">     169970 :                 Assert(_bt_compare(rel, itup_key, page, offset) &lt; 0);</span>
<span class="lineNum">     411 </span><span class="lineCov">     169970 :                 break;</span>
<span class="lineNum">     412 </span>            :             }
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span><span class="lineCov">      87240 :             curitemid = PageGetItemId(page, offset);</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            :             /*
<span class="lineNum">     417 </span>            :              * We can skip items that are marked killed.
<span class="lineNum">     418 </span>            :              *
<span class="lineNum">     419 </span>            :              * In the presence of heavy update activity an index may contain
<span class="lineNum">     420 </span>            :              * many killed items with the same key; running _bt_compare() on
<span class="lineNum">     421 </span>            :              * each killed item gets expensive.  Just advance over killed
<span class="lineNum">     422 </span>            :              * items as quickly as we can.  We only apply _bt_compare() when
<span class="lineNum">     423 </span>            :              * we get to a non-killed item.  Even those comparisons could be
<span class="lineNum">     424 </span>            :              * avoided (in the common case where there is only one page to
<span class="lineNum">     425 </span>            :              * visit) by reusing bounds, but just skipping dead items is fast
<span class="lineNum">     426 </span>            :              * enough.
<span class="lineNum">     427 </span>            :              */
<span class="lineNum">     428 </span><span class="lineCov">      87240 :             if (!ItemIdIsDead(curitemid))</span>
<span class="lineNum">     429 </span>            :             {
<span class="lineNum">     430 </span>            :                 ItemPointerData htid;
<span class="lineNum">     431 </span>            :                 bool        all_dead;
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span><span class="lineCov">      51364 :                 if (_bt_compare(rel, itup_key, page, offset) != 0)</span>
<span class="lineNum">     434 </span><span class="lineCov">      21484 :                     break;      /* we're past all the equal tuples */</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            :                 /* okay, we gotta fetch the heap tuple ... */
<span class="lineNum">     437 </span><span class="lineCov">      40622 :                 curitup = (IndexTuple) PageGetItem(page, curitemid);</span>
<span class="lineNum">     438 </span><span class="lineCov">      40622 :                 htid = curitup-&gt;t_tid;</span>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            :                 /*
<span class="lineNum">     441 </span>            :                  * If we are doing a recheck, we expect to find the tuple we
<span class="lineNum">     442 </span>            :                  * are rechecking.  It's not a duplicate, but we have to keep
<span class="lineNum">     443 </span>            :                  * scanning.
<span class="lineNum">     444 </span>            :                  */
<span class="lineNum">     445 </span><span class="lineCov">      40688 :                 if (checkUnique == UNIQUE_CHECK_EXISTING &amp;&amp;</span>
<span class="lineNum">     446 </span><span class="lineCov">         66 :                     ItemPointerCompare(&amp;htid, &amp;itup-&gt;t_tid) == 0)</span>
<span class="lineNum">     447 </span>            :                 {
<span class="lineNum">     448 </span><span class="lineCov">         18 :                     found = true;</span>
<span class="lineNum">     449 </span>            :                 }
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            :                 /*
<span class="lineNum">     452 </span>            :                  * Check if there's any table tuples for this index entry
<span class="lineNum">     453 </span>            :                  * satisfying SnapshotDirty. This is necessary because for AMs
<span class="lineNum">     454 </span>            :                  * with optimizations like heap's HOT, we have just a single
<span class="lineNum">     455 </span>            :                  * index entry for the entire chain.
<span class="lineNum">     456 </span>            :                  */
<span class="lineNum">     457 </span><span class="lineCov">      40604 :                 else if (table_index_fetch_tuple_check(heapRel, &amp;htid,</span>
<span class="lineNum">     458 </span>            :                                                        &amp;SnapshotDirty,
<span class="lineNum">     459 </span>            :                                                        &amp;all_dead))
<span class="lineNum">     460 </span>            :                 {
<span class="lineNum">     461 </span>            :                     TransactionId xwait;
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            :                     /*
<span class="lineNum">     464 </span>            :                      * It is a duplicate. If we are only doing a partial
<span class="lineNum">     465 </span>            :                      * check, then don't bother checking if the tuple is being
<span class="lineNum">     466 </span>            :                      * updated in another transaction. Just return the fact
<span class="lineNum">     467 </span>            :                      * that it is a potential conflict and leave the full
<span class="lineNum">     468 </span>            :                      * check till later. Don't invalidate binary search
<span class="lineNum">     469 </span>            :                      * bounds.
<span class="lineNum">     470 </span>            :                      */
<span class="lineNum">     471 </span><span class="lineCov">        130 :                     if (checkUnique == UNIQUE_CHECK_PARTIAL)</span>
<span class="lineNum">     472 </span>            :                     {
<span class="lineNum">     473 </span><span class="lineCov">         32 :                         if (nbuf != InvalidBuffer)</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                             _bt_relbuf(rel, nbuf);</span>
<span class="lineNum">     475 </span><span class="lineCov">         32 :                         *is_unique = false;</span>
<span class="lineNum">     476 </span><span class="lineCov">         64 :                         return InvalidTransactionId;</span>
<span class="lineNum">     477 </span>            :                     }
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            :                     /*
<span class="lineNum">     480 </span>            :                      * If this tuple is being updated by other transaction
<span class="lineNum">     481 </span>            :                      * then we have to wait for its commit/abort.
<span class="lineNum">     482 </span>            :                      */
<span class="lineNum">     483 </span><span class="lineCov">        196 :                     xwait = (TransactionIdIsValid(SnapshotDirty.xmin)) ?</span>
<span class="lineNum">     484 </span><span class="lineCov">         98 :                         SnapshotDirty.xmin : SnapshotDirty.xmax;</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineCov">         98 :                     if (TransactionIdIsValid(xwait))</span>
<span class="lineNum">     487 </span>            :                     {
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :                         if (nbuf != InvalidBuffer)</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :                             _bt_relbuf(rel, nbuf);</span>
<span class="lineNum">     490 </span>            :                         /* Tell _bt_doinsert to wait... */
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :                         *speculativeToken = SnapshotDirty.speculativeToken;</span>
<span class="lineNum">     492 </span>            :                         /* Caller releases lock on buf immediately */
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :                         insertstate-&gt;bounds_valid = false;</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :                         return xwait;</span>
<span class="lineNum">     495 </span>            :                     }
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :                     /*
<span class="lineNum">     498 </span>            :                      * Otherwise we have a definite conflict.  But before
<span class="lineNum">     499 </span>            :                      * complaining, look to see if the tuple we want to insert
<span class="lineNum">     500 </span>            :                      * is itself now committed dead --- if so, don't complain.
<span class="lineNum">     501 </span>            :                      * This is a waste of time in normal scenarios but we must
<span class="lineNum">     502 </span>            :                      * do it to support CREATE INDEX CONCURRENTLY.
<span class="lineNum">     503 </span>            :                      *
<span class="lineNum">     504 </span>            :                      * We must follow HOT-chains here because during
<span class="lineNum">     505 </span>            :                      * concurrent index build, we insert the root TID though
<span class="lineNum">     506 </span>            :                      * the actual tuple may be somewhere in the HOT-chain.
<span class="lineNum">     507 </span>            :                      * While following the chain we might not stop at the
<span class="lineNum">     508 </span>            :                      * exact tuple which triggered the insert, but that's OK
<span class="lineNum">     509 </span>            :                      * because if we find a live tuple anywhere in this chain,
<span class="lineNum">     510 </span>            :                      * we have a unique key conflict.  The other live tuple is
<span class="lineNum">     511 </span>            :                      * not part of this chain because it had a different index
<span class="lineNum">     512 </span>            :                      * entry.
<span class="lineNum">     513 </span>            :                      */
<span class="lineNum">     514 </span><span class="lineCov">         98 :                     htid = itup-&gt;t_tid;</span>
<span class="lineNum">     515 </span><span class="lineCov">         98 :                     if (table_index_fetch_tuple_check(heapRel, &amp;htid,</span>
<span class="lineNum">     516 </span>            :                                                       SnapshotSelf, NULL))
<span class="lineNum">     517 </span>            :                     {
<span class="lineNum">     518 </span>            :                         /* Normal case --- it's still live */
<span class="lineNum">     519 </span>            :                     }
<span class="lineNum">     520 </span>            :                     else
<span class="lineNum">     521 </span>            :                     {
<span class="lineNum">     522 </span>            :                         /*
<span class="lineNum">     523 </span>            :                          * It's been deleted, so no error, and no need to
<span class="lineNum">     524 </span>            :                          * continue searching
<span class="lineNum">     525 </span>            :                          */
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     527 </span>            :                     }
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span>            :                     /*
<span class="lineNum">     530 </span>            :                      * Check for a conflict-in as we would if we were going to
<span class="lineNum">     531 </span>            :                      * write to this page.  We aren't actually going to write,
<span class="lineNum">     532 </span>            :                      * but we want a chance to report SSI conflicts that would
<span class="lineNum">     533 </span>            :                      * otherwise be masked by this unique constraint
<span class="lineNum">     534 </span>            :                      * violation.
<span class="lineNum">     535 </span>            :                      */
<span class="lineNum">     536 </span><span class="lineCov">         98 :                     CheckForSerializableConflictIn(rel, NULL, insertstate-&gt;buf);</span>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            :                     /*
<span class="lineNum">     539 </span>            :                      * This is a definite conflict.  Break the tuple down into
<span class="lineNum">     540 </span>            :                      * datums and report the error.  But first, make sure we
<span class="lineNum">     541 </span>            :                      * release the buffer locks we're holding ---
<span class="lineNum">     542 </span>            :                      * BuildIndexValueDescription could make catalog accesses,
<span class="lineNum">     543 </span>            :                      * which in the worst case might touch this same index and
<span class="lineNum">     544 </span>            :                      * cause deadlocks.
<span class="lineNum">     545 </span>            :                      */
<span class="lineNum">     546 </span><span class="lineCov">         98 :                     if (nbuf != InvalidBuffer)</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :                         _bt_relbuf(rel, nbuf);</span>
<span class="lineNum">     548 </span><span class="lineCov">         98 :                     _bt_relbuf(rel, insertstate-&gt;buf);</span>
<span class="lineNum">     549 </span><span class="lineCov">         98 :                     insertstate-&gt;buf = InvalidBuffer;</span>
<span class="lineNum">     550 </span><span class="lineCov">         98 :                     insertstate-&gt;bounds_valid = false;</span>
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            :                     {
<span class="lineNum">     553 </span>            :                         Datum       values[INDEX_MAX_KEYS];
<span class="lineNum">     554 </span>            :                         bool        isnull[INDEX_MAX_KEYS];
<span class="lineNum">     555 </span>            :                         char       *key_desc;
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineCov">         98 :                         index_deform_tuple(itup, RelationGetDescr(rel),</span>
<span class="lineNum">     558 </span>            :                                            values, isnull);
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span><span class="lineCov">         98 :                         key_desc = BuildIndexValueDescription(rel, values,</span>
<span class="lineNum">     561 </span>            :                                                               isnull);
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span><span class="lineCov">         98 :                         ereport(ERROR,</span>
<span class="lineNum">     564 </span>            :                                 (errcode(ERRCODE_UNIQUE_VIOLATION),
<span class="lineNum">     565 </span>            :                                  errmsg(&quot;duplicate key value violates unique constraint \&quot;%s\&quot;&quot;,
<span class="lineNum">     566 </span>            :                                         RelationGetRelationName(rel)),
<span class="lineNum">     567 </span>            :                                  key_desc ? errdetail(&quot;Key %s already exists.&quot;,
<span class="lineNum">     568 </span>            :                                                       key_desc) : 0,
<span class="lineNum">     569 </span>            :                                  errtableconstraint(heapRel,
<span class="lineNum">     570 </span>            :                                                     RelationGetRelationName(rel))));
<span class="lineNum">     571 </span>            :                     }
<span class="lineNum">     572 </span>            :                 }
<span class="lineNum">     573 </span><span class="lineCov">      40474 :                 else if (all_dead)</span>
<span class="lineNum">     574 </span>            :                 {
<span class="lineNum">     575 </span>            :                     /*
<span class="lineNum">     576 </span>            :                      * The conflicting tuple (or whole HOT chain) is dead to
<span class="lineNum">     577 </span>            :                      * everyone, so we may as well mark the index entry
<span class="lineNum">     578 </span>            :                      * killed.
<span class="lineNum">     579 </span>            :                      */
<span class="lineNum">     580 </span><span class="lineCov">        686 :                     ItemIdMarkDead(curitemid);</span>
<span class="lineNum">     581 </span><span class="lineCov">        686 :                     opaque-&gt;btpo_flags |= BTP_HAS_GARBAGE;</span>
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            :                     /*
<span class="lineNum">     584 </span>            :                      * Mark buffer with a dirty hint, since state is not
<span class="lineNum">     585 </span>            :                      * crucial. Be sure to mark the proper buffer dirty.
<span class="lineNum">     586 </span>            :                      */
<span class="lineNum">     587 </span><span class="lineCov">        686 :                     if (nbuf != InvalidBuffer)</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :                         MarkBufferDirtyHint(nbuf, true);</span>
<span class="lineNum">     589 </span>            :                     else
<span class="lineNum">     590 </span><span class="lineCov">        686 :                         MarkBufferDirtyHint(insertstate-&gt;buf, true);</span>
<span class="lineNum">     591 </span>            :                 }
<span class="lineNum">     592 </span>            :             }
<span class="lineNum">     593 </span>            :         }
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            :         /*
<span class="lineNum">     596 </span>            :          * Advance to next tuple to continue checking.
<span class="lineNum">     597 </span>            :          */
<span class="lineNum">     598 </span><span class="lineCov">     273216 :         if (offset &lt; maxoff)</span>
<span class="lineNum">     599 </span><span class="lineCov">      75362 :             offset = OffsetNumberNext(offset);</span>
<span class="lineNum">     600 </span>            :         else
<span class="lineNum">     601 </span>            :         {
<span class="lineNum">     602 </span>            :             int         highkeycmp;
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            :             /* If scankey == hikey we gotta check the next page too */
<span class="lineNum">     605 </span><span class="lineCov">     197854 :             if (P_RIGHTMOST(opaque))</span>
<span class="lineNum">     606 </span><span class="lineCov">     197556 :                 break;</span>
<span class="lineNum">     607 </span><span class="lineCov">        298 :             highkeycmp = _bt_compare(rel, itup_key, page, P_HIKEY);</span>
<span class="lineNum">     608 </span><span class="lineCov">        298 :             Assert(highkeycmp &lt;= 0);</span>
<span class="lineNum">     609 </span><span class="lineCov">        298 :             if (highkeycmp != 0)</span>
<span class="lineNum">     610 </span><span class="lineCov">        298 :                 break;</span>
<span class="lineNum">     611 </span>            :             /* Advance to next non-dead page --- there must be one */
<span class="lineNum">     612 </span>            :             for (;;)
<span class="lineNum">     613 </span>            :             {
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :                 nblkno = opaque-&gt;btpo_next;</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :                 nbuf = _bt_relandgetbuf(rel, nbuf, nblkno, BT_READ);</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :                 page = BufferGetPage(nbuf);</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :                 opaque = (BTPageOpaque) PageGetSpecialPointer(page);</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :                 if (!P_IGNORE(opaque))</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :                 if (P_RIGHTMOST(opaque))</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :                     elog(ERROR, &quot;fell off the end of index \&quot;%s\&quot;&quot;,</span>
<span class="lineNum">     622 </span>            :                          RelationGetRelationName(rel));
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :             maxoff = PageGetMaxOffsetNumber(page);</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :             offset = P_FIRSTDATAKEY(opaque);</span>
<span class="lineNum">     626 </span>            :             /* Don't invalidate binary search bounds */
<span class="lineNum">     627 </span>            :         }
<span class="lineNum">     628 </span><span class="lineCov">      75362 :     }</span>
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            :     /*
<span class="lineNum">     631 </span>            :      * If we are doing a recheck then we should have found the tuple we are
<span class="lineNum">     632 </span>            :      * checking.  Otherwise there's something very wrong --- probably, the
<span class="lineNum">     633 </span>            :      * index is on a non-immutable expression.
<span class="lineNum">     634 </span>            :      */
<span class="lineNum">     635 </span><span class="lineCov">     378566 :     if (checkUnique == UNIQUE_CHECK_EXISTING &amp;&amp; !found)</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :         ereport(ERROR,</span>
<span class="lineNum">     637 </span>            :                 (errcode(ERRCODE_INTERNAL_ERROR),
<span class="lineNum">     638 </span>            :                  errmsg(&quot;failed to re-find tuple within index \&quot;%s\&quot;&quot;,
<span class="lineNum">     639 </span>            :                         RelationGetRelationName(rel)),
<span class="lineNum">     640 </span>            :                  errhint(&quot;This may be because of a non-immutable index expression.&quot;),
<span class="lineNum">     641 </span>            :                  errtableconstraint(heapRel,
<span class="lineNum">     642 </span>            :                                     RelationGetRelationName(rel))));
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span><span class="lineCov">     378566 :     if (nbuf != InvalidBuffer)</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :         _bt_relbuf(rel, nbuf);</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineCov">     378566 :     return InvalidTransactionId;</span>
<span class="lineNum">     648 </span>            : }
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            : /*
<span class="lineNum">     652 </span>            :  *  _bt_findinsertloc() -- Finds an insert location for a tuple
<span class="lineNum">     653 </span>            :  *
<span class="lineNum">     654 </span>            :  *      On entry, insertstate buffer contains the page the new tuple belongs
<span class="lineNum">     655 </span>            :  *      on.  It is exclusive-locked and pinned by the caller.
<span class="lineNum">     656 </span>            :  *
<span class="lineNum">     657 </span>            :  *      If 'checkingunique' is true, the buffer on entry is the first page
<span class="lineNum">     658 </span>            :  *      that contains duplicates of the new key.  If there are duplicates on
<span class="lineNum">     659 </span>            :  *      multiple pages, the correct insertion position might be some page to
<span class="lineNum">     660 </span>            :  *      the right, rather than the first page.  In that case, this function
<span class="lineNum">     661 </span>            :  *      moves right to the correct target page.
<span class="lineNum">     662 </span>            :  *
<span class="lineNum">     663 </span>            :  *      (In a !heapkeyspace index, there can be multiple pages with the same
<span class="lineNum">     664 </span>            :  *      high key, where the new tuple could legitimately be placed on.  In
<span class="lineNum">     665 </span>            :  *      that case, the caller passes the first page containing duplicates,
<span class="lineNum">     666 </span>            :  *      just like when checkingunique=true.  If that page doesn't have enough
<span class="lineNum">     667 </span>            :  *      room for the new tuple, this function moves right, trying to find a
<span class="lineNum">     668 </span>            :  *      legal page that does.)
<span class="lineNum">     669 </span>            :  *
<span class="lineNum">     670 </span>            :  *      On exit, insertstate buffer contains the chosen insertion page, and
<span class="lineNum">     671 </span>            :  *      the offset within that page is returned.  If _bt_findinsertloc needed
<span class="lineNum">     672 </span>            :  *      to move right, the lock and pin on the original page are released, and
<span class="lineNum">     673 </span>            :  *      the new buffer is exclusively locked and pinned instead.
<span class="lineNum">     674 </span>            :  *
<span class="lineNum">     675 </span>            :  *      If insertstate contains cached binary search bounds, we will take
<span class="lineNum">     676 </span>            :  *      advantage of them.  This avoids repeating comparisons that we made in
<span class="lineNum">     677 </span>            :  *      _bt_check_unique() already.
<span class="lineNum">     678 </span>            :  *
<span class="lineNum">     679 </span>            :  *      If there is not enough room on the page for the new tuple, we try to
<span class="lineNum">     680 </span>            :  *      make room by removing any LP_DEAD tuples.
<a name="681"><span class="lineNum">     681 </span>            :  */</a>
<span class="lineNum">     682 </span>            : static OffsetNumber
<span class="lineNum">     683 </span><span class="lineCov">     633686 : _bt_findinsertloc(Relation rel,</span>
<span class="lineNum">     684 </span>            :                   BTInsertState insertstate,
<span class="lineNum">     685 </span>            :                   bool checkingunique,
<span class="lineNum">     686 </span>            :                   BTStack stack,
<span class="lineNum">     687 </span>            :                   Relation heapRel)
<span class="lineNum">     688 </span>            : {
<span class="lineNum">     689 </span><span class="lineCov">     633686 :     BTScanInsert itup_key = insertstate-&gt;itup_key;</span>
<span class="lineNum">     690 </span><span class="lineCov">     633686 :     Page        page = BufferGetPage(insertstate-&gt;buf);</span>
<span class="lineNum">     691 </span>            :     BTPageOpaque lpageop;
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span><span class="lineCov">     633686 :     lpageop = (BTPageOpaque) PageGetSpecialPointer(page);</span>
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            :     /* Check 1/3 of a page restriction */
<span class="lineNum">     696 </span><span class="lineCov">     633686 :     if (unlikely(insertstate-&gt;itemsz &gt; BTMaxItemSize(page)))</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :         _bt_check_third_page(rel, heapRel, itup_key-&gt;heapkeyspace, page,</span>
<span class="lineNum">     698 </span>            :                              insertstate-&gt;itup);
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span><span class="lineCov">     633686 :     Assert(P_ISLEAF(lpageop) &amp;&amp; !P_INCOMPLETE_SPLIT(lpageop));</span>
<span class="lineNum">     701 </span><span class="lineCov">     633686 :     Assert(!insertstate-&gt;bounds_valid || checkingunique);</span>
<span class="lineNum">     702 </span><span class="lineCov">     633686 :     Assert(!itup_key-&gt;heapkeyspace || itup_key-&gt;scantid != NULL);</span>
<span class="lineNum">     703 </span><span class="lineCov">     633686 :     Assert(itup_key-&gt;heapkeyspace || itup_key-&gt;scantid == NULL);</span>
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span><span class="lineCov">     633686 :     if (itup_key-&gt;heapkeyspace)</span>
<span class="lineNum">     706 </span>            :     {
<span class="lineNum">     707 </span>            :         /*
<span class="lineNum">     708 </span>            :          * If we're inserting into a unique index, we may have to walk right
<span class="lineNum">     709 </span>            :          * through leaf pages to find the one leaf page that we must insert on
<span class="lineNum">     710 </span>            :          * to.
<span class="lineNum">     711 </span>            :          *
<span class="lineNum">     712 </span>            :          * This is needed for checkingunique callers because a scantid was not
<span class="lineNum">     713 </span>            :          * used when we called _bt_search().  scantid can only be set after
<span class="lineNum">     714 </span>            :          * _bt_check_unique() has checked for duplicates.  The buffer
<span class="lineNum">     715 </span>            :          * initially stored in insertstate-&gt;buf has the page where the first
<span class="lineNum">     716 </span>            :          * duplicate key might be found, which isn't always the page that new
<span class="lineNum">     717 </span>            :          * tuple belongs on.  The heap TID attribute for new tuple (scantid)
<span class="lineNum">     718 </span>            :          * could force us to insert on a sibling page, though that should be
<span class="lineNum">     719 </span>            :          * very rare in practice.
<span class="lineNum">     720 </span>            :          */
<span class="lineNum">     721 </span><span class="lineCov">     633686 :         if (checkingunique)</span>
<span class="lineNum">     722 </span>            :         {
<span class="lineNum">     723 </span>            :             for (;;)
<span class="lineNum">     724 </span>            :             {
<span class="lineNum">     725 </span>            :                 /*
<span class="lineNum">     726 </span>            :                  * Does the new tuple belong on this page?
<span class="lineNum">     727 </span>            :                  *
<span class="lineNum">     728 </span>            :                  * The earlier _bt_check_unique() call may well have
<span class="lineNum">     729 </span>            :                  * established a strict upper bound on the offset for the new
<span class="lineNum">     730 </span>            :                  * item.  If it's not the last item of the page (i.e. if there
<span class="lineNum">     731 </span>            :                  * is at least one tuple on the page that goes after the tuple
<span class="lineNum">     732 </span>            :                  * we're inserting) then we know that the tuple belongs on
<span class="lineNum">     733 </span>            :                  * this page.  We can skip the high key check.
<span class="lineNum">     734 </span>            :                  */
<span class="lineNum">     735 </span><span class="lineCov">     756388 :                 if (insertstate-&gt;bounds_valid &amp;&amp;</span>
<span class="lineNum">     736 </span><span class="lineCov">     755616 :                     insertstate-&gt;low &lt;= insertstate-&gt;stricthigh &amp;&amp;</span>
<span class="lineNum">     737 </span><span class="lineCov">     377808 :                     insertstate-&gt;stricthigh &lt;= PageGetMaxOffsetNumber(page))</span>
<span class="lineNum">     738 </span><span class="lineCov">     177832 :                     break;</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            :                 /* Test '&lt;=', not '!=', since scantid is set now */
<span class="lineNum">     741 </span><span class="lineCov">     202752 :                 if (P_RIGHTMOST(lpageop) ||</span>
<span class="lineNum">     742 </span><span class="lineCov">       2004 :                     _bt_compare(rel, itup_key, page, P_HIKEY) &lt;= 0)</span>
<span class="lineNum">     743 </span>            :                     break;
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :                 _bt_stepright(rel, insertstate, stack);</span>
<span class="lineNum">     746 </span>            :                 /* Update local state after stepping right */
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :                 page = BufferGetPage(insertstate-&gt;buf);</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :                 lpageop = (BTPageOpaque) PageGetSpecialPointer(page);</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     750 </span>            :         }
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span>            :         /*
<span class="lineNum">     753 </span>            :          * If the target page is full, see if we can obtain enough space by
<span class="lineNum">     754 </span>            :          * erasing LP_DEAD items
<span class="lineNum">     755 </span>            :          */
<span class="lineNum">     756 </span><span class="lineCov">     636742 :         if (PageGetFreeSpace(page) &lt; insertstate-&gt;itemsz &amp;&amp;</span>
<span class="lineNum">     757 </span><span class="lineCov">       3056 :             P_HAS_GARBAGE(lpageop))</span>
<span class="lineNum">     758 </span>            :         {
<span class="lineNum">     759 </span><span class="lineCov">        776 :             _bt_vacuum_one_page(rel, insertstate-&gt;buf, heapRel);</span>
<span class="lineNum">     760 </span><span class="lineCov">        776 :             insertstate-&gt;bounds_valid = false;</span>
<span class="lineNum">     761 </span>            :         }
<span class="lineNum">     762 </span>            :     }
<span class="lineNum">     763 </span>            :     else
<span class="lineNum">     764 </span>            :     {
<span class="lineNum">     765 </span>            :         /*----------
<span class="lineNum">     766 </span>            :          * This is a !heapkeyspace (version 2 or 3) index.  The current page
<span class="lineNum">     767 </span>            :          * is the first page that we could insert the new tuple to, but there
<span class="lineNum">     768 </span>            :          * may be other pages to the right that we could opt to use instead.
<span class="lineNum">     769 </span>            :          *
<span class="lineNum">     770 </span>            :          * If the new key is equal to one or more existing keys, we can
<span class="lineNum">     771 </span>            :          * legitimately place it anywhere in the series of equal keys.  In
<span class="lineNum">     772 </span>            :          * fact, if the new key is equal to the page's &quot;high key&quot; we can place
<span class="lineNum">     773 </span>            :          * it on the next page.  If it is equal to the high key, and there's
<span class="lineNum">     774 </span>            :          * not room to insert the new tuple on the current page without
<span class="lineNum">     775 </span>            :          * splitting, then we move right hoping to find more free space and
<span class="lineNum">     776 </span>            :          * avoid a split.
<span class="lineNum">     777 </span>            :          *
<span class="lineNum">     778 </span>            :          * Keep scanning right until we
<span class="lineNum">     779 </span>            :          *      (a) find a page with enough free space,
<span class="lineNum">     780 </span>            :          *      (b) reach the last page where the tuple can legally go, or
<span class="lineNum">     781 </span>            :          *      (c) get tired of searching.
<span class="lineNum">     782 </span>            :          * (c) is not flippant; it is important because if there are many
<span class="lineNum">     783 </span>            :          * pages' worth of equal keys, it's better to split one of the early
<span class="lineNum">     784 </span>            :          * pages than to scan all the way to the end of the run of equal keys
<span class="lineNum">     785 </span>            :          * on every insert.  We implement &quot;get tired&quot; as a random choice,
<span class="lineNum">     786 </span>            :          * since stopping after scanning a fixed number of pages wouldn't work
<span class="lineNum">     787 </span>            :          * well (we'd never reach the right-hand side of previously split
<span class="lineNum">     788 </span>            :          * pages).  The probability of moving right is set at 0.99, which may
<span class="lineNum">     789 </span>            :          * seem too high to change the behavior much, but it does an excellent
<span class="lineNum">     790 </span>            :          * job of preventing O(N^2) behavior with many equal keys.
<span class="lineNum">     791 </span>            :          *----------
<span class="lineNum">     792 </span>            :          */
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :         while (PageGetFreeSpace(page) &lt; insertstate-&gt;itemsz)</span>
<span class="lineNum">     794 </span>            :         {
<span class="lineNum">     795 </span>            :             /*
<span class="lineNum">     796 </span>            :              * Before considering moving right, see if we can obtain enough
<span class="lineNum">     797 </span>            :              * space by erasing LP_DEAD items
<span class="lineNum">     798 </span>            :              */
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :             if (P_HAS_GARBAGE(lpageop))</span>
<span class="lineNum">     800 </span>            :             {
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :                 _bt_vacuum_one_page(rel, insertstate-&gt;buf, heapRel);</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :                 insertstate-&gt;bounds_valid = false;</span>
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :                 if (PageGetFreeSpace(page) &gt;= insertstate-&gt;itemsz)</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :                     break;      /* OK, now we have enough space */</span>
<span class="lineNum">     806 </span>            :             }
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span>            :             /*
<span class="lineNum">     809 </span>            :              * Nope, so check conditions (b) and (c) enumerated above
<span class="lineNum">     810 </span>            :              *
<span class="lineNum">     811 </span>            :              * The earlier _bt_check_unique() call may well have established a
<span class="lineNum">     812 </span>            :              * strict upper bound on the offset for the new item.  If it's not
<span class="lineNum">     813 </span>            :              * the last item of the page (i.e. if there is at least one tuple
<span class="lineNum">     814 </span>            :              * on the page that's greater than the tuple we're inserting to)
<span class="lineNum">     815 </span>            :              * then we know that the tuple belongs on this page.  We can skip
<span class="lineNum">     816 </span>            :              * the high key check.
<span class="lineNum">     817 </span>            :              */
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :             if (insertstate-&gt;bounds_valid &amp;&amp;</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :                 insertstate-&gt;low &lt;= insertstate-&gt;stricthigh &amp;&amp;</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :                 insertstate-&gt;stricthigh &lt;= PageGetMaxOffsetNumber(page))</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :             if (P_RIGHTMOST(lpageop) ||</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :                 _bt_compare(rel, itup_key, page, P_HIKEY) != 0 ||</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :                 random() &lt;= (MAX_RANDOM_VALUE / 100))</span>
<span class="lineNum">     826 </span>            :                 break;
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :             _bt_stepright(rel, insertstate, stack);</span>
<span class="lineNum">     829 </span>            :             /* Update local state after stepping right */
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :             page = BufferGetPage(insertstate-&gt;buf);</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :             lpageop = (BTPageOpaque) PageGetSpecialPointer(page);</span>
<span class="lineNum">     832 </span>            :         }
<span class="lineNum">     833 </span>            :     }
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            :     /*
<span class="lineNum">     836 </span>            :      * We should now be on the correct page.  Find the offset within the page
<span class="lineNum">     837 </span>            :      * for the new tuple. (Possibly reusing earlier search bounds.)
<span class="lineNum">     838 </span>            :      */
<span class="lineNum">     839 </span><span class="lineCov">     633686 :     Assert(P_RIGHTMOST(lpageop) ||</span>
<span class="lineNum">     840 </span>            :            _bt_compare(rel, itup_key, page, P_HIKEY) &lt;= 0);
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span><span class="lineCov">     633686 :     return _bt_binsrch_insert(rel, insertstate);</span>
<span class="lineNum">     843 </span>            : }
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            : /*
<span class="lineNum">     846 </span>            :  * Step right to next non-dead page, during insertion.
<span class="lineNum">     847 </span>            :  *
<span class="lineNum">     848 </span>            :  * This is a bit more complicated than moving right in a search.  We must
<span class="lineNum">     849 </span>            :  * write-lock the target page before releasing write lock on current page;
<span class="lineNum">     850 </span>            :  * else someone else's _bt_check_unique scan could fail to see our insertion.
<span class="lineNum">     851 </span>            :  * Write locks on intermediate dead pages won't do because we don't know when
<span class="lineNum">     852 </span>            :  * they will get de-linked from the tree.
<span class="lineNum">     853 </span>            :  *
<span class="lineNum">     854 </span>            :  * This is more aggressive than it needs to be for non-unique !heapkeyspace
<span class="lineNum">     855 </span>            :  * indexes.
<a name="856"><span class="lineNum">     856 </span>            :  */</a>
<span class="lineNum">     857 </span>            : static void
<span class="lineNum">     858 </span><span class="lineNoCov">          0 : _bt_stepright(Relation rel, BTInsertState insertstate, BTStack stack)</span>
<span class="lineNum">     859 </span>            : {
<span class="lineNum">     860 </span>            :     Page        page;
<span class="lineNum">     861 </span>            :     BTPageOpaque lpageop;
<span class="lineNum">     862 </span>            :     Buffer      rbuf;
<span class="lineNum">     863 </span>            :     BlockNumber rblkno;
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :     page = BufferGetPage(insertstate-&gt;buf);</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :     lpageop = (BTPageOpaque) PageGetSpecialPointer(page);</span>
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :     rbuf = InvalidBuffer;</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     rblkno = lpageop-&gt;btpo_next;</span>
<span class="lineNum">     870 </span>            :     for (;;)
<span class="lineNum">     871 </span>            :     {
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :         rbuf = _bt_relandgetbuf(rel, rbuf, rblkno, BT_WRITE);</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :         page = BufferGetPage(rbuf);</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :         lpageop = (BTPageOpaque) PageGetSpecialPointer(page);</span>
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span>            :         /*
<span class="lineNum">     877 </span>            :          * If this page was incompletely split, finish the split now.  We do
<span class="lineNum">     878 </span>            :          * this while holding a lock on the left sibling, which is not good
<span class="lineNum">     879 </span>            :          * because finishing the split could be a fairly lengthy operation.
<span class="lineNum">     880 </span>            :          * But this should happen very seldom.
<span class="lineNum">     881 </span>            :          */
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :         if (P_INCOMPLETE_SPLIT(lpageop))</span>
<span class="lineNum">     883 </span>            :         {
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :             _bt_finish_split(rel, rbuf, stack);</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :             rbuf = InvalidBuffer;</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     887 </span>            :         }
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :         if (!P_IGNORE(lpageop))</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :         if (P_RIGHTMOST(lpageop))</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;fell off the end of index \&quot;%s\&quot;&quot;,</span>
<span class="lineNum">     893 </span>            :                  RelationGetRelationName(rel));
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :         rblkno = lpageop-&gt;btpo_next;</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     897 </span>            :     /* rbuf locked; unlock buf, update state for caller */
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :     _bt_relbuf(rel, insertstate-&gt;buf);</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :     insertstate-&gt;buf = rbuf;</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     insertstate-&gt;bounds_valid = false;</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            : /*----------
<span class="lineNum">     904 </span>            :  *  _bt_insertonpg() -- Insert a tuple on a particular page in the index.
<span class="lineNum">     905 </span>            :  *
<span class="lineNum">     906 </span>            :  *      This recursive procedure does the following things:
<span class="lineNum">     907 </span>            :  *
<span class="lineNum">     908 </span>            :  *          +  if necessary, splits the target page, using 'itup_key' for
<span class="lineNum">     909 </span>            :  *             suffix truncation on leaf pages (caller passes NULL for
<span class="lineNum">     910 </span>            :  *             non-leaf pages).
<span class="lineNum">     911 </span>            :  *          +  inserts the tuple.
<span class="lineNum">     912 </span>            :  *          +  if the page was split, pops the parent stack, and finds the
<span class="lineNum">     913 </span>            :  *             right place to insert the new child pointer (by walking
<span class="lineNum">     914 </span>            :  *             right using information stored in the parent stack).
<span class="lineNum">     915 </span>            :  *          +  invokes itself with the appropriate tuple for the right
<span class="lineNum">     916 </span>            :  *             child page on the parent.
<span class="lineNum">     917 </span>            :  *          +  updates the metapage if a true root or fast root is split.
<span class="lineNum">     918 </span>            :  *
<span class="lineNum">     919 </span>            :  *      On entry, we must have the correct buffer in which to do the
<span class="lineNum">     920 </span>            :  *      insertion, and the buffer must be pinned and write-locked.  On return,
<span class="lineNum">     921 </span>            :  *      we will have dropped both the pin and the lock on the buffer.
<span class="lineNum">     922 </span>            :  *
<span class="lineNum">     923 </span>            :  *      This routine only performs retail tuple insertions.  'itup' should
<span class="lineNum">     924 </span>            :  *      always be either a non-highkey leaf item, or a downlink (new high
<span class="lineNum">     925 </span>            :  *      key items are created indirectly, when a page is split).  When
<span class="lineNum">     926 </span>            :  *      inserting to a non-leaf page, 'cbuf' is the left-sibling of the page
<span class="lineNum">     927 </span>            :  *      we're inserting the downlink for.  This function will clear the
<span class="lineNum">     928 </span>            :  *      INCOMPLETE_SPLIT flag on it, and release the buffer.
<span class="lineNum">     929 </span>            :  *----------
<a name="930"><span class="lineNum">     930 </span>            :  */</a>
<span class="lineNum">     931 </span>            : static void
<span class="lineNum">     932 </span><span class="lineCov">     635896 : _bt_insertonpg(Relation rel,</span>
<span class="lineNum">     933 </span>            :                BTScanInsert itup_key,
<span class="lineNum">     934 </span>            :                Buffer buf,
<span class="lineNum">     935 </span>            :                Buffer cbuf,
<span class="lineNum">     936 </span>            :                BTStack stack,
<span class="lineNum">     937 </span>            :                IndexTuple itup,
<span class="lineNum">     938 </span>            :                OffsetNumber newitemoff,
<span class="lineNum">     939 </span>            :                bool split_only_page)
<span class="lineNum">     940 </span>            : {
<span class="lineNum">     941 </span>            :     Page        page;
<span class="lineNum">     942 </span>            :     BTPageOpaque lpageop;
<span class="lineNum">     943 </span>            :     Size        itemsz;
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span><span class="lineCov">     635896 :     page = BufferGetPage(buf);</span>
<span class="lineNum">     946 </span><span class="lineCov">     635896 :     lpageop = (BTPageOpaque) PageGetSpecialPointer(page);</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span>            :     /* child buffer must be given iff inserting on an internal page */
<span class="lineNum">     949 </span><span class="lineCov">     635896 :     Assert(P_ISLEAF(lpageop) == !BufferIsValid(cbuf));</span>
<span class="lineNum">     950 </span>            :     /* tuple must have appropriate number of attributes */
<span class="lineNum">     951 </span><span class="lineCov">     635896 :     Assert(!P_ISLEAF(lpageop) ||</span>
<span class="lineNum">     952 </span>            :            BTreeTupleGetNAtts(itup, rel) ==
<span class="lineNum">     953 </span>            :            IndexRelationGetNumberOfAttributes(rel));
<span class="lineNum">     954 </span><span class="lineCov">     635896 :     Assert(P_ISLEAF(lpageop) ||</span>
<span class="lineNum">     955 </span>            :            BTreeTupleGetNAtts(itup, rel) &lt;=
<span class="lineNum">     956 </span>            :            IndexRelationGetNumberOfKeyAttributes(rel));
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span>            :     /* The caller should've finished any incomplete splits already. */
<span class="lineNum">     959 </span><span class="lineCov">     635896 :     if (P_INCOMPLETE_SPLIT(lpageop))</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;cannot insert to incompletely split page %u&quot;,</span>
<span class="lineNum">     961 </span>            :              BufferGetBlockNumber(buf));
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span><span class="lineCov">     635896 :     itemsz = IndexTupleSize(itup);</span>
<span class="lineNum">     964 </span><span class="lineCov">     635896 :     itemsz = MAXALIGN(itemsz);  /* be safe, PageAddItem will do this but we</span>
<span class="lineNum">     965 </span>            :                                  * need to be consistent */
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            :     /*
<span class="lineNum">     968 </span>            :      * Do we need to split the page to fit the item on it?
<span class="lineNum">     969 </span>            :      *
<span class="lineNum">     970 </span>            :      * Note: PageGetFreeSpace() subtracts sizeof(ItemIdData) from its result,
<span class="lineNum">     971 </span>            :      * so this comparison is correct even though we appear to be accounting
<span class="lineNum">     972 </span>            :      * only for the item and not for its line pointer.
<span class="lineNum">     973 </span>            :      */
<span class="lineNum">     974 </span><span class="lineCov">     635896 :     if (PageGetFreeSpace(page) &lt; itemsz)</span>
<span class="lineNum">     975 </span>            :     {
<span class="lineNum">     976 </span><span class="lineCov">       2290 :         bool        is_root = P_ISROOT(lpageop);</span>
<span class="lineNum">     977 </span><span class="lineCov">       2290 :         bool        is_only = P_LEFTMOST(lpageop) &amp;&amp; P_RIGHTMOST(lpageop);</span>
<span class="lineNum">     978 </span>            :         Buffer      rbuf;
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            :         /*
<span class="lineNum">     981 </span>            :          * If we're here then a pagesplit is needed. We should never reach
<span class="lineNum">     982 </span>            :          * here if we're using the fastpath since we should have checked for
<span class="lineNum">     983 </span>            :          * all the required conditions, including the fact that this page has
<span class="lineNum">     984 </span>            :          * enough freespace. Note that this routine can in theory deal with
<span class="lineNum">     985 </span>            :          * the situation where a NULL stack pointer is passed (that's what
<span class="lineNum">     986 </span>            :          * would happen if the fastpath is taken). But that path is much
<span class="lineNum">     987 </span>            :          * slower, defeating the very purpose of the optimization.  The
<span class="lineNum">     988 </span>            :          * following assertion should protect us from any future code changes
<span class="lineNum">     989 </span>            :          * that invalidate those assumptions.
<span class="lineNum">     990 </span>            :          *
<span class="lineNum">     991 </span>            :          * Note that whenever we fail to take the fastpath, we clear the
<span class="lineNum">     992 </span>            :          * cached block. Checking for a valid cached block at this point is
<span class="lineNum">     993 </span>            :          * enough to decide whether we're in a fastpath or not.
<span class="lineNum">     994 </span>            :          */
<span class="lineNum">     995 </span><span class="lineCov">       2290 :         Assert(!(P_ISLEAF(lpageop) &amp;&amp;</span>
<span class="lineNum">     996 </span>            :                  BlockNumberIsValid(RelationGetTargetBlock(rel))));
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            :         /* split the buffer into left and right halves */
<span class="lineNum">     999 </span><span class="lineCov">       2290 :         rbuf = _bt_split(rel, itup_key, buf, cbuf, newitemoff, itemsz, itup);</span>
<span class="lineNum">    1000 </span><span class="lineCov">       2290 :         PredicateLockPageSplit(rel,</span>
<span class="lineNum">    1001 </span>            :                                BufferGetBlockNumber(buf),
<span class="lineNum">    1002 </span>            :                                BufferGetBlockNumber(rbuf));
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            :         /*----------
<span class="lineNum">    1005 </span>            :          * By here,
<span class="lineNum">    1006 </span>            :          *
<span class="lineNum">    1007 </span>            :          *      +  our target page has been split;
<span class="lineNum">    1008 </span>            :          *      +  the original tuple has been inserted;
<span class="lineNum">    1009 </span>            :          *      +  we have write locks on both the old (left half)
<span class="lineNum">    1010 </span>            :          *         and new (right half) buffers, after the split; and
<span class="lineNum">    1011 </span>            :          *      +  we know the key we want to insert into the parent
<span class="lineNum">    1012 </span>            :          *         (it's the &quot;high key&quot; on the left child page).
<span class="lineNum">    1013 </span>            :          *
<span class="lineNum">    1014 </span>            :          * We're ready to do the parent insertion.  We need to hold onto the
<span class="lineNum">    1015 </span>            :          * locks for the child pages until we locate the parent, but we can
<span class="lineNum">    1016 </span>            :          * at least release the lock on the right child before doing the
<span class="lineNum">    1017 </span>            :          * actual insertion.  The lock on the left child will be released
<span class="lineNum">    1018 </span>            :          * last of all by parent insertion, where it is the 'cbuf' of parent
<span class="lineNum">    1019 </span>            :          * page.
<span class="lineNum">    1020 </span>            :          *----------
<span class="lineNum">    1021 </span>            :          */
<span class="lineNum">    1022 </span><span class="lineCov">       2290 :         _bt_insert_parent(rel, buf, rbuf, stack, is_root, is_only);</span>
<span class="lineNum">    1023 </span>            :     }
<span class="lineNum">    1024 </span>            :     else
<span class="lineNum">    1025 </span>            :     {
<span class="lineNum">    1026 </span><span class="lineCov">     633606 :         Buffer      metabuf = InvalidBuffer;</span>
<span class="lineNum">    1027 </span><span class="lineCov">     633606 :         Page        metapg = NULL;</span>
<span class="lineNum">    1028 </span><span class="lineCov">     633606 :         BTMetaPageData *metad = NULL;</span>
<span class="lineNum">    1029 </span>            :         OffsetNumber itup_off;
<span class="lineNum">    1030 </span>            :         BlockNumber itup_blkno;
<span class="lineNum">    1031 </span><span class="lineCov">     633606 :         BlockNumber cachedBlock = InvalidBlockNumber;</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span><span class="lineCov">     633606 :         itup_off = newitemoff;</span>
<span class="lineNum">    1034 </span><span class="lineCov">     633606 :         itup_blkno = BufferGetBlockNumber(buf);</span>
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span>            :         /*
<span class="lineNum">    1037 </span>            :          * If we are doing this insert because we split a page that was the
<span class="lineNum">    1038 </span>            :          * only one on its tree level, but was not the root, it may have been
<span class="lineNum">    1039 </span>            :          * the &quot;fast root&quot;.  We need to ensure that the fast root link points
<span class="lineNum">    1040 </span>            :          * at or above the current page.  We can safely acquire a lock on the
<span class="lineNum">    1041 </span>            :          * metapage here --- see comments for _bt_newroot().
<span class="lineNum">    1042 </span>            :          */
<span class="lineNum">    1043 </span><span class="lineCov">     633606 :         if (split_only_page)</span>
<span class="lineNum">    1044 </span>            :         {
<span class="lineNum">    1045 </span><span class="lineCov">          2 :             Assert(!P_ISLEAF(lpageop));</span>
<span class="lineNum">    1046 </span>            : 
<span class="lineNum">    1047 </span><span class="lineCov">          2 :             metabuf = _bt_getbuf(rel, BTREE_METAPAGE, BT_WRITE);</span>
<span class="lineNum">    1048 </span><span class="lineCov">          2 :             metapg = BufferGetPage(metabuf);</span>
<span class="lineNum">    1049 </span><span class="lineCov">          2 :             metad = BTPageGetMeta(metapg);</span>
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span><span class="lineCov">          2 :             if (metad-&gt;btm_fastlevel &gt;= lpageop-&gt;btpo.level)</span>
<span class="lineNum">    1052 </span>            :             {
<span class="lineNum">    1053 </span>            :                 /* no update wanted */
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :                 _bt_relbuf(rel, metabuf);</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :                 metabuf = InvalidBuffer;</span>
<span class="lineNum">    1056 </span>            :             }
<span class="lineNum">    1057 </span>            :         }
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span>            :         /*
<span class="lineNum">    1060 </span>            :          * Every internal page should have exactly one negative infinity item
<span class="lineNum">    1061 </span>            :          * at all times.  Only _bt_split() and _bt_newroot() should add items
<span class="lineNum">    1062 </span>            :          * that become negative infinity items through truncation, since
<span class="lineNum">    1063 </span>            :          * they're the only routines that allocate new internal pages.  Do not
<span class="lineNum">    1064 </span>            :          * allow a retail insertion of a new item at the negative infinity
<span class="lineNum">    1065 </span>            :          * offset.
<span class="lineNum">    1066 </span>            :          */
<span class="lineNum">    1067 </span><span class="lineCov">     633606 :         if (!P_ISLEAF(lpageop) &amp;&amp; newitemoff == P_FIRSTDATAKEY(lpageop))</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;cannot insert second negative infinity item in block %u of index \&quot;%s\&quot;&quot;,</span>
<span class="lineNum">    1069 </span>            :                  itup_blkno, RelationGetRelationName(rel));
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span>            :         /* Do the update.  No ereport(ERROR) until changes are logged */
<span class="lineNum">    1072 </span><span class="lineCov">     633606 :         START_CRIT_SECTION();</span>
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span><span class="lineCov">     633606 :         if (!_bt_pgaddtup(page, itemsz, itup, newitemoff))</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :             elog(PANIC, &quot;failed to add new item to block %u in index \&quot;%s\&quot;&quot;,</span>
<span class="lineNum">    1076 </span>            :                  itup_blkno, RelationGetRelationName(rel));
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span><span class="lineCov">     633606 :         MarkBufferDirty(buf);</span>
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span><span class="lineCov">     633606 :         if (BufferIsValid(metabuf))</span>
<span class="lineNum">    1081 </span>            :         {
<span class="lineNum">    1082 </span>            :             /* upgrade meta-page if needed */
<span class="lineNum">    1083 </span><span class="lineCov">          2 :             if (metad-&gt;btm_version &lt; BTREE_NOVAC_VERSION)</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :                 _bt_upgrademetapage(metapg);</span>
<span class="lineNum">    1085 </span><span class="lineCov">          2 :             metad-&gt;btm_fastroot = itup_blkno;</span>
<span class="lineNum">    1086 </span><span class="lineCov">          2 :             metad-&gt;btm_fastlevel = lpageop-&gt;btpo.level;</span>
<span class="lineNum">    1087 </span><span class="lineCov">          2 :             MarkBufferDirty(metabuf);</span>
<span class="lineNum">    1088 </span>            :         }
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            :         /* clear INCOMPLETE_SPLIT flag on child if inserting a downlink */
<span class="lineNum">    1091 </span><span class="lineCov">     633606 :         if (BufferIsValid(cbuf))</span>
<span class="lineNum">    1092 </span>            :         {
<span class="lineNum">    1093 </span><span class="lineCov">       2208 :             Page        cpage = BufferGetPage(cbuf);</span>
<span class="lineNum">    1094 </span><span class="lineCov">       2208 :             BTPageOpaque cpageop = (BTPageOpaque) PageGetSpecialPointer(cpage);</span>
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span><span class="lineCov">       2208 :             Assert(P_INCOMPLETE_SPLIT(cpageop));</span>
<span class="lineNum">    1097 </span><span class="lineCov">       2208 :             cpageop-&gt;btpo_flags &amp;= ~BTP_INCOMPLETE_SPLIT;</span>
<span class="lineNum">    1098 </span><span class="lineCov">       2208 :             MarkBufferDirty(cbuf);</span>
<span class="lineNum">    1099 </span>            :         }
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span>            :         /*
<span class="lineNum">    1102 </span>            :          * Cache the block information if we just inserted into the rightmost
<span class="lineNum">    1103 </span>            :          * leaf page of the index and it's not the root page.  For very small
<span class="lineNum">    1104 </span>            :          * index where root is also the leaf, there is no point trying for any
<span class="lineNum">    1105 </span>            :          * optimization.
<span class="lineNum">    1106 </span>            :          */
<span class="lineNum">    1107 </span><span class="lineCov">     633606 :         if (P_RIGHTMOST(lpageop) &amp;&amp; P_ISLEAF(lpageop) &amp;&amp; !P_ISROOT(lpageop))</span>
<span class="lineNum">    1108 </span><span class="lineCov">     325476 :             cachedBlock = BufferGetBlockNumber(buf);</span>
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span>            :         /* XLOG stuff */
<span class="lineNum">    1111 </span><span class="lineCov">     633606 :         if (RelationNeedsWAL(rel))</span>
<span class="lineNum">    1112 </span>            :         {
<span class="lineNum">    1113 </span>            :             xl_btree_insert xlrec;
<span class="lineNum">    1114 </span>            :             xl_btree_metadata xlmeta;
<span class="lineNum">    1115 </span>            :             uint8       xlinfo;
<span class="lineNum">    1116 </span>            :             XLogRecPtr  recptr;
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineCov">     632904 :             xlrec.offnum = itup_off;</span>
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span><span class="lineCov">     632904 :             XLogBeginInsert();</span>
<span class="lineNum">    1121 </span><span class="lineCov">     632904 :             XLogRegisterData((char *) &amp;xlrec, SizeOfBtreeInsert);</span>
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span><span class="lineCov">     632904 :             if (P_ISLEAF(lpageop))</span>
<span class="lineNum">    1124 </span><span class="lineCov">     630696 :                 xlinfo = XLOG_BTREE_INSERT_LEAF;</span>
<span class="lineNum">    1125 </span>            :             else
<span class="lineNum">    1126 </span>            :             {
<span class="lineNum">    1127 </span>            :                 /*
<span class="lineNum">    1128 </span>            :                  * Register the left child whose INCOMPLETE_SPLIT flag was
<span class="lineNum">    1129 </span>            :                  * cleared.
<span class="lineNum">    1130 </span>            :                  */
<span class="lineNum">    1131 </span><span class="lineCov">       2208 :                 XLogRegisterBuffer(1, cbuf, REGBUF_STANDARD);</span>
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span><span class="lineCov">       2208 :                 xlinfo = XLOG_BTREE_INSERT_UPPER;</span>
<span class="lineNum">    1134 </span>            :             }
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span><span class="lineCov">     632904 :             if (BufferIsValid(metabuf))</span>
<span class="lineNum">    1137 </span>            :             {
<span class="lineNum">    1138 </span><span class="lineCov">          2 :                 Assert(metad-&gt;btm_version &gt;= BTREE_NOVAC_VERSION);</span>
<span class="lineNum">    1139 </span><span class="lineCov">          2 :                 xlmeta.version = metad-&gt;btm_version;</span>
<span class="lineNum">    1140 </span><span class="lineCov">          2 :                 xlmeta.root = metad-&gt;btm_root;</span>
<span class="lineNum">    1141 </span><span class="lineCov">          2 :                 xlmeta.level = metad-&gt;btm_level;</span>
<span class="lineNum">    1142 </span><span class="lineCov">          2 :                 xlmeta.fastroot = metad-&gt;btm_fastroot;</span>
<span class="lineNum">    1143 </span><span class="lineCov">          2 :                 xlmeta.fastlevel = metad-&gt;btm_fastlevel;</span>
<span class="lineNum">    1144 </span><span class="lineCov">          2 :                 xlmeta.oldest_btpo_xact = metad-&gt;btm_oldest_btpo_xact;</span>
<span class="lineNum">    1145 </span><span class="lineCov">          2 :                 xlmeta.last_cleanup_num_heap_tuples =</span>
<span class="lineNum">    1146 </span><span class="lineCov">          2 :                     metad-&gt;btm_last_cleanup_num_heap_tuples;</span>
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span><span class="lineCov">          2 :                 XLogRegisterBuffer(2, metabuf, REGBUF_WILL_INIT | REGBUF_STANDARD);</span>
<span class="lineNum">    1149 </span><span class="lineCov">          2 :                 XLogRegisterBufData(2, (char *) &amp;xlmeta, sizeof(xl_btree_metadata));</span>
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span><span class="lineCov">          2 :                 xlinfo = XLOG_BTREE_INSERT_META;</span>
<span class="lineNum">    1152 </span>            :             }
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span><span class="lineCov">     632904 :             XLogRegisterBuffer(0, buf, REGBUF_STANDARD);</span>
<span class="lineNum">    1155 </span><span class="lineCov">     632904 :             XLogRegisterBufData(0, (char *) itup, IndexTupleSize(itup));</span>
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span><span class="lineCov">     632904 :             recptr = XLogInsert(RM_BTREE_ID, xlinfo);</span>
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span><span class="lineCov">     632904 :             if (BufferIsValid(metabuf))</span>
<span class="lineNum">    1160 </span>            :             {
<span class="lineNum">    1161 </span><span class="lineCov">          2 :                 PageSetLSN(metapg, recptr);</span>
<span class="lineNum">    1162 </span>            :             }
<span class="lineNum">    1163 </span><span class="lineCov">     632904 :             if (BufferIsValid(cbuf))</span>
<span class="lineNum">    1164 </span>            :             {
<span class="lineNum">    1165 </span><span class="lineCov">       2208 :                 PageSetLSN(BufferGetPage(cbuf), recptr);</span>
<span class="lineNum">    1166 </span>            :             }
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineCov">     632904 :             PageSetLSN(page, recptr);</span>
<span class="lineNum">    1169 </span>            :         }
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span><span class="lineCov">     633606 :         END_CRIT_SECTION();</span>
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span>            :         /* release buffers */
<span class="lineNum">    1174 </span><span class="lineCov">     633606 :         if (BufferIsValid(metabuf))</span>
<span class="lineNum">    1175 </span><span class="lineCov">          2 :             _bt_relbuf(rel, metabuf);</span>
<span class="lineNum">    1176 </span><span class="lineCov">     633606 :         if (BufferIsValid(cbuf))</span>
<span class="lineNum">    1177 </span><span class="lineCov">       2208 :             _bt_relbuf(rel, cbuf);</span>
<span class="lineNum">    1178 </span><span class="lineCov">     633606 :         _bt_relbuf(rel, buf);</span>
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span>            :         /*
<span class="lineNum">    1181 </span>            :          * If we decided to cache the insertion target block, then set it now.
<span class="lineNum">    1182 </span>            :          * But before that, check for the height of the tree and don't go for
<span class="lineNum">    1183 </span>            :          * the optimization for small indexes. We defer that check to this
<span class="lineNum">    1184 </span>            :          * point to ensure that we don't call _bt_getrootheight while holding
<span class="lineNum">    1185 </span>            :          * lock on any other block.
<span class="lineNum">    1186 </span>            :          *
<span class="lineNum">    1187 </span>            :          * We do this after dropping locks on all buffers. So the information
<span class="lineNum">    1188 </span>            :          * about whether the insertion block is still the rightmost block or
<span class="lineNum">    1189 </span>            :          * not may have changed in between. But we will deal with that during
<span class="lineNum">    1190 </span>            :          * next insert operation. No special care is required while setting
<span class="lineNum">    1191 </span>            :          * it.
<span class="lineNum">    1192 </span>            :          */
<span class="lineNum">    1193 </span><span class="lineCov">     959082 :         if (BlockNumberIsValid(cachedBlock) &amp;&amp;</span>
<span class="lineNum">    1194 </span><span class="lineCov">     325476 :             _bt_getrootheight(rel) &gt;= BTREE_FASTPATH_MIN_LEVEL)</span>
<span class="lineNum">    1195 </span><span class="lineCov">         18 :             RelationSetTargetBlock(rel, cachedBlock);</span>
<span class="lineNum">    1196 </span>            :     }
<span class="lineNum">    1197 </span><span class="lineCov">     635896 : }</span>
<span class="lineNum">    1198 </span>            : 
<span class="lineNum">    1199 </span>            : /*
<span class="lineNum">    1200 </span>            :  *  _bt_split() -- split a page in the btree.
<span class="lineNum">    1201 </span>            :  *
<span class="lineNum">    1202 </span>            :  *      On entry, buf is the page to split, and is pinned and write-locked.
<span class="lineNum">    1203 </span>            :  *      newitemoff etc. tell us about the new item that must be inserted
<span class="lineNum">    1204 </span>            :  *      along with the data from the original page.
<span class="lineNum">    1205 </span>            :  *
<span class="lineNum">    1206 </span>            :  *      itup_key is used for suffix truncation on leaf pages (internal
<span class="lineNum">    1207 </span>            :  *      page callers pass NULL).  When splitting a non-leaf page, 'cbuf'
<span class="lineNum">    1208 </span>            :  *      is the left-sibling of the page we're inserting the downlink for.
<span class="lineNum">    1209 </span>            :  *      This function will clear the INCOMPLETE_SPLIT flag on it, and
<span class="lineNum">    1210 </span>            :  *      release the buffer.
<span class="lineNum">    1211 </span>            :  *
<span class="lineNum">    1212 </span>            :  *      Returns the new right sibling of buf, pinned and write-locked.
<span class="lineNum">    1213 </span>            :  *      The pin and lock on buf are maintained.
<a name="1214"><span class="lineNum">    1214 </span>            :  */</a>
<span class="lineNum">    1215 </span>            : static Buffer
<span class="lineNum">    1216 </span><span class="lineCov">       2290 : _bt_split(Relation rel, BTScanInsert itup_key, Buffer buf, Buffer cbuf,</span>
<span class="lineNum">    1217 </span>            :           OffsetNumber newitemoff, Size newitemsz, IndexTuple newitem)
<span class="lineNum">    1218 </span>            : {
<span class="lineNum">    1219 </span>            :     Buffer      rbuf;
<span class="lineNum">    1220 </span>            :     Page        origpage;
<span class="lineNum">    1221 </span>            :     Page        leftpage,
<span class="lineNum">    1222 </span>            :                 rightpage;
<span class="lineNum">    1223 </span>            :     BlockNumber origpagenumber,
<span class="lineNum">    1224 </span>            :                 rightpagenumber;
<span class="lineNum">    1225 </span>            :     BTPageOpaque ropaque,
<span class="lineNum">    1226 </span>            :                 lopaque,
<span class="lineNum">    1227 </span>            :                 oopaque;
<span class="lineNum">    1228 </span><span class="lineCov">       2290 :     Buffer      sbuf = InvalidBuffer;</span>
<span class="lineNum">    1229 </span><span class="lineCov">       2290 :     Page        spage = NULL;</span>
<span class="lineNum">    1230 </span><span class="lineCov">       2290 :     BTPageOpaque sopaque = NULL;</span>
<span class="lineNum">    1231 </span>            :     Size        itemsz;
<span class="lineNum">    1232 </span>            :     ItemId      itemid;
<span class="lineNum">    1233 </span>            :     IndexTuple  item;
<span class="lineNum">    1234 </span>            :     OffsetNumber leftoff,
<span class="lineNum">    1235 </span>            :                 rightoff;
<span class="lineNum">    1236 </span>            :     OffsetNumber firstright;
<span class="lineNum">    1237 </span>            :     OffsetNumber maxoff;
<span class="lineNum">    1238 </span>            :     OffsetNumber i;
<span class="lineNum">    1239 </span>            :     bool        newitemonleft,
<span class="lineNum">    1240 </span>            :                 isleaf;
<span class="lineNum">    1241 </span>            :     IndexTuple  lefthikey;
<span class="lineNum">    1242 </span><span class="lineCov">       2290 :     int         indnatts = IndexRelationGetNumberOfAttributes(rel);</span>
<span class="lineNum">    1243 </span><span class="lineCov">       2290 :     int         indnkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);</span>
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            :     /*
<span class="lineNum">    1246 </span>            :      * origpage is the original page to be split.  leftpage is a temporary
<span class="lineNum">    1247 </span>            :      * buffer that receives the left-sibling data, which will be copied back
<span class="lineNum">    1248 </span>            :      * into origpage on success.  rightpage is the new page that will receive
<span class="lineNum">    1249 </span>            :      * the right-sibling data.
<span class="lineNum">    1250 </span>            :      *
<span class="lineNum">    1251 </span>            :      * leftpage is allocated after choosing a split point.  rightpage's new
<span class="lineNum">    1252 </span>            :      * buffer isn't acquired until after leftpage is initialized and has new
<span class="lineNum">    1253 </span>            :      * high key, the last point where splitting the page may fail (barring
<span class="lineNum">    1254 </span>            :      * corruption).  Failing before acquiring new buffer won't have lasting
<span class="lineNum">    1255 </span>            :      * consequences, since origpage won't have been modified and leftpage is
<span class="lineNum">    1256 </span>            :      * only workspace.
<span class="lineNum">    1257 </span>            :      */
<span class="lineNum">    1258 </span><span class="lineCov">       2290 :     origpage = BufferGetPage(buf);</span>
<span class="lineNum">    1259 </span><span class="lineCov">       2290 :     oopaque = (BTPageOpaque) PageGetSpecialPointer(origpage);</span>
<span class="lineNum">    1260 </span><span class="lineCov">       2290 :     origpagenumber = BufferGetBlockNumber(buf);</span>
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span>            :     /*
<span class="lineNum">    1263 </span>            :      * Choose a point to split origpage at.
<span class="lineNum">    1264 </span>            :      *
<span class="lineNum">    1265 </span>            :      * A split point can be thought of as a point _between_ two existing
<span class="lineNum">    1266 </span>            :      * tuples on origpage (lastleft and firstright tuples), provided you
<span class="lineNum">    1267 </span>            :      * pretend that the new item that didn't fit is already on origpage.
<span class="lineNum">    1268 </span>            :      *
<span class="lineNum">    1269 </span>            :      * Since origpage does not actually contain newitem, the representation of
<span class="lineNum">    1270 </span>            :      * split points needs to work with two boundary cases: splits where
<span class="lineNum">    1271 </span>            :      * newitem is lastleft, and splits where newitem is firstright.
<span class="lineNum">    1272 </span>            :      * newitemonleft resolves the ambiguity that would otherwise exist when
<span class="lineNum">    1273 </span>            :      * newitemoff == firstright.  In all other cases it's clear which side of
<span class="lineNum">    1274 </span>            :      * the split every tuple goes on from context.  newitemonleft is usually
<span class="lineNum">    1275 </span>            :      * (but not always) redundant information.
<span class="lineNum">    1276 </span>            :      */
<span class="lineNum">    1277 </span><span class="lineCov">       2290 :     firstright = _bt_findsplitloc(rel, origpage, newitemoff, newitemsz,</span>
<span class="lineNum">    1278 </span>            :                                   newitem, &amp;newitemonleft);
<span class="lineNum">    1279 </span>            : 
<span class="lineNum">    1280 </span>            :     /* Allocate temp buffer for leftpage */
<span class="lineNum">    1281 </span><span class="lineCov">       2290 :     leftpage = PageGetTempPage(origpage);</span>
<span class="lineNum">    1282 </span><span class="lineCov">       2290 :     _bt_pageinit(leftpage, BufferGetPageSize(buf));</span>
<span class="lineNum">    1283 </span><span class="lineCov">       2290 :     lopaque = (BTPageOpaque) PageGetSpecialPointer(leftpage);</span>
<span class="lineNum">    1284 </span>            : 
<span class="lineNum">    1285 </span>            :     /*
<span class="lineNum">    1286 </span>            :      * leftpage won't be the root when we're done.  Also, clear the SPLIT_END
<span class="lineNum">    1287 </span>            :      * and HAS_GARBAGE flags.
<span class="lineNum">    1288 </span>            :      */
<span class="lineNum">    1289 </span><span class="lineCov">       2290 :     lopaque-&gt;btpo_flags = oopaque-&gt;btpo_flags;</span>
<span class="lineNum">    1290 </span><span class="lineCov">       2290 :     lopaque-&gt;btpo_flags &amp;= ~(BTP_ROOT | BTP_SPLIT_END | BTP_HAS_GARBAGE);</span>
<span class="lineNum">    1291 </span>            :     /* set flag in leftpage indicating that rightpage has no downlink yet */
<span class="lineNum">    1292 </span><span class="lineCov">       2290 :     lopaque-&gt;btpo_flags |= BTP_INCOMPLETE_SPLIT;</span>
<span class="lineNum">    1293 </span><span class="lineCov">       2290 :     lopaque-&gt;btpo_prev = oopaque-&gt;btpo_prev;</span>
<span class="lineNum">    1294 </span>            :     /* handle btpo_next after rightpage buffer acquired */
<span class="lineNum">    1295 </span><span class="lineCov">       2290 :     lopaque-&gt;btpo.level = oopaque-&gt;btpo.level;</span>
<span class="lineNum">    1296 </span>            :     /* handle btpo_cycleid after rightpage buffer acquired */
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            :     /*
<span class="lineNum">    1299 </span>            :      * Copy the original page's LSN into leftpage, which will become the
<span class="lineNum">    1300 </span>            :      * updated version of the page.  We need this because XLogInsert will
<span class="lineNum">    1301 </span>            :      * examine the LSN and possibly dump it in a page image.
<span class="lineNum">    1302 </span>            :      */
<span class="lineNum">    1303 </span><span class="lineCov">       2290 :     PageSetLSN(leftpage, PageGetLSN(origpage));</span>
<span class="lineNum">    1304 </span><span class="lineCov">       2290 :     isleaf = P_ISLEAF(oopaque);</span>
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span>            :     /*
<span class="lineNum">    1307 </span>            :      * The &quot;high key&quot; for the new left page will be the first key that's going
<span class="lineNum">    1308 </span>            :      * to go into the new right page, or a truncated version if this is a leaf
<span class="lineNum">    1309 </span>            :      * page split.
<span class="lineNum">    1310 </span>            :      *
<span class="lineNum">    1311 </span>            :      * The high key for the left page is formed using the first item on the
<span class="lineNum">    1312 </span>            :      * right page, which may seem to be contrary to Lehman &amp; Yao's approach of
<span class="lineNum">    1313 </span>            :      * using the left page's last item as its new high key when splitting on
<span class="lineNum">    1314 </span>            :      * the leaf level.  It isn't, though: suffix truncation will leave the
<span class="lineNum">    1315 </span>            :      * left page's high key fully equal to the last item on the left page when
<span class="lineNum">    1316 </span>            :      * two tuples with equal key values (excluding heap TID) enclose the split
<span class="lineNum">    1317 </span>            :      * point.  It isn't actually necessary for a new leaf high key to be equal
<span class="lineNum">    1318 </span>            :      * to the last item on the left for the L&amp;Y &quot;subtree&quot; invariant to hold.
<span class="lineNum">    1319 </span>            :      * It's sufficient to make sure that the new leaf high key is strictly
<span class="lineNum">    1320 </span>            :      * less than the first item on the right leaf page, and greater than or
<span class="lineNum">    1321 </span>            :      * equal to (not necessarily equal to) the last item on the left leaf
<span class="lineNum">    1322 </span>            :      * page.
<span class="lineNum">    1323 </span>            :      *
<span class="lineNum">    1324 </span>            :      * In other words, when suffix truncation isn't possible, L&amp;Y's exact
<span class="lineNum">    1325 </span>            :      * approach to leaf splits is taken.  (Actually, even that is slightly
<span class="lineNum">    1326 </span>            :      * inaccurate.  A tuple with all the keys from firstright but the heap TID
<span class="lineNum">    1327 </span>            :      * from lastleft will be used as the new high key, since the last left
<span class="lineNum">    1328 </span>            :      * tuple could be physically larger despite being opclass-equal in respect
<span class="lineNum">    1329 </span>            :      * of all attributes prior to the heap TID attribute.)
<span class="lineNum">    1330 </span>            :      */
<span class="lineNum">    1331 </span><span class="lineCov">       2290 :     if (!newitemonleft &amp;&amp; newitemoff == firstright)</span>
<span class="lineNum">    1332 </span>            :     {
<span class="lineNum">    1333 </span>            :         /* incoming tuple will become first on right page */
<span class="lineNum">    1334 </span><span class="lineCov">          2 :         itemsz = newitemsz;</span>
<span class="lineNum">    1335 </span><span class="lineCov">          2 :         item = newitem;</span>
<span class="lineNum">    1336 </span>            :     }
<span class="lineNum">    1337 </span>            :     else
<span class="lineNum">    1338 </span>            :     {
<span class="lineNum">    1339 </span>            :         /* existing item at firstright will become first on right page */
<span class="lineNum">    1340 </span><span class="lineCov">       2288 :         itemid = PageGetItemId(origpage, firstright);</span>
<span class="lineNum">    1341 </span><span class="lineCov">       2288 :         itemsz = ItemIdGetLength(itemid);</span>
<span class="lineNum">    1342 </span><span class="lineCov">       2288 :         item = (IndexTuple) PageGetItem(origpage, itemid);</span>
<span class="lineNum">    1343 </span>            :     }
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span>            :     /*
<span class="lineNum">    1346 </span>            :      * Truncate unneeded key and non-key attributes of the high key item
<span class="lineNum">    1347 </span>            :      * before inserting it on the left page.  This can only happen at the leaf
<span class="lineNum">    1348 </span>            :      * level, since in general all pivot tuple values originate from leaf
<span class="lineNum">    1349 </span>            :      * level high keys.  A pivot tuple in a grandparent page must guide a
<span class="lineNum">    1350 </span>            :      * search not only to the correct parent page, but also to the correct
<span class="lineNum">    1351 </span>            :      * leaf page.
<span class="lineNum">    1352 </span>            :      */
<span class="lineNum">    1353 </span><span class="lineCov">       2290 :     if (isleaf &amp;&amp; (itup_key-&gt;heapkeyspace || indnatts != indnkeyatts))</span>
<span class="lineNum">    1354 </span><span class="lineCov">       2288 :     {</span>
<span class="lineNum">    1355 </span>            :         IndexTuple  lastleft;
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span>            :         /*
<span class="lineNum">    1358 </span>            :          * Determine which tuple will become the last on the left page.  This
<span class="lineNum">    1359 </span>            :          * is needed to decide how many attributes from the first item on the
<span class="lineNum">    1360 </span>            :          * right page must remain in new high key for left page.
<span class="lineNum">    1361 </span>            :          */
<span class="lineNum">    1362 </span><span class="lineCov">       2288 :         if (newitemonleft &amp;&amp; newitemoff == firstright)</span>
<span class="lineNum">    1363 </span>            :         {
<span class="lineNum">    1364 </span>            :             /* incoming tuple will become last on left page */
<span class="lineNum">    1365 </span><span class="lineCov">        104 :             lastleft = newitem;</span>
<span class="lineNum">    1366 </span>            :         }
<span class="lineNum">    1367 </span>            :         else
<span class="lineNum">    1368 </span>            :         {
<span class="lineNum">    1369 </span>            :             OffsetNumber lastleftoff;
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span>            :             /* item just before firstright will become last on left page */
<span class="lineNum">    1372 </span><span class="lineCov">       2184 :             lastleftoff = OffsetNumberPrev(firstright);</span>
<span class="lineNum">    1373 </span><span class="lineCov">       2184 :             Assert(lastleftoff &gt;= P_FIRSTDATAKEY(oopaque));</span>
<span class="lineNum">    1374 </span><span class="lineCov">       2184 :             itemid = PageGetItemId(origpage, lastleftoff);</span>
<span class="lineNum">    1375 </span><span class="lineCov">       2184 :             lastleft = (IndexTuple) PageGetItem(origpage, itemid);</span>
<span class="lineNum">    1376 </span>            :         }
<span class="lineNum">    1377 </span>            : 
<span class="lineNum">    1378 </span><span class="lineCov">       2288 :         Assert(lastleft != item);</span>
<span class="lineNum">    1379 </span><span class="lineCov">       2288 :         lefthikey = _bt_truncate(rel, lastleft, item, itup_key);</span>
<span class="lineNum">    1380 </span><span class="lineCov">       2288 :         itemsz = IndexTupleSize(lefthikey);</span>
<span class="lineNum">    1381 </span><span class="lineCov">       2288 :         itemsz = MAXALIGN(itemsz);</span>
<span class="lineNum">    1382 </span>            :     }
<span class="lineNum">    1383 </span>            :     else
<span class="lineNum">    1384 </span><span class="lineCov">          2 :         lefthikey = item;</span>
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span>            :     /*
<span class="lineNum">    1387 </span>            :      * Add new high key to leftpage
<span class="lineNum">    1388 </span>            :      */
<span class="lineNum">    1389 </span><span class="lineCov">       2290 :     leftoff = P_HIKEY;</span>
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span><span class="lineCov">       2290 :     Assert(BTreeTupleGetNAtts(lefthikey, rel) &gt; 0);</span>
<span class="lineNum">    1392 </span><span class="lineCov">       2290 :     Assert(BTreeTupleGetNAtts(lefthikey, rel) &lt;= indnkeyatts);</span>
<span class="lineNum">    1393 </span><span class="lineCov">       2290 :     if (PageAddItem(leftpage, (Item) lefthikey, itemsz, leftoff,</span>
<span class="lineNum">    1394 </span>            :                     false, false) == InvalidOffsetNumber)
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :         elog(ERROR, &quot;failed to add hikey to the left sibling&quot;</span>
<span class="lineNum">    1396 </span>            :              &quot; while splitting block %u of index \&quot;%s\&quot;&quot;,
<span class="lineNum">    1397 </span>            :              origpagenumber, RelationGetRelationName(rel));
<span class="lineNum">    1398 </span><span class="lineCov">       2290 :     leftoff = OffsetNumberNext(leftoff);</span>
<span class="lineNum">    1399 </span>            :     /* be tidy */
<span class="lineNum">    1400 </span><span class="lineCov">       2290 :     if (lefthikey != item)</span>
<span class="lineNum">    1401 </span><span class="lineCov">       2288 :         pfree(lefthikey);</span>
<span class="lineNum">    1402 </span>            : 
<span class="lineNum">    1403 </span>            :     /*
<span class="lineNum">    1404 </span>            :      * Acquire a new right page to split into, now that left page has a new
<span class="lineNum">    1405 </span>            :      * high key.  From here on, it's not okay to throw an error without
<span class="lineNum">    1406 </span>            :      * zeroing rightpage first.  This coding rule ensures that we won't
<span class="lineNum">    1407 </span>            :      * confuse future VACUUM operations, which might otherwise try to re-find
<span class="lineNum">    1408 </span>            :      * a downlink to a leftover junk page as the page undergoes deletion.
<span class="lineNum">    1409 </span>            :      *
<span class="lineNum">    1410 </span>            :      * It would be reasonable to start the critical section just after the new
<span class="lineNum">    1411 </span>            :      * rightpage buffer is acquired instead; that would allow us to avoid
<span class="lineNum">    1412 </span>            :      * leftover junk pages without bothering to zero rightpage.  We do it this
<span class="lineNum">    1413 </span>            :      * way because it avoids an unnecessary PANIC when either origpage or its
<span class="lineNum">    1414 </span>            :      * existing sibling page are corrupt.
<span class="lineNum">    1415 </span>            :      */
<span class="lineNum">    1416 </span><span class="lineCov">       2290 :     rbuf = _bt_getbuf(rel, P_NEW, BT_WRITE);</span>
<span class="lineNum">    1417 </span><span class="lineCov">       2290 :     rightpage = BufferGetPage(rbuf);</span>
<span class="lineNum">    1418 </span><span class="lineCov">       2290 :     rightpagenumber = BufferGetBlockNumber(rbuf);</span>
<span class="lineNum">    1419 </span>            :     /* rightpage was initialized by _bt_getbuf */
<span class="lineNum">    1420 </span><span class="lineCov">       2290 :     ropaque = (BTPageOpaque) PageGetSpecialPointer(rightpage);</span>
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span>            :     /*
<span class="lineNum">    1423 </span>            :      * Finish off remaining leftpage special area fields.  They cannot be set
<span class="lineNum">    1424 </span>            :      * before both origpage (leftpage) and rightpage buffers are acquired and
<span class="lineNum">    1425 </span>            :      * locked.
<span class="lineNum">    1426 </span>            :      */
<span class="lineNum">    1427 </span><span class="lineCov">       2290 :     lopaque-&gt;btpo_next = rightpagenumber;</span>
<span class="lineNum">    1428 </span><span class="lineCov">       2290 :     lopaque-&gt;btpo_cycleid = _bt_vacuum_cycleid(rel);</span>
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span>            :     /*
<span class="lineNum">    1431 </span>            :      * rightpage won't be the root when we're done.  Also, clear the SPLIT_END
<span class="lineNum">    1432 </span>            :      * and HAS_GARBAGE flags.
<span class="lineNum">    1433 </span>            :      */
<span class="lineNum">    1434 </span><span class="lineCov">       2290 :     ropaque-&gt;btpo_flags = oopaque-&gt;btpo_flags;</span>
<span class="lineNum">    1435 </span><span class="lineCov">       2290 :     ropaque-&gt;btpo_flags &amp;= ~(BTP_ROOT | BTP_SPLIT_END | BTP_HAS_GARBAGE);</span>
<span class="lineNum">    1436 </span><span class="lineCov">       2290 :     ropaque-&gt;btpo_prev = origpagenumber;</span>
<span class="lineNum">    1437 </span><span class="lineCov">       2290 :     ropaque-&gt;btpo_next = oopaque-&gt;btpo_next;</span>
<span class="lineNum">    1438 </span><span class="lineCov">       2290 :     ropaque-&gt;btpo.level = oopaque-&gt;btpo.level;</span>
<span class="lineNum">    1439 </span><span class="lineCov">       2290 :     ropaque-&gt;btpo_cycleid = lopaque-&gt;btpo_cycleid;</span>
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            :     /*
<span class="lineNum">    1442 </span>            :      * Add new high key to rightpage where necessary.
<span class="lineNum">    1443 </span>            :      *
<span class="lineNum">    1444 </span>            :      * If the page we're splitting is not the rightmost page at its level in
<span class="lineNum">    1445 </span>            :      * the tree, then the first entry on the page is the high key from
<span class="lineNum">    1446 </span>            :      * origpage.
<span class="lineNum">    1447 </span>            :      */
<span class="lineNum">    1448 </span><span class="lineCov">       2290 :     rightoff = P_HIKEY;</span>
<span class="lineNum">    1449 </span>            : 
<span class="lineNum">    1450 </span><span class="lineCov">       2290 :     if (!P_RIGHTMOST(oopaque))</span>
<span class="lineNum">    1451 </span>            :     {
<span class="lineNum">    1452 </span><span class="lineCov">       1172 :         itemid = PageGetItemId(origpage, P_HIKEY);</span>
<span class="lineNum">    1453 </span><span class="lineCov">       1172 :         itemsz = ItemIdGetLength(itemid);</span>
<span class="lineNum">    1454 </span><span class="lineCov">       1172 :         item = (IndexTuple) PageGetItem(origpage, itemid);</span>
<span class="lineNum">    1455 </span><span class="lineCov">       1172 :         Assert(BTreeTupleGetNAtts(item, rel) &gt; 0);</span>
<span class="lineNum">    1456 </span><span class="lineCov">       1172 :         Assert(BTreeTupleGetNAtts(item, rel) &lt;= indnkeyatts);</span>
<span class="lineNum">    1457 </span><span class="lineCov">       1172 :         if (PageAddItem(rightpage, (Item) item, itemsz, rightoff,</span>
<span class="lineNum">    1458 </span>            :                         false, false) == InvalidOffsetNumber)
<span class="lineNum">    1459 </span>            :         {
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :             memset(rightpage, 0, BufferGetPageSize(rbuf));</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;failed to add hikey to the right sibling&quot;</span>
<span class="lineNum">    1462 </span>            :                  &quot; while splitting block %u of index \&quot;%s\&quot;&quot;,
<span class="lineNum">    1463 </span>            :                  origpagenumber, RelationGetRelationName(rel));
<span class="lineNum">    1464 </span>            :         }
<span class="lineNum">    1465 </span><span class="lineCov">       1172 :         rightoff = OffsetNumberNext(rightoff);</span>
<span class="lineNum">    1466 </span>            :     }
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span>            :     /*
<span class="lineNum">    1469 </span>            :      * Now transfer all the data items (non-pivot tuples in isleaf case, or
<span class="lineNum">    1470 </span>            :      * additional pivot tuples in !isleaf case) to the appropriate page.
<span class="lineNum">    1471 </span>            :      *
<span class="lineNum">    1472 </span>            :      * Note: we *must* insert at least the right page's items in item-number
<span class="lineNum">    1473 </span>            :      * order, for the benefit of _bt_restore_page().
<span class="lineNum">    1474 </span>            :      */
<span class="lineNum">    1475 </span><span class="lineCov">       2290 :     maxoff = PageGetMaxOffsetNumber(origpage);</span>
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span><span class="lineCov">     720840 :     for (i = P_FIRSTDATAKEY(oopaque); i &lt;= maxoff; i = OffsetNumberNext(i))</span>
<span class="lineNum">    1478 </span>            :     {
<span class="lineNum">    1479 </span><span class="lineCov">     718550 :         itemid = PageGetItemId(origpage, i);</span>
<span class="lineNum">    1480 </span><span class="lineCov">     718550 :         itemsz = ItemIdGetLength(itemid);</span>
<span class="lineNum">    1481 </span><span class="lineCov">     718550 :         item = (IndexTuple) PageGetItem(origpage, itemid);</span>
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span>            :         /* does new item belong before this one? */
<span class="lineNum">    1484 </span><span class="lineCov">     718550 :         if (i == newitemoff)</span>
<span class="lineNum">    1485 </span>            :         {
<span class="lineNum">    1486 </span><span class="lineCov">       1288 :             if (newitemonleft)</span>
<span class="lineNum">    1487 </span>            :             {
<span class="lineNum">    1488 </span><span class="lineCov">        366 :                 Assert(newitemoff &lt;= firstright);</span>
<span class="lineNum">    1489 </span><span class="lineCov">        366 :                 if (!_bt_pgaddtup(leftpage, newitemsz, newitem, leftoff))</span>
<span class="lineNum">    1490 </span>            :                 {
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :                     memset(rightpage, 0, BufferGetPageSize(rbuf));</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :                     elog(ERROR, &quot;failed to add new item to the left sibling&quot;</span>
<span class="lineNum">    1493 </span>            :                          &quot; while splitting block %u of index \&quot;%s\&quot;&quot;,
<span class="lineNum">    1494 </span>            :                          origpagenumber, RelationGetRelationName(rel));
<span class="lineNum">    1495 </span>            :                 }
<span class="lineNum">    1496 </span><span class="lineCov">        366 :                 leftoff = OffsetNumberNext(leftoff);</span>
<span class="lineNum">    1497 </span>            :             }
<span class="lineNum">    1498 </span>            :             else
<span class="lineNum">    1499 </span>            :             {
<span class="lineNum">    1500 </span><span class="lineCov">        922 :                 Assert(newitemoff &gt;= firstright);</span>
<span class="lineNum">    1501 </span><span class="lineCov">        922 :                 if (!_bt_pgaddtup(rightpage, newitemsz, newitem, rightoff))</span>
<span class="lineNum">    1502 </span>            :                 {
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :                     memset(rightpage, 0, BufferGetPageSize(rbuf));</span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :                     elog(ERROR, &quot;failed to add new item to the right sibling&quot;</span>
<span class="lineNum">    1505 </span>            :                          &quot; while splitting block %u of index \&quot;%s\&quot;&quot;,
<span class="lineNum">    1506 </span>            :                          origpagenumber, RelationGetRelationName(rel));
<span class="lineNum">    1507 </span>            :                 }
<span class="lineNum">    1508 </span><span class="lineCov">        922 :                 rightoff = OffsetNumberNext(rightoff);</span>
<span class="lineNum">    1509 </span>            :             }
<span class="lineNum">    1510 </span>            :         }
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span>            :         /* decide which page to put it on */
<span class="lineNum">    1513 </span><span class="lineCov">     718550 :         if (i &lt; firstright)</span>
<span class="lineNum">    1514 </span>            :         {
<span class="lineNum">    1515 </span><span class="lineCov">     550292 :             if (!_bt_pgaddtup(leftpage, itemsz, item, leftoff))</span>
<span class="lineNum">    1516 </span>            :             {
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :                 memset(rightpage, 0, BufferGetPageSize(rbuf));</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :                 elog(ERROR, &quot;failed to add old item to the left sibling&quot;</span>
<span class="lineNum">    1519 </span>            :                      &quot; while splitting block %u of index \&quot;%s\&quot;&quot;,
<span class="lineNum">    1520 </span>            :                      origpagenumber, RelationGetRelationName(rel));
<span class="lineNum">    1521 </span>            :             }
<span class="lineNum">    1522 </span><span class="lineCov">     550292 :             leftoff = OffsetNumberNext(leftoff);</span>
<span class="lineNum">    1523 </span>            :         }
<span class="lineNum">    1524 </span>            :         else
<span class="lineNum">    1525 </span>            :         {
<span class="lineNum">    1526 </span><span class="lineCov">     168258 :             if (!_bt_pgaddtup(rightpage, itemsz, item, rightoff))</span>
<span class="lineNum">    1527 </span>            :             {
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :                 memset(rightpage, 0, BufferGetPageSize(rbuf));</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :                 elog(ERROR, &quot;failed to add old item to the right sibling&quot;</span>
<span class="lineNum">    1530 </span>            :                      &quot; while splitting block %u of index \&quot;%s\&quot;&quot;,
<span class="lineNum">    1531 </span>            :                      origpagenumber, RelationGetRelationName(rel));
<span class="lineNum">    1532 </span>            :             }
<span class="lineNum">    1533 </span><span class="lineCov">     168258 :             rightoff = OffsetNumberNext(rightoff);</span>
<span class="lineNum">    1534 </span>            :         }
<span class="lineNum">    1535 </span>            :     }
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span>            :     /* cope with possibility that newitem goes at the end */
<span class="lineNum">    1538 </span><span class="lineCov">       2290 :     if (i &lt;= newitemoff)</span>
<span class="lineNum">    1539 </span>            :     {
<span class="lineNum">    1540 </span>            :         /*
<span class="lineNum">    1541 </span>            :          * Can't have newitemonleft here; that would imply we were told to put
<span class="lineNum">    1542 </span>            :          * *everything* on the left page, which cannot fit (if it could, we'd
<span class="lineNum">    1543 </span>            :          * not be splitting the page).
<span class="lineNum">    1544 </span>            :          */
<span class="lineNum">    1545 </span><span class="lineCov">       1002 :         Assert(!newitemonleft);</span>
<span class="lineNum">    1546 </span><span class="lineCov">       1002 :         if (!_bt_pgaddtup(rightpage, newitemsz, newitem, rightoff))</span>
<span class="lineNum">    1547 </span>            :         {
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :             memset(rightpage, 0, BufferGetPageSize(rbuf));</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :             elog(ERROR, &quot;failed to add new item to the right sibling&quot;</span>
<span class="lineNum">    1550 </span>            :                  &quot; while splitting block %u of index \&quot;%s\&quot;&quot;,
<span class="lineNum">    1551 </span>            :                  origpagenumber, RelationGetRelationName(rel));
<span class="lineNum">    1552 </span>            :         }
<span class="lineNum">    1553 </span><span class="lineCov">       1002 :         rightoff = OffsetNumberNext(rightoff);</span>
<span class="lineNum">    1554 </span>            :     }
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span>            :     /*
<span class="lineNum">    1557 </span>            :      * We have to grab the right sibling (if any) and fix the prev pointer
<span class="lineNum">    1558 </span>            :      * there. We are guaranteed that this is deadlock-free since no other
<span class="lineNum">    1559 </span>            :      * writer will be holding a lock on that page and trying to move left, and
<span class="lineNum">    1560 </span>            :      * all readers release locks on a page before trying to fetch its
<span class="lineNum">    1561 </span>            :      * neighbors.
<span class="lineNum">    1562 </span>            :      */
<span class="lineNum">    1563 </span><span class="lineCov">       2290 :     if (!P_RIGHTMOST(oopaque))</span>
<span class="lineNum">    1564 </span>            :     {
<span class="lineNum">    1565 </span><span class="lineCov">       1172 :         sbuf = _bt_getbuf(rel, oopaque-&gt;btpo_next, BT_WRITE);</span>
<span class="lineNum">    1566 </span><span class="lineCov">       1172 :         spage = BufferGetPage(sbuf);</span>
<span class="lineNum">    1567 </span><span class="lineCov">       1172 :         sopaque = (BTPageOpaque) PageGetSpecialPointer(spage);</span>
<span class="lineNum">    1568 </span><span class="lineCov">       1172 :         if (sopaque-&gt;btpo_prev != origpagenumber)</span>
<span class="lineNum">    1569 </span>            :         {
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :             memset(rightpage, 0, BufferGetPageSize(rbuf));</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">    1572 </span>            :                     (errcode(ERRCODE_INDEX_CORRUPTED),
<span class="lineNum">    1573 </span>            :                      errmsg_internal(&quot;right sibling's left-link doesn't match: &quot;
<span class="lineNum">    1574 </span>            :                                      &quot;block %u links to %u instead of expected %u in index \&quot;%s\&quot;&quot;,
<span class="lineNum">    1575 </span>            :                                      oopaque-&gt;btpo_next, sopaque-&gt;btpo_prev, origpagenumber,
<span class="lineNum">    1576 </span>            :                                      RelationGetRelationName(rel))));
<span class="lineNum">    1577 </span>            :         }
<span class="lineNum">    1578 </span>            : 
<span class="lineNum">    1579 </span>            :         /*
<span class="lineNum">    1580 </span>            :          * Check to see if we can set the SPLIT_END flag in the right-hand
<span class="lineNum">    1581 </span>            :          * split page; this can save some I/O for vacuum since it need not
<span class="lineNum">    1582 </span>            :          * proceed to the right sibling.  We can set the flag if the right
<span class="lineNum">    1583 </span>            :          * sibling has a different cycleid: that means it could not be part of
<span class="lineNum">    1584 </span>            :          * a group of pages that were all split off from the same ancestor
<span class="lineNum">    1585 </span>            :          * page.  If you're confused, imagine that page A splits to A B and
<span class="lineNum">    1586 </span>            :          * then again, yielding A C B, while vacuum is in progress.  Tuples
<span class="lineNum">    1587 </span>            :          * originally in A could now be in either B or C, hence vacuum must
<span class="lineNum">    1588 </span>            :          * examine both pages.  But if D, our right sibling, has a different
<span class="lineNum">    1589 </span>            :          * cycleid then it could not contain any tuples that were in A when
<span class="lineNum">    1590 </span>            :          * the vacuum started.
<span class="lineNum">    1591 </span>            :          */
<span class="lineNum">    1592 </span><span class="lineCov">       1172 :         if (sopaque-&gt;btpo_cycleid != ropaque-&gt;btpo_cycleid)</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :             ropaque-&gt;btpo_flags |= BTP_SPLIT_END;</span>
<span class="lineNum">    1594 </span>            :     }
<span class="lineNum">    1595 </span>            : 
<span class="lineNum">    1596 </span>            :     /*
<span class="lineNum">    1597 </span>            :      * Right sibling is locked, new siblings are prepared, but original page
<span class="lineNum">    1598 </span>            :      * is not updated yet.
<span class="lineNum">    1599 </span>            :      *
<span class="lineNum">    1600 </span>            :      * NO EREPORT(ERROR) till right sibling is updated.  We can get away with
<span class="lineNum">    1601 </span>            :      * not starting the critical section till here because we haven't been
<span class="lineNum">    1602 </span>            :      * scribbling on the original page yet; see comments above.
<span class="lineNum">    1603 </span>            :      */
<span class="lineNum">    1604 </span><span class="lineCov">       2290 :     START_CRIT_SECTION();</span>
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span>            :     /*
<span class="lineNum">    1607 </span>            :      * By here, the original data page has been split into two new halves, and
<span class="lineNum">    1608 </span>            :      * these are correct.  The algorithm requires that the left page never
<span class="lineNum">    1609 </span>            :      * move during a split, so we copy the new left page back on top of the
<span class="lineNum">    1610 </span>            :      * original.  Note that this is not a waste of time, since we also require
<span class="lineNum">    1611 </span>            :      * (in the page management code) that the center of a page always be
<span class="lineNum">    1612 </span>            :      * clean, and the most efficient way to guarantee this is just to compact
<span class="lineNum">    1613 </span>            :      * the data by reinserting it into a new left page.  (XXX the latter
<span class="lineNum">    1614 </span>            :      * comment is probably obsolete; but in any case it's good to not scribble
<span class="lineNum">    1615 </span>            :      * on the original page until we enter the critical section.)
<span class="lineNum">    1616 </span>            :      *
<span class="lineNum">    1617 </span>            :      * We need to do this before writing the WAL record, so that XLogInsert
<span class="lineNum">    1618 </span>            :      * can WAL log an image of the page if necessary.
<span class="lineNum">    1619 </span>            :      */
<span class="lineNum">    1620 </span><span class="lineCov">       2290 :     PageRestoreTempPage(leftpage, origpage);</span>
<span class="lineNum">    1621 </span>            :     /* leftpage, lopaque must not be used below here */
<span class="lineNum">    1622 </span>            : 
<span class="lineNum">    1623 </span><span class="lineCov">       2290 :     MarkBufferDirty(buf);</span>
<span class="lineNum">    1624 </span><span class="lineCov">       2290 :     MarkBufferDirty(rbuf);</span>
<span class="lineNum">    1625 </span>            : 
<span class="lineNum">    1626 </span><span class="lineCov">       2290 :     if (!P_RIGHTMOST(ropaque))</span>
<span class="lineNum">    1627 </span>            :     {
<span class="lineNum">    1628 </span><span class="lineCov">       1172 :         sopaque-&gt;btpo_prev = rightpagenumber;</span>
<span class="lineNum">    1629 </span><span class="lineCov">       1172 :         MarkBufferDirty(sbuf);</span>
<span class="lineNum">    1630 </span>            :     }
<span class="lineNum">    1631 </span>            : 
<span class="lineNum">    1632 </span>            :     /*
<span class="lineNum">    1633 </span>            :      * Clear INCOMPLETE_SPLIT flag on child if inserting the new item finishes
<span class="lineNum">    1634 </span>            :      * a split.
<span class="lineNum">    1635 </span>            :      */
<span class="lineNum">    1636 </span><span class="lineCov">       2290 :     if (!isleaf)</span>
<span class="lineNum">    1637 </span>            :     {
<span class="lineNum">    1638 </span><span class="lineCov">          2 :         Page        cpage = BufferGetPage(cbuf);</span>
<span class="lineNum">    1639 </span><span class="lineCov">          2 :         BTPageOpaque cpageop = (BTPageOpaque) PageGetSpecialPointer(cpage);</span>
<span class="lineNum">    1640 </span>            : 
<span class="lineNum">    1641 </span><span class="lineCov">          2 :         cpageop-&gt;btpo_flags &amp;= ~BTP_INCOMPLETE_SPLIT;</span>
<span class="lineNum">    1642 </span><span class="lineCov">          2 :         MarkBufferDirty(cbuf);</span>
<span class="lineNum">    1643 </span>            :     }
<span class="lineNum">    1644 </span>            : 
<span class="lineNum">    1645 </span>            :     /* XLOG stuff */
<span class="lineNum">    1646 </span><span class="lineCov">       2290 :     if (RelationNeedsWAL(rel))</span>
<span class="lineNum">    1647 </span>            :     {
<span class="lineNum">    1648 </span>            :         xl_btree_split xlrec;
<span class="lineNum">    1649 </span>            :         uint8       xlinfo;
<span class="lineNum">    1650 </span>            :         XLogRecPtr  recptr;
<span class="lineNum">    1651 </span>            : 
<span class="lineNum">    1652 </span><span class="lineCov">       2290 :         xlrec.level = ropaque-&gt;btpo.level;</span>
<span class="lineNum">    1653 </span><span class="lineCov">       2290 :         xlrec.firstright = firstright;</span>
<span class="lineNum">    1654 </span><span class="lineCov">       2290 :         xlrec.newitemoff = newitemoff;</span>
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span><span class="lineCov">       2290 :         XLogBeginInsert();</span>
<span class="lineNum">    1657 </span><span class="lineCov">       2290 :         XLogRegisterData((char *) &amp;xlrec, SizeOfBtreeSplit);</span>
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span><span class="lineCov">       2290 :         XLogRegisterBuffer(0, buf, REGBUF_STANDARD);</span>
<span class="lineNum">    1660 </span><span class="lineCov">       2290 :         XLogRegisterBuffer(1, rbuf, REGBUF_WILL_INIT);</span>
<span class="lineNum">    1661 </span>            :         /* Log the right sibling, because we've changed its prev-pointer. */
<span class="lineNum">    1662 </span><span class="lineCov">       2290 :         if (!P_RIGHTMOST(ropaque))</span>
<span class="lineNum">    1663 </span><span class="lineCov">       1172 :             XLogRegisterBuffer(2, sbuf, REGBUF_STANDARD);</span>
<span class="lineNum">    1664 </span><span class="lineCov">       2290 :         if (BufferIsValid(cbuf))</span>
<span class="lineNum">    1665 </span><span class="lineCov">          2 :             XLogRegisterBuffer(3, cbuf, REGBUF_STANDARD);</span>
<span class="lineNum">    1666 </span>            : 
<span class="lineNum">    1667 </span>            :         /*
<span class="lineNum">    1668 </span>            :          * Log the new item, if it was inserted on the left page. (If it was
<span class="lineNum">    1669 </span>            :          * put on the right page, we don't need to explicitly WAL log it
<span class="lineNum">    1670 </span>            :          * because it's included with all the other items on the right page.)
<span class="lineNum">    1671 </span>            :          * Show the new item as belonging to the left page buffer, so that it
<span class="lineNum">    1672 </span>            :          * is not stored if XLogInsert decides it needs a full-page image of
<span class="lineNum">    1673 </span>            :          * the left page.  We store the offset anyway, though, to support
<span class="lineNum">    1674 </span>            :          * archive compression of these records.
<span class="lineNum">    1675 </span>            :          */
<span class="lineNum">    1676 </span><span class="lineCov">       2290 :         if (newitemonleft)</span>
<span class="lineNum">    1677 </span><span class="lineCov">        366 :             XLogRegisterBufData(0, (char *) newitem, MAXALIGN(newitemsz));</span>
<span class="lineNum">    1678 </span>            : 
<span class="lineNum">    1679 </span>            :         /* Log the left page's new high key */
<span class="lineNum">    1680 </span><span class="lineCov">       2290 :         itemid = PageGetItemId(origpage, P_HIKEY);</span>
<span class="lineNum">    1681 </span><span class="lineCov">       2290 :         item = (IndexTuple) PageGetItem(origpage, itemid);</span>
<span class="lineNum">    1682 </span><span class="lineCov">       2290 :         XLogRegisterBufData(0, (char *) item, MAXALIGN(IndexTupleSize(item)));</span>
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span>            :         /*
<span class="lineNum">    1685 </span>            :          * Log the contents of the right page in the format understood by
<span class="lineNum">    1686 </span>            :          * _bt_restore_page().  The whole right page will be recreated.
<span class="lineNum">    1687 </span>            :          *
<span class="lineNum">    1688 </span>            :          * Direct access to page is not good but faster - we should implement
<span class="lineNum">    1689 </span>            :          * some new func in page API.  Note we only store the tuples
<span class="lineNum">    1690 </span>            :          * themselves, knowing that they were inserted in item-number order
<span class="lineNum">    1691 </span>            :          * and so the line pointers can be reconstructed.  See comments for
<span class="lineNum">    1692 </span>            :          * _bt_restore_page().
<span class="lineNum">    1693 </span>            :          */
<span class="lineNum">    1694 </span><span class="lineCov">       6870 :         XLogRegisterBufData(1,</span>
<span class="lineNum">    1695 </span><span class="lineCov">       2290 :                             (char *) rightpage + ((PageHeader) rightpage)-&gt;pd_upper,</span>
<span class="lineNum">    1696 </span><span class="lineCov">       4580 :                             ((PageHeader) rightpage)-&gt;pd_special - ((PageHeader) rightpage)-&gt;pd_upper);</span>
<span class="lineNum">    1697 </span>            : 
<span class="lineNum">    1698 </span><span class="lineCov">       2290 :         xlinfo = newitemonleft ? XLOG_BTREE_SPLIT_L : XLOG_BTREE_SPLIT_R;</span>
<span class="lineNum">    1699 </span><span class="lineCov">       2290 :         recptr = XLogInsert(RM_BTREE_ID, xlinfo);</span>
<span class="lineNum">    1700 </span>            : 
<span class="lineNum">    1701 </span><span class="lineCov">       2290 :         PageSetLSN(origpage, recptr);</span>
<span class="lineNum">    1702 </span><span class="lineCov">       2290 :         PageSetLSN(rightpage, recptr);</span>
<span class="lineNum">    1703 </span><span class="lineCov">       2290 :         if (!P_RIGHTMOST(ropaque))</span>
<span class="lineNum">    1704 </span>            :         {
<span class="lineNum">    1705 </span><span class="lineCov">       1172 :             PageSetLSN(spage, recptr);</span>
<span class="lineNum">    1706 </span>            :         }
<span class="lineNum">    1707 </span><span class="lineCov">       2290 :         if (!isleaf)</span>
<span class="lineNum">    1708 </span>            :         {
<span class="lineNum">    1709 </span><span class="lineCov">          2 :             PageSetLSN(BufferGetPage(cbuf), recptr);</span>
<span class="lineNum">    1710 </span>            :         }
<span class="lineNum">    1711 </span>            :     }
<span class="lineNum">    1712 </span>            : 
<span class="lineNum">    1713 </span><span class="lineCov">       2290 :     END_CRIT_SECTION();</span>
<span class="lineNum">    1714 </span>            : 
<span class="lineNum">    1715 </span>            :     /* release the old right sibling */
<span class="lineNum">    1716 </span><span class="lineCov">       2290 :     if (!P_RIGHTMOST(ropaque))</span>
<span class="lineNum">    1717 </span><span class="lineCov">       1172 :         _bt_relbuf(rel, sbuf);</span>
<span class="lineNum">    1718 </span>            : 
<span class="lineNum">    1719 </span>            :     /* release the child */
<span class="lineNum">    1720 </span><span class="lineCov">       2290 :     if (!isleaf)</span>
<span class="lineNum">    1721 </span><span class="lineCov">          2 :         _bt_relbuf(rel, cbuf);</span>
<span class="lineNum">    1722 </span>            : 
<span class="lineNum">    1723 </span>            :     /* split's done */
<span class="lineNum">    1724 </span><span class="lineCov">       2290 :     return rbuf;</span>
<span class="lineNum">    1725 </span>            : }
<span class="lineNum">    1726 </span>            : 
<span class="lineNum">    1727 </span>            : /*
<span class="lineNum">    1728 </span>            :  * _bt_insert_parent() -- Insert downlink into parent, completing split.
<span class="lineNum">    1729 </span>            :  *
<span class="lineNum">    1730 </span>            :  * On entry, buf and rbuf are the left and right split pages, which we
<span class="lineNum">    1731 </span>            :  * still hold write locks on.  Both locks will be released here.  We
<span class="lineNum">    1732 </span>            :  * release the rbuf lock once we have a write lock on the page that we
<span class="lineNum">    1733 </span>            :  * intend to insert a downlink to rbuf on (i.e. buf's current parent page).
<span class="lineNum">    1734 </span>            :  * The lock on buf is released at the same point as the lock on the parent
<span class="lineNum">    1735 </span>            :  * page, since buf's INCOMPLETE_SPLIT flag must be cleared by the same
<span class="lineNum">    1736 </span>            :  * atomic operation that completes the split by inserting a new downlink.
<span class="lineNum">    1737 </span>            :  *
<span class="lineNum">    1738 </span>            :  * stack - stack showing how we got here.  Will be NULL when splitting true
<span class="lineNum">    1739 </span>            :  *          root, or during concurrent root split, where we can be inefficient
<span class="lineNum">    1740 </span>            :  * is_root - we split the true root
<span class="lineNum">    1741 </span>            :  * is_only - we split a page alone on its level (might have been fast root)
<a name="1742"><span class="lineNum">    1742 </span>            :  */</a>
<span class="lineNum">    1743 </span>            : static void
<span class="lineNum">    1744 </span><span class="lineCov">       2290 : _bt_insert_parent(Relation rel,</span>
<span class="lineNum">    1745 </span>            :                   Buffer buf,
<span class="lineNum">    1746 </span>            :                   Buffer rbuf,
<span class="lineNum">    1747 </span>            :                   BTStack stack,
<span class="lineNum">    1748 </span>            :                   bool is_root,
<span class="lineNum">    1749 </span>            :                   bool is_only)
<span class="lineNum">    1750 </span>            : {
<span class="lineNum">    1751 </span>            :     /*
<span class="lineNum">    1752 </span>            :      * Here we have to do something Lehman and Yao don't talk about: deal with
<span class="lineNum">    1753 </span>            :      * a root split and construction of a new root.  If our stack is empty
<span class="lineNum">    1754 </span>            :      * then we have just split a node on what had been the root level when we
<span class="lineNum">    1755 </span>            :      * descended the tree.  If it was still the root then we perform a
<span class="lineNum">    1756 </span>            :      * new-root construction.  If it *wasn't* the root anymore, search to find
<span class="lineNum">    1757 </span>            :      * the next higher level that someone constructed meanwhile, and find the
<span class="lineNum">    1758 </span>            :      * right place to insert as for the normal case.
<span class="lineNum">    1759 </span>            :      *
<span class="lineNum">    1760 </span>            :      * If we have to search for the parent level, we do so by re-descending
<span class="lineNum">    1761 </span>            :      * from the root.  This is not super-efficient, but it's rare enough not
<span class="lineNum">    1762 </span>            :      * to matter.
<span class="lineNum">    1763 </span>            :      */
<span class="lineNum">    1764 </span><span class="lineCov">       2290 :     if (is_root)</span>
<span class="lineNum">    1765 </span>            :     {
<span class="lineNum">    1766 </span>            :         Buffer      rootbuf;
<span class="lineNum">    1767 </span>            : 
<span class="lineNum">    1768 </span><span class="lineCov">         80 :         Assert(stack == NULL);</span>
<span class="lineNum">    1769 </span><span class="lineCov">         80 :         Assert(is_only);</span>
<span class="lineNum">    1770 </span>            :         /* create a new root node and update the metapage */
<span class="lineNum">    1771 </span><span class="lineCov">         80 :         rootbuf = _bt_newroot(rel, buf, rbuf);</span>
<span class="lineNum">    1772 </span>            :         /* release the split buffers */
<span class="lineNum">    1773 </span><span class="lineCov">         80 :         _bt_relbuf(rel, rootbuf);</span>
<span class="lineNum">    1774 </span><span class="lineCov">         80 :         _bt_relbuf(rel, rbuf);</span>
<span class="lineNum">    1775 </span><span class="lineCov">         80 :         _bt_relbuf(rel, buf);</span>
<span class="lineNum">    1776 </span>            :     }
<span class="lineNum">    1777 </span>            :     else
<span class="lineNum">    1778 </span>            :     {
<span class="lineNum">    1779 </span><span class="lineCov">       2210 :         BlockNumber bknum = BufferGetBlockNumber(buf);</span>
<span class="lineNum">    1780 </span><span class="lineCov">       2210 :         BlockNumber rbknum = BufferGetBlockNumber(rbuf);</span>
<span class="lineNum">    1781 </span><span class="lineCov">       2210 :         Page        page = BufferGetPage(buf);</span>
<span class="lineNum">    1782 </span>            :         IndexTuple  new_item;
<span class="lineNum">    1783 </span>            :         BTStackData fakestack;
<span class="lineNum">    1784 </span>            :         IndexTuple  ritem;
<span class="lineNum">    1785 </span>            :         Buffer      pbuf;
<span class="lineNum">    1786 </span>            : 
<span class="lineNum">    1787 </span><span class="lineCov">       2210 :         if (stack == NULL)</span>
<span class="lineNum">    1788 </span>            :         {
<span class="lineNum">    1789 </span>            :             BTPageOpaque lpageop;
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span><span class="lineCov">          2 :             elog(DEBUG2, &quot;concurrent ROOT page split&quot;);</span>
<span class="lineNum">    1792 </span><span class="lineCov">          2 :             lpageop = (BTPageOpaque) PageGetSpecialPointer(page);</span>
<span class="lineNum">    1793 </span>            :             /* Find the leftmost page at the next level up */
<span class="lineNum">    1794 </span><span class="lineCov">          2 :             pbuf = _bt_get_endpoint(rel, lpageop-&gt;btpo.level + 1, false,</span>
<span class="lineNum">    1795 </span>            :                                     NULL);
<span class="lineNum">    1796 </span>            :             /* Set up a phony stack entry pointing there */
<span class="lineNum">    1797 </span><span class="lineCov">          2 :             stack = &amp;fakestack;</span>
<span class="lineNum">    1798 </span><span class="lineCov">          2 :             stack-&gt;bts_blkno = BufferGetBlockNumber(pbuf);</span>
<span class="lineNum">    1799 </span><span class="lineCov">          2 :             stack-&gt;bts_offset = InvalidOffsetNumber;</span>
<span class="lineNum">    1800 </span><span class="lineCov">          2 :             stack-&gt;bts_parent = NULL;</span>
<span class="lineNum">    1801 </span><span class="lineCov">          2 :             _bt_relbuf(rel, pbuf);</span>
<span class="lineNum">    1802 </span>            :         }
<span class="lineNum">    1803 </span>            : 
<span class="lineNum">    1804 </span>            :         /* get high key from left, a strict lower bound for new right page */
<span class="lineNum">    1805 </span><span class="lineCov">       2210 :         ritem = (IndexTuple) PageGetItem(page,</span>
<span class="lineNum">    1806 </span>            :                                          PageGetItemId(page, P_HIKEY));
<span class="lineNum">    1807 </span>            : 
<span class="lineNum">    1808 </span>            :         /* form an index tuple that points at the new right page */
<span class="lineNum">    1809 </span><span class="lineCov">       2210 :         new_item = CopyIndexTuple(ritem);</span>
<span class="lineNum">    1810 </span><span class="lineCov">       2210 :         BTreeInnerTupleSetDownLink(new_item, rbknum);</span>
<span class="lineNum">    1811 </span>            : 
<span class="lineNum">    1812 </span>            :         /*
<span class="lineNum">    1813 </span>            :          * Re-find and write lock the parent of buf.
<span class="lineNum">    1814 </span>            :          *
<span class="lineNum">    1815 </span>            :          * It's possible that the location of buf's downlink has changed since
<span class="lineNum">    1816 </span>            :          * our initial _bt_search() descent.  _bt_getstackbuf() will detect
<span class="lineNum">    1817 </span>            :          * and recover from this, updating the stack, which ensures that the
<span class="lineNum">    1818 </span>            :          * new downlink will be inserted at the correct offset. Even buf's
<span class="lineNum">    1819 </span>            :          * parent may have changed.
<span class="lineNum">    1820 </span>            :          */
<span class="lineNum">    1821 </span><span class="lineCov">       2210 :         pbuf = _bt_getstackbuf(rel, stack, bknum);</span>
<span class="lineNum">    1822 </span>            : 
<span class="lineNum">    1823 </span>            :         /*
<span class="lineNum">    1824 </span>            :          * Now we can unlock the right child. The left child will be unlocked
<span class="lineNum">    1825 </span>            :          * by _bt_insertonpg().
<span class="lineNum">    1826 </span>            :          */
<span class="lineNum">    1827 </span><span class="lineCov">       2210 :         _bt_relbuf(rel, rbuf);</span>
<span class="lineNum">    1828 </span>            : 
<span class="lineNum">    1829 </span><span class="lineCov">       2210 :         if (pbuf == InvalidBuffer)</span>
<span class="lineNum">    1830 </span><span class="lineNoCov">          0 :             ereport(ERROR,</span>
<span class="lineNum">    1831 </span>            :                     (errcode(ERRCODE_INDEX_CORRUPTED),
<span class="lineNum">    1832 </span>            :                      errmsg_internal(&quot;failed to re-find parent key in index \&quot;%s\&quot; for split pages %u/%u&quot;,
<span class="lineNum">    1833 </span>            :                                      RelationGetRelationName(rel), bknum, rbknum)));
<span class="lineNum">    1834 </span>            : 
<span class="lineNum">    1835 </span>            :         /* Recursively insert into the parent */
<span class="lineNum">    1836 </span><span class="lineCov">       4420 :         _bt_insertonpg(rel, NULL, pbuf, buf, stack-&gt;bts_parent,</span>
<span class="lineNum">    1837 </span><span class="lineCov">       2210 :                        new_item, stack-&gt;bts_offset + 1,</span>
<span class="lineNum">    1838 </span>            :                        is_only);
<span class="lineNum">    1839 </span>            : 
<span class="lineNum">    1840 </span>            :         /* be tidy */
<span class="lineNum">    1841 </span><span class="lineCov">       2210 :         pfree(new_item);</span>
<span class="lineNum">    1842 </span>            :     }
<span class="lineNum">    1843 </span><span class="lineCov">       2290 : }</span>
<span class="lineNum">    1844 </span>            : 
<span class="lineNum">    1845 </span>            : /*
<span class="lineNum">    1846 </span>            :  * _bt_finish_split() -- Finish an incomplete split
<span class="lineNum">    1847 </span>            :  *
<span class="lineNum">    1848 </span>            :  * A crash or other failure can leave a split incomplete.  The insertion
<span class="lineNum">    1849 </span>            :  * routines won't allow to insert on a page that is incompletely split.
<span class="lineNum">    1850 </span>            :  * Before inserting on such a page, call _bt_finish_split().
<span class="lineNum">    1851 </span>            :  *
<span class="lineNum">    1852 </span>            :  * On entry, 'lbuf' must be locked in write-mode.  On exit, it is unlocked
<span class="lineNum">    1853 </span>            :  * and unpinned.
<a name="1854"><span class="lineNum">    1854 </span>            :  */</a>
<span class="lineNum">    1855 </span>            : void
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 : _bt_finish_split(Relation rel, Buffer lbuf, BTStack stack)</span>
<span class="lineNum">    1857 </span>            : {
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :     Page        lpage = BufferGetPage(lbuf);</span>
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :     BTPageOpaque lpageop = (BTPageOpaque) PageGetSpecialPointer(lpage);</span>
<span class="lineNum">    1860 </span>            :     Buffer      rbuf;
<span class="lineNum">    1861 </span>            :     Page        rpage;
<span class="lineNum">    1862 </span>            :     BTPageOpaque rpageop;
<span class="lineNum">    1863 </span>            :     bool        was_root;
<span class="lineNum">    1864 </span>            :     bool        was_only;
<span class="lineNum">    1865 </span>            : 
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :     Assert(P_INCOMPLETE_SPLIT(lpageop));</span>
<span class="lineNum">    1867 </span>            : 
<span class="lineNum">    1868 </span>            :     /* Lock right sibling, the one missing the downlink */
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :     rbuf = _bt_getbuf(rel, lpageop-&gt;btpo_next, BT_WRITE);</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :     rpage = BufferGetPage(rbuf);</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :     rpageop = (BTPageOpaque) PageGetSpecialPointer(rpage);</span>
<span class="lineNum">    1872 </span>            : 
<span class="lineNum">    1873 </span>            :     /* Could this be a root split? */
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :     if (!stack)</span>
<span class="lineNum">    1875 </span>            :     {
<span class="lineNum">    1876 </span>            :         Buffer      metabuf;
<span class="lineNum">    1877 </span>            :         Page        metapg;
<span class="lineNum">    1878 </span>            :         BTMetaPageData *metad;
<span class="lineNum">    1879 </span>            : 
<span class="lineNum">    1880 </span>            :         /* acquire lock on the metapage */
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :         metabuf = _bt_getbuf(rel, BTREE_METAPAGE, BT_WRITE);</span>
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :         metapg = BufferGetPage(metabuf);</span>
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :         metad = BTPageGetMeta(metapg);</span>
<span class="lineNum">    1884 </span>            : 
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :         was_root = (metad-&gt;btm_root == BufferGetBlockNumber(lbuf));</span>
<span class="lineNum">    1886 </span>            : 
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :         _bt_relbuf(rel, metabuf);</span>
<span class="lineNum">    1888 </span>            :     }
<span class="lineNum">    1889 </span>            :     else
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :         was_root = false;</span>
<span class="lineNum">    1891 </span>            : 
<span class="lineNum">    1892 </span>            :     /* Was this the only page on the level before split? */
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :     was_only = (P_LEFTMOST(lpageop) &amp;&amp; P_RIGHTMOST(rpageop));</span>
<span class="lineNum">    1894 </span>            : 
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :     elog(DEBUG1, &quot;finishing incomplete split of %u/%u&quot;,</span>
<span class="lineNum">    1896 </span>            :          BufferGetBlockNumber(lbuf), BufferGetBlockNumber(rbuf));
<span class="lineNum">    1897 </span>            : 
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :     _bt_insert_parent(rel, lbuf, rbuf, stack, was_root, was_only);</span>
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1900 </span>            : 
<span class="lineNum">    1901 </span>            : /*
<span class="lineNum">    1902 </span>            :  *  _bt_getstackbuf() -- Walk back up the tree one step, and find the pivot
<span class="lineNum">    1903 </span>            :  *                       tuple whose downlink points to child page.
<span class="lineNum">    1904 </span>            :  *
<span class="lineNum">    1905 </span>            :  *      Caller passes child's block number, which is used to identify
<span class="lineNum">    1906 </span>            :  *      associated pivot tuple in parent page using a linear search that
<span class="lineNum">    1907 </span>            :  *      matches on pivot's downlink/block number.  The expected location of
<span class="lineNum">    1908 </span>            :  *      the pivot tuple is taken from the stack one level above the child
<span class="lineNum">    1909 </span>            :  *      page.  This is used as a starting point.  Insertions into the
<span class="lineNum">    1910 </span>            :  *      parent level could cause the pivot tuple to move right; deletions
<span class="lineNum">    1911 </span>            :  *      could cause it to move left, but not left of the page we previously
<span class="lineNum">    1912 </span>            :  *      found it on.
<span class="lineNum">    1913 </span>            :  *
<span class="lineNum">    1914 </span>            :  *      Caller can use its stack to relocate the pivot tuple/downlink for
<span class="lineNum">    1915 </span>            :  *      any same-level page to the right of the page found by its initial
<span class="lineNum">    1916 </span>            :  *      descent.  This is necessary because of the possibility that caller
<span class="lineNum">    1917 </span>            :  *      moved right to recover from a concurrent page split.  It's also
<span class="lineNum">    1918 </span>            :  *      convenient for certain callers to be able to step right when there
<span class="lineNum">    1919 </span>            :  *      wasn't a concurrent page split, while still using their original
<span class="lineNum">    1920 </span>            :  *      stack.  For example, the checkingunique _bt_doinsert() case may
<span class="lineNum">    1921 </span>            :  *      have to step right when there are many physical duplicates, and its
<span class="lineNum">    1922 </span>            :  *      scantid forces an insertion to the right of the &quot;first page the
<span class="lineNum">    1923 </span>            :  *      value could be on&quot;.
<span class="lineNum">    1924 </span>            :  *
<span class="lineNum">    1925 </span>            :  *      Returns write-locked parent page buffer, or InvalidBuffer if pivot
<span class="lineNum">    1926 </span>            :  *      tuple not found (should not happen).  Adjusts bts_blkno &amp;
<span class="lineNum">    1927 </span>            :  *      bts_offset if changed.  Page split caller should insert its new
<span class="lineNum">    1928 </span>            :  *      pivot tuple for its new right sibling page on parent page, at the
<span class="lineNum">    1929 </span>            :  *      offset number bts_offset + 1.
<a name="1930"><span class="lineNum">    1930 </span>            :  */</a>
<span class="lineNum">    1931 </span>            : Buffer
<span class="lineNum">    1932 </span><span class="lineCov">       3526 : _bt_getstackbuf(Relation rel, BTStack stack, BlockNumber child)</span>
<span class="lineNum">    1933 </span>            : {
<span class="lineNum">    1934 </span>            :     BlockNumber blkno;
<span class="lineNum">    1935 </span>            :     OffsetNumber start;
<span class="lineNum">    1936 </span>            : 
<span class="lineNum">    1937 </span><span class="lineCov">       3526 :     blkno = stack-&gt;bts_blkno;</span>
<span class="lineNum">    1938 </span><span class="lineCov">       3526 :     start = stack-&gt;bts_offset;</span>
<span class="lineNum">    1939 </span>            : 
<span class="lineNum">    1940 </span>            :     for (;;)
<span class="lineNum">    1941 </span>            :     {
<span class="lineNum">    1942 </span>            :         Buffer      buf;
<span class="lineNum">    1943 </span>            :         Page        page;
<span class="lineNum">    1944 </span>            :         BTPageOpaque opaque;
<span class="lineNum">    1945 </span>            : 
<span class="lineNum">    1946 </span><span class="lineCov">       3526 :         buf = _bt_getbuf(rel, blkno, BT_WRITE);</span>
<span class="lineNum">    1947 </span><span class="lineCov">       3526 :         page = BufferGetPage(buf);</span>
<span class="lineNum">    1948 </span><span class="lineCov">       3526 :         opaque = (BTPageOpaque) PageGetSpecialPointer(page);</span>
<span class="lineNum">    1949 </span>            : 
<span class="lineNum">    1950 </span><span class="lineCov">       3526 :         if (P_INCOMPLETE_SPLIT(opaque))</span>
<span class="lineNum">    1951 </span>            :         {
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :             _bt_finish_split(rel, buf, stack-&gt;bts_parent);</span>
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1954 </span>            :         }
<span class="lineNum">    1955 </span>            : 
<span class="lineNum">    1956 </span><span class="lineCov">       3526 :         if (!P_IGNORE(opaque))</span>
<span class="lineNum">    1957 </span>            :         {
<span class="lineNum">    1958 </span>            :             OffsetNumber offnum,
<span class="lineNum">    1959 </span>            :                         minoff,
<span class="lineNum">    1960 </span>            :                         maxoff;
<span class="lineNum">    1961 </span>            :             ItemId      itemid;
<span class="lineNum">    1962 </span>            :             IndexTuple  item;
<span class="lineNum">    1963 </span>            : 
<span class="lineNum">    1964 </span><span class="lineCov">       3526 :             minoff = P_FIRSTDATAKEY(opaque);</span>
<span class="lineNum">    1965 </span><span class="lineCov">       3526 :             maxoff = PageGetMaxOffsetNumber(page);</span>
<span class="lineNum">    1966 </span>            : 
<span class="lineNum">    1967 </span>            :             /*
<span class="lineNum">    1968 </span>            :              * start = InvalidOffsetNumber means &quot;search the whole page&quot;. We
<span class="lineNum">    1969 </span>            :              * need this test anyway due to possibility that page has a high
<span class="lineNum">    1970 </span>            :              * key now when it didn't before.
<span class="lineNum">    1971 </span>            :              */
<span class="lineNum">    1972 </span><span class="lineCov">       3526 :             if (start &lt; minoff)</span>
<span class="lineNum">    1973 </span><span class="lineCov">          2 :                 start = minoff;</span>
<span class="lineNum">    1974 </span>            : 
<span class="lineNum">    1975 </span>            :             /*
<span class="lineNum">    1976 </span>            :              * Need this check too, to guard against possibility that page
<span class="lineNum">    1977 </span>            :              * split since we visited it originally.
<span class="lineNum">    1978 </span>            :              */
<span class="lineNum">    1979 </span><span class="lineCov">       3526 :             if (start &gt; maxoff)</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :                 start = OffsetNumberNext(maxoff);</span>
<span class="lineNum">    1981 </span>            : 
<span class="lineNum">    1982 </span>            :             /*
<span class="lineNum">    1983 </span>            :              * These loops will check every item on the page --- but in an
<span class="lineNum">    1984 </span>            :              * order that's attuned to the probability of where it actually
<span class="lineNum">    1985 </span>            :              * is.  Scan to the right first, then to the left.
<span class="lineNum">    1986 </span>            :              */
<span class="lineNum">    1987 </span><span class="lineCov">       7052 :             for (offnum = start;</span>
<span class="lineNum">    1988 </span>            :                  offnum &lt;= maxoff;
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 :                  offnum = OffsetNumberNext(offnum))</span>
<span class="lineNum">    1990 </span>            :             {
<span class="lineNum">    1991 </span><span class="lineCov">       3526 :                 itemid = PageGetItemId(page, offnum);</span>
<span class="lineNum">    1992 </span><span class="lineCov">       3526 :                 item = (IndexTuple) PageGetItem(page, itemid);</span>
<span class="lineNum">    1993 </span>            : 
<span class="lineNum">    1994 </span><span class="lineCov">       3526 :                 if (BTreeInnerTupleGetDownLink(item) == child)</span>
<span class="lineNum">    1995 </span>            :                 {
<span class="lineNum">    1996 </span>            :                     /* Return accurate pointer to where link is now */
<span class="lineNum">    1997 </span><span class="lineCov">       3526 :                     stack-&gt;bts_blkno = blkno;</span>
<span class="lineNum">    1998 </span><span class="lineCov">       3526 :                     stack-&gt;bts_offset = offnum;</span>
<span class="lineNum">    1999 </span><span class="lineCov">       3526 :                     return buf;</span>
<span class="lineNum">    2000 </span>            :                 }
<span class="lineNum">    2001 </span>            :             }
<span class="lineNum">    2002 </span>            : 
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :             for (offnum = OffsetNumberPrev(start);</span>
<span class="lineNum">    2004 </span>            :                  offnum &gt;= minoff;
<span class="lineNum">    2005 </span><span class="lineNoCov">          0 :                  offnum = OffsetNumberPrev(offnum))</span>
<span class="lineNum">    2006 </span>            :             {
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :                 itemid = PageGetItemId(page, offnum);</span>
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :                 item = (IndexTuple) PageGetItem(page, itemid);</span>
<span class="lineNum">    2009 </span>            : 
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 :                 if (BTreeInnerTupleGetDownLink(item) == child)</span>
<span class="lineNum">    2011 </span>            :                 {
<span class="lineNum">    2012 </span>            :                     /* Return accurate pointer to where link is now */
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :                     stack-&gt;bts_blkno = blkno;</span>
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :                     stack-&gt;bts_offset = offnum;</span>
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :                     return buf;</span>
<span class="lineNum">    2016 </span>            :                 }
<span class="lineNum">    2017 </span>            :             }
<span class="lineNum">    2018 </span>            :         }
<span class="lineNum">    2019 </span>            : 
<span class="lineNum">    2020 </span>            :         /*
<span class="lineNum">    2021 </span>            :          * The item we're looking for moved right at least one page.
<span class="lineNum">    2022 </span>            :          *
<span class="lineNum">    2023 </span>            :          * Lehman and Yao couple/chain locks when moving right here, which we
<span class="lineNum">    2024 </span>            :          * can avoid.  See nbtree/README.
<span class="lineNum">    2025 </span>            :          */
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :         if (P_RIGHTMOST(opaque))</span>
<span class="lineNum">    2027 </span>            :         {
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :             _bt_relbuf(rel, buf);</span>
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :             return InvalidBuffer;</span>
<span class="lineNum">    2030 </span>            :         }
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :         blkno = opaque-&gt;btpo_next;</span>
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :         start = InvalidOffsetNumber;</span>
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :         _bt_relbuf(rel, buf);</span>
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2035 </span>            : }
<span class="lineNum">    2036 </span>            : 
<span class="lineNum">    2037 </span>            : /*
<span class="lineNum">    2038 </span>            :  *  _bt_newroot() -- Create a new root page for the index.
<span class="lineNum">    2039 </span>            :  *
<span class="lineNum">    2040 </span>            :  *      We've just split the old root page and need to create a new one.
<span class="lineNum">    2041 </span>            :  *      In order to do this, we add a new root page to the file, then lock
<span class="lineNum">    2042 </span>            :  *      the metadata page and update it.  This is guaranteed to be deadlock-
<span class="lineNum">    2043 </span>            :  *      free, because all readers release their locks on the metadata page
<span class="lineNum">    2044 </span>            :  *      before trying to lock the root, and all writers lock the root before
<span class="lineNum">    2045 </span>            :  *      trying to lock the metadata page.  We have a write lock on the old
<span class="lineNum">    2046 </span>            :  *      root page, so we have not introduced any cycles into the waits-for
<span class="lineNum">    2047 </span>            :  *      graph.
<span class="lineNum">    2048 </span>            :  *
<span class="lineNum">    2049 </span>            :  *      On entry, lbuf (the old root) and rbuf (its new peer) are write-
<span class="lineNum">    2050 </span>            :  *      locked. On exit, a new root page exists with entries for the
<span class="lineNum">    2051 </span>            :  *      two new children, metapage is updated and unlocked/unpinned.
<span class="lineNum">    2052 </span>            :  *      The new root buffer is returned to caller which has to unlock/unpin
<span class="lineNum">    2053 </span>            :  *      lbuf, rbuf &amp; rootbuf.
<a name="2054"><span class="lineNum">    2054 </span>            :  */</a>
<span class="lineNum">    2055 </span>            : static Buffer
<span class="lineNum">    2056 </span><span class="lineCov">         80 : _bt_newroot(Relation rel, Buffer lbuf, Buffer rbuf)</span>
<span class="lineNum">    2057 </span>            : {
<span class="lineNum">    2058 </span>            :     Buffer      rootbuf;
<span class="lineNum">    2059 </span>            :     Page        lpage,
<span class="lineNum">    2060 </span>            :                 rootpage;
<span class="lineNum">    2061 </span>            :     BlockNumber lbkno,
<span class="lineNum">    2062 </span>            :                 rbkno;
<span class="lineNum">    2063 </span>            :     BlockNumber rootblknum;
<span class="lineNum">    2064 </span>            :     BTPageOpaque rootopaque;
<span class="lineNum">    2065 </span>            :     BTPageOpaque lopaque;
<span class="lineNum">    2066 </span>            :     ItemId      itemid;
<span class="lineNum">    2067 </span>            :     IndexTuple  item;
<span class="lineNum">    2068 </span>            :     IndexTuple  left_item;
<span class="lineNum">    2069 </span>            :     Size        left_item_sz;
<span class="lineNum">    2070 </span>            :     IndexTuple  right_item;
<span class="lineNum">    2071 </span>            :     Size        right_item_sz;
<span class="lineNum">    2072 </span>            :     Buffer      metabuf;
<span class="lineNum">    2073 </span>            :     Page        metapg;
<span class="lineNum">    2074 </span>            :     BTMetaPageData *metad;
<span class="lineNum">    2075 </span>            : 
<span class="lineNum">    2076 </span><span class="lineCov">         80 :     lbkno = BufferGetBlockNumber(lbuf);</span>
<span class="lineNum">    2077 </span><span class="lineCov">         80 :     rbkno = BufferGetBlockNumber(rbuf);</span>
<span class="lineNum">    2078 </span><span class="lineCov">         80 :     lpage = BufferGetPage(lbuf);</span>
<span class="lineNum">    2079 </span><span class="lineCov">         80 :     lopaque = (BTPageOpaque) PageGetSpecialPointer(lpage);</span>
<span class="lineNum">    2080 </span>            : 
<span class="lineNum">    2081 </span>            :     /* get a new root page */
<span class="lineNum">    2082 </span><span class="lineCov">         80 :     rootbuf = _bt_getbuf(rel, P_NEW, BT_WRITE);</span>
<span class="lineNum">    2083 </span><span class="lineCov">         80 :     rootpage = BufferGetPage(rootbuf);</span>
<span class="lineNum">    2084 </span><span class="lineCov">         80 :     rootblknum = BufferGetBlockNumber(rootbuf);</span>
<span class="lineNum">    2085 </span>            : 
<span class="lineNum">    2086 </span>            :     /* acquire lock on the metapage */
<span class="lineNum">    2087 </span><span class="lineCov">         80 :     metabuf = _bt_getbuf(rel, BTREE_METAPAGE, BT_WRITE);</span>
<span class="lineNum">    2088 </span><span class="lineCov">         80 :     metapg = BufferGetPage(metabuf);</span>
<span class="lineNum">    2089 </span><span class="lineCov">         80 :     metad = BTPageGetMeta(metapg);</span>
<span class="lineNum">    2090 </span>            : 
<span class="lineNum">    2091 </span>            :     /*
<span class="lineNum">    2092 </span>            :      * Create downlink item for left page (old root).  Since this will be the
<span class="lineNum">    2093 </span>            :      * first item in a non-leaf page, it implicitly has minus-infinity key
<span class="lineNum">    2094 </span>            :      * value, so we need not store any actual key in it.
<span class="lineNum">    2095 </span>            :      */
<span class="lineNum">    2096 </span><span class="lineCov">         80 :     left_item_sz = sizeof(IndexTupleData);</span>
<span class="lineNum">    2097 </span><span class="lineCov">         80 :     left_item = (IndexTuple) palloc(left_item_sz);</span>
<span class="lineNum">    2098 </span><span class="lineCov">         80 :     left_item-&gt;t_info = left_item_sz;</span>
<span class="lineNum">    2099 </span><span class="lineCov">         80 :     BTreeInnerTupleSetDownLink(left_item, lbkno);</span>
<span class="lineNum">    2100 </span><span class="lineCov">         80 :     BTreeTupleSetNAtts(left_item, 0);</span>
<span class="lineNum">    2101 </span>            : 
<span class="lineNum">    2102 </span>            :     /*
<span class="lineNum">    2103 </span>            :      * Create downlink item for right page.  The key for it is obtained from
<span class="lineNum">    2104 </span>            :      * the &quot;high key&quot; position in the left page.
<span class="lineNum">    2105 </span>            :      */
<span class="lineNum">    2106 </span><span class="lineCov">         80 :     itemid = PageGetItemId(lpage, P_HIKEY);</span>
<span class="lineNum">    2107 </span><span class="lineCov">         80 :     right_item_sz = ItemIdGetLength(itemid);</span>
<span class="lineNum">    2108 </span><span class="lineCov">         80 :     item = (IndexTuple) PageGetItem(lpage, itemid);</span>
<span class="lineNum">    2109 </span><span class="lineCov">         80 :     right_item = CopyIndexTuple(item);</span>
<span class="lineNum">    2110 </span><span class="lineCov">         80 :     BTreeInnerTupleSetDownLink(right_item, rbkno);</span>
<span class="lineNum">    2111 </span>            : 
<span class="lineNum">    2112 </span>            :     /* NO EREPORT(ERROR) from here till newroot op is logged */
<span class="lineNum">    2113 </span><span class="lineCov">         80 :     START_CRIT_SECTION();</span>
<span class="lineNum">    2114 </span>            : 
<span class="lineNum">    2115 </span>            :     /* upgrade metapage if needed */
<span class="lineNum">    2116 </span><span class="lineCov">         80 :     if (metad-&gt;btm_version &lt; BTREE_NOVAC_VERSION)</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :         _bt_upgrademetapage(metapg);</span>
<span class="lineNum">    2118 </span>            : 
<span class="lineNum">    2119 </span>            :     /* set btree special data */
<span class="lineNum">    2120 </span><span class="lineCov">         80 :     rootopaque = (BTPageOpaque) PageGetSpecialPointer(rootpage);</span>
<span class="lineNum">    2121 </span><span class="lineCov">         80 :     rootopaque-&gt;btpo_prev = rootopaque-&gt;btpo_next = P_NONE;</span>
<span class="lineNum">    2122 </span><span class="lineCov">         80 :     rootopaque-&gt;btpo_flags = BTP_ROOT;</span>
<span class="lineNum">    2123 </span><span class="lineCov">         80 :     rootopaque-&gt;btpo.level =</span>
<span class="lineNum">    2124 </span><span class="lineCov">         80 :         ((BTPageOpaque) PageGetSpecialPointer(lpage))-&gt;btpo.level + 1;</span>
<span class="lineNum">    2125 </span><span class="lineCov">         80 :     rootopaque-&gt;btpo_cycleid = 0;</span>
<span class="lineNum">    2126 </span>            : 
<span class="lineNum">    2127 </span>            :     /* update metapage data */
<span class="lineNum">    2128 </span><span class="lineCov">         80 :     metad-&gt;btm_root = rootblknum;</span>
<span class="lineNum">    2129 </span><span class="lineCov">         80 :     metad-&gt;btm_level = rootopaque-&gt;btpo.level;</span>
<span class="lineNum">    2130 </span><span class="lineCov">         80 :     metad-&gt;btm_fastroot = rootblknum;</span>
<span class="lineNum">    2131 </span><span class="lineCov">         80 :     metad-&gt;btm_fastlevel = rootopaque-&gt;btpo.level;</span>
<span class="lineNum">    2132 </span>            : 
<span class="lineNum">    2133 </span>            :     /*
<span class="lineNum">    2134 </span>            :      * Insert the left page pointer into the new root page.  The root page is
<span class="lineNum">    2135 </span>            :      * the rightmost page on its level so there is no &quot;high key&quot; in it; the
<span class="lineNum">    2136 </span>            :      * two items will go into positions P_HIKEY and P_FIRSTKEY.
<span class="lineNum">    2137 </span>            :      *
<span class="lineNum">    2138 </span>            :      * Note: we *must* insert the two items in item-number order, for the
<span class="lineNum">    2139 </span>            :      * benefit of _bt_restore_page().
<span class="lineNum">    2140 </span>            :      */
<span class="lineNum">    2141 </span><span class="lineCov">         80 :     Assert(BTreeTupleGetNAtts(left_item, rel) == 0);</span>
<span class="lineNum">    2142 </span><span class="lineCov">         80 :     if (PageAddItem(rootpage, (Item) left_item, left_item_sz, P_HIKEY,</span>
<span class="lineNum">    2143 </span>            :                     false, false) == InvalidOffsetNumber)
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :         elog(PANIC, &quot;failed to add leftkey to new root page&quot;</span>
<span class="lineNum">    2145 </span>            :              &quot; while splitting block %u of index \&quot;%s\&quot;&quot;,
<span class="lineNum">    2146 </span>            :              BufferGetBlockNumber(lbuf), RelationGetRelationName(rel));
<span class="lineNum">    2147 </span>            : 
<span class="lineNum">    2148 </span>            :     /*
<span class="lineNum">    2149 </span>            :      * insert the right page pointer into the new root page.
<span class="lineNum">    2150 </span>            :      */
<span class="lineNum">    2151 </span><span class="lineCov">         80 :     Assert(BTreeTupleGetNAtts(right_item, rel) &gt; 0);</span>
<span class="lineNum">    2152 </span><span class="lineCov">         80 :     Assert(BTreeTupleGetNAtts(right_item, rel) &lt;=</span>
<span class="lineNum">    2153 </span>            :            IndexRelationGetNumberOfKeyAttributes(rel));
<span class="lineNum">    2154 </span><span class="lineCov">         80 :     if (PageAddItem(rootpage, (Item) right_item, right_item_sz, P_FIRSTKEY,</span>
<span class="lineNum">    2155 </span>            :                     false, false) == InvalidOffsetNumber)
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :         elog(PANIC, &quot;failed to add rightkey to new root page&quot;</span>
<span class="lineNum">    2157 </span>            :              &quot; while splitting block %u of index \&quot;%s\&quot;&quot;,
<span class="lineNum">    2158 </span>            :              BufferGetBlockNumber(lbuf), RelationGetRelationName(rel));
<span class="lineNum">    2159 </span>            : 
<span class="lineNum">    2160 </span>            :     /* Clear the incomplete-split flag in the left child */
<span class="lineNum">    2161 </span><span class="lineCov">         80 :     Assert(P_INCOMPLETE_SPLIT(lopaque));</span>
<span class="lineNum">    2162 </span><span class="lineCov">         80 :     lopaque-&gt;btpo_flags &amp;= ~BTP_INCOMPLETE_SPLIT;</span>
<span class="lineNum">    2163 </span><span class="lineCov">         80 :     MarkBufferDirty(lbuf);</span>
<span class="lineNum">    2164 </span>            : 
<span class="lineNum">    2165 </span><span class="lineCov">         80 :     MarkBufferDirty(rootbuf);</span>
<span class="lineNum">    2166 </span><span class="lineCov">         80 :     MarkBufferDirty(metabuf);</span>
<span class="lineNum">    2167 </span>            : 
<span class="lineNum">    2168 </span>            :     /* XLOG stuff */
<span class="lineNum">    2169 </span><span class="lineCov">         80 :     if (RelationNeedsWAL(rel))</span>
<span class="lineNum">    2170 </span>            :     {
<span class="lineNum">    2171 </span>            :         xl_btree_newroot xlrec;
<span class="lineNum">    2172 </span>            :         XLogRecPtr  recptr;
<span class="lineNum">    2173 </span>            :         xl_btree_metadata md;
<span class="lineNum">    2174 </span>            : 
<span class="lineNum">    2175 </span><span class="lineCov">         80 :         xlrec.rootblk = rootblknum;</span>
<span class="lineNum">    2176 </span><span class="lineCov">         80 :         xlrec.level = metad-&gt;btm_level;</span>
<span class="lineNum">    2177 </span>            : 
<span class="lineNum">    2178 </span><span class="lineCov">         80 :         XLogBeginInsert();</span>
<span class="lineNum">    2179 </span><span class="lineCov">         80 :         XLogRegisterData((char *) &amp;xlrec, SizeOfBtreeNewroot);</span>
<span class="lineNum">    2180 </span>            : 
<span class="lineNum">    2181 </span><span class="lineCov">         80 :         XLogRegisterBuffer(0, rootbuf, REGBUF_WILL_INIT);</span>
<span class="lineNum">    2182 </span><span class="lineCov">         80 :         XLogRegisterBuffer(1, lbuf, REGBUF_STANDARD);</span>
<span class="lineNum">    2183 </span><span class="lineCov">         80 :         XLogRegisterBuffer(2, metabuf, REGBUF_WILL_INIT | REGBUF_STANDARD);</span>
<span class="lineNum">    2184 </span>            : 
<span class="lineNum">    2185 </span><span class="lineCov">         80 :         Assert(metad-&gt;btm_version &gt;= BTREE_NOVAC_VERSION);</span>
<span class="lineNum">    2186 </span><span class="lineCov">         80 :         md.version = metad-&gt;btm_version;</span>
<span class="lineNum">    2187 </span><span class="lineCov">         80 :         md.root = rootblknum;</span>
<span class="lineNum">    2188 </span><span class="lineCov">         80 :         md.level = metad-&gt;btm_level;</span>
<span class="lineNum">    2189 </span><span class="lineCov">         80 :         md.fastroot = rootblknum;</span>
<span class="lineNum">    2190 </span><span class="lineCov">         80 :         md.fastlevel = metad-&gt;btm_level;</span>
<span class="lineNum">    2191 </span><span class="lineCov">         80 :         md.oldest_btpo_xact = metad-&gt;btm_oldest_btpo_xact;</span>
<span class="lineNum">    2192 </span><span class="lineCov">         80 :         md.last_cleanup_num_heap_tuples = metad-&gt;btm_last_cleanup_num_heap_tuples;</span>
<span class="lineNum">    2193 </span>            : 
<span class="lineNum">    2194 </span><span class="lineCov">         80 :         XLogRegisterBufData(2, (char *) &amp;md, sizeof(xl_btree_metadata));</span>
<span class="lineNum">    2195 </span>            : 
<span class="lineNum">    2196 </span>            :         /*
<span class="lineNum">    2197 </span>            :          * Direct access to page is not good but faster - we should implement
<span class="lineNum">    2198 </span>            :          * some new func in page API.
<span class="lineNum">    2199 </span>            :          */
<span class="lineNum">    2200 </span><span class="lineCov">        240 :         XLogRegisterBufData(0,</span>
<span class="lineNum">    2201 </span><span class="lineCov">         80 :                             (char *) rootpage + ((PageHeader) rootpage)-&gt;pd_upper,</span>
<span class="lineNum">    2202 </span><span class="lineCov">         80 :                             ((PageHeader) rootpage)-&gt;pd_special -</span>
<span class="lineNum">    2203 </span><span class="lineCov">         80 :                             ((PageHeader) rootpage)-&gt;pd_upper);</span>
<span class="lineNum">    2204 </span>            : 
<span class="lineNum">    2205 </span><span class="lineCov">         80 :         recptr = XLogInsert(RM_BTREE_ID, XLOG_BTREE_NEWROOT);</span>
<span class="lineNum">    2206 </span>            : 
<span class="lineNum">    2207 </span><span class="lineCov">         80 :         PageSetLSN(lpage, recptr);</span>
<span class="lineNum">    2208 </span><span class="lineCov">         80 :         PageSetLSN(rootpage, recptr);</span>
<span class="lineNum">    2209 </span><span class="lineCov">         80 :         PageSetLSN(metapg, recptr);</span>
<span class="lineNum">    2210 </span>            :     }
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span><span class="lineCov">         80 :     END_CRIT_SECTION();</span>
<span class="lineNum">    2213 </span>            : 
<span class="lineNum">    2214 </span>            :     /* done with metapage */
<span class="lineNum">    2215 </span><span class="lineCov">         80 :     _bt_relbuf(rel, metabuf);</span>
<span class="lineNum">    2216 </span>            : 
<span class="lineNum">    2217 </span><span class="lineCov">         80 :     pfree(left_item);</span>
<span class="lineNum">    2218 </span><span class="lineCov">         80 :     pfree(right_item);</span>
<span class="lineNum">    2219 </span>            : 
<span class="lineNum">    2220 </span><span class="lineCov">         80 :     return rootbuf;</span>
<span class="lineNum">    2221 </span>            : }
<span class="lineNum">    2222 </span>            : 
<span class="lineNum">    2223 </span>            : /*
<span class="lineNum">    2224 </span>            :  *  _bt_pgaddtup() -- add a tuple to a particular page in the index.
<span class="lineNum">    2225 </span>            :  *
<span class="lineNum">    2226 </span>            :  *      This routine adds the tuple to the page as requested.  It does
<span class="lineNum">    2227 </span>            :  *      not affect pin/lock status, but you'd better have a write lock
<span class="lineNum">    2228 </span>            :  *      and pin on the target buffer!  Don't forget to write and release
<span class="lineNum">    2229 </span>            :  *      the buffer afterwards, either.
<span class="lineNum">    2230 </span>            :  *
<span class="lineNum">    2231 </span>            :  *      The main difference between this routine and a bare PageAddItem call
<span class="lineNum">    2232 </span>            :  *      is that this code knows that the leftmost index tuple on a non-leaf
<span class="lineNum">    2233 </span>            :  *      btree page has a key that must be treated as minus infinity.
<span class="lineNum">    2234 </span>            :  *      Therefore, it truncates away all attributes.  CAUTION: this works
<span class="lineNum">    2235 </span>            :  *      ONLY if we insert the tuples in order, so that the given itup_off
<span class="lineNum">    2236 </span>            :  *      does represent the final position of the tuple!
<a name="2237"><span class="lineNum">    2237 </span>            :  */</a>
<span class="lineNum">    2238 </span>            : static bool
<span class="lineNum">    2239 </span><span class="lineCov">    1354446 : _bt_pgaddtup(Page page,</span>
<span class="lineNum">    2240 </span>            :              Size itemsize,
<span class="lineNum">    2241 </span>            :              IndexTuple itup,
<span class="lineNum">    2242 </span>            :              OffsetNumber itup_off)
<span class="lineNum">    2243 </span>            : {
<span class="lineNum">    2244 </span><span class="lineCov">    1354446 :     BTPageOpaque opaque = (BTPageOpaque) PageGetSpecialPointer(page);</span>
<span class="lineNum">    2245 </span>            :     IndexTupleData trunctuple;
<span class="lineNum">    2246 </span>            : 
<span class="lineNum">    2247 </span><span class="lineCov">    1354446 :     if (!P_ISLEAF(opaque) &amp;&amp; itup_off == P_FIRSTDATAKEY(opaque))</span>
<span class="lineNum">    2248 </span>            :     {
<span class="lineNum">    2249 </span><span class="lineCov">          4 :         trunctuple = *itup;</span>
<span class="lineNum">    2250 </span><span class="lineCov">          4 :         trunctuple.t_info = sizeof(IndexTupleData);</span>
<span class="lineNum">    2251 </span><span class="lineCov">          4 :         BTreeTupleSetNAtts(&amp;trunctuple, 0);</span>
<span class="lineNum">    2252 </span><span class="lineCov">          4 :         itup = &amp;trunctuple;</span>
<span class="lineNum">    2253 </span><span class="lineCov">          4 :         itemsize = sizeof(IndexTupleData);</span>
<span class="lineNum">    2254 </span>            :     }
<span class="lineNum">    2255 </span>            : 
<span class="lineNum">    2256 </span><span class="lineCov">    1354446 :     if (PageAddItem(page, (Item) itup, itemsize, itup_off,</span>
<span class="lineNum">    2257 </span>            :                     false, false) == InvalidOffsetNumber)
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2259 </span>            : 
<span class="lineNum">    2260 </span><span class="lineCov">    1354446 :     return true;</span>
<span class="lineNum">    2261 </span>            : }
<span class="lineNum">    2262 </span>            : 
<span class="lineNum">    2263 </span>            : /*
<span class="lineNum">    2264 </span>            :  * _bt_vacuum_one_page - vacuum just one index page.
<span class="lineNum">    2265 </span>            :  *
<span class="lineNum">    2266 </span>            :  * Try to remove LP_DEAD items from the given page.  The passed buffer
<span class="lineNum">    2267 </span>            :  * must be exclusive-locked, but unlike a real VACUUM, we don't need a
<span class="lineNum">    2268 </span>            :  * super-exclusive &quot;cleanup&quot; lock (see nbtree/README).
<a name="2269"><span class="lineNum">    2269 </span>            :  */</a>
<span class="lineNum">    2270 </span>            : static void
<span class="lineNum">    2271 </span><span class="lineCov">        776 : _bt_vacuum_one_page(Relation rel, Buffer buffer, Relation heapRel)</span>
<span class="lineNum">    2272 </span>            : {
<span class="lineNum">    2273 </span>            :     OffsetNumber deletable[MaxOffsetNumber];
<span class="lineNum">    2274 </span><span class="lineCov">        776 :     int         ndeletable = 0;</span>
<span class="lineNum">    2275 </span>            :     OffsetNumber offnum,
<span class="lineNum">    2276 </span>            :                 minoff,
<span class="lineNum">    2277 </span>            :                 maxoff;
<span class="lineNum">    2278 </span><span class="lineCov">        776 :     Page        page = BufferGetPage(buffer);</span>
<span class="lineNum">    2279 </span><span class="lineCov">        776 :     BTPageOpaque opaque = (BTPageOpaque) PageGetSpecialPointer(page);</span>
<span class="lineNum">    2280 </span>            : 
<span class="lineNum">    2281 </span><span class="lineCov">        776 :     Assert(P_ISLEAF(opaque));</span>
<span class="lineNum">    2282 </span>            : 
<span class="lineNum">    2283 </span>            :     /*
<span class="lineNum">    2284 </span>            :      * Scan over all items to see which ones need to be deleted according to
<span class="lineNum">    2285 </span>            :      * LP_DEAD flags.
<span class="lineNum">    2286 </span>            :      */
<span class="lineNum">    2287 </span><span class="lineCov">        776 :     minoff = P_FIRSTDATAKEY(opaque);</span>
<span class="lineNum">    2288 </span><span class="lineCov">        776 :     maxoff = PageGetMaxOffsetNumber(page);</span>
<span class="lineNum">    2289 </span><span class="lineCov">     226532 :     for (offnum = minoff;</span>
<span class="lineNum">    2290 </span>            :          offnum &lt;= maxoff;
<span class="lineNum">    2291 </span><span class="lineCov">     224980 :          offnum = OffsetNumberNext(offnum))</span>
<span class="lineNum">    2292 </span>            :     {
<span class="lineNum">    2293 </span><span class="lineCov">     224980 :         ItemId      itemId = PageGetItemId(page, offnum);</span>
<span class="lineNum">    2294 </span>            : 
<span class="lineNum">    2295 </span><span class="lineCov">     224980 :         if (ItemIdIsDead(itemId))</span>
<span class="lineNum">    2296 </span><span class="lineCov">      11596 :             deletable[ndeletable++] = offnum;</span>
<span class="lineNum">    2297 </span>            :     }
<span class="lineNum">    2298 </span>            : 
<span class="lineNum">    2299 </span><span class="lineCov">        776 :     if (ndeletable &gt; 0)</span>
<span class="lineNum">    2300 </span><span class="lineCov">        776 :         _bt_delitems_delete(rel, buffer, deletable, ndeletable, heapRel);</span>
<span class="lineNum">    2301 </span>            : 
<span class="lineNum">    2302 </span>            :     /*
<span class="lineNum">    2303 </span>            :      * Note: if we didn't find any LP_DEAD items, then the page's
<span class="lineNum">    2304 </span>            :      * BTP_HAS_GARBAGE hint bit is falsely set.  We do not bother expending a
<span class="lineNum">    2305 </span>            :      * separate write to clear it, however.  We will clear it when we split
<span class="lineNum">    2306 </span>            :      * the page.
<span class="lineNum">    2307 </span>            :      */
<span class="lineNum">    2308 </span><span class="lineCov">        776 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
